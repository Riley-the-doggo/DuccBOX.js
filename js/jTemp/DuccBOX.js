/*! For license information please see DuccBOX.min.js.LICENSE.txt */
//How did this work
(() => {
  /*!
 * Socket.IO v4.1.3
 * (c) 2014-2021 Guillermo Rauch
 * Released under the MIT License.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["io"] = factory();
	else
		root["io"] = factory();
})(self, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/index.js":
/*!************************!*\
  !*** ./build/index.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;

var url_1 = __webpack_require__(/*! ./url */ "./build/url.js");

var manager_1 = __webpack_require__(/*! ./manager */ "./build/manager.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-client");
/**
 * Module exports.
 */


module.exports = exports = lookup;
/**
 * Managers cache.
 */

var cache = exports.managers = {};

function lookup(uri, opts) {
  if (_typeof(uri) === "object") {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};
  var parsed = url_1.url(uri, opts.path || "/socket.io");
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id]["nsps"];
  var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  var io;

  if (newConnection) {
    debug("ignoring socket cache for %s", source);
    io = new manager_1.Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug("new io instance for %s", source);
      cache[id] = new manager_1.Manager(source, opts);
    }

    io = cache[id];
  }

  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }

  return io.socket(parsed.path, opts);
}

exports.io = lookup;
/**
 * Protocol version.
 *
 * @public
 */

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

Object.defineProperty(exports, "protocol", {
  enumerable: true,
  get: function get() {
    return socket_io_parser_1.protocol;
  }
});
/**
 * `connect`.
 *
 * @param {String} uri
 * @public
 */

exports.connect = lookup;
/**
 * Expose constructors for standalone build.
 *
 * @public
 */

var manager_2 = __webpack_require__(/*! ./manager */ "./build/manager.js");

Object.defineProperty(exports, "Manager", {
  enumerable: true,
  get: function get() {
    return manager_2.Manager;
  }
});

var socket_1 = __webpack_require__(/*! ./socket */ "./build/socket.js");

Object.defineProperty(exports, "Socket", {
  enumerable: true,
  get: function get() {
    return socket_1.Socket;
  }
});
exports["default"] = lookup;

/***/ }),

/***/ "./build/manager.js":
/*!**************************!*\
  !*** ./build/manager.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Manager = void 0;

var eio = __webpack_require__(/*! engine.io-client */ "./node_modules/engine.io-client/lib/index.js");

var socket_1 = __webpack_require__(/*! ./socket */ "./build/socket.js");

var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var on_1 = __webpack_require__(/*! ./on */ "./build/on.js");

var Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./build/typed-events.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-client:manager");

var Manager = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Manager, _typed_events_1$Stric);

  var _super = _createSuper(Manager);

  function Manager(uri, opts) {
    var _this;

    _classCallCheck(this, Manager);

    _this = _super.call(this);
    _this.nsps = {};
    _this.subs = [];

    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = undefined;
    }

    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    _this.opts = opts;

    _this.reconnection(opts.reconnection !== false);

    _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);

    _this.reconnectionDelay(opts.reconnectionDelay || 1000);

    _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);

    _this.randomizationFactor(opts.randomizationFactor || 0.5);

    _this.backoff = new Backoff({
      min: _this.reconnectionDelay(),
      max: _this.reconnectionDelayMax(),
      jitter: _this.randomizationFactor()
    });

    _this.timeout(null == opts.timeout ? 20000 : opts.timeout);

    _this._readyState = "closed";
    _this.uri = uri;

    var _parser = opts.parser || parser;

    _this.encoder = new _parser.Encoder();
    _this.decoder = new _parser.Decoder();
    _this._autoConnect = opts.autoConnect !== false;
    if (_this._autoConnect) _this.open();
    return _this;
  }

  _createClass(Manager, [{
    key: "reconnection",
    value: function reconnection(v) {
      if (!arguments.length) return this._reconnection;
      this._reconnection = !!v;
      return this;
    }
  }, {
    key: "reconnectionAttempts",
    value: function reconnectionAttempts(v) {
      if (v === undefined) return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    }
  }, {
    key: "reconnectionDelay",
    value: function reconnectionDelay(v) {
      var _a;

      if (v === undefined) return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
      return this;
    }
  }, {
    key: "randomizationFactor",
    value: function randomizationFactor(v) {
      var _a;

      if (v === undefined) return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
      return this;
    }
  }, {
    key: "reconnectionDelayMax",
    value: function reconnectionDelayMax(v) {
      var _a;

      if (v === undefined) return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
      return this;
    }
  }, {
    key: "timeout",
    value: function timeout(v) {
      if (!arguments.length) return this._timeout;
      this._timeout = v;
      return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */

  }, {
    key: "maybeReconnectOnOpen",
    value: function maybeReconnectOnOpen() {
      // Only try to reconnect if it's the first time we're connecting
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        // keeps reconnection from firing twice for the same reconnection loop
        this.reconnect();
      }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */

  }, {
    key: "open",
    value: function open(fn) {
      var _this2 = this;

      debug("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open")) return this;
      debug("opening %s", this.uri);
      this.engine = eio(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this._readyState = "opening";
      this.skipReconnect = false; // emit `open`

      var openSubDestroy = on_1.on(socket, "open", function () {
        self.onopen();
        fn && fn();
      }); // emit `error`

      var errorSub = on_1.on(socket, "error", function (err) {
        debug("error");
        self.cleanup();
        self._readyState = "closed";

        _this2.emitReserved("error", err);

        if (fn) {
          fn(err);
        } else {
          // Only do this if there is no fn to handle the error
          self.maybeReconnectOnOpen();
        }
      });

      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug("connect attempt will timeout after %d", timeout);

        if (timeout === 0) {
          openSubDestroy(); // prevents a race condition with the 'open' event
        } // set timer


        var timer = setTimeout(function () {
          debug("connect attempt timed out after %d", timeout);
          openSubDestroy();
          socket.close();
          socket.emit("error", new Error("timeout"));
        }, timeout);

        if (this.opts.autoUnref) {
          timer.unref();
        }

        this.subs.push(function subDestroy() {
          clearTimeout(timer);
        });
      }

      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */

  }, {
    key: "connect",
    value: function connect(fn) {
      return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */

  }, {
    key: "onopen",
    value: function onopen() {
      debug("open"); // clear old subs

      this.cleanup(); // mark as open

      this._readyState = "open";
      this.emitReserved("open"); // add new subs

      var socket = this.engine;
      this.subs.push(on_1.on(socket, "ping", this.onping.bind(this)), on_1.on(socket, "data", this.ondata.bind(this)), on_1.on(socket, "error", this.onerror.bind(this)), on_1.on(socket, "close", this.onclose.bind(this)), on_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */

  }, {
    key: "onping",
    value: function onping() {
      this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */

  }, {
    key: "ondata",
    value: function ondata(data) {
      this.decoder.add(data);
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */

  }, {
    key: "ondecoded",
    value: function ondecoded(packet) {
      this.emitReserved("packet", packet);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */

  }, {
    key: "onerror",
    value: function onerror(err) {
      debug("error", err);
      this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */

  }, {
    key: "socket",
    value: function socket(nsp, opts) {
      var socket = this.nsps[nsp];

      if (!socket) {
        socket = new socket_1.Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
      }

      return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */

  }, {
    key: "_destroy",
    value: function _destroy(socket) {
      var nsps = Object.keys(this.nsps);

      for (var _i = 0, _nsps = nsps; _i < _nsps.length; _i++) {
        var nsp = _nsps[_i];
        var _socket = this.nsps[nsp];

        if (_socket.active) {
          debug("socket %s is still active, skipping close", nsp);
          return;
        }
      }

      this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */

  }, {
    key: "_packet",
    value: function _packet(packet) {
      debug("writing packet %j", packet);
      var encodedPackets = this.encoder.encode(packet);

      for (var i = 0; i < encodedPackets.length; i++) {
        this.engine.write(encodedPackets[i], packet.options);
      }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */

  }, {
    key: "cleanup",
    value: function cleanup() {
      debug("cleanup");
      this.subs.forEach(function (subDestroy) {
        return subDestroy();
      });
      this.subs.length = 0;
      this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */

  }, {
    key: "_close",
    value: function _close() {
      debug("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;

      if ("opening" === this._readyState) {
        // `onclose` will not fire because
        // an open event never happened
        this.cleanup();
      }

      this.backoff.reset();
      this._readyState = "closed";
      if (this.engine) this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */

  }, {
    key: "onclose",
    value: function onclose(reason) {
      debug("onclose");
      this.cleanup();
      this.backoff.reset();
      this._readyState = "closed";
      this.emitReserved("close", reason);

      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */

  }, {
    key: "reconnect",
    value: function reconnect() {
      var _this3 = this;

      if (this._reconnecting || this.skipReconnect) return this;
      var self = this;

      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        this.emitReserved("reconnect_failed");
        this._reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay);
        this._reconnecting = true;
        var timer = setTimeout(function () {
          if (self.skipReconnect) return;
          debug("attempting reconnect");

          _this3.emitReserved("reconnect_attempt", self.backoff.attempts); // check again for the case socket closed in above events


          if (self.skipReconnect) return;
          self.open(function (err) {
            if (err) {
              debug("reconnect attempt error");
              self._reconnecting = false;
              self.reconnect();

              _this3.emitReserved("reconnect_error", err);
            } else {
              debug("reconnect success");
              self.onreconnect();
            }
          });
        }, delay);

        if (this.opts.autoUnref) {
          timer.unref();
        }

        this.subs.push(function subDestroy() {
          clearTimeout(timer);
        });
      }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */

  }, {
    key: "onreconnect",
    value: function onreconnect() {
      var attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      this.emitReserved("reconnect", attempt);
    }
  }]);

  return Manager;
}(typed_events_1.StrictEventEmitter);

exports.Manager = Manager;

/***/ }),

/***/ "./build/on.js":
/*!*********************!*\
  !*** ./build/on.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.on = void 0;

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

exports.on = on;

/***/ }),

/***/ "./build/socket.js":
/*!*************************!*\
  !*** ./build/socket.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = void 0;

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var on_1 = __webpack_require__(/*! ./on */ "./build/on.js");

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./build/typed-events.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-client:socket");
/**
 * Internal events.
 * These events can't be emitted by the user.
 */


var RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});

var Socket = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Socket, _typed_events_1$Stric);

  var _super = _createSuper(Socket);

  /**
   * `Socket` constructor.
   *
   * @public
   */
  function Socket(io, nsp, opts) {
    var _this;

    _classCallCheck(this, Socket);

    _this = _super.call(this);
    _this.receiveBuffer = [];
    _this.sendBuffer = [];
    _this.ids = 0;
    _this.acks = {};
    _this.flags = {};
    _this.io = io;
    _this.nsp = nsp;
    _this.ids = 0;
    _this.acks = {};
    _this.receiveBuffer = [];
    _this.sendBuffer = [];
    _this.connected = false;
    _this.disconnected = true;
    _this.flags = {};

    if (opts && opts.auth) {
      _this.auth = opts.auth;
    }

    if (_this.io._autoConnect) _this.open();
    return _this;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */


  _createClass(Socket, [{
    key: "subEvents",
    value: function subEvents() {
      if (this.subs) return;
      var io = this.io;
      this.subs = [on_1.on(io, "open", this.onopen.bind(this)), on_1.on(io, "packet", this.onpacket.bind(this)), on_1.on(io, "error", this.onerror.bind(this)), on_1.on(io, "close", this.onclose.bind(this))];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects
     */

  }, {
    key: "active",
    get: function get() {
      return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @public
     */

  }, {
    key: "connect",
    value: function connect() {
      if (this.connected) return this;
      this.subEvents();
      if (!this.io["_reconnecting"]) this.io.open(); // ensure open

      if ("open" === this.io._readyState) this.onopen();
      return this;
    }
    /**
     * Alias for connect()
     */

  }, {
    key: "open",
    value: function open() {
      return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @return self
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev + '" is a reserved event name');
      }

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      args.unshift(ev);
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false; // event ack callback

      if ("function" === typeof args[args.length - 1]) {
        debug("emitting packet with ack id %d", this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }

      var isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
      var discardPacket = this.flags["volatile"] && (!isTransportWritable || !this.connected);

      if (discardPacket) {
        debug("discard packet as the transport is not currently writable");
      } else if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }

      this.flags = {};
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */

  }, {
    key: "packet",
    value: function packet(_packet) {
      _packet.nsp = this.nsp;

      this.io._packet(_packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */

  }, {
    key: "onopen",
    value: function onopen() {
      var _this2 = this;

      debug("transport is open - connecting");

      if (typeof this.auth == "function") {
        this.auth(function (data) {
          _this2.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: data
          });
        });
      } else {
        this.packet({
          type: socket_io_parser_1.PacketType.CONNECT,
          data: this.auth
        });
      }
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */

  }, {
    key: "onerror",
    value: function onerror(err) {
      if (!this.connected) {
        this.emitReserved("connect_error", err);
      }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @private
     */

  }, {
    key: "onclose",
    value: function onclose(reason) {
      debug("close (%s)", reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      this.emitReserved("disconnect", reason);
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */

  }, {
    key: "onpacket",
    value: function onpacket(packet) {
      var sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace) return;

      switch (packet.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            var id = packet.data.sid;
            this.onconnect(id);
          } else {
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }

          break;

        case socket_io_parser_1.PacketType.EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;

        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          var err = new Error(packet.data.message); // @ts-ignore

          err.data = packet.data.data;
          this.emitReserved("connect_error", err);
          break;
      }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */

  }, {
    key: "onevent",
    value: function onevent(packet) {
      var args = packet.data || [];
      debug("emitting event %j", args);

      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }

      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
  }, {
    key: "emitEvent",
    value: function emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        var listeners = this._anyListeners.slice();

        var _iterator = _createForOfIteratorHelper(listeners),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            listener.apply(this, args);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      _get(_getPrototypeOf(Socket.prototype), "emit", this).apply(this, args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */

  }, {
    key: "ack",
    value: function ack(id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        sent = true;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        debug("sending ack %j", args);
        self.packet({
          type: socket_io_parser_1.PacketType.ACK,
          id: id,
          data: args
        });
      };
    }
    /**
     * Called upon a server acknowlegement.
     *
     * @param packet
     * @private
     */

  }, {
    key: "onack",
    value: function onack(packet) {
      var ack = this.acks[packet.id];

      if ("function" === typeof ack) {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug("bad ack %s", packet.id);
      }
    }
    /**
     * Called upon server connect.
     *
     * @private
     */

  }, {
    key: "onconnect",
    value: function onconnect(id) {
      debug("socket connected with id %s", id);
      this.id = id;
      this.connected = true;
      this.disconnected = false;
      this.emitBuffered();
      this.emitReserved("connect");
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */

  }, {
    key: "emitBuffered",
    value: function emitBuffered() {
      var _this3 = this;

      this.receiveBuffer.forEach(function (args) {
        return _this3.emitEvent(args);
      });
      this.receiveBuffer = [];
      this.sendBuffer.forEach(function (packet) {
        return _this3.packet(packet);
      });
      this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */

  }, {
    key: "ondisconnect",
    value: function ondisconnect() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (this.subs) {
        // clean subscriptions to avoid reconnections
        this.subs.forEach(function (subDestroy) {
          return subDestroy();
        });
        this.subs = undefined;
      }

      this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually.
     *
     * @return self
     * @public
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({
          type: socket_io_parser_1.PacketType.DISCONNECT
        });
      } // remove socket from pool


      this.destroy();

      if (this.connected) {
        // fire events
        this.onclose("io client disconnect");
      }

      return this;
    }
    /**
     * Alias for disconnect()
     *
     * @return self
     * @public
     */

  }, {
    key: "close",
    value: function close() {
      return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      this.flags.compress = _compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @returns self
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      this.flags["volatile"] = true;
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @param listener
     * @public
     */

  }, {
    key: "onAny",
    value: function onAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.push(listener);

      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     * @public
     */

  }, {
    key: "prependAny",
    value: function prependAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.unshift(listener);

      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @param listener
     * @public
     */

  }, {
    key: "offAny",
    value: function offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }

      if (listener) {
        var listeners = this._anyListeners;

        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }

      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     *
     * @public
     */

  }, {
    key: "listenersAny",
    value: function listenersAny() {
      return this._anyListeners || [];
    }
  }]);

  return Socket;
}(typed_events_1.StrictEventEmitter);

exports.Socket = Socket;

/***/ }),

/***/ "./build/typed-events.js":
/*!*******************************!*\
  !*** ./build/typed-events.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StrictEventEmitter = void 0;

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");
/**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
 * parameters for mappings of event names to event data types, and strictly
 * types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
 * listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
 * emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
 * emitted by socket.io with `emitReserved`, and can be listened to with
 * `listen`.
 */


var StrictEventEmitter = /*#__PURE__*/function (_Emitter) {
  _inherits(StrictEventEmitter, _Emitter);

  var _super = _createSuper(StrictEventEmitter);

  function StrictEventEmitter() {
    _classCallCheck(this, StrictEventEmitter);

    return _super.apply(this, arguments);
  }

  _createClass(StrictEventEmitter, [{
    key: "on",
    value:
    /**
     * Adds the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    function on(ev, listener) {
      _get(_getPrototypeOf(StrictEventEmitter.prototype), "on", this).call(this, ev, listener);

      return this;
    }
    /**
     * Adds a one-time `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */

  }, {
    key: "once",
    value: function once(ev, listener) {
      _get(_getPrototypeOf(StrictEventEmitter.prototype), "once", this).call(this, ev, listener);

      return this;
    }
    /**
     * Emits an event.
     *
     * @param ev Name of the event
     * @param args Values to send to listeners of this event
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_get2 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get2, [this, ev].concat(args));

      return this;
    }
    /**
     * Emits a reserved event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can emit its own reserved events.
     *
     * @param ev Reserved event name
     * @param args Arguments to emit along with the event
     */

  }, {
    key: "emitReserved",
    value: function emitReserved(ev) {
      var _get3;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (_get3 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get3, [this, ev].concat(args));

      return this;
    }
    /**
     * Returns the listeners listening to an event.
     *
     * @param event Event name
     * @returns Array of listeners subscribed to `event`
     */

  }, {
    key: "listeners",
    value: function listeners(event) {
      return _get(_getPrototypeOf(StrictEventEmitter.prototype), "listeners", this).call(this, event);
    }
  }]);

  return StrictEventEmitter;
}(Emitter);

exports.StrictEventEmitter = StrictEventEmitter;

/***/ }),

/***/ "./build/url.js":
/*!**********************!*\
  !*** ./build/url.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.url = void 0;

var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-client:url");
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */


function url(uri) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var loc = arguments.length > 2 ? arguments[2] : undefined;
  var obj = uri; // default to window.location

  loc = loc || typeof location !== "undefined" && location;
  if (null == uri) uri = loc.protocol + "//" + loc.host; // relative path support

  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug("protocol-less url %s", uri);

      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    } // parse


    debug("parse %s", uri);
    obj = parseuri(uri);
  } // make sure we treat `localhost:80` and `localhost` equally


  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }

  obj.path = obj.path || "/";
  var ipv6 = obj.host.indexOf(":") !== -1;
  var host = ipv6 ? "[" + obj.host + "]" : obj.host; // define unique id

  obj.id = obj.protocol + "://" + host + ":" + obj.port + path; // define href

  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

exports.url = url;

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Expose `Backoff`.
 */
module.exports = Backoff;
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */


Backoff.prototype.duration = function () {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);

  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }

  return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */


Backoff.prototype.reset = function () {
  this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */


Backoff.prototype.setMin = function (min) {
  this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */


Backoff.prototype.setMax = function (max) {
  this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */


Backoff.prototype.setJitter = function (jitter) {
  this.jitter = jitter;
};

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Expose `Emitter`.
 */
if (true) {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  } // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.


  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
      callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || function () {};
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        return enableOverride === null ? createDebug.enabled(namespace) : enableOverride;
      },
      set: function set(v) {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/globalThis.browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/globalThis.browser.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
}();

/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Socket = __webpack_require__(/*! ./socket */ "./node_modules/engine.io-client/lib/socket.js");

module.exports = function (uri, opts) {
  return new Socket(uri, opts);
};
/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */


module.exports.Socket = Socket;
module.exports.protocol = Socket.protocol; // this is an int

module.exports.Transport = __webpack_require__(/*! ./transport */ "./node_modules/engine.io-client/lib/transport.js");
module.exports.transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");
module.exports.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:socket");

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");

var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");

var Socket = /*#__PURE__*/function (_Emitter) {
  _inherits(Socket, _Emitter);

  var _super = _createSuper(Socket);

  /**
   * Socket constructor.
   *
   * @param {String|Object} uri or options
   * @param {Object} options
   * @api public
   */
  function Socket(uri) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Socket);

    _this = _super.call(this);

    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = null;
    }

    if (uri) {
      uri = parseuri(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query) opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parseuri(opts.host).host;
    }

    _this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;

    if (opts.hostname && !opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = _this.secure ? "443" : "80";
    }

    _this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    _this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : _this.secure ? 443 : 80);
    _this.transports = opts.transports || ["polling", "websocket"];
    _this.readyState = "";
    _this.writeBuffer = [];
    _this.prevBufferLen = 0;
    _this.opts = _extends({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      jsonp: true,
      timestampParam: "t",
      rememberUpgrade: false,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: true
    }, opts);
    _this.opts.path = _this.opts.path.replace(/\/$/, "") + "/";

    if (typeof _this.opts.query === "string") {
      _this.opts.query = parseqs.decode(_this.opts.query);
    } // set on handshake


    _this.id = null;
    _this.upgrades = null;
    _this.pingInterval = null;
    _this.pingTimeout = null; // set on heartbeat

    _this.pingTimeoutTimer = null;

    if (typeof addEventListener === "function") {
      if (_this.opts.closeOnBeforeunload) {
        // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
        // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
        // closed/reloaded)
        addEventListener("beforeunload", function () {
          if (_this.transport) {
            // silently close the transport
            _this.transport.removeAllListeners();

            _this.transport.close();
          }
        }, false);
      }

      if (_this.hostname !== "localhost") {
        _this.offlineEventListener = function () {
          _this.onClose("transport close");
        };

        addEventListener("offline", _this.offlineEventListener, false);
      }
    }

    _this.open();

    return _this;
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} transport name
   * @return {Transport}
   * @api private
   */


  _createClass(Socket, [{
    key: "createTransport",
    value: function createTransport(name) {
      debug('creating transport "%s"', name);
      var query = clone(this.opts.query); // append engine.io protocol identifier

      query.EIO = parser.protocol; // transport name

      query.transport = name; // session id if we already have one

      if (this.id) query.sid = this.id;

      var opts = _extends({}, this.opts.transportOptions[name], this.opts, {
        query: query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      });

      debug("options: %j", opts);
      return new transports[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @api private
     */

  }, {
    key: "open",
    value: function open() {
      var _this2 = this;

      var transport;

      if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport = "websocket";
      } else if (0 === this.transports.length) {
        // Emit error on next tick so it can be listened to
        setTimeout(function () {
          _this2.emit("error", "No transports available");
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }

      this.readyState = "opening"; // Retry with the next transport if the transport is disabled (jsonp: false)

      try {
        transport = this.createTransport(transport);
      } catch (e) {
        debug("error while creating transport: %s", e);
        this.transports.shift();
        this.open();
        return;
      }

      transport.open();
      this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @api private
     */

  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      var _this3 = this;

      debug("setting transport %s", transport.name);

      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      } // set up transport


      this.transport = transport; // set up transport listeners

      transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", function () {
        _this3.onClose("transport close");
      });
    }
    /**
     * Probes a transport.
     *
     * @param {String} transport name
     * @api private
     */

  }, {
    key: "probe",
    value: function probe(name) {
      var _this4 = this;

      debug('probing transport "%s"', name);
      var transport = this.createTransport(name, {
        probe: 1
      });
      var failed = false;
      Socket.priorWebsocketSuccess = false;

      var onTransportOpen = function onTransportOpen() {
        if (failed) return;
        debug('probe transport "%s" opened', name);
        transport.send([{
          type: "ping",
          data: "probe"
        }]);
        transport.once("packet", function (msg) {
          if (failed) return;

          if ("pong" === msg.type && "probe" === msg.data) {
            debug('probe transport "%s" pong', name);
            _this4.upgrading = true;

            _this4.emit("upgrading", transport);

            if (!transport) return;
            Socket.priorWebsocketSuccess = "websocket" === transport.name;
            debug('pausing current transport "%s"', _this4.transport.name);

            _this4.transport.pause(function () {
              if (failed) return;
              if ("closed" === _this4.readyState) return;
              debug("changing transport and sending upgrade packet");
              cleanup();

              _this4.setTransport(transport);

              transport.send([{
                type: "upgrade"
              }]);

              _this4.emit("upgrade", transport);

              transport = null;
              _this4.upgrading = false;

              _this4.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            var err = new Error("probe error");
            err.transport = transport.name;

            _this4.emit("upgradeError", err);
          }
        });
      };

      function freezeTransport() {
        if (failed) return; // Any callback called by transport should be ignored since now

        failed = true;
        cleanup();
        transport.close();
        transport = null;
      } // Handle any error that happens while probing


      var onerror = function onerror(err) {
        var error = new Error("probe error: " + err);
        error.transport = transport.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);

        _this4.emit("upgradeError", error);
      };

      function onTransportClose() {
        onerror("transport closed");
      } // When the socket is closed while we're probing


      function onclose() {
        onerror("socket closed");
      } // When the socket is upgraded while we're probing


      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          debug('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      } // Remove all listeners on the transport and on self


      var cleanup = function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);

        _this4.removeListener("close", onclose);

        _this4.removeListener("upgrading", onupgrade);
      };

      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      transport.open();
    }
    /**
     * Called when connection is deemed open.
     *
     * @api public
     */

  }, {
    key: "onOpen",
    value: function onOpen() {
      debug("socket open");
      this.readyState = "open";
      Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emit("open");
      this.flush(); // we check for `readyState` in case an `open`
      // listener already closed the socket

      if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
        debug("starting upgrade probes");
        var i = 0;
        var l = this.upgrades.length;

        for (; i < l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    }
    /**
     * Handles a packet.
     *
     * @api private
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emit("packet", packet); // Socket is live - any packet counts

        this.emit("heartbeat");

        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;

          case "ping":
            this.resetPingTimeout();
            this.sendPacket("pong");
            this.emit("ping");
            this.emit("pong");
            break;

          case "error":
            var err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;

          case "message":
            this.emit("data", packet.data);
            this.emit("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} handshake obj
     * @api private
     */

  }, {
    key: "onHandshake",
    value: function onHandshake(data) {
      this.emit("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.onOpen(); // In case open handler closes socket

      if ("closed" === this.readyState) return;
      this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @api private
     */

  }, {
    key: "resetPingTimeout",
    value: function resetPingTimeout() {
      var _this5 = this;

      clearTimeout(this.pingTimeoutTimer);
      this.pingTimeoutTimer = setTimeout(function () {
        _this5.onClose("ping timeout");
      }, this.pingInterval + this.pingTimeout);

      if (this.opts.autoUnref) {
        this.pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @api private
     */

  }, {
    key: "onDrain",
    value: function onDrain() {
      this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on `drain`

      this.prevBufferLen = 0;

      if (0 === this.writeBuffer.length) {
        this.emit("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @api private
     */

  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        debug("flushing %d packets in socket", this.writeBuffer.length);
        this.transport.send(this.writeBuffer); // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on `drain`

        this.prevBufferLen = this.writeBuffer.length;
        this.emit("flush");
      }
    }
    /**
     * Sends a message.
     *
     * @param {String} message.
     * @param {Function} callback function.
     * @param {Object} options.
     * @return {Socket} for chaining.
     * @api public
     */

  }, {
    key: "write",
    value: function write(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
  }, {
    key: "send",
    value: function send(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} callback function.
     * @api private
     */

  }, {
    key: "sendPacket",
    value: function sendPacket(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = undefined;
      }

      if ("function" === typeof options) {
        fn = options;
        options = null;
      }

      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }

      options = options || {};
      options.compress = false !== options.compress;
      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emit("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn) this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     *
     * @api private
     */

  }, {
    key: "close",
    value: function close() {
      var _this6 = this;

      var close = function close() {
        _this6.onClose("forced close");

        debug("socket closing - telling transport to close");

        _this6.transport.close();
      };

      var cleanupAndClose = function cleanupAndClose() {
        _this6.removeListener("upgrade", cleanupAndClose);

        _this6.removeListener("upgradeError", cleanupAndClose);

        close();
      };

      var waitForUpgrade = function waitForUpgrade() {
        // wait for upgrade to finish since we can't send packets while pausing a transport
        _this6.once("upgrade", cleanupAndClose);

        _this6.once("upgradeError", cleanupAndClose);
      };

      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";

        if (this.writeBuffer.length) {
          this.once("drain", function () {
            if (_this6.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }

      return this;
    }
    /**
     * Called upon transport error
     *
     * @api private
     */

  }, {
    key: "onError",
    value: function onError(err) {
      debug("socket error %j", err);
      Socket.priorWebsocketSuccess = false;
      this.emit("error", err);
      this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose(reason, desc) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket close with reason: "%s"', reason); // clear timers

        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer); // stop event from firing again for transport

        this.transport.removeAllListeners("close"); // ensure transport won't stay open

        this.transport.close(); // ignore further transport communication

        this.transport.removeAllListeners();

        if (typeof removeEventListener === "function") {
          removeEventListener("offline", this.offlineEventListener, false);
        } // set ready state


        this.readyState = "closed"; // clear session id

        this.id = null; // emit close event

        this.emit("close", reason, desc); // clean buffers after, so users can still
        // grab the buffers on `close` event

        this.writeBuffer = [];
        this.prevBufferLen = 0;
      }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} server upgrades
     * @api private
     *
     */

  }, {
    key: "filterUpgrades",
    value: function filterUpgrades(upgrades) {
      var filteredUpgrades = [];
      var i = 0;
      var j = upgrades.length;

      for (; i < j; i++) {
        if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }

      return filteredUpgrades;
    }
  }]);

  return Socket;
}(Emitter);

Socket.priorWebsocketSuccess = false;
/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

function clone(obj) {
  var o = {};

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }

  return o;
}

module.exports = Socket;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transport.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:transport");

var Transport = /*#__PURE__*/function (_Emitter) {
  _inherits(Transport, _Emitter);

  var _super = _createSuper(Transport);

  /**
   * Transport abstract constructor.
   *
   * @param {Object} options.
   * @api private
   */
  function Transport(opts) {
    var _this;

    _classCallCheck(this, Transport);

    _this = _super.call(this);
    _this.opts = opts;
    _this.query = opts.query;
    _this.readyState = "";
    _this.socket = opts.socket;
    return _this;
  }
  /**
   * Emits an error.
   *
   * @param {String} str
   * @return {Transport} for chaining
   * @api public
   */


  _createClass(Transport, [{
    key: "onError",
    value: function onError(msg, desc) {
      var err = new Error(msg);
      err.type = "TransportError";
      err.description = desc;
      this.emit("error", err);
      return this;
    }
    /**
     * Opens the transport.
     *
     * @api public
     */

  }, {
    key: "open",
    value: function open() {
      if ("closed" === this.readyState || "" === this.readyState) {
        this.readyState = "opening";
        this.doOpen();
      }

      return this;
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "close",
    value: function close() {
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.doClose();
        this.onClose();
      }

      return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      if ("open" === this.readyState) {
        this.write(packets);
      } else {
        // this might happen if the transport was silently closed in the beforeunload event handler
        debug("transport is not open, discarding packets");
      }
    }
    /**
     * Called upon open
     *
     * @api private
     */

  }, {
    key: "onOpen",
    value: function onOpen() {
      this.readyState = "open";
      this.writable = true;
      this.emit("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      var packet = parser.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      this.emit("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose() {
      this.readyState = "closed";
      this.emit("close");
    }
  }]);

  return Transport;
}(Emitter);

module.exports = Transport;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var XMLHttpRequest = __webpack_require__(/*! ../../contrib/xmlhttprequest-ssl/XMLHttpRequest */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");

var XHR = __webpack_require__(/*! ./polling-xhr */ "./node_modules/engine.io-client/lib/transports/polling-xhr.js");

var JSONP = __webpack_require__(/*! ./polling-jsonp */ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js");

var websocket = __webpack_require__(/*! ./websocket */ "./node_modules/engine.io-client/lib/transports/websocket.js");

exports.polling = polling;
exports.websocket = websocket;
/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== "undefined") {
    var isSSL = "https:" === location.protocol;
    var port = location.port; // some user agents have empty `location.port`

    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ("open" in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error("JSONP disabled");
    return new JSONP(opts);
  }
}

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");

var globalThis = __webpack_require__(/*! ../globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;
/**
 * Global JSONP callbacks.
 */

var callbacks;

var JSONPPolling = /*#__PURE__*/function (_Polling) {
  _inherits(JSONPPolling, _Polling);

  var _super = _createSuper(JSONPPolling);

  /**
   * JSONP Polling constructor.
   *
   * @param {Object} opts.
   * @api public
   */
  function JSONPPolling(opts) {
    var _this;

    _classCallCheck(this, JSONPPolling);

    _this = _super.call(this, opts);
    _this.query = _this.query || {}; // define global callbacks array if not present
    // we do this here (lazily) to avoid unneeded global pollution

    if (!callbacks) {
      // we need to consider multiple engines in the same page
      callbacks = globalThis.___eio = globalThis.___eio || [];
    } // callback identifier


    _this.index = callbacks.length; // add callback to jsonp global

    callbacks.push(_this.onData.bind(_assertThisInitialized(_this))); // append to query string

    _this.query.j = _this.index;
    return _this;
  }
  /**
   * JSONP only supports binary as base64 encoded strings
   */


  _createClass(JSONPPolling, [{
    key: "supportsBinary",
    get: function get() {
      return false;
    }
    /**
     * Closes the socket.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose() {
      if (this.script) {
        // prevent spurious errors from being emitted when the window is unloaded
        this.script.onerror = function () {};

        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      if (this.form) {
        this.form.parentNode.removeChild(this.form);
        this.form = null;
        this.iframe = null;
      }

      _get(_getPrototypeOf(JSONPPolling.prototype), "doClose", this).call(this);
    }
    /**
     * Starts a poll cycle.
     *
     * @api private
     */

  }, {
    key: "doPoll",
    value: function doPoll() {
      var _this2 = this;

      var script = document.createElement("script");

      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      script.async = true;
      script.src = this.uri();

      script.onerror = function (e) {
        _this2.onError("jsonp poll error", e);
      };

      var insertAt = document.getElementsByTagName("script")[0];

      if (insertAt) {
        insertAt.parentNode.insertBefore(script, insertAt);
      } else {
        (document.head || document.body).appendChild(script);
      }

      this.script = script;
      var isUAgecko = "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);

      if (isUAgecko) {
        setTimeout(function () {
          var iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      }
    }
    /**
     * Writes with a hidden iframe.
     *
     * @param {String} data to send
     * @param {Function} called upon flush.
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, fn) {
      var _this3 = this;

      var iframe;

      if (!this.form) {
        var form = document.createElement("form");
        var area = document.createElement("textarea");
        var id = this.iframeId = "eio_iframe_" + this.index;
        form.className = "socketio";
        form.style.position = "absolute";
        form.style.top = "-1000px";
        form.style.left = "-1000px";
        form.target = id;
        form.method = "POST";
        form.setAttribute("accept-charset", "utf-8");
        area.name = "d";
        form.appendChild(area);
        document.body.appendChild(form);
        this.form = form;
        this.area = area;
      }

      this.form.action = this.uri();

      function complete() {
        initIframe();
        fn();
      }

      var initIframe = function initIframe() {
        if (_this3.iframe) {
          try {
            _this3.form.removeChild(_this3.iframe);
          } catch (e) {
            _this3.onError("jsonp polling iframe removal error", e);
          }
        }

        try {
          // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
          var html = '<iframe src="javascript:0" name="' + _this3.iframeId + '">';
          iframe = document.createElement(html);
        } catch (e) {
          iframe = document.createElement("iframe");
          iframe.name = _this3.iframeId;
          iframe.src = "javascript:0";
        }

        iframe.id = _this3.iframeId;

        _this3.form.appendChild(iframe);

        _this3.iframe = iframe;
      };

      initIframe(); // escape \n to prevent it from being converted into \r\n by some UAs
      // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side

      data = data.replace(rEscapedNewline, "\\\n");
      this.area.value = data.replace(rNewline, "\\n");

      try {
        this.form.submit();
      } catch (e) {}

      if (this.iframe.attachEvent) {
        this.iframe.onreadystatechange = function () {
          if (_this3.iframe.readyState === "complete") {
            complete();
          }
        };
      } else {
        this.iframe.onload = complete;
      }
    }
  }]);

  return JSONPPolling;
}(Polling);

module.exports = JSONPPolling;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-xhr.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* global attachEvent */
var XMLHttpRequest = __webpack_require__(/*! ../../contrib/xmlhttprequest-ssl/XMLHttpRequest */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");

var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var _require = __webpack_require__(/*! ../util */ "./node_modules/engine.io-client/lib/util.js"),
    pick = _require.pick;

var globalThis = __webpack_require__(/*! ../globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:polling-xhr");
/**
 * Empty function
 */


function empty() {}

var hasXHR2 = function () {
  var xhr = new XMLHttpRequest({
    xdomain: false
  });
  return null != xhr.responseType;
}();

var XHR = /*#__PURE__*/function (_Polling) {
  _inherits(XHR, _Polling);

  var _super = _createSuper(XHR);

  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @api public
   */
  function XHR(opts) {
    var _this;

    _classCallCheck(this, XHR);

    _this = _super.call(this, opts);

    if (typeof location !== "undefined") {
      var isSSL = "https:" === location.protocol;
      var port = location.port; // some user agents have empty `location.port`

      if (!port) {
        port = isSSL ? 443 : 80;
      }

      _this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      _this.xs = opts.secure !== isSSL;
    }
    /**
     * XHR supports binary
     */


    var forceBase64 = opts && opts.forceBase64;
    _this.supportsBinary = hasXHR2 && !forceBase64;
    return _this;
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @api private
   */


  _createClass(XHR, [{
    key: "request",
    value: function request() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _extends(opts, {
        xd: this.xd,
        xs: this.xs
      }, this.opts);

      return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, fn) {
      var _this2 = this;

      var req = this.request({
        method: "POST",
        data: data
      });
      req.on("success", fn);
      req.on("error", function (err) {
        _this2.onError("xhr post error", err);
      });
    }
    /**
     * Starts a poll cycle.
     *
     * @api private
     */

  }, {
    key: "doPoll",
    value: function doPoll() {
      var _this3 = this;

      debug("xhr poll");
      var req = this.request();
      req.on("data", this.onData.bind(this));
      req.on("error", function (err) {
        _this3.onError("xhr poll error", err);
      });
      this.pollXhr = req;
    }
  }]);

  return XHR;
}(Polling);

var Request = /*#__PURE__*/function (_Emitter) {
  _inherits(Request, _Emitter);

  var _super2 = _createSuper(Request);

  /**
   * Request constructor
   *
   * @param {Object} options
   * @api public
   */
  function Request(uri, opts) {
    var _this4;

    _classCallCheck(this, Request);

    _this4 = _super2.call(this);
    _this4.opts = opts;
    _this4.method = opts.method || "GET";
    _this4.uri = uri;
    _this4.async = false !== opts.async;
    _this4.data = undefined !== opts.data ? opts.data : null;

    _this4.create();

    return _this4;
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @api private
   */


  _createClass(Request, [{
    key: "create",
    value: function create() {
      var _this5 = this;

      var opts = pick(this.opts, "agent", "enablesXDR", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
      opts.xdomain = !!this.opts.xd;
      opts.xscheme = !!this.opts.xs;
      var xhr = this.xhr = new XMLHttpRequest(opts);

      try {
        debug("xhr open %s: %s", this.method, this.uri);
        xhr.open(this.method, this.uri, this.async);

        try {
          if (this.opts.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);

            for (var i in this.opts.extraHeaders) {
              if (this.opts.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
              }
            }
          }
        } catch (e) {}

        if ("POST" === this.method) {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {}
        }

        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {} // ie6 check


        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.opts.withCredentials;
        }

        if (this.opts.requestTimeout) {
          xhr.timeout = this.opts.requestTimeout;
        }

        if (this.hasXDR()) {
          xhr.onload = function () {
            _this5.onLoad();
          };

          xhr.onerror = function () {
            _this5.onError(xhr.responseText);
          };
        } else {
          xhr.onreadystatechange = function () {
            if (4 !== xhr.readyState) return;

            if (200 === xhr.status || 1223 === xhr.status) {
              _this5.onLoad();
            } else {
              // make sure the `error` event handler that's user-set
              // does not throw in the same tick and gets caught here
              setTimeout(function () {
                _this5.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
        }

        debug("xhr data %s", this.data);
        xhr.send(this.data);
      } catch (e) {
        // Need to defer since .create() is called directly from the constructor
        // and thus the 'error' event can only be only bound *after* this exception
        // occurs.  Therefore, also, we cannot throw here at all.
        setTimeout(function () {
          _this5.onError(e);
        }, 0);
        return;
      }

      if (typeof document !== "undefined") {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    }
    /**
     * Called upon successful response.
     *
     * @api private
     */

  }, {
    key: "onSuccess",
    value: function onSuccess() {
      this.emit("success");
      this.cleanup();
    }
    /**
     * Called if we have data.
     *
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      this.emit("data", data);
      this.onSuccess();
    }
    /**
     * Called upon error.
     *
     * @api private
     */

  }, {
    key: "onError",
    value: function onError(err) {
      this.emit("error", err);
      this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @api private
     */

  }, {
    key: "cleanup",
    value: function cleanup(fromError) {
      if ("undefined" === typeof this.xhr || null === this.xhr) {
        return;
      } // xmlhttprequest


      if (this.hasXDR()) {
        this.xhr.onload = this.xhr.onerror = empty;
      } else {
        this.xhr.onreadystatechange = empty;
      }

      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {}
      }

      if (typeof document !== "undefined") {
        delete Request.requests[this.index];
      }

      this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @api private
     */

  }, {
    key: "onLoad",
    value: function onLoad() {
      var data = this.xhr.responseText;

      if (data !== null) {
        this.onData(data);
      }
    }
    /**
     * Check if it has XDomainRequest.
     *
     * @api private
     */

  }, {
    key: "hasXDR",
    value: function hasXDR() {
      return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
    }
    /**
     * Aborts the request.
     *
     * @api public
     */

  }, {
    key: "abort",
    value: function abort() {
      this.cleanup();
    }
  }]);

  return Request;
}(Emitter);
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */


Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    var terminationEvent = "onpagehide" in globalThis ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

module.exports = XHR;
module.exports.Request = Request;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");

var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:polling");

var Polling = /*#__PURE__*/function (_Transport) {
  _inherits(Polling, _Transport);

  var _super = _createSuper(Polling);

  function Polling() {
    _classCallCheck(this, Polling);

    return _super.apply(this, arguments);
  }

  _createClass(Polling, [{
    key: "name",
    get:
    /**
     * Transport name.
     */
    function get() {
      return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @api private
     */

  }, {
    key: "doOpen",
    value: function doOpen() {
      this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} callback upon buffers are flushed and transport is paused
     * @api private
     */

  }, {
    key: "pause",
    value: function pause(onPause) {
      var _this = this;

      this.readyState = "pausing";

      var pause = function pause() {
        debug("paused");
        _this.readyState = "paused";
        onPause();
      };

      if (this.polling || !this.writable) {
        var total = 0;

        if (this.polling) {
          debug("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function () {
            debug("pre-pause polling complete");
            --total || pause();
          });
        }

        if (!this.writable) {
          debug("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function () {
            debug("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    /**
     * Starts polling cycle.
     *
     * @api public
     */

  }, {
    key: "poll",
    value: function poll() {
      debug("polling");
      this.polling = true;
      this.doPoll();
      this.emit("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      var _this2 = this;

      debug("polling got data %s", data);

      var callback = function callback(packet) {
        // if its the first message we consider the transport open
        if ("opening" === _this2.readyState && packet.type === "open") {
          _this2.onOpen();
        } // if its a close packet, we close the ongoing requests


        if ("close" === packet.type) {
          _this2.onClose();

          return false;
        } // otherwise bypass onData and handle the message


        _this2.onPacket(packet);
      }; // decode payload


      parser.decodePayload(data, this.socket.binaryType).forEach(callback); // if an event did not trigger closing

      if ("closed" !== this.readyState) {
        // if we got data we're not polling
        this.polling = false;
        this.emit("pollComplete");

        if ("open" === this.readyState) {
          this.poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    }
    /**
     * For polling, send a close packet.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose() {
      var _this3 = this;

      var close = function close() {
        debug("writing close packet");

        _this3.write([{
          type: "close"
        }]);
      };

      if ("open" === this.readyState) {
        debug("transport open - closing");
        close();
      } else {
        // in case we're trying to close while
        // handshaking is in progress (GH-164)
        debug("transport not open - deferring close");
        this.once("open", close);
      }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} data packets
     * @param {Function} drain callback
     * @api private
     */

  }, {
    key: "write",
    value: function write(packets) {
      var _this4 = this;

      this.writable = false;
      parser.encodePayload(packets, function (data) {
        _this4.doWrite(data, function () {
          _this4.writable = true;

          _this4.emit("drain");
        });
      });
    }
    /**
     * Generates uri for connection.
     *
     * @api private
     */

  }, {
    key: "uri",
    value: function uri() {
      var query = this.query || {};
      var schema = this.opts.secure ? "https" : "http";
      var port = ""; // cache busting is forced

      if (false !== this.opts.timestampRequests) {
        query[this.opts.timestampParam] = yeast();
      }

      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }

      query = parseqs.encode(query); // avoid port if default for schema

      if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
        port = ":" + this.opts.port;
      } // prepend ? to query


      if (query.length) {
        query = "?" + query;
      }

      var ipv6 = this.opts.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
    }
  }]);

  return Polling;
}(Transport);

module.exports = Polling;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var globalThis = __webpack_require__(/*! ../globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

var nextTick = function () {
  var isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";

  if (isPromiseAvailable) {
    return function (cb) {
      return Promise.resolve().then(cb);
    };
  } else {
    return function (cb) {
      return setTimeout(cb, 0);
    };
  }
}();

module.exports = {
  WebSocket: globalThis.WebSocket || globalThis.MozWebSocket,
  usingBrowserWebSocket: true,
  defaultBinaryType: "arraybuffer",
  nextTick: nextTick
};

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/websocket.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");

var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");

var _require = __webpack_require__(/*! ../util */ "./node_modules/engine.io-client/lib/util.js"),
    pick = _require.pick;

var _require2 = __webpack_require__(/*! ./websocket-constructor */ "./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js"),
    WebSocket = _require2.WebSocket,
    usingBrowserWebSocket = _require2.usingBrowserWebSocket,
    defaultBinaryType = _require2.defaultBinaryType,
    nextTick = _require2.nextTick;

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:websocket"); // detect ReactNative environment


var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";

var WS = /*#__PURE__*/function (_Transport) {
  _inherits(WS, _Transport);

  var _super = _createSuper(WS);

  /**
   * WebSocket transport constructor.
   *
   * @api {Object} connection options
   * @api public
   */
  function WS(opts) {
    var _this;

    _classCallCheck(this, WS);

    _this = _super.call(this, opts);
    _this.supportsBinary = !opts.forceBase64;
    return _this;
  }
  /**
   * Transport name.
   *
   * @api public
   */


  _createClass(WS, [{
    key: "name",
    get: function get() {
      return "websocket";
    }
    /**
     * Opens socket.
     *
     * @api private
     */

  }, {
    key: "doOpen",
    value: function doOpen() {
      if (!this.check()) {
        // let probe timeout
        return;
      }

      var uri = this.uri();
      var protocols = this.opts.protocols; // React Native only supports the 'headers' option, and will print a warning if anything else is passed

      var opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");

      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }

      try {
        this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
      } catch (err) {
        return this.emit("error", err);
      }

      this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
      this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @api private
     */

  }, {
    key: "addEventListeners",
    value: function addEventListeners() {
      var _this2 = this;

      this.ws.onopen = function () {
        if (_this2.opts.autoUnref) {
          _this2.ws._socket.unref();
        }

        _this2.onOpen();
      };

      this.ws.onclose = this.onClose.bind(this);

      this.ws.onmessage = function (ev) {
        return _this2.onData(ev.data);
      };

      this.ws.onerror = function (e) {
        return _this2.onError("websocket error", e);
      };
    }
    /**
     * Writes data to socket.
     *
     * @param {Array} array of packets.
     * @api private
     */

  }, {
    key: "write",
    value: function write(packets) {
      var _this3 = this;

      this.writable = false; // encodePacket efficient as it uses WS framing
      // no need for encodePayload

      var _loop = function _loop(i) {
        var packet = packets[i];
        var lastPacket = i === packets.length - 1;
        parser.encodePacket(packet, _this3.supportsBinary, function (data) {
          // always create a new object (GH-437)
          var opts = {};

          if (!usingBrowserWebSocket) {
            if (packet.options) {
              opts.compress = packet.options.compress;
            }

            if (_this3.opts.perMessageDeflate) {
              var len = "string" === typeof data ? Buffer.byteLength(data) : data.length;

              if (len < _this3.opts.perMessageDeflate.threshold) {
                opts.compress = false;
              }
            }
          } // Sometimes the websocket has already been closed but the browser didn't
          // have a chance of informing us about it yet, in that case send will
          // throw an error


          try {
            if (usingBrowserWebSocket) {
              // TypeError is thrown when passing the second argument on Safari
              _this3.ws.send(data);
            } else {
              _this3.ws.send(data, opts);
            }
          } catch (e) {
            debug("websocket closed before onclose event");
          }

          if (lastPacket) {
            // fake drain
            // defer to next tick to allow Socket to clear writeBuffer
            nextTick(function () {
              _this3.writable = true;

              _this3.emit("drain");
            });
          }
        });
      };

      for (var i = 0; i < packets.length; i++) {
        _loop(i);
      }
    }
    /**
     * Called upon close
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose() {
      Transport.prototype.onClose.call(this);
    }
    /**
     * Closes socket.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
        this.ws = null;
      }
    }
    /**
     * Generates uri for connection.
     *
     * @api private
     */

  }, {
    key: "uri",
    value: function uri() {
      var query = this.query || {};
      var schema = this.opts.secure ? "wss" : "ws";
      var port = ""; // avoid port if default for schema

      if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
        port = ":" + this.opts.port;
      } // append timestamp to URI


      if (this.opts.timestampRequests) {
        query[this.opts.timestampParam] = yeast();
      } // communicate binary support capabilities


      if (!this.supportsBinary) {
        query.b64 = 1;
      }

      query = parseqs.encode(query); // prepend ? to query

      if (query.length) {
        query = "?" + query;
      }

      var ipv6 = this.opts.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @api public
     */

  }, {
    key: "check",
    value: function check() {
      return !!WebSocket && !("__initialize" in WebSocket && this.name === WS.prototype.name);
    }
  }]);

  return WS;
}(Transport);

module.exports = WS;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/util.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-client/lib/util.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports.pick = function (obj) {
  for (var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    attr[_key - 1] = arguments[_key];
  }

  return attr.reduce(function (acc, k) {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }

    return acc;
  }, {});
};

/***/ }),

/***/ "./node_modules/engine.io-client/lib/xmlhttprequest.js":
/*!*************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/xmlhttprequest.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// browser shim for xmlhttprequest module
var hasCORS = __webpack_require__(/*! has-cors */ "./node_modules/has-cors/index.js");

var globalThis = __webpack_require__(/*! ./globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

module.exports = function (opts) {
  var xdomain = opts.xdomain; // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx

  var xscheme = opts.xscheme; // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217

  var enablesXDR = opts.enablesXDR; // XMLHttpRequest can be disabled on IE

  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {} // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example


  try {
    if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {}

  if (!xdomain) {
    try {
      return new globalThis[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {}
  }
};

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/commons.js":
/*!******************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/commons.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var PACKET_TYPES = Object.create(null); // no Map = no polyfill

PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach(function (key) {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = {
  type: "error",
  data: "parser error"
};
module.exports = {
  PACKET_TYPES: PACKET_TYPES,
  PACKET_TYPES_REVERSE: PACKET_TYPES_REVERSE,
  ERROR_PACKET: ERROR_PACKET
};

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/decodePacket.browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/decodePacket.browser.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(/*! ./commons */ "./node_modules/engine.io-parser/lib/commons.js"),
    PACKET_TYPES_REVERSE = _require.PACKET_TYPES_REVERSE,
    ERROR_PACKET = _require.ERROR_PACKET;

var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var base64decoder;

if (withNativeArrayBuffer) {
  base64decoder = __webpack_require__(/*! base64-arraybuffer */ "./node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
}

var decodePacket = function decodePacket(encodedPacket, binaryType) {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }

  var type = encodedPacket.charAt(0);

  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }

  var packetType = PACKET_TYPES_REVERSE[type];

  if (!packetType) {
    return ERROR_PACKET;
  }

  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};

var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
  if (base64decoder) {
    var decoded = base64decoder.decode(data);
    return mapBinary(decoded, binaryType);
  } else {
    return {
      base64: true,
      data: data
    }; // fallback for old browsers
  }
};

var mapBinary = function mapBinary(data, binaryType) {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;

    case "arraybuffer":
    default:
      return data;
    // assuming the data is already an ArrayBuffer
  }
};

module.exports = decodePacket;

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/encodePacket.browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/encodePacket.browser.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(/*! ./commons */ "./node_modules/engine.io-parser/lib/commons.js"),
    PACKET_TYPES = _require.PACKET_TYPES;

var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function"; // ArrayBuffer.isView method is not defined in IE10

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};

var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
  var type = _ref.type,
      data = _ref.data;

  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data instanceof ArrayBuffer ? data : data.buffer);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  } // plain string


  return callback(PACKET_TYPES[type] + (data || ""));
};

var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
  var fileReader = new FileReader();

  fileReader.onload = function () {
    var content = fileReader.result.split(",")[1];
    callback("b" + content);
  };

  return fileReader.readAsDataURL(data);
};

module.exports = encodePacket;

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var encodePacket = __webpack_require__(/*! ./encodePacket */ "./node_modules/engine.io-parser/lib/encodePacket.browser.js");

var decodePacket = __webpack_require__(/*! ./decodePacket */ "./node_modules/engine.io-parser/lib/decodePacket.browser.js");

var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

var encodePayload = function encodePayload(packets, callback) {
  // some packets may be added to the array while encoding, so the initial length must be saved
  var length = packets.length;
  var encodedPackets = new Array(length);
  var count = 0;
  packets.forEach(function (packet, i) {
    // force base64 encoding for binary packets
    encodePacket(packet, false, function (encodedPacket) {
      encodedPackets[i] = encodedPacket;

      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};

var decodePayload = function decodePayload(encodedPayload, binaryType) {
  var encodedPackets = encodedPayload.split(SEPARATOR);
  var packets = [];

  for (var i = 0; i < encodedPackets.length; i++) {
    var decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);

    if (decodedPacket.type === "error") {
      break;
    }
  }

  return packets;
};

module.exports = {
  protocol: 4,
  encodePacket: encodePacket,
  encodePayload: encodePayload,
  decodePacket: decodePacket,
  decodePayload: decodePayload
};

/***/ }),

/***/ "./node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function (chars) {
  "use strict";

  exports.encode = function (arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
        i,
        len = bytes.length,
        base64 = "";

    for (i = 0; i < len; i += 3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64 += chars[bytes[i + 2] & 63];
    }

    if (len % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode = function (base64) {
    var bufferLength = base64.length * 0.75,
        len = base64.length,
        i,
        p = 0,
        encoded1,
        encoded2,
        encoded3,
        encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;

      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i += 4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i + 1]);
      encoded3 = chars.indexOf(base64[i + 2]);
      encoded4 = chars.indexOf(base64[i + 3]);
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

/***/ }),

/***/ "./node_modules/has-cors/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-cors/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */
try {
  module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};

  var type = _typeof(val);

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/parseqs/index.js":
/*!***************************************!*\
  !*** ./node_modules/parseqs/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */


exports.decode = function (qs) {
  var qry = {};
  var pairs = qs.split('&');

  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }

  return qry;
};

/***/ }),

/***/ "./node_modules/parseuri/index.js":
/*!****************************************!*\
  !*** ./node_modules/parseuri/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];

module.exports = function parseuri(str) {
  var src = str,
      b = str.indexOf('['),
      e = str.indexOf(']');

  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
  }

  var m = re.exec(str || ''),
      uri = {},
      i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
    uri.ipv6uri = true;
  }

  uri.pathNames = pathNames(uri, uri['path']);
  uri.queryKey = queryKey(uri, uri['query']);
  return uri;
};

function pathNames(obj, path) {
  var regx = /\/{2,9}/g,
      names = path.replace(regx, "/").split("/");

  if (path.substr(0, 1) == '/' || path.length === 0) {
    names.splice(0, 1);
  }

  if (path.substr(path.length - 1, 1) == '/') {
    names.splice(names.length - 1, 1);
  }

  return names;
}

function queryKey(uri, query) {
  var data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/binary.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/binary.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reconstructPacket = exports.deconstructPacket = void 0;

var is_binary_1 = __webpack_require__(/*! ./is-binary */ "./node_modules/socket.io-parser/dist/is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */


function deconstructPacket(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'

  return {
    packet: pack,
    buffers: buffers
  };
}

exports.deconstructPacket = deconstructPacket;

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (is_binary_1.isBinary(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    var newData = new Array(data.length);

    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }

    return newData;
  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
    var _newData = {};

    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        _newData[key] = _deconstructPacket(data[key], buffers);
      }
    }

    return _newData;
  }

  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */


function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful

  return packet;
}

exports.reconstructPacket = reconstructPacket;

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (Array.isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (_typeof(data) === "object") {
    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }

  return data;
}

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var binary_1 = __webpack_require__(/*! ./binary */ "./node_modules/socket.io-parser/dist/binary.js");

var is_binary_1 = __webpack_require__(/*! ./is-binary */ "./node_modules/socket.io-parser/dist/is-binary.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-parser");
/**
 * Protocol version.
 *
 * @public
 */


exports.protocol = 5;
var PacketType;

(function (PacketType) {
  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType[PacketType["EVENT"] = 2] = "EVENT";
  PacketType[PacketType["ACK"] = 3] = "ACK";
  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */


var Encoder = /*#__PURE__*/function () {
  function Encoder() {
    _classCallCheck(this, Encoder);
  }

  _createClass(Encoder, [{
    key: "encode",
    value:
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    function encode(obj) {
      debug("encoding packet %j", obj);

      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (is_binary_1.hasBinary(obj)) {
          obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
          return this.encodeAsBinary(obj);
        }
      }

      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */

  }, {
    key: "encodeAsString",
    value: function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type; // attachments if we have them

      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      } // if we have a namespace other than `/`
      // we append it followed by a comma `,`


      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      } // immediately followed by the id


      if (null != obj.id) {
        str += obj.id;
      } // json data


      if (null != obj.data) {
        str += JSON.stringify(obj.data);
      }

      debug("encoded %j as %s", obj, str);
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */

  }, {
    key: "encodeAsBinary",
    value: function encodeAsBinary(obj) {
      var deconstruction = binary_1.deconstructPacket(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list

      return buffers; // write all the buffers
    }
  }]);

  return Encoder;
}();

exports.Encoder = Encoder;
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */

var Decoder = /*#__PURE__*/function (_Emitter) {
  _inherits(Decoder, _Emitter);

  var _super = _createSuper(Decoder);

  function Decoder() {
    _classCallCheck(this, Decoder);

    return _super.call(this);
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */


  _createClass(Decoder, [{
    key: "add",
    value: function add(obj) {
      var packet;

      if (typeof obj === "string") {
        packet = this.decodeString(obj);

        if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow

          if (packet.attachments === 0) {
            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        } else {
          // non-binary full packet
          _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
        }
      } else if (is_binary_1.isBinary(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);

          if (packet) {
            // received final buffer
            this.reconstructor = null;

            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */

  }, {
    key: "decodeString",
    value: function decodeString(str) {
      var i = 0; // look up type

      var p = {
        type: Number(str.charAt(0))
      };

      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      } // look up attachments if type binary


      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;

        while (str.charAt(++i) !== "-" && i != str.length) {}

        var buf = str.substring(start, i);

        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }

        p.attachments = Number(buf);
      } // look up namespace (if any)


      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;

        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }

        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      } // look up id


      var next = str.charAt(i + 1);

      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;

        while (++i) {
          var _c = str.charAt(i);

          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }

          if (i === str.length) break;
        }

        p.id = Number(str.substring(_start2, i + 1));
      } // look up json data


      if (str.charAt(++i)) {
        var payload = tryParse(str.substr(i));

        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }

      debug("decoded %s as %j", str, p);
      return p;
    }
  }, {
    key: "destroy",
    value:
    /**
     * Deallocates a parser's resources
     */
    function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    }
  }], [{
    key: "isPayloadValid",
    value: function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return _typeof(payload) === "object";

        case PacketType.DISCONNECT:
          return payload === undefined;

        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || _typeof(payload) === "object";

        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && payload.length > 0;

        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
  }]);

  return Decoder;
}(Emitter);

exports.Decoder = Decoder;

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch (e) {
    return false;
  }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */


var BinaryReconstructor = /*#__PURE__*/function () {
  function BinaryReconstructor(packet) {
    _classCallCheck(this, BinaryReconstructor);

    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */


  _createClass(BinaryReconstructor, [{
    key: "takeBinaryData",
    value: function takeBinaryData(binData) {
      this.buffers.push(binData);

      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }

      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */

  }, {
    key: "finishedReconstruction",
    value: function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }]);

  return BinaryReconstructor;
}();

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/is-binary.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/is-binary.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasBinary = exports.isBinary = void 0;
var withNativeArrayBuffer = typeof ArrayBuffer === "function";

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */

function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}

exports.isBinary = isBinary;

function hasBinary(obj, toJSON) {
  if (!obj || _typeof(obj) !== "object") {
    return false;
  }

  if (Array.isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }

    return false;
  }

  if (isBinary(obj)) {
    return true;
  }

  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

exports.hasBinary = hasBinary;

/***/ }),

/***/ "./node_modules/yeast/index.js":
/*!*************************************!*\
  !*** ./node_modules/yeast/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
    length = 64,
    map = {},
    seed = 0,
    i = 0,
    prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */

function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */


function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */


function yeast() {
  var now = encode(+new Date());
  if (now !== prev) return seed = 0, prev = now;
  return now + '.' + encode(seed++);
} //
// Map each character to its index.
//


for (; i < length; i++) {
  map[alphabet[i]] = i;
} //
// Expose the `yeast`, `encode` and `decode` functions.
//


yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

/***/ })

/******/ });
});
//# sourceMappingURL=socket.io.js.map
  var t = {
      873: (t) => {
        t.exports = (function t(e, n, i) {
          function r(s, a) {
            if (!n[s]) {
              if (!e[s]) {
                if (o) return o(s, !0);
                throw new Error("Cannot find module '" + s + "'");
              }
              var l = (n[s] = { exports: {} });
              e[s][0].call(
                l.exports,
                function (t) {
                  return r(e[s][1][t] || t);
                },
                l,
                l.exports,
                t,
                e,
                n,
                i
              );
            }
            return n[s].exports;
          }
          for (var o = void 0, s = 0; s < i.length; s++) r(i[s]);
          return r;
        })(
          {
            1: [
              function (t, e) {
                e.exports = {
                  name: "cannon",
                  version: "0.6.2",
                  description:
                    "A lightweight 3D physics engine written in JavaScript.",
                  homepage: "https://github.com/schteppe/cannon.js",
                  author:
                    "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                  keywords: ["cannon.js", "cannon", "physics", "engine", "3d"],
                  main: "./build/cannon.js",
                  engines: { node: "*" },
                  repository: {
                    type: "git",
                    url: "https://github.com/schteppe/cannon.js.git",
                  },
                  bugs: { url: "https://github.com/schteppe/cannon.js/issues" },
                  licenses: [{ type: "MIT" }],
                  devDependencies: {
                    jshint: "latest",
                    "uglify-js": "latest",
                    nodeunit: "^0.9.0",
                    grunt: "~0.4.0",
                    "grunt-contrib-jshint": "~0.1.1",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-concat": "~0.1.3",
                    "grunt-contrib-uglify": "^0.5.1",
                    "grunt-browserify": "^2.1.4",
                    "grunt-contrib-yuidoc": "^0.5.2",
                    browserify: "*",
                  },
                  dependencies: {},
                };
              },
              {},
            ],
            2: [
              function (t, e) {
                e.exports = {
                  version: t("../package.json").version,
                  AABB: t("./collision/AABB"),
                  ArrayCollisionMatrix: t("./collision/ArrayCollisionMatrix"),
                  Body: t("./objects/Body"),
                  Box: t("./shapes/Box"),
                  Broadphase: t("./collision/Broadphase"),
                  Constraint: t("./constraints/Constraint"),
                  ContactEquation: t("./equations/ContactEquation"),
                  Narrowphase: t("./world/Narrowphase"),
                  ConeTwistConstraint: t("./constraints/ConeTwistConstraint"),
                  ContactMaterial: t("./material/ContactMaterial"),
                  ConvexPolyhedron: t("./shapes/ConvexPolyhedron"),
                  Cylinder: t("./shapes/Cylinder"),
                  DistanceConstraint: t("./constraints/DistanceConstraint"),
                  Equation: t("./equations/Equation"),
                  EventTarget: t("./utils/EventTarget"),
                  FrictionEquation: t("./equations/FrictionEquation"),
                  GSSolver: t("./solver/GSSolver"),
                  GridBroadphase: t("./collision/GridBroadphase"),
                  Heightfield: t("./shapes/Heightfield"),
                  HingeConstraint: t("./constraints/HingeConstraint"),
                  LockConstraint: t("./constraints/LockConstraint"),
                  Mat3: t("./math/Mat3"),
                  Material: t("./material/Material"),
                  NaiveBroadphase: t("./collision/NaiveBroadphase"),
                  ObjectCollisionMatrix: t("./collision/ObjectCollisionMatrix"),
                  Pool: t("./utils/Pool"),
                  Particle: t("./shapes/Particle"),
                  Plane: t("./shapes/Plane"),
                  PointToPointConstraint: t(
                    "./constraints/PointToPointConstraint"
                  ),
                  Quaternion: t("./math/Quaternion"),
                  Ray: t("./collision/Ray"),
                  RaycastVehicle: t("./objects/RaycastVehicle"),
                  RaycastResult: t("./collision/RaycastResult"),
                  RigidVehicle: t("./objects/RigidVehicle"),
                  RotationalEquation: t("./equations/RotationalEquation"),
                  RotationalMotorEquation: t(
                    "./equations/RotationalMotorEquation"
                  ),
                  SAPBroadphase: t("./collision/SAPBroadphase"),
                  SPHSystem: t("./objects/SPHSystem"),
                  Shape: t("./shapes/Shape"),
                  Solver: t("./solver/Solver"),
                  Sphere: t("./shapes/Sphere"),
                  SplitSolver: t("./solver/SplitSolver"),
                  Spring: t("./objects/Spring"),
                  Trimesh: t("./shapes/Trimesh"),
                  Vec3: t("./math/Vec3"),
                  Vec3Pool: t("./utils/Vec3Pool"),
                  World: t("./world/World"),
                };
              },
              {
                "../package.json": 1,
                "./collision/AABB": 3,
                "./collision/ArrayCollisionMatrix": 4,
                "./collision/Broadphase": 5,
                "./collision/GridBroadphase": 6,
                "./collision/NaiveBroadphase": 7,
                "./collision/ObjectCollisionMatrix": 8,
                "./collision/Ray": 9,
                "./collision/RaycastResult": 10,
                "./collision/SAPBroadphase": 11,
                "./constraints/ConeTwistConstraint": 12,
                "./constraints/Constraint": 13,
                "./constraints/DistanceConstraint": 14,
                "./constraints/HingeConstraint": 15,
                "./constraints/LockConstraint": 16,
                "./constraints/PointToPointConstraint": 17,
                "./equations/ContactEquation": 19,
                "./equations/Equation": 20,
                "./equations/FrictionEquation": 21,
                "./equations/RotationalEquation": 22,
                "./equations/RotationalMotorEquation": 23,
                "./material/ContactMaterial": 24,
                "./material/Material": 25,
                "./math/Mat3": 27,
                "./math/Quaternion": 28,
                "./math/Vec3": 30,
                "./objects/Body": 31,
                "./objects/RaycastVehicle": 32,
                "./objects/RigidVehicle": 33,
                "./objects/SPHSystem": 34,
                "./objects/Spring": 35,
                "./shapes/Box": 37,
                "./shapes/ConvexPolyhedron": 38,
                "./shapes/Cylinder": 39,
                "./shapes/Heightfield": 40,
                "./shapes/Particle": 41,
                "./shapes/Plane": 42,
                "./shapes/Shape": 43,
                "./shapes/Sphere": 44,
                "./shapes/Trimesh": 45,
                "./solver/GSSolver": 46,
                "./solver/Solver": 47,
                "./solver/SplitSolver": 48,
                "./utils/EventTarget": 49,
                "./utils/Pool": 51,
                "./utils/Vec3Pool": 54,
                "./world/Narrowphase": 55,
                "./world/World": 56,
              },
            ],
            3: [
              function (t, e) {
                function n(t) {
                  (t = t || {}),
                    (this.lowerBound = new i()),
                    t.lowerBound && this.lowerBound.copy(t.lowerBound),
                    (this.upperBound = new i()),
                    t.upperBound && this.upperBound.copy(t.upperBound);
                }
                var i = t("../math/Vec3");
                t("../utils/Utils"), (e.exports = n);
                var r = new i();
                (n.prototype.setFromPoints = function (t, e, n, i) {
                  var o = this.lowerBound,
                    s = this.upperBound,
                    a = n;
                  o.copy(t[0]), a && a.vmult(o, o), s.copy(o);
                  for (var l = 1; l < t.length; l++) {
                    var c = t[l];
                    a && (a.vmult(c, r), (c = r)),
                      c.x > s.x && (s.x = c.x),
                      c.x < o.x && (o.x = c.x),
                      c.y > s.y && (s.y = c.y),
                      c.y < o.y && (o.y = c.y),
                      c.z > s.z && (s.z = c.z),
                      c.z < o.z && (o.z = c.z);
                  }
                  return (
                    e && (e.vadd(o, o), e.vadd(s, s)),
                    i &&
                      ((o.x -= i),
                      (o.y -= i),
                      (o.z -= i),
                      (s.x += i),
                      (s.y += i),
                      (s.z += i)),
                    this
                  );
                }),
                  (n.prototype.copy = function (t) {
                    return (
                      this.lowerBound.copy(t.lowerBound),
                      this.upperBound.copy(t.upperBound),
                      this
                    );
                  }),
                  (n.prototype.clone = function () {
                    return new n().copy(this);
                  }),
                  (n.prototype.extend = function (t) {
                    var e = t.lowerBound.x;
                    this.lowerBound.x > e && (this.lowerBound.x = e);
                    var n = t.upperBound.x;
                    this.upperBound.x < n && (this.upperBound.x = n),
                      (e = t.lowerBound.y),
                      this.lowerBound.y > e && (this.lowerBound.y = e),
                      (n = t.upperBound.y),
                      this.upperBound.y < n && (this.upperBound.y = n),
                      (e = t.lowerBound.z),
                      this.lowerBound.z > e && (this.lowerBound.z = e),
                      (n = t.upperBound.z),
                      this.upperBound.z < n && (this.upperBound.z = n);
                  }),
                  (n.prototype.overlaps = function (t) {
                    var e = this.lowerBound,
                      n = this.upperBound,
                      i = t.lowerBound,
                      r = t.upperBound;
                    return (
                      ((i.x <= n.x && n.x <= r.x) ||
                        (e.x <= r.x && r.x <= n.x)) &&
                      ((i.y <= n.y && n.y <= r.y) ||
                        (e.y <= r.y && r.y <= n.y)) &&
                      ((i.z <= n.z && n.z <= r.z) || (e.z <= r.z && r.z <= n.z))
                    );
                  }),
                  (n.prototype.contains = function (t) {
                    var e = this.lowerBound,
                      n = this.upperBound,
                      i = t.lowerBound,
                      r = t.upperBound;
                    return (
                      e.x <= i.x &&
                      n.x >= r.x &&
                      e.y <= i.y &&
                      n.y >= r.y &&
                      e.z <= i.z &&
                      n.z >= r.z
                    );
                  }),
                  (n.prototype.getCorners = function (t, e, n, i, r, o, s, a) {
                    var l = this.lowerBound,
                      c = this.upperBound;
                    t.copy(l),
                      e.set(c.x, l.y, l.z),
                      n.set(c.x, c.y, l.z),
                      i.set(l.x, c.y, c.z),
                      r.set(c.x, l.y, l.z),
                      o.set(l.x, c.y, l.z),
                      s.set(l.x, l.y, c.z),
                      a.copy(c);
                  });
                var o = [
                  new i(),
                  new i(),
                  new i(),
                  new i(),
                  new i(),
                  new i(),
                  new i(),
                  new i(),
                ];
                (n.prototype.toLocalFrame = function (t, e) {
                  var n = o,
                    i = n[0],
                    r = n[1],
                    s = n[2],
                    a = n[3],
                    l = n[4],
                    c = n[5],
                    u = n[6],
                    h = n[7];
                  this.getCorners(i, r, s, a, l, c, u, h);
                  for (var d = 0; 8 !== d; d++) {
                    var p = n[d];
                    t.pointToLocal(p, p);
                  }
                  return e.setFromPoints(n);
                }),
                  (n.prototype.toWorldFrame = function (t, e) {
                    var n = o,
                      i = n[0],
                      r = n[1],
                      s = n[2],
                      a = n[3],
                      l = n[4],
                      c = n[5],
                      u = n[6],
                      h = n[7];
                    this.getCorners(i, r, s, a, l, c, u, h);
                    for (var d = 0; 8 !== d; d++) {
                      var p = n[d];
                      t.pointToWorld(p, p);
                    }
                    return e.setFromPoints(n);
                  });
              },
              { "../math/Vec3": 30, "../utils/Utils": 53 },
            ],
            4: [
              function (t, e) {
                function n() {
                  this.matrix = [];
                }
                (e.exports = n),
                  (n.prototype.get = function (t, e) {
                    if (((t = t.index), (e = e.index) > t)) {
                      var n = e;
                      (e = t), (t = n);
                    }
                    return this.matrix[((t * (t + 1)) >> 1) + e - 1];
                  }),
                  (n.prototype.set = function (t, e, n) {
                    if (((t = t.index), (e = e.index) > t)) {
                      var i = e;
                      (e = t), (t = i);
                    }
                    this.matrix[((t * (t + 1)) >> 1) + e - 1] = n ? 1 : 0;
                  }),
                  (n.prototype.reset = function () {
                    for (var t = 0, e = this.matrix.length; t !== e; t++)
                      this.matrix[t] = 0;
                  }),
                  (n.prototype.setNumObjects = function (t) {
                    this.matrix.length = (t * (t - 1)) >> 1;
                  });
              },
              {},
            ],
            5: [
              function (t, e) {
                function n() {
                  (this.world = null),
                    (this.useBoundingBoxes = !1),
                    (this.dirty = !0);
                }
                var i = t("../objects/Body"),
                  r = t("../math/Vec3"),
                  o = t("../math/Quaternion");
                t("../shapes/Shape"),
                  t("../shapes/Plane"),
                  (e.exports = n),
                  (n.prototype.collisionPairs = function () {
                    throw new Error(
                      "collisionPairs not implemented for this BroadPhase class!"
                    );
                  });
                var s = i.STATIC | i.KINEMATIC;
                (n.prototype.needBroadphaseCollision = function (t, e) {
                  return (
                    0 != (t.collisionFilterGroup & e.collisionFilterMask) &&
                    0 != (e.collisionFilterGroup & t.collisionFilterMask) &&
                    ((0 == (t.type & s) && t.sleepState !== i.SLEEPING) ||
                      (0 == (e.type & s) && e.sleepState !== i.SLEEPING))
                  );
                }),
                  (n.prototype.intersectionTest = function (t, e, n, i) {
                    this.useBoundingBoxes
                      ? this.doBoundingBoxBroadphase(t, e, n, i)
                      : this.doBoundingSphereBroadphase(t, e, n, i);
                  });
                var a = new r();
                new r(),
                  new o(),
                  new r(),
                  (n.prototype.doBoundingSphereBroadphase = function (
                    t,
                    e,
                    n,
                    i
                  ) {
                    var r = a;
                    e.position.vsub(t.position, r),
                      Math.pow(t.boundingRadius + e.boundingRadius, 2) >
                        r.norm2() && (n.push(t), i.push(e));
                  }),
                  (n.prototype.doBoundingBoxBroadphase = function (t, e, n, i) {
                    t.aabbNeedsUpdate && t.computeAABB(),
                      e.aabbNeedsUpdate && e.computeAABB(),
                      t.aabb.overlaps(e.aabb) && (n.push(t), i.push(e));
                  });
                var l = { keys: [] },
                  c = [],
                  u = [];
                (n.prototype.makePairsUnique = function (t, e) {
                  for (
                    var n = l, i = c, r = u, o = t.length, s = 0;
                    s !== o;
                    s++
                  )
                    (i[s] = t[s]), (r[s] = e[s]);
                  for (t.length = 0, e.length = 0, s = 0; s !== o; s++) {
                    var a = i[s].id,
                      h = r[s].id;
                    (n[(d = h > a ? a + "," + h : h + "," + a)] = s),
                      n.keys.push(d);
                  }
                  for (s = 0; s !== n.keys.length; s++) {
                    var d = n.keys.pop(),
                      p = n[d];
                    t.push(i[p]), e.push(r[p]), delete n[d];
                  }
                }),
                  (n.prototype.setWorld = function () {});
                var h = new r();
                (n.boundingSphereCheck = function (t, e) {
                  var n = h;
                  return (
                    t.position.vsub(e.position, n),
                    Math.pow(
                      t.shape.boundingSphereRadius +
                        e.shape.boundingSphereRadius,
                      2
                    ) > n.norm2()
                  );
                }),
                  (n.prototype.aabbQuery = function () {
                    return (
                      console.warn(
                        ".aabbQuery is not implemented in this Broadphase subclass."
                      ),
                      []
                    );
                  });
              },
              {
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/Body": 31,
                "../shapes/Plane": 42,
                "../shapes/Shape": 43,
              },
            ],
            6: [
              function (t, e) {
                function n(t, e, n, o, s) {
                  i.apply(this),
                    (this.nx = n || 10),
                    (this.ny = o || 10),
                    (this.nz = s || 10),
                    (this.aabbMin = t || new r(100, 100, 100)),
                    (this.aabbMax = e || new r(-100, -100, -100));
                  var a = this.nx * this.ny * this.nz;
                  if (0 >= a)
                    throw "GridBroadphase: Each dimension's n must be >0";
                  (this.bins = []),
                    (this.binLengths = []),
                    (this.bins.length = a),
                    (this.binLengths.length = a);
                  for (var l = 0; a > l; l++)
                    (this.bins[l] = []), (this.binLengths[l] = 0);
                }
                e.exports = n;
                var i = t("./Broadphase"),
                  r = t("../math/Vec3"),
                  o = t("../shapes/Shape");
                (n.prototype = new i()), (n.prototype.constructor = n);
                var s = new r();
                new r(),
                  (n.prototype.collisionPairs = function (t, e, n) {
                    function i(t, e, n, i, r, o, s) {
                      var a = ((t - x) * _) | 0,
                        l = ((e - b) * M) | 0,
                        c = ((n - w) * S) | 0,
                        g = D((i - x) * _),
                        v = D((r - b) * M),
                        y = D((o - w) * S);
                      0 > a ? (a = 0) : a >= u && (a = u - 1),
                        0 > l ? (l = 0) : l >= h && (l = h - 1),
                        0 > c ? (c = 0) : c >= d && (c = d - 1),
                        0 > g ? (g = 0) : g >= u && (g = u - 1),
                        0 > v ? (v = 0) : v >= h && (v = h - 1),
                        0 > y ? (y = 0) : y >= d && (y = d - 1),
                        (l *= f),
                        (c *= m),
                        (g *= p),
                        (v *= f),
                        (y *= m);
                      for (var E = (a *= p); g >= E; E += p)
                        for (var T = l; v >= T; T += f)
                          for (var A = c; y >= A; A += m) {
                            var C = E + T + A;
                            N[C][I[C]++] = s;
                          }
                    }
                    for (
                      var r = t.numObjects(),
                        a = t.bodies,
                        l = this.aabbMax,
                        c = this.aabbMin,
                        u = this.nx,
                        h = this.ny,
                        d = this.nz,
                        p = h * d,
                        f = d,
                        m = 1,
                        g = l.x,
                        v = l.y,
                        y = l.z,
                        x = c.x,
                        b = c.y,
                        w = c.z,
                        _ = u / (g - x),
                        M = h / (v - b),
                        S = d / (y - w),
                        E = (g - x) / u,
                        T = (v - b) / h,
                        A = (y - w) / d,
                        C = 0.5 * Math.sqrt(E * E + T * T + A * A),
                        L = o.types,
                        R = L.SPHERE,
                        P = L.PLANE,
                        N = (L.BOX, L.COMPOUND, L.CONVEXPOLYHEDRON, this.bins),
                        I = this.binLengths,
                        B = this.bins.length,
                        O = 0;
                      O !== B;
                      O++
                    )
                      I[O] = 0;
                    var D = Math.ceil;
                    for (c = Math.min, l = Math.max, O = 0; O !== r; O++) {
                      var k = (nt = a[O]).shape;
                      switch (k.type) {
                        case R:
                          var F = nt.position.x,
                            z = nt.position.y,
                            H = nt.position.z,
                            U = k.radius;
                          i(F - U, z - U, H - U, F + U, z + U, H + U, nt);
                          break;
                        case P:
                          k.worldNormalNeedsUpdate &&
                            k.computeWorldNormal(nt.quaternion);
                          var V = k.worldNormal,
                            G = x + 0.5 * E - nt.position.x,
                            j = b + 0.5 * T - nt.position.y,
                            W = w + 0.5 * A - nt.position.z,
                            q = s;
                          q.set(G, j, W);
                          for (
                            var X = 0, Y = 0;
                            X !== u;
                            X++, Y += p, q.y = j, q.x += E
                          )
                            for (
                              var Z = 0, J = 0;
                              Z !== h;
                              Z++, J += f, q.z = W, q.y += T
                            )
                              for (
                                var K = 0, Q = 0;
                                K !== d;
                                K++, Q += m, q.z += A
                              )
                                if (q.dot(V) < C) {
                                  var $ = Y + J + Q;
                                  N[$][I[$]++] = nt;
                                }
                          break;
                        default:
                          nt.aabbNeedsUpdate && nt.computeAABB(),
                            i(
                              nt.aabb.lowerBound.x,
                              nt.aabb.lowerBound.y,
                              nt.aabb.lowerBound.z,
                              nt.aabb.upperBound.x,
                              nt.aabb.upperBound.y,
                              nt.aabb.upperBound.z,
                              nt
                            );
                      }
                    }
                    for (O = 0; O !== B; O++) {
                      var tt = I[O];
                      if (tt > 1) {
                        var et = N[O];
                        for (X = 0; X !== tt; X++) {
                          var nt = et[X];
                          for (Z = 0; Z !== X; Z++) {
                            var it = et[Z];
                            this.needBroadphaseCollision(nt, it) &&
                              this.intersectionTest(nt, it, e, n);
                          }
                        }
                      }
                    }
                    this.makePairsUnique(e, n);
                  });
              },
              { "../math/Vec3": 30, "../shapes/Shape": 43, "./Broadphase": 5 },
            ],
            7: [
              function (t, e) {
                function n() {
                  i.apply(this);
                }
                e.exports = n;
                var i = t("./Broadphase"),
                  r = t("./AABB");
                (n.prototype = new i()),
                  (n.prototype.constructor = n),
                  (n.prototype.collisionPairs = function (t, e, n) {
                    var i,
                      r,
                      o,
                      s,
                      a = t.bodies,
                      l = a.length;
                    for (i = 0; i !== l; i++)
                      for (r = 0; r !== i; r++)
                        (o = a[i]),
                          (s = a[r]),
                          this.needBroadphaseCollision(o, s) &&
                            this.intersectionTest(o, s, e, n);
                  }),
                  new r(),
                  (n.prototype.aabbQuery = function (t, e, n) {
                    n = n || [];
                    for (var i = 0; i < t.bodies.length; i++) {
                      var r = t.bodies[i];
                      r.aabbNeedsUpdate && r.computeAABB(),
                        r.aabb.overlaps(e) && n.push(r);
                    }
                    return n;
                  });
              },
              { "./AABB": 3, "./Broadphase": 5 },
            ],
            8: [
              function (t, e) {
                function n() {
                  this.matrix = {};
                }
                (e.exports = n),
                  (n.prototype.get = function (t, e) {
                    if (((t = t.id), (e = e.id) > t)) {
                      var n = e;
                      (e = t), (t = n);
                    }
                    return t + "-" + e in this.matrix;
                  }),
                  (n.prototype.set = function (t, e, n) {
                    if (((t = t.id), (e = e.id) > t)) {
                      var i = e;
                      (e = t), (t = i);
                    }
                    n
                      ? (this.matrix[t + "-" + e] = !0)
                      : delete this.matrix[t + "-" + e];
                  }),
                  (n.prototype.reset = function () {
                    this.matrix = {};
                  }),
                  (n.prototype.setNumObjects = function () {});
              },
              {},
            ],
            9: [
              function (t, e) {
                function n(t, e) {
                  (this.from = t ? t.clone() : new r()),
                    (this.to = e ? e.clone() : new r()),
                    (this._direction = new r()),
                    (this.precision = 1e-4),
                    (this.checkCollisionResponse = !0),
                    (this.skipBackfaces = !1),
                    (this.collisionFilterMask = -1),
                    (this.collisionFilterGroup = -1),
                    (this.mode = n.ANY),
                    (this.result = new a()),
                    (this.hasHit = !1),
                    (this.callback = function () {});
                }
                function i(t, e, n, i) {
                  i.vsub(e, I), n.vsub(e, d), t.vsub(e, p);
                  var r,
                    o,
                    s = I.dot(I),
                    a = I.dot(d),
                    l = I.dot(p),
                    c = d.dot(d),
                    u = d.dot(p);
                  return (
                    (r = c * l - a * u) >= 0 &&
                    (o = s * u - a * l) >= 0 &&
                    s * c - a * a > r + o
                  );
                }
                e.exports = n;
                var r = t("../math/Vec3"),
                  o = t("../math/Quaternion"),
                  s = t("../math/Transform"),
                  a =
                    (t("../shapes/ConvexPolyhedron"),
                    t("../shapes/Box"),
                    t("../collision/RaycastResult")),
                  l = t("../shapes/Shape"),
                  c = t("../collision/AABB");
                (n.prototype.constructor = n),
                  (n.CLOSEST = 1),
                  (n.ANY = 2),
                  (n.ALL = 4);
                var u = new c(),
                  h = [];
                n.prototype.intersectWorld = function (t, e) {
                  return (
                    (this.mode = e.mode || n.ANY),
                    (this.result = e.result || new a()),
                    (this.skipBackfaces = !!e.skipBackfaces),
                    (this.collisionFilterMask =
                      void 0 !== e.collisionFilterMask
                        ? e.collisionFilterMask
                        : -1),
                    (this.collisionFilterGroup =
                      void 0 !== e.collisionFilterGroup
                        ? e.collisionFilterGroup
                        : -1),
                    e.from && this.from.copy(e.from),
                    e.to && this.to.copy(e.to),
                    (this.callback = e.callback || function () {}),
                    (this.hasHit = !1),
                    this.result.reset(),
                    this._updateDirection(),
                    this.getAABB(u),
                    (h.length = 0),
                    t.broadphase.aabbQuery(t, u, h),
                    this.intersectBodies(h),
                    this.hasHit
                  );
                };
                var d = new r(),
                  p = new r();
                n.pointInTriangle = i;
                var f = new r(),
                  m = new o();
                (n.prototype.intersectBody = function (t, e) {
                  e && ((this.result = e), this._updateDirection());
                  var n = this.checkCollisionResponse;
                  if (
                    (!n || t.collisionResponse) &&
                    0 != (this.collisionFilterGroup & t.collisionFilterMask) &&
                    0 != (t.collisionFilterGroup & this.collisionFilterMask)
                  )
                    for (
                      var i = f, r = m, o = 0, s = t.shapes.length;
                      s > o;
                      o++
                    ) {
                      var a = t.shapes[o];
                      if (
                        (!n || a.collisionResponse) &&
                        (t.quaternion.mult(t.shapeOrientations[o], r),
                        t.quaternion.vmult(t.shapeOffsets[o], i),
                        i.vadd(t.position, i),
                        this.intersectShape(a, r, i, t),
                        this.result._shouldStop)
                      )
                        break;
                    }
                }),
                  (n.prototype.intersectBodies = function (t, e) {
                    e && ((this.result = e), this._updateDirection());
                    for (
                      var n = 0, i = t.length;
                      !this.result._shouldStop && i > n;
                      n++
                    )
                      this.intersectBody(t[n]);
                  }),
                  (n.prototype._updateDirection = function () {
                    this.to.vsub(this.from, this._direction),
                      this._direction.normalize();
                  }),
                  (n.prototype.intersectShape = function (t, e, n, i) {
                    if (
                      !(
                        (function (t, e, n) {
                          n.vsub(t, I);
                          var i = I.dot(e);
                          return e.mult(i, B), B.vadd(t, B), n.distanceTo(B);
                        })(this.from, this._direction, n) >
                        t.boundingSphereRadius
                      )
                    ) {
                      var r = this[t.type];
                      r && r.call(this, t, e, n, i);
                    }
                  });
                var g = (new r(), new r(), new r()),
                  v = new r(),
                  y = new r(),
                  x = new r();
                new r(),
                  new a(),
                  (n.prototype.intersectBox = function (t, e, n, i) {
                    return this.intersectConvex(
                      t.convexPolyhedronRepresentation,
                      e,
                      n,
                      i
                    );
                  }),
                  (n.prototype[l.types.BOX] = n.prototype.intersectBox),
                  (n.prototype.intersectPlane = function (t, e, n, i) {
                    var o = this.from,
                      s = this.to,
                      a = this._direction,
                      l = new r(0, 0, 1);
                    e.vmult(l, l);
                    var c = new r();
                    o.vsub(n, c);
                    var u = c.dot(l);
                    if (
                      (s.vsub(n, c), !(u * c.dot(l) > 0 || o.distanceTo(s) < u))
                    ) {
                      var h = l.dot(a);
                      if (!(Math.abs(h) < this.precision)) {
                        var d = new r(),
                          p = new r(),
                          f = new r();
                        o.vsub(n, d);
                        var m = -l.dot(d) / h;
                        a.scale(m, p),
                          o.vadd(p, f),
                          this.reportIntersection(l, f, t, i, -1);
                      }
                    }
                  }),
                  (n.prototype[l.types.PLANE] = n.prototype.intersectPlane),
                  (n.prototype.getAABB = function (t) {
                    var e = this.to,
                      n = this.from;
                    (t.lowerBound.x = Math.min(e.x, n.x)),
                      (t.lowerBound.y = Math.min(e.y, n.y)),
                      (t.lowerBound.z = Math.min(e.z, n.z)),
                      (t.upperBound.x = Math.max(e.x, n.x)),
                      (t.upperBound.y = Math.max(e.y, n.y)),
                      (t.upperBound.z = Math.max(e.z, n.z));
                  });
                var b = { faceList: [0] };
                (n.prototype.intersectHeightfield = function (t, e, i, o) {
                  var a = (t.data, t.elementSize, new r()),
                    l = new n(this.from, this.to);
                  s.pointToLocalFrame(i, e, l.from, l.from),
                    s.pointToLocalFrame(i, e, l.to, l.to);
                  var c = [],
                    u = null,
                    h = null,
                    d = null,
                    p = null,
                    f = t.getIndexOfPosition(l.from.x, l.from.y, c, !1);
                  if (
                    (f && ((u = c[0]), (h = c[1]), (d = c[0]), (p = c[1])),
                    (f = t.getIndexOfPosition(l.to.x, l.to.y, c, !1)) &&
                      ((null === u || c[0] < u) && (u = c[0]),
                      (null === d || c[0] > d) && (d = c[0]),
                      (null === h || c[1] < h) && (h = c[1]),
                      (null === p || c[1] > p) && (p = c[1])),
                    null !== u)
                  ) {
                    var m = [];
                    t.getRectMinMax(u, h, d, p, m);
                    for (var g = u; d >= g; g++)
                      for (var v = h; p >= v; v++) {
                        if (this.result._shouldStop) return;
                        if (
                          (t.getConvexTrianglePillar(g, v, !1),
                          s.pointToWorldFrame(i, e, t.pillarOffset, a),
                          this.intersectConvex(t.pillarConvex, e, a, o, b),
                          this.result._shouldStop)
                        )
                          return;
                        t.getConvexTrianglePillar(g, v, !0),
                          s.pointToWorldFrame(i, e, t.pillarOffset, a),
                          this.intersectConvex(t.pillarConvex, e, a, o, b);
                      }
                  }
                }),
                  (n.prototype[l.types.HEIGHTFIELD] =
                    n.prototype.intersectHeightfield);
                var w = new r(),
                  _ = new r();
                (n.prototype.intersectSphere = function (t, e, n, i) {
                  var r = this.from,
                    o = this.to,
                    s = t.radius,
                    a =
                      Math.pow(o.x - r.x, 2) +
                      Math.pow(o.y - r.y, 2) +
                      Math.pow(o.z - r.z, 2),
                    l =
                      2 *
                      ((o.x - r.x) * (r.x - n.x) +
                        (o.y - r.y) * (r.y - n.y) +
                        (o.z - r.z) * (r.z - n.z)),
                    c =
                      Math.pow(r.x - n.x, 2) +
                      Math.pow(r.y - n.y, 2) +
                      Math.pow(r.z - n.z, 2) -
                      Math.pow(s, 2),
                    u = Math.pow(l, 2) - 4 * a * c,
                    h = w,
                    d = _;
                  if (!(0 > u))
                    if (0 === u)
                      r.lerp(o, u, h),
                        h.vsub(n, d),
                        d.normalize(),
                        this.reportIntersection(d, h, t, i, -1);
                    else {
                      var p = (-l - Math.sqrt(u)) / (2 * a),
                        f = (-l + Math.sqrt(u)) / (2 * a);
                      if (
                        (p >= 0 &&
                          1 >= p &&
                          (r.lerp(o, p, h),
                          h.vsub(n, d),
                          d.normalize(),
                          this.reportIntersection(d, h, t, i, -1)),
                        this.result._shouldStop)
                      )
                        return;
                      f >= 0 &&
                        1 >= f &&
                        (r.lerp(o, f, h),
                        h.vsub(n, d),
                        d.normalize(),
                        this.reportIntersection(d, h, t, i, -1));
                    }
                }),
                  (n.prototype[l.types.SPHERE] = n.prototype.intersectSphere);
                var M = new r(),
                  S = (new r(), new r(), new r());
                (n.prototype.intersectConvex = function (t, e, n, r, o) {
                  for (
                    var s = M,
                      a = S,
                      l = (o && o.faceList) || null,
                      c = t.faces,
                      u = t.vertices,
                      h = t.faceNormals,
                      d = this._direction,
                      p = this.from,
                      f = this.to,
                      m = p.distanceTo(f),
                      b = l ? l.length : c.length,
                      w = this.result,
                      _ = 0;
                    !w._shouldStop && b > _;
                    _++
                  ) {
                    var E = l ? l[_] : _,
                      T = c[E],
                      A = h[E],
                      C = e,
                      L = n;
                    a.copy(u[T[0]]),
                      C.vmult(a, a),
                      a.vadd(L, a),
                      a.vsub(p, a),
                      C.vmult(A, s);
                    var R = d.dot(s);
                    if (!(Math.abs(R) < this.precision)) {
                      var P = s.dot(a) / R;
                      if (!(0 > P)) {
                        d.mult(P, g),
                          g.vadd(p, g),
                          v.copy(u[T[0]]),
                          C.vmult(v, v),
                          L.vadd(v, v);
                        for (
                          var N = 1;
                          !w._shouldStop && N < T.length - 1;
                          N++
                        ) {
                          y.copy(u[T[N]]),
                            x.copy(u[T[N + 1]]),
                            C.vmult(y, y),
                            C.vmult(x, x),
                            L.vadd(y, y),
                            L.vadd(x, x);
                          var I = g.distanceTo(p);
                          (!i(g, v, y, x) && !i(g, y, v, x)) ||
                            I > m ||
                            this.reportIntersection(s, g, t, r, E);
                        }
                      }
                    }
                  }
                }),
                  (n.prototype[l.types.CONVEXPOLYHEDRON] =
                    n.prototype.intersectConvex);
                var E = new r(),
                  T = new r(),
                  A = new r(),
                  C = new r(),
                  L = new r(),
                  R = new r(),
                  P = (new c(), []),
                  N = new s();
                (n.prototype.intersectTrimesh = function (t, e, n, r, o) {
                  var a = E,
                    l = P,
                    c = N,
                    u = S,
                    h = T,
                    d = A,
                    p = C,
                    f = R,
                    m = L,
                    b = (o && o.faceList, t.indices),
                    w = (t.vertices, t.faceNormals, this.from),
                    _ = this.to,
                    M = this._direction;
                  c.position.copy(n),
                    c.quaternion.copy(e),
                    s.vectorToLocalFrame(n, e, M, h),
                    s.pointToLocalFrame(n, e, w, d),
                    s.pointToLocalFrame(n, e, _, p);
                  var I = d.distanceSquared(p);
                  t.tree.rayQuery(this, c, l);
                  for (
                    var B = 0, O = l.length;
                    !this.result._shouldStop && B !== O;
                    B++
                  ) {
                    var D = l[B];
                    t.getNormal(D, a), t.getVertex(b[3 * D], v), v.vsub(d, u);
                    var k = h.dot(a),
                      F = a.dot(u) / k;
                    if (!(0 > F)) {
                      h.scale(F, g),
                        g.vadd(d, g),
                        t.getVertex(b[3 * D + 1], y),
                        t.getVertex(b[3 * D + 2], x);
                      var z = g.distanceSquared(d);
                      (!i(g, y, v, x) && !i(g, v, y, x)) ||
                        z > I ||
                        (s.vectorToWorldFrame(e, a, m),
                        s.pointToWorldFrame(n, e, g, f),
                        this.reportIntersection(m, f, t, r, D));
                    }
                  }
                  l.length = 0;
                }),
                  (n.prototype[l.types.TRIMESH] = n.prototype.intersectTrimesh),
                  (n.prototype.reportIntersection = function (t, e, i, r, o) {
                    var s = this.from,
                      a = this.to,
                      l = s.distanceTo(e),
                      c = this.result;
                    if (!(this.skipBackfaces && t.dot(this._direction) > 0))
                      switch (
                        ((c.hitFaceIndex = void 0 !== o ? o : -1), this.mode)
                      ) {
                        case n.ALL:
                          (this.hasHit = !0),
                            c.set(s, a, t, e, i, r, l),
                            (c.hasHit = !0),
                            this.callback(c);
                          break;
                        case n.CLOSEST:
                          (l < c.distance || !c.hasHit) &&
                            ((this.hasHit = !0),
                            (c.hasHit = !0),
                            c.set(s, a, t, e, i, r, l));
                          break;
                        case n.ANY:
                          (this.hasHit = !0),
                            (c.hasHit = !0),
                            c.set(s, a, t, e, i, r, l),
                            (c._shouldStop = !0);
                      }
                  });
                var I = new r(),
                  B = new r();
              },
              {
                "../collision/AABB": 3,
                "../collision/RaycastResult": 10,
                "../math/Quaternion": 28,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "../shapes/Box": 37,
                "../shapes/ConvexPolyhedron": 38,
                "../shapes/Shape": 43,
              },
            ],
            10: [
              function (t, e) {
                function n() {
                  (this.rayFromWorld = new i()),
                    (this.rayToWorld = new i()),
                    (this.hitNormalWorld = new i()),
                    (this.hitPointWorld = new i()),
                    (this.hasHit = !1),
                    (this.shape = null),
                    (this.body = null),
                    (this.hitFaceIndex = -1),
                    (this.distance = -1),
                    (this._shouldStop = !1);
                }
                var i = t("../math/Vec3");
                (e.exports = n),
                  (n.prototype.reset = function () {
                    this.rayFromWorld.setZero(),
                      this.rayToWorld.setZero(),
                      this.hitNormalWorld.setZero(),
                      this.hitPointWorld.setZero(),
                      (this.hasHit = !1),
                      (this.shape = null),
                      (this.body = null),
                      (this.hitFaceIndex = -1),
                      (this.distance = -1),
                      (this._shouldStop = !1);
                  }),
                  (n.prototype.abort = function () {
                    this._shouldStop = !0;
                  }),
                  (n.prototype.set = function (t, e, n, i, r, o, s) {
                    this.rayFromWorld.copy(t),
                      this.rayToWorld.copy(e),
                      this.hitNormalWorld.copy(n),
                      this.hitPointWorld.copy(i),
                      (this.shape = r),
                      (this.body = o),
                      (this.distance = s);
                  });
              },
              { "../math/Vec3": 30 },
            ],
            11: [
              function (t, e) {
                function n(t) {
                  i.apply(this),
                    (this.axisList = []),
                    (this.world = null),
                    (this.axisIndex = 0);
                  var e = this.axisList;
                  (this._addBodyHandler = function (t) {
                    e.push(t.body);
                  }),
                    (this._removeBodyHandler = function (t) {
                      var n = e.indexOf(t.body);
                      -1 !== n && e.splice(n, 1);
                    }),
                    t && this.setWorld(t);
                }
                var i = (t("../shapes/Shape"), t("../collision/Broadphase"));
                (e.exports = n),
                  (n.prototype = new i()),
                  (n.prototype.setWorld = function (t) {
                    this.axisList.length = 0;
                    for (var e = 0; e < t.bodies.length; e++)
                      this.axisList.push(t.bodies[e]);
                    t.removeEventListener("addBody", this._addBodyHandler),
                      t.removeEventListener(
                        "removeBody",
                        this._removeBodyHandler
                      ),
                      t.addEventListener("addBody", this._addBodyHandler),
                      t.addEventListener("removeBody", this._removeBodyHandler),
                      (this.world = t),
                      (this.dirty = !0);
                  }),
                  (n.insertionSortX = function (t) {
                    for (var e = 1, n = t.length; n > e; e++) {
                      for (
                        var i = t[e], r = e - 1;
                        r >= 0 &&
                        !(t[r].aabb.lowerBound.x <= i.aabb.lowerBound.x);
                        r--
                      )
                        t[r + 1] = t[r];
                      t[r + 1] = i;
                    }
                    return t;
                  }),
                  (n.insertionSortY = function (t) {
                    for (var e = 1, n = t.length; n > e; e++) {
                      for (
                        var i = t[e], r = e - 1;
                        r >= 0 &&
                        !(t[r].aabb.lowerBound.y <= i.aabb.lowerBound.y);
                        r--
                      )
                        t[r + 1] = t[r];
                      t[r + 1] = i;
                    }
                    return t;
                  }),
                  (n.insertionSortZ = function (t) {
                    for (var e = 1, n = t.length; n > e; e++) {
                      for (
                        var i = t[e], r = e - 1;
                        r >= 0 &&
                        !(t[r].aabb.lowerBound.z <= i.aabb.lowerBound.z);
                        r--
                      )
                        t[r + 1] = t[r];
                      t[r + 1] = i;
                    }
                    return t;
                  }),
                  (n.prototype.collisionPairs = function (t, e, i) {
                    var r,
                      o,
                      s = this.axisList,
                      a = s.length,
                      l = this.axisIndex;
                    for (
                      this.dirty && (this.sortList(), (this.dirty = !1)), r = 0;
                      r !== a;
                      r++
                    ) {
                      var c = s[r];
                      for (o = r + 1; a > o; o++) {
                        var u = s[o];
                        if (this.needBroadphaseCollision(c, u)) {
                          if (!n.checkBounds(c, u, l)) break;
                          this.intersectionTest(c, u, e, i);
                        }
                      }
                    }
                  }),
                  (n.prototype.sortList = function () {
                    for (
                      var t = this.axisList,
                        e = this.axisIndex,
                        i = t.length,
                        r = 0;
                      r !== i;
                      r++
                    ) {
                      var o = t[r];
                      o.aabbNeedsUpdate && o.computeAABB();
                    }
                    0 === e
                      ? n.insertionSortX(t)
                      : 1 === e
                      ? n.insertionSortY(t)
                      : 2 === e && n.insertionSortZ(t);
                  }),
                  (n.checkBounds = function (t, e, n) {
                    var i, r;
                    return (
                      0 === n
                        ? ((i = t.position.x), (r = e.position.x))
                        : 1 === n
                        ? ((i = t.position.y), (r = e.position.y))
                        : 2 === n && ((i = t.position.z), (r = e.position.z)),
                      i + t.boundingRadius > r - e.boundingRadius
                    );
                  }),
                  (n.prototype.autoDetectAxis = function () {
                    for (
                      var t = 0,
                        e = 0,
                        n = 0,
                        i = 0,
                        r = 0,
                        o = 0,
                        s = this.axisList,
                        a = s.length,
                        l = 1 / a,
                        c = 0;
                      c !== a;
                      c++
                    ) {
                      var u = s[c],
                        h = u.position.x;
                      (t += h), (e += h * h);
                      var d = u.position.y;
                      (n += d), (i += d * d);
                      var p = u.position.z;
                      (r += p), (o += p * p);
                    }
                    var f = e - t * t * l,
                      m = i - n * n * l,
                      g = o - r * r * l;
                    this.axisIndex = f > m ? (f > g ? 0 : 2) : m > g ? 1 : 2;
                  }),
                  (n.prototype.aabbQuery = function (t, e, n) {
                    (n = n || []),
                      this.dirty && (this.sortList(), (this.dirty = !1));
                    var i = this.axisIndex,
                      r = "x";
                    1 === i && (r = "y"), 2 === i && (r = "z");
                    for (
                      var o = this.axisList,
                        s = (e.lowerBound[r], e.upperBound[r], 0);
                      s < o.length;
                      s++
                    ) {
                      var a = o[s];
                      a.aabbNeedsUpdate && a.computeAABB(),
                        a.aabb.overlaps(e) && n.push(a);
                    }
                    return n;
                  });
              },
              { "../collision/Broadphase": 5, "../shapes/Shape": 43 },
            ],
            12: [
              function (t, e) {
                function n(t, e, n) {
                  var a = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6,
                    l = n.pivotA ? n.pivotA.clone() : new s(),
                    c = n.pivotB ? n.pivotB.clone() : new s();
                  (this.axisA = n.axisA ? n.axisA.clone() : new s()),
                    (this.axisB = n.axisB ? n.axisB.clone() : new s()),
                    i.call(this, t, l, e, c, a),
                    (this.collideConnected = !!n.collideConnected),
                    (this.angle = void 0 !== n.angle ? n.angle : 0);
                  var u = (this.coneEquation = new r(t, e, n)),
                    h = (this.twistEquation = new o(t, e, n));
                  (this.twistAngle =
                    void 0 !== n.twistAngle ? n.twistAngle : 0),
                    (u.maxForce = 0),
                    (u.minForce = -a),
                    (h.maxForce = 0),
                    (h.minForce = -a),
                    this.equations.push(u, h);
                }
                e.exports = n;
                var i = (t("./Constraint"), t("./PointToPointConstraint")),
                  r = t("../equations/ConeEquation"),
                  o = t("../equations/RotationalEquation"),
                  s = (t("../equations/ContactEquation"), t("../math/Vec3"));
                (n.prototype = new i()),
                  (n.constructor = n),
                  new s(),
                  new s(),
                  (n.prototype.update = function () {
                    var t = this.bodyA,
                      e = this.bodyB,
                      n = this.coneEquation,
                      r = this.twistEquation;
                    i.prototype.update.call(this),
                      t.vectorToWorldFrame(this.axisA, n.axisA),
                      e.vectorToWorldFrame(this.axisB, n.axisB),
                      this.axisA.tangents(r.axisA, r.axisA),
                      t.vectorToWorldFrame(r.axisA, r.axisA),
                      this.axisB.tangents(r.axisB, r.axisB),
                      e.vectorToWorldFrame(r.axisB, r.axisB),
                      (n.angle = this.angle),
                      (r.maxAngle = this.twistAngle);
                  });
              },
              {
                "../equations/ConeEquation": 18,
                "../equations/ContactEquation": 19,
                "../equations/RotationalEquation": 22,
                "../math/Vec3": 30,
                "./Constraint": 13,
                "./PointToPointConstraint": 17,
              },
            ],
            13: [
              function (t, e) {
                function n(t, e, r) {
                  (r = i.defaults(r, {
                    collideConnected: !0,
                    wakeUpBodies: !0,
                  })),
                    (this.equations = []),
                    (this.bodyA = t),
                    (this.bodyB = e),
                    (this.id = n.idCounter++),
                    (this.collideConnected = r.collideConnected),
                    r.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp());
                }
                e.exports = n;
                var i = t("../utils/Utils");
                (n.prototype.update = function () {
                  throw new Error(
                    "method update() not implmemented in this Constraint subclass!"
                  );
                }),
                  (n.prototype.enable = function () {
                    for (var t = this.equations, e = 0; e < t.length; e++)
                      t[e].enabled = !0;
                  }),
                  (n.prototype.disable = function () {
                    for (var t = this.equations, e = 0; e < t.length; e++)
                      t[e].enabled = !1;
                  }),
                  (n.idCounter = 0);
              },
              { "../utils/Utils": 53 },
            ],
            14: [
              function (t, e) {
                function n(t, e, n, o) {
                  i.call(this, t, e),
                    void 0 === n && (n = t.position.distanceTo(e.position)),
                    void 0 === o && (o = 1e6),
                    (this.distance = n);
                  var s = (this.distanceEquation = new r(t, e));
                  this.equations.push(s), (s.minForce = -o), (s.maxForce = o);
                }
                e.exports = n;
                var i = t("./Constraint"),
                  r = t("../equations/ContactEquation");
                (n.prototype = new i()),
                  (n.prototype.update = function () {
                    var t = this.bodyA,
                      e = this.bodyB,
                      n = this.distanceEquation,
                      i = 0.5 * this.distance,
                      r = n.ni;
                    e.position.vsub(t.position, r),
                      r.normalize(),
                      r.mult(i, n.ri),
                      r.mult(-i, n.rj);
                  });
              },
              { "../equations/ContactEquation": 19, "./Constraint": 13 },
            ],
            15: [
              function (t, e) {
                function n(t, e, n) {
                  var a = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6,
                    l = n.pivotA ? n.pivotA.clone() : new s(),
                    c = n.pivotB ? n.pivotB.clone() : new s();
                  i.call(this, t, l, e, c, a),
                    (this.axisA = n.axisA
                      ? n.axisA.clone()
                      : new s(1, 0, 0)).normalize(),
                    (this.axisB = n.axisB
                      ? n.axisB.clone()
                      : new s(1, 0, 0)).normalize();
                  var u = (this.rotationalEquation1 = new r(t, e, n)),
                    h = (this.rotationalEquation2 = new r(t, e, n)),
                    d = (this.motorEquation = new o(t, e, a));
                  (d.enabled = !1), this.equations.push(u, h, d);
                }
                e.exports = n;
                var i = (t("./Constraint"), t("./PointToPointConstraint")),
                  r = t("../equations/RotationalEquation"),
                  o = t("../equations/RotationalMotorEquation"),
                  s = (t("../equations/ContactEquation"), t("../math/Vec3"));
                (n.prototype = new i()),
                  (n.constructor = n),
                  (n.prototype.enableMotor = function () {
                    this.motorEquation.enabled = !0;
                  }),
                  (n.prototype.disableMotor = function () {
                    this.motorEquation.enabled = !1;
                  }),
                  (n.prototype.setMotorSpeed = function (t) {
                    this.motorEquation.targetVelocity = t;
                  }),
                  (n.prototype.setMotorMaxForce = function (t) {
                    (this.motorEquation.maxForce = t),
                      (this.motorEquation.minForce = -t);
                  });
                var a = new s(),
                  l = new s();
                n.prototype.update = function () {
                  var t = this.bodyA,
                    e = this.bodyB,
                    n = this.motorEquation,
                    r = this.rotationalEquation1,
                    o = this.rotationalEquation2,
                    s = a,
                    c = l,
                    u = this.axisA,
                    h = this.axisB;
                  i.prototype.update.call(this),
                    t.quaternion.vmult(u, s),
                    e.quaternion.vmult(h, c),
                    s.tangents(r.axisA, o.axisA),
                    r.axisB.copy(c),
                    o.axisB.copy(c),
                    this.motorEquation.enabled &&
                      (t.quaternion.vmult(this.axisA, n.axisA),
                      e.quaternion.vmult(this.axisB, n.axisB));
                };
              },
              {
                "../equations/ContactEquation": 19,
                "../equations/RotationalEquation": 22,
                "../equations/RotationalMotorEquation": 23,
                "../math/Vec3": 30,
                "./Constraint": 13,
                "./PointToPointConstraint": 17,
              },
            ],
            16: [
              function (t, e) {
                function n(t, e, n) {
                  var s = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6,
                    a = new o(),
                    l = new o(),
                    c = new o();
                  t.position.vadd(e.position, c),
                    c.scale(0.5, c),
                    e.pointToLocalFrame(c, l),
                    t.pointToLocalFrame(c, a),
                    i.call(this, t, a, e, l, s);
                  var u = (this.rotationalEquation1 = new r(t, e, n)),
                    h = (this.rotationalEquation2 = new r(t, e, n)),
                    d = (this.rotationalEquation3 = new r(t, e, n));
                  this.equations.push(u, h, d);
                }
                e.exports = n;
                var i = (t("./Constraint"), t("./PointToPointConstraint")),
                  r = t("../equations/RotationalEquation"),
                  o =
                    (t("../equations/RotationalMotorEquation"),
                    t("../equations/ContactEquation"),
                    t("../math/Vec3"));
                (n.prototype = new i()),
                  (n.constructor = n),
                  new o(),
                  new o(),
                  (n.prototype.update = function () {
                    var t = this.bodyA,
                      e = this.bodyB,
                      n = (this.motorEquation, this.rotationalEquation1),
                      r = this.rotationalEquation2,
                      s = this.rotationalEquation3;
                    i.prototype.update.call(this),
                      t.vectorToWorldFrame(o.UNIT_X, n.axisA),
                      e.vectorToWorldFrame(o.UNIT_Y, n.axisB),
                      t.vectorToWorldFrame(o.UNIT_Y, r.axisA),
                      e.vectorToWorldFrame(o.UNIT_Z, r.axisB),
                      t.vectorToWorldFrame(o.UNIT_Z, s.axisA),
                      e.vectorToWorldFrame(o.UNIT_X, s.axisB);
                  });
              },
              {
                "../equations/ContactEquation": 19,
                "../equations/RotationalEquation": 22,
                "../equations/RotationalMotorEquation": 23,
                "../math/Vec3": 30,
                "./Constraint": 13,
                "./PointToPointConstraint": 17,
              },
            ],
            17: [
              function (t, e) {
                function n(t, e, n, s, a) {
                  i.call(this, t, n),
                    (a = void 0 !== a ? a : 1e6),
                    (this.pivotA = e ? e.clone() : new o()),
                    (this.pivotB = s ? s.clone() : new o());
                  var l = (this.equationX = new r(t, n)),
                    c = (this.equationY = new r(t, n)),
                    u = (this.equationZ = new r(t, n));
                  this.equations.push(l, c, u),
                    (l.minForce = c.minForce = u.minForce = -a),
                    (l.maxForce = c.maxForce = u.maxForce = a),
                    l.ni.set(1, 0, 0),
                    c.ni.set(0, 1, 0),
                    u.ni.set(0, 0, 1);
                }
                e.exports = n;
                var i = t("./Constraint"),
                  r = t("../equations/ContactEquation"),
                  o = t("../math/Vec3");
                (n.prototype = new i()),
                  (n.prototype.update = function () {
                    var t = this.bodyA,
                      e = this.bodyB,
                      n = this.equationX,
                      i = this.equationY,
                      r = this.equationZ;
                    t.quaternion.vmult(this.pivotA, n.ri),
                      e.quaternion.vmult(this.pivotB, n.rj),
                      i.ri.copy(n.ri),
                      i.rj.copy(n.rj),
                      r.ri.copy(n.ri),
                      r.rj.copy(n.rj);
                  });
              },
              {
                "../equations/ContactEquation": 19,
                "../math/Vec3": 30,
                "./Constraint": 13,
              },
            ],
            18: [
              function (t, e) {
                function n(t, e, n) {
                  var o = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6;
                  r.call(this, t, e, -o, o),
                    (this.axisA = n.axisA ? n.axisA.clone() : new i(1, 0, 0)),
                    (this.axisB = n.axisB ? n.axisB.clone() : new i(0, 1, 0)),
                    (this.angle = void 0 !== n.angle ? n.angle : 0);
                }
                e.exports = n;
                var i = t("../math/Vec3"),
                  r = (t("../math/Mat3"), t("./Equation"));
                (n.prototype = new r()), (n.prototype.constructor = n);
                var o = new i(),
                  s = new i();
                n.prototype.computeB = function (t) {
                  var e = this.a,
                    n = this.b,
                    i = this.axisA,
                    r = this.axisB,
                    a = o,
                    l = s,
                    c = this.jacobianElementA,
                    u = this.jacobianElementB;
                  return (
                    i.cross(r, a),
                    r.cross(i, l),
                    c.rotational.copy(l),
                    u.rotational.copy(a),
                    -(Math.cos(this.angle) - i.dot(r)) * e -
                      this.computeGW() * n -
                      t * this.computeGiMf()
                  );
                };
              },
              { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 },
            ],
            19: [
              function (t, e) {
                function n(t, e, n) {
                  (n = void 0 !== n ? n : 1e6),
                    i.call(this, t, e, 0, n),
                    (this.restitution = 0),
                    (this.ri = new r()),
                    (this.rj = new r()),
                    (this.ni = new r());
                }
                e.exports = n;
                var i = t("./Equation"),
                  r = t("../math/Vec3");
                t("../math/Mat3"),
                  (n.prototype = new i()),
                  (n.prototype.constructor = n);
                var o = new r(),
                  s = new r(),
                  a = new r();
                n.prototype.computeB = function (t) {
                  var e = this.a,
                    n = this.b,
                    i = this.bi,
                    r = this.bj,
                    l = this.ri,
                    c = this.rj,
                    u = o,
                    h = s,
                    d = i.velocity,
                    p = i.angularVelocity,
                    f = (i.force, i.torque, r.velocity),
                    m = r.angularVelocity,
                    g = (r.force, r.torque, a),
                    v = this.jacobianElementA,
                    y = this.jacobianElementB,
                    x = this.ni;
                  l.cross(x, u),
                    c.cross(x, h),
                    x.negate(v.spatial),
                    u.negate(v.rotational),
                    y.spatial.copy(x),
                    y.rotational.copy(h),
                    g.copy(r.position),
                    g.vadd(c, g),
                    g.vsub(i.position, g),
                    g.vsub(l, g);
                  var b = x.dot(g),
                    w = this.restitution + 1;
                  return (
                    -b * e -
                    (w * f.dot(x) - w * d.dot(x) + m.dot(h) - p.dot(u)) * n -
                    t * this.computeGiMf()
                  );
                };
                var l = new r(),
                  c = new r(),
                  u = new r(),
                  h = new r(),
                  d = new r();
                n.prototype.getImpactVelocityAlongNormal = function () {
                  var t = l,
                    e = c,
                    n = u,
                    i = h,
                    r = d;
                  return (
                    this.bi.position.vadd(this.ri, n),
                    this.bj.position.vadd(this.rj, i),
                    this.bi.getVelocityAtWorldPoint(n, t),
                    this.bj.getVelocityAtWorldPoint(i, e),
                    t.vsub(e, r),
                    this.ni.dot(r)
                  );
                };
              },
              { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 },
            ],
            20: [
              function (t, e) {
                function n(t, e, r, o) {
                  (this.id = n.id++),
                    (this.minForce = void 0 === r ? -1e6 : r),
                    (this.maxForce = void 0 === o ? 1e6 : o),
                    (this.bi = t),
                    (this.bj = e),
                    (this.a = 0),
                    (this.b = 0),
                    (this.eps = 0),
                    (this.jacobianElementA = new i()),
                    (this.jacobianElementB = new i()),
                    (this.enabled = !0),
                    this.setSpookParams(1e7, 4, 1 / 60);
                }
                e.exports = n;
                var i = t("../math/JacobianElement"),
                  r = t("../math/Vec3");
                (n.prototype.constructor = n),
                  (n.id = 0),
                  (n.prototype.setSpookParams = function (t, e, n) {
                    var i = e,
                      r = t,
                      o = n;
                    (this.a = 4 / (o * (1 + 4 * i))),
                      (this.b = (4 * i) / (1 + 4 * i)),
                      (this.eps = 4 / (o * o * r * (1 + 4 * i)));
                  }),
                  (n.prototype.computeB = function (t, e, n) {
                    var i = this.computeGW();
                    return (
                      -this.computeGq() * t - i * e - this.computeGiMf() * n
                    );
                  }),
                  (n.prototype.computeGq = function () {
                    var t = this.jacobianElementA,
                      e = this.jacobianElementB,
                      n = this.bi,
                      i = this.bj,
                      r = n.position,
                      o = i.position;
                    return t.spatial.dot(r) + e.spatial.dot(o);
                  });
                var o = new r();
                (n.prototype.computeGW = function () {
                  var t = this.jacobianElementA,
                    e = this.jacobianElementB,
                    n = this.bi,
                    i = this.bj,
                    r = n.velocity,
                    s = i.velocity,
                    a = n.angularVelocity || o,
                    l = i.angularVelocity || o;
                  return t.multiplyVectors(r, a) + e.multiplyVectors(s, l);
                }),
                  (n.prototype.computeGWlambda = function () {
                    var t = this.jacobianElementA,
                      e = this.jacobianElementB,
                      n = this.bi,
                      i = this.bj,
                      r = n.vlambda,
                      s = i.vlambda,
                      a = n.wlambda || o,
                      l = i.wlambda || o;
                    return t.multiplyVectors(r, a) + e.multiplyVectors(s, l);
                  });
                var s = new r(),
                  a = new r(),
                  l = new r(),
                  c = new r();
                n.prototype.computeGiMf = function () {
                  var t = this.jacobianElementA,
                    e = this.jacobianElementB,
                    n = this.bi,
                    i = this.bj,
                    r = n.force,
                    o = n.torque,
                    u = i.force,
                    h = i.torque,
                    d = n.invMassSolve,
                    p = i.invMassSolve;
                  return (
                    n.invInertiaWorldSolve
                      ? n.invInertiaWorldSolve.vmult(o, l)
                      : l.set(0, 0, 0),
                    i.invInertiaWorldSolve
                      ? i.invInertiaWorldSolve.vmult(h, c)
                      : c.set(0, 0, 0),
                    r.mult(d, s),
                    u.mult(p, a),
                    t.multiplyVectors(s, l) + e.multiplyVectors(a, c)
                  );
                };
                var u = new r();
                n.prototype.computeGiMGt = function () {
                  var t = this.jacobianElementA,
                    e = this.jacobianElementB,
                    n = this.bi,
                    i = this.bj,
                    r = n.invMassSolve,
                    o = i.invMassSolve,
                    s = n.invInertiaWorldSolve,
                    a = i.invInertiaWorldSolve,
                    l = r + o;
                  return (
                    s && (s.vmult(t.rotational, u), (l += u.dot(t.rotational))),
                    a && (a.vmult(e.rotational, u), (l += u.dot(e.rotational))),
                    l
                  );
                };
                var h = new r();
                new r(),
                  new r(),
                  new r(),
                  new r(),
                  new r(),
                  (n.prototype.addToWlambda = function (t) {
                    var e = this.jacobianElementA,
                      n = this.jacobianElementB,
                      i = this.bi,
                      r = this.bj,
                      o = h;
                    e.spatial.mult(i.invMassSolve * t, o),
                      i.vlambda.vadd(o, i.vlambda),
                      n.spatial.mult(r.invMassSolve * t, o),
                      r.vlambda.vadd(o, r.vlambda),
                      i.invInertiaWorldSolve &&
                        (i.invInertiaWorldSolve.vmult(e.rotational, o),
                        o.mult(t, o),
                        i.wlambda.vadd(o, i.wlambda)),
                      r.invInertiaWorldSolve &&
                        (r.invInertiaWorldSolve.vmult(n.rotational, o),
                        o.mult(t, o),
                        r.wlambda.vadd(o, r.wlambda));
                  }),
                  (n.prototype.computeC = function () {
                    return this.computeGiMGt() + this.eps;
                  });
              },
              { "../math/JacobianElement": 26, "../math/Vec3": 30 },
            ],
            21: [
              function (t, e) {
                function n(t, e, n) {
                  i.call(this, t, e, -n, n),
                    (this.ri = new r()),
                    (this.rj = new r()),
                    (this.t = new r());
                }
                e.exports = n;
                var i = t("./Equation"),
                  r = t("../math/Vec3");
                t("../math/Mat3"),
                  (n.prototype = new i()),
                  (n.prototype.constructor = n);
                var o = new r(),
                  s = new r();
                n.prototype.computeB = function (t) {
                  var e = (this.a, this.b),
                    n = (this.bi, this.bj, this.ri),
                    i = this.rj,
                    r = o,
                    a = s,
                    l = this.t;
                  n.cross(l, r), i.cross(l, a);
                  var c = this.jacobianElementA,
                    u = this.jacobianElementB;
                  return (
                    l.negate(c.spatial),
                    r.negate(c.rotational),
                    u.spatial.copy(l),
                    u.rotational.copy(a),
                    -this.computeGW() * e - t * this.computeGiMf()
                  );
                };
              },
              { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 },
            ],
            22: [
              function (t, e) {
                function n(t, e, n) {
                  var o = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6;
                  r.call(this, t, e, -o, o),
                    (this.axisA = n.axisA ? n.axisA.clone() : new i(1, 0, 0)),
                    (this.axisB = n.axisB ? n.axisB.clone() : new i(0, 1, 0)),
                    (this.maxAngle = Math.PI / 2);
                }
                e.exports = n;
                var i = t("../math/Vec3"),
                  r = (t("../math/Mat3"), t("./Equation"));
                (n.prototype = new r()), (n.prototype.constructor = n);
                var o = new i(),
                  s = new i();
                n.prototype.computeB = function (t) {
                  var e = this.a,
                    n = this.b,
                    i = this.axisA,
                    r = this.axisB,
                    a = o,
                    l = s,
                    c = this.jacobianElementA,
                    u = this.jacobianElementB;
                  return (
                    i.cross(r, a),
                    r.cross(i, l),
                    c.rotational.copy(l),
                    u.rotational.copy(a),
                    -(Math.cos(this.maxAngle) - i.dot(r)) * e -
                      this.computeGW() * n -
                      t * this.computeGiMf()
                  );
                };
              },
              { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 },
            ],
            23: [
              function (t, e) {
                function n(t, e, n) {
                  (n = void 0 !== n ? n : 1e6),
                    r.call(this, t, e, -n, n),
                    (this.axisA = new i()),
                    (this.axisB = new i()),
                    (this.targetVelocity = 0);
                }
                e.exports = n;
                var i = t("../math/Vec3"),
                  r = (t("../math/Mat3"), t("./Equation"));
                (n.prototype = new r()),
                  (n.prototype.constructor = n),
                  (n.prototype.computeB = function (t) {
                    var e = (this.a, this.b),
                      n = (this.bi, this.bj, this.axisA),
                      i = this.axisB,
                      r = this.jacobianElementA,
                      o = this.jacobianElementB;
                    return (
                      r.rotational.copy(n),
                      i.negate(o.rotational),
                      -(this.computeGW() - this.targetVelocity) * e -
                        t * this.computeGiMf()
                    );
                  });
              },
              { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 },
            ],
            24: [
              function (t, e) {
                function n(t, e, r) {
                  (r = i.defaults(r, {
                    friction: 0.3,
                    restitution: 0.3,
                    contactEquationStiffness: 1e7,
                    contactEquationRelaxation: 3,
                    frictionEquationStiffness: 1e7,
                    frictionEquationRelaxation: 3,
                  })),
                    (this.id = n.idCounter++),
                    (this.materials = [t, e]),
                    (this.friction = r.friction),
                    (this.restitution = r.restitution),
                    (this.contactEquationStiffness =
                      r.contactEquationStiffness),
                    (this.contactEquationRelaxation =
                      r.contactEquationRelaxation),
                    (this.frictionEquationStiffness =
                      r.frictionEquationStiffness),
                    (this.frictionEquationRelaxation =
                      r.frictionEquationRelaxation);
                }
                var i = t("../utils/Utils");
                (e.exports = n), (n.idCounter = 0);
              },
              { "../utils/Utils": 53 },
            ],
            25: [
              function (t, e) {
                function n(t) {
                  var e = "";
                  "string" == typeof (t = t || {})
                    ? ((e = t), (t = {}))
                    : "object" == typeof t && (e = ""),
                    (this.name = e),
                    (this.id = n.idCounter++),
                    (this.friction = void 0 !== t.friction ? t.friction : -1),
                    (this.restitution =
                      void 0 !== t.restitution ? t.restitution : -1);
                }
                (e.exports = n), (n.idCounter = 0);
              },
              {},
            ],
            26: [
              function (t, e) {
                function n() {
                  (this.spatial = new i()), (this.rotational = new i());
                }
                e.exports = n;
                var i = t("./Vec3");
                (n.prototype.multiplyElement = function (t) {
                  return (
                    t.spatial.dot(this.spatial) +
                    t.rotational.dot(this.rotational)
                  );
                }),
                  (n.prototype.multiplyVectors = function (t, e) {
                    return t.dot(this.spatial) + e.dot(this.rotational);
                  });
              },
              { "./Vec3": 30 },
            ],
            27: [
              function (t, e) {
                function n(t) {
                  this.elements = t || [0, 0, 0, 0, 0, 0, 0, 0, 0];
                }
                e.exports = n;
                var i = t("./Vec3");
                (n.prototype.identity = function () {
                  var t = this.elements;
                  (t[0] = 1),
                    (t[1] = 0),
                    (t[2] = 0),
                    (t[3] = 0),
                    (t[4] = 1),
                    (t[5] = 0),
                    (t[6] = 0),
                    (t[7] = 0),
                    (t[8] = 1);
                }),
                  (n.prototype.setZero = function () {
                    var t = this.elements;
                    (t[0] = 0),
                      (t[1] = 0),
                      (t[2] = 0),
                      (t[3] = 0),
                      (t[4] = 0),
                      (t[5] = 0),
                      (t[6] = 0),
                      (t[7] = 0),
                      (t[8] = 0);
                  }),
                  (n.prototype.setTrace = function (t) {
                    var e = this.elements;
                    (e[0] = t.x), (e[4] = t.y), (e[8] = t.z);
                  }),
                  (n.prototype.getTrace = function (t) {
                    t = t || new i();
                    var e = this.elements;
                    (t.x = e[0]), (t.y = e[4]), (t.z = e[8]);
                  }),
                  (n.prototype.vmult = function (t, e) {
                    e = e || new i();
                    var n = this.elements,
                      r = t.x,
                      o = t.y,
                      s = t.z;
                    return (
                      (e.x = n[0] * r + n[1] * o + n[2] * s),
                      (e.y = n[3] * r + n[4] * o + n[5] * s),
                      (e.z = n[6] * r + n[7] * o + n[8] * s),
                      e
                    );
                  }),
                  (n.prototype.smult = function (t) {
                    for (var e = 0; e < this.elements.length; e++)
                      this.elements[e] *= t;
                  }),
                  (n.prototype.mmult = function (t, e) {
                    for (var i = e || new n(), r = 0; 3 > r; r++)
                      for (var o = 0; 3 > o; o++) {
                        for (var s = 0, a = 0; 3 > a; a++)
                          s += t.elements[r + 3 * a] * this.elements[a + 3 * o];
                        i.elements[r + 3 * o] = s;
                      }
                    return i;
                  }),
                  (n.prototype.scale = function (t, e) {
                    e = e || new n();
                    for (
                      var i = this.elements, r = e.elements, o = 0;
                      3 !== o;
                      o++
                    )
                      (r[3 * o + 0] = t.x * i[3 * o + 0]),
                        (r[3 * o + 1] = t.y * i[3 * o + 1]),
                        (r[3 * o + 2] = t.z * i[3 * o + 2]);
                    return e;
                  }),
                  (n.prototype.solve = function (t, e) {
                    e = e || new i();
                    for (var n = [], r = 0; 12 > r; r++) n.push(0);
                    var o;
                    for (r = 0; 3 > r; r++)
                      for (o = 0; 3 > o; o++)
                        n[r + 4 * o] = this.elements[r + 3 * o];
                    (n[3] = t.x), (n[7] = t.y), (n[11] = t.z);
                    var s,
                      a,
                      l = 3,
                      c = l;
                    do {
                      if (0 === n[(r = c - l) + 4 * r])
                        for (o = r + 1; c > o; o++)
                          if (0 !== n[r + 4 * o]) {
                            s = 4;
                            do {
                              n[(a = 4 - s) + 4 * r] += n[a + 4 * o];
                            } while (--s);
                            break;
                          }
                      if (0 !== n[r + 4 * r])
                        for (o = r + 1; c > o; o++) {
                          var u = n[r + 4 * o] / n[r + 4 * r];
                          s = 4;
                          do {
                            n[(a = 4 - s) + 4 * o] =
                              r >= a ? 0 : n[a + 4 * o] - n[a + 4 * r] * u;
                          } while (--s);
                        }
                    } while (--l);
                    if (
                      ((e.z = n[11] / n[10]),
                      (e.y = (n[7] - n[6] * e.z) / n[5]),
                      (e.x = (n[3] - n[2] * e.z - n[1] * e.y) / n[0]),
                      isNaN(e.x) ||
                        isNaN(e.y) ||
                        isNaN(e.z) ||
                        1 / 0 === e.x ||
                        1 / 0 === e.y ||
                        1 / 0 === e.z)
                    )
                      throw (
                        "Could not solve equation! Got x=[" +
                        e.toString() +
                        "], b=[" +
                        t.toString() +
                        "], A=[" +
                        this.toString() +
                        "]"
                      );
                    return e;
                  }),
                  (n.prototype.e = function (t, e, n) {
                    return void 0 === n
                      ? this.elements[e + 3 * t]
                      : void (this.elements[e + 3 * t] = n);
                  }),
                  (n.prototype.copy = function (t) {
                    for (var e = 0; e < t.elements.length; e++)
                      this.elements[e] = t.elements[e];
                    return this;
                  }),
                  (n.prototype.toString = function () {
                    for (var t = "", e = 0; 9 > e; e++)
                      t += this.elements[e] + ",";
                    return t;
                  }),
                  (n.prototype.reverse = function (t) {
                    t = t || new n();
                    for (var e = [], i = 0; 18 > i; i++) e.push(0);
                    var r;
                    for (i = 0; 3 > i; i++)
                      for (r = 0; 3 > r; r++)
                        e[i + 6 * r] = this.elements[i + 3 * r];
                    (e[3] = 1),
                      (e[9] = 0),
                      (e[15] = 0),
                      (e[4] = 0),
                      (e[10] = 1),
                      (e[16] = 0),
                      (e[5] = 0),
                      (e[11] = 0),
                      (e[17] = 1);
                    var o,
                      s,
                      a = 3,
                      l = a;
                    do {
                      if (0 === e[(i = l - a) + 6 * i])
                        for (r = i + 1; l > r; r++)
                          if (0 !== e[i + 6 * r]) {
                            o = 6;
                            do {
                              e[(s = 6 - o) + 6 * i] += e[s + 6 * r];
                            } while (--o);
                            break;
                          }
                      if (0 !== e[i + 6 * i])
                        for (r = i + 1; l > r; r++) {
                          var c = e[i + 6 * r] / e[i + 6 * i];
                          o = 6;
                          do {
                            e[(s = 6 - o) + 6 * r] =
                              i >= s ? 0 : e[s + 6 * r] - e[s + 6 * i] * c;
                          } while (--o);
                        }
                    } while (--a);
                    i = 2;
                    do {
                      r = i - 1;
                      do {
                        (c = e[i + 6 * r] / e[i + 6 * i]), (o = 6);
                        do {
                          e[(s = 6 - o) + 6 * r] =
                            e[s + 6 * r] - e[s + 6 * i] * c;
                        } while (--o);
                      } while (r--);
                    } while (--i);
                    i = 2;
                    do {
                      (c = 1 / e[i + 6 * i]), (o = 6);
                      do {
                        e[(s = 6 - o) + 6 * i] = e[s + 6 * i] * c;
                      } while (--o);
                    } while (i--);
                    i = 2;
                    do {
                      r = 2;
                      do {
                        if (((s = e[3 + r + 6 * i]), isNaN(s) || 1 / 0 === s))
                          throw (
                            "Could not reverse! A=[" + this.toString() + "]"
                          );
                        t.e(i, r, s);
                      } while (r--);
                    } while (i--);
                    return t;
                  }),
                  (n.prototype.setRotationFromQuaternion = function (t) {
                    var e = t.x,
                      n = t.y,
                      i = t.z,
                      r = t.w,
                      o = e + e,
                      s = n + n,
                      a = i + i,
                      l = e * o,
                      c = e * s,
                      u = e * a,
                      h = n * s,
                      d = n * a,
                      p = i * a,
                      f = r * o,
                      m = r * s,
                      g = r * a,
                      v = this.elements;
                    return (
                      (v[0] = 1 - (h + p)),
                      (v[1] = c - g),
                      (v[2] = u + m),
                      (v[3] = c + g),
                      (v[4] = 1 - (l + p)),
                      (v[5] = d - f),
                      (v[6] = u - m),
                      (v[7] = d + f),
                      (v[8] = 1 - (l + h)),
                      this
                    );
                  }),
                  (n.prototype.transpose = function (t) {
                    for (
                      var e = (t = t || new n()).elements,
                        i = this.elements,
                        r = 0;
                      3 !== r;
                      r++
                    )
                      for (var o = 0; 3 !== o; o++) e[3 * r + o] = i[3 * o + r];
                    return t;
                  });
              },
              { "./Vec3": 30 },
            ],
            28: [
              function (t, e) {
                function n(t, e, n, i) {
                  (this.x = void 0 !== t ? t : 0),
                    (this.y = void 0 !== e ? e : 0),
                    (this.z = void 0 !== n ? n : 0),
                    (this.w = void 0 !== i ? i : 1);
                }
                e.exports = n;
                var i = t("./Vec3");
                (n.prototype.set = function (t, e, n, i) {
                  (this.x = t), (this.y = e), (this.z = n), (this.w = i);
                }),
                  (n.prototype.toString = function () {
                    return this.x + "," + this.y + "," + this.z + "," + this.w;
                  }),
                  (n.prototype.toArray = function () {
                    return [this.x, this.y, this.z, this.w];
                  }),
                  (n.prototype.setFromAxisAngle = function (t, e) {
                    var n = Math.sin(0.5 * e);
                    (this.x = t.x * n),
                      (this.y = t.y * n),
                      (this.z = t.z * n),
                      (this.w = Math.cos(0.5 * e));
                  }),
                  (n.prototype.toAxisAngle = function (t) {
                    (t = t || new i()), this.normalize();
                    var e = 2 * Math.acos(this.w),
                      n = Math.sqrt(1 - this.w * this.w);
                    return (
                      0.001 > n
                        ? ((t.x = this.x), (t.y = this.y), (t.z = this.z))
                        : ((t.x = this.x / n),
                          (t.y = this.y / n),
                          (t.z = this.z / n)),
                      [t, e]
                    );
                  });
                var r = new i(),
                  o = new i();
                n.prototype.setFromVectors = function (t, e) {
                  if (t.isAntiparallelTo(e)) {
                    var n = r,
                      i = o;
                    t.tangents(n, i), this.setFromAxisAngle(n, Math.PI);
                  } else {
                    var s = t.cross(e);
                    (this.x = s.x),
                      (this.y = s.y),
                      (this.z = s.z),
                      (this.w =
                        Math.sqrt(
                          Math.pow(t.norm(), 2) * Math.pow(e.norm(), 2)
                        ) + t.dot(e)),
                      this.normalize();
                  }
                };
                var s = new i(),
                  a = new i(),
                  l = new i();
                (n.prototype.mult = function (t, e) {
                  e = e || new n();
                  var i = this.w,
                    r = s,
                    o = a,
                    c = l;
                  return (
                    r.set(this.x, this.y, this.z),
                    o.set(t.x, t.y, t.z),
                    (e.w = i * t.w - r.dot(o)),
                    r.cross(o, c),
                    (e.x = i * o.x + t.w * r.x + c.x),
                    (e.y = i * o.y + t.w * r.y + c.y),
                    (e.z = i * o.z + t.w * r.z + c.z),
                    e
                  );
                }),
                  (n.prototype.inverse = function (t) {
                    var e = this.x,
                      i = this.y,
                      r = this.z,
                      o = this.w;
                    (t = t || new n()), this.conjugate(t);
                    var s = 1 / (e * e + i * i + r * r + o * o);
                    return (t.x *= s), (t.y *= s), (t.z *= s), (t.w *= s), t;
                  }),
                  (n.prototype.conjugate = function (t) {
                    return (
                      ((t = t || new n()).x = -this.x),
                      (t.y = -this.y),
                      (t.z = -this.z),
                      (t.w = this.w),
                      t
                    );
                  }),
                  (n.prototype.normalize = function () {
                    var t = Math.sqrt(
                      this.x * this.x +
                        this.y * this.y +
                        this.z * this.z +
                        this.w * this.w
                    );
                    0 === t
                      ? ((this.x = 0), (this.y = 0), (this.z = 0), (this.w = 0))
                      : ((t = 1 / t),
                        (this.x *= t),
                        (this.y *= t),
                        (this.z *= t),
                        (this.w *= t));
                  }),
                  (n.prototype.normalizeFast = function () {
                    var t =
                      (3 -
                        (this.x * this.x +
                          this.y * this.y +
                          this.z * this.z +
                          this.w * this.w)) /
                      2;
                    0 === t
                      ? ((this.x = 0), (this.y = 0), (this.z = 0), (this.w = 0))
                      : ((this.x *= t),
                        (this.y *= t),
                        (this.z *= t),
                        (this.w *= t));
                  }),
                  (n.prototype.vmult = function (t, e) {
                    e = e || new i();
                    var n = t.x,
                      r = t.y,
                      o = t.z,
                      s = this.x,
                      a = this.y,
                      l = this.z,
                      c = this.w,
                      u = c * n + a * o - l * r,
                      h = c * r + l * n - s * o,
                      d = c * o + s * r - a * n,
                      p = -s * n - a * r - l * o;
                    return (
                      (e.x = u * c + p * -s + h * -l - d * -a),
                      (e.y = h * c + p * -a + d * -s - u * -l),
                      (e.z = d * c + p * -l + u * -a - h * -s),
                      e
                    );
                  }),
                  (n.prototype.copy = function (t) {
                    return (
                      (this.x = t.x),
                      (this.y = t.y),
                      (this.z = t.z),
                      (this.w = t.w),
                      this
                    );
                  }),
                  (n.prototype.toEuler = function (t, e) {
                    e = e || "YZX";
                    var n,
                      i,
                      r,
                      o = this.x,
                      s = this.y,
                      a = this.z,
                      l = this.w;
                    switch (e) {
                      case "YZX":
                        var c = o * s + a * l;
                        if (
                          (c > 0.499 &&
                            ((n = 2 * Math.atan2(o, l)),
                            (i = Math.PI / 2),
                            (r = 0)),
                          -0.499 > c &&
                            ((n = -2 * Math.atan2(o, l)),
                            (i = -Math.PI / 2),
                            (r = 0)),
                          isNaN(n))
                        ) {
                          var u = o * o,
                            h = s * s,
                            d = a * a;
                          (n = Math.atan2(
                            2 * s * l - 2 * o * a,
                            1 - 2 * h - 2 * d
                          )),
                            (i = Math.asin(2 * c)),
                            (r = Math.atan2(
                              2 * o * l - 2 * s * a,
                              1 - 2 * u - 2 * d
                            ));
                        }
                        break;
                      default:
                        throw new Error(
                          "Euler order " + e + " not supported yet."
                        );
                    }
                    (t.y = n), (t.z = i), (t.x = r);
                  }),
                  (n.prototype.setFromEuler = function (t, e, n, i) {
                    i = i || "XYZ";
                    var r = Math.cos(t / 2),
                      o = Math.cos(e / 2),
                      s = Math.cos(n / 2),
                      a = Math.sin(t / 2),
                      l = Math.sin(e / 2),
                      c = Math.sin(n / 2);
                    return (
                      "XYZ" === i
                        ? ((this.x = a * o * s + r * l * c),
                          (this.y = r * l * s - a * o * c),
                          (this.z = r * o * c + a * l * s),
                          (this.w = r * o * s - a * l * c))
                        : "YXZ" === i
                        ? ((this.x = a * o * s + r * l * c),
                          (this.y = r * l * s - a * o * c),
                          (this.z = r * o * c - a * l * s),
                          (this.w = r * o * s + a * l * c))
                        : "ZXY" === i
                        ? ((this.x = a * o * s - r * l * c),
                          (this.y = r * l * s + a * o * c),
                          (this.z = r * o * c + a * l * s),
                          (this.w = r * o * s - a * l * c))
                        : "ZYX" === i
                        ? ((this.x = a * o * s - r * l * c),
                          (this.y = r * l * s + a * o * c),
                          (this.z = r * o * c - a * l * s),
                          (this.w = r * o * s + a * l * c))
                        : "YZX" === i
                        ? ((this.x = a * o * s + r * l * c),
                          (this.y = r * l * s + a * o * c),
                          (this.z = r * o * c - a * l * s),
                          (this.w = r * o * s - a * l * c))
                        : "XZY" === i &&
                          ((this.x = a * o * s - r * l * c),
                          (this.y = r * l * s - a * o * c),
                          (this.z = r * o * c + a * l * s),
                          (this.w = r * o * s + a * l * c)),
                      this
                    );
                  }),
                  (n.prototype.clone = function () {
                    return new n(this.x, this.y, this.z, this.w);
                  });
              },
              { "./Vec3": 30 },
            ],
            29: [
              function (t, e) {
                function n(t) {
                  (t = t || {}),
                    (this.position = new i()),
                    t.position && this.position.copy(t.position),
                    (this.quaternion = new r()),
                    t.quaternion && this.quaternion.copy(t.quaternion);
                }
                var i = t("./Vec3"),
                  r = t("./Quaternion");
                e.exports = n;
                var o = new r();
                (n.pointToLocalFrame = function (t, e, n, r) {
                  return (
                    (r = r || new i()),
                    n.vsub(t, r),
                    e.conjugate(o),
                    o.vmult(r, r),
                    r
                  );
                }),
                  (n.prototype.pointToLocal = function (t, e) {
                    return n.pointToLocalFrame(
                      this.position,
                      this.quaternion,
                      t,
                      e
                    );
                  }),
                  (n.pointToWorldFrame = function (t, e, n, r) {
                    return (r = r || new i()), e.vmult(n, r), r.vadd(t, r), r;
                  }),
                  (n.prototype.pointToWorld = function (t, e) {
                    return n.pointToWorldFrame(
                      this.position,
                      this.quaternion,
                      t,
                      e
                    );
                  }),
                  (n.prototype.vectorToWorldFrame = function (t, e) {
                    return (e = e || new i()), this.quaternion.vmult(t, e), e;
                  }),
                  (n.vectorToWorldFrame = function (t, e, n) {
                    return t.vmult(e, n), n;
                  }),
                  (n.vectorToLocalFrame = function (t, e, n, r) {
                    return (
                      (r = r || new i()),
                      (e.w *= -1),
                      e.vmult(n, r),
                      (e.w *= -1),
                      r
                    );
                  });
              },
              { "./Quaternion": 28, "./Vec3": 30 },
            ],
            30: [
              function (t, e) {
                function n(t, e, n) {
                  (this.x = t || 0), (this.y = e || 0), (this.z = n || 0);
                }
                e.exports = n;
                var i = t("./Mat3");
                (n.ZERO = new n(0, 0, 0)),
                  (n.UNIT_X = new n(1, 0, 0)),
                  (n.UNIT_Y = new n(0, 1, 0)),
                  (n.UNIT_Z = new n(0, 0, 1)),
                  (n.prototype.cross = function (t, e) {
                    var i = t.x,
                      r = t.y,
                      o = t.z,
                      s = this.x,
                      a = this.y,
                      l = this.z;
                    return (
                      ((e = e || new n()).x = a * o - l * r),
                      (e.y = l * i - s * o),
                      (e.z = s * r - a * i),
                      e
                    );
                  }),
                  (n.prototype.set = function (t, e, n) {
                    return (this.x = t), (this.y = e), (this.z = n), this;
                  }),
                  (n.prototype.setZero = function () {
                    this.x = this.y = this.z = 0;
                  }),
                  (n.prototype.vadd = function (t, e) {
                    return e
                      ? ((e.x = t.x + this.x),
                        (e.y = t.y + this.y),
                        void (e.z = t.z + this.z))
                      : new n(this.x + t.x, this.y + t.y, this.z + t.z);
                  }),
                  (n.prototype.vsub = function (t, e) {
                    return e
                      ? ((e.x = this.x - t.x),
                        (e.y = this.y - t.y),
                        void (e.z = this.z - t.z))
                      : new n(this.x - t.x, this.y - t.y, this.z - t.z);
                  }),
                  (n.prototype.crossmat = function () {
                    return new i([
                      0,
                      -this.z,
                      this.y,
                      this.z,
                      0,
                      -this.x,
                      -this.y,
                      this.x,
                      0,
                    ]);
                  }),
                  (n.prototype.normalize = function () {
                    var t = this.x,
                      e = this.y,
                      n = this.z,
                      i = Math.sqrt(t * t + e * e + n * n);
                    if (i > 0) {
                      var r = 1 / i;
                      (this.x *= r), (this.y *= r), (this.z *= r);
                    } else (this.x = 0), (this.y = 0), (this.z = 0);
                    return i;
                  }),
                  (n.prototype.unit = function (t) {
                    t = t || new n();
                    var e = this.x,
                      i = this.y,
                      r = this.z,
                      o = Math.sqrt(e * e + i * i + r * r);
                    return (
                      o > 0
                        ? ((o = 1 / o),
                          (t.x = e * o),
                          (t.y = i * o),
                          (t.z = r * o))
                        : ((t.x = 1), (t.y = 0), (t.z = 0)),
                      t
                    );
                  }),
                  (n.prototype.norm = function () {
                    var t = this.x,
                      e = this.y,
                      n = this.z;
                    return Math.sqrt(t * t + e * e + n * n);
                  }),
                  (n.prototype.length = n.prototype.norm),
                  (n.prototype.norm2 = function () {
                    return this.dot(this);
                  }),
                  (n.prototype.lengthSquared = n.prototype.norm2),
                  (n.prototype.distanceTo = function (t) {
                    var e = this.x,
                      n = this.y,
                      i = this.z,
                      r = t.x,
                      o = t.y,
                      s = t.z;
                    return Math.sqrt(
                      (r - e) * (r - e) + (o - n) * (o - n) + (s - i) * (s - i)
                    );
                  }),
                  (n.prototype.distanceSquared = function (t) {
                    var e = this.x,
                      n = this.y,
                      i = this.z,
                      r = t.x,
                      o = t.y,
                      s = t.z;
                    return (
                      (r - e) * (r - e) + (o - n) * (o - n) + (s - i) * (s - i)
                    );
                  }),
                  (n.prototype.mult = function (t, e) {
                    e = e || new n();
                    var i = this.x,
                      r = this.y,
                      o = this.z;
                    return (e.x = t * i), (e.y = t * r), (e.z = t * o), e;
                  }),
                  (n.prototype.scale = n.prototype.mult),
                  (n.prototype.dot = function (t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z;
                  }),
                  (n.prototype.isZero = function () {
                    return 0 === this.x && 0 === this.y && 0 === this.z;
                  }),
                  (n.prototype.negate = function (t) {
                    return (
                      ((t = t || new n()).x = -this.x),
                      (t.y = -this.y),
                      (t.z = -this.z),
                      t
                    );
                  });
                var r = new n(),
                  o = new n();
                (n.prototype.tangents = function (t, e) {
                  var n = this.norm();
                  if (n > 0) {
                    var i = r,
                      s = 1 / n;
                    i.set(this.x * s, this.y * s, this.z * s);
                    var a = o;
                    Math.abs(i.x) < 0.9
                      ? (a.set(1, 0, 0), i.cross(a, t))
                      : (a.set(0, 1, 0), i.cross(a, t)),
                      i.cross(t, e);
                  } else t.set(1, 0, 0), e.set(0, 1, 0);
                }),
                  (n.prototype.toString = function () {
                    return this.x + "," + this.y + "," + this.z;
                  }),
                  (n.prototype.toArray = function () {
                    return [this.x, this.y, this.z];
                  }),
                  (n.prototype.copy = function (t) {
                    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
                  }),
                  (n.prototype.lerp = function (t, e, n) {
                    var i = this.x,
                      r = this.y,
                      o = this.z;
                    (n.x = i + (t.x - i) * e),
                      (n.y = r + (t.y - r) * e),
                      (n.z = o + (t.z - o) * e);
                  }),
                  (n.prototype.almostEquals = function (t, e) {
                    return (
                      void 0 === e && (e = 1e-6),
                      !(
                        Math.abs(this.x - t.x) > e ||
                        Math.abs(this.y - t.y) > e ||
                        Math.abs(this.z - t.z) > e
                      )
                    );
                  }),
                  (n.prototype.almostZero = function (t) {
                    return (
                      void 0 === t && (t = 1e-6),
                      !(
                        Math.abs(this.x) > t ||
                        Math.abs(this.y) > t ||
                        Math.abs(this.z) > t
                      )
                    );
                  });
                var s = new n();
                (n.prototype.isAntiparallelTo = function (t, e) {
                  return this.negate(s), s.almostEquals(t, e);
                }),
                  (n.prototype.clone = function () {
                    return new n(this.x, this.y, this.z);
                  });
              },
              { "./Mat3": 27 },
            ],
            31: [
              function (t, e) {
                function n(t) {
                  (t = t || {}),
                    i.apply(this),
                    (this.id = n.idCounter++),
                    (this.world = null),
                    (this.preStep = null),
                    (this.postStep = null),
                    (this.vlambda = new r()),
                    (this.collisionFilterGroup =
                      "number" == typeof t.collisionFilterGroup
                        ? t.collisionFilterGroup
                        : 1),
                    (this.collisionFilterMask =
                      "number" == typeof t.collisionFilterMask
                        ? t.collisionFilterMask
                        : 1),
                    (this.collisionResponse = !0),
                    (this.position = new r()),
                    t.position && this.position.copy(t.position),
                    (this.previousPosition = new r()),
                    (this.initPosition = new r()),
                    (this.velocity = new r()),
                    t.velocity && this.velocity.copy(t.velocity),
                    (this.initVelocity = new r()),
                    (this.force = new r());
                  var e = "number" == typeof t.mass ? t.mass : 0;
                  (this.mass = e),
                    (this.invMass = e > 0 ? 1 / e : 0),
                    (this.material = t.material || null),
                    (this.linearDamping =
                      "number" == typeof t.linearDamping
                        ? t.linearDamping
                        : 0.01),
                    (this.type = 0 >= e ? n.STATIC : n.DYNAMIC),
                    typeof t.type == typeof n.STATIC && (this.type = t.type),
                    (this.allowSleep = void 0 === t.allowSleep || t.allowSleep),
                    (this.sleepState = 0),
                    (this.sleepSpeedLimit =
                      void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : 0.1),
                    (this.sleepTimeLimit =
                      void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1),
                    (this.timeLastSleepy = 0),
                    (this._wakeUpAfterNarrowphase = !1),
                    (this.torque = new r()),
                    (this.quaternion = new s()),
                    t.quaternion && this.quaternion.copy(t.quaternion),
                    (this.initQuaternion = new s()),
                    (this.angularVelocity = new r()),
                    t.angularVelocity &&
                      this.angularVelocity.copy(t.angularVelocity),
                    (this.initAngularVelocity = new r()),
                    (this.interpolatedPosition = new r()),
                    (this.interpolatedQuaternion = new s()),
                    (this.shapes = []),
                    (this.shapeOffsets = []),
                    (this.shapeOrientations = []),
                    (this.inertia = new r()),
                    (this.invInertia = new r()),
                    (this.invInertiaWorld = new o()),
                    (this.invMassSolve = 0),
                    (this.invInertiaSolve = new r()),
                    (this.invInertiaWorldSolve = new o()),
                    (this.fixedRotation =
                      void 0 !== t.fixedRotation && t.fixedRotation),
                    (this.angularDamping =
                      void 0 !== t.angularDamping ? t.angularDamping : 0.01),
                    (this.aabb = new a()),
                    (this.aabbNeedsUpdate = !0),
                    (this.wlambda = new r()),
                    t.shape && this.addShape(t.shape),
                    this.updateMassProperties();
                }
                e.exports = n;
                var i = t("../utils/EventTarget"),
                  r = (t("../shapes/Shape"), t("../math/Vec3")),
                  o = t("../math/Mat3"),
                  s = t("../math/Quaternion"),
                  a = (t("../material/Material"), t("../collision/AABB")),
                  l = t("../shapes/Box");
                (n.prototype = new i()),
                  (n.prototype.constructor = n),
                  (n.DYNAMIC = 1),
                  (n.STATIC = 2),
                  (n.KINEMATIC = 4),
                  (n.AWAKE = 0),
                  (n.SLEEPY = 1),
                  (n.SLEEPING = 2),
                  (n.idCounter = 0),
                  (n.prototype.wakeUp = function () {
                    var t = this.sleepState;
                    (this.sleepState = 0),
                      t === n.SLEEPING &&
                        this.dispatchEvent({ type: "wakeup" });
                  }),
                  (n.prototype.sleep = function () {
                    (this.sleepState = n.SLEEPING),
                      this.velocity.set(0, 0, 0),
                      this.angularVelocity.set(0, 0, 0);
                  }),
                  (n.sleepyEvent = { type: "sleepy" }),
                  (n.sleepEvent = { type: "sleep" }),
                  (n.prototype.sleepTick = function (t) {
                    if (this.allowSleep) {
                      var e = this.sleepState,
                        i =
                          this.velocity.norm2() + this.angularVelocity.norm2(),
                        r = Math.pow(this.sleepSpeedLimit, 2);
                      e === n.AWAKE && r > i
                        ? ((this.sleepState = n.SLEEPY),
                          (this.timeLastSleepy = t),
                          this.dispatchEvent(n.sleepyEvent))
                        : e === n.SLEEPY && i > r
                        ? this.wakeUp()
                        : e === n.SLEEPY &&
                          t - this.timeLastSleepy > this.sleepTimeLimit &&
                          (this.sleep(), this.dispatchEvent(n.sleepEvent));
                    }
                  }),
                  (n.prototype.updateSolveMassProperties = function () {
                    this.sleepState === n.SLEEPING || this.type === n.KINEMATIC
                      ? ((this.invMassSolve = 0),
                        this.invInertiaSolve.setZero(),
                        this.invInertiaWorldSolve.setZero())
                      : ((this.invMassSolve = this.invMass),
                        this.invInertiaSolve.copy(this.invInertia),
                        this.invInertiaWorldSolve.copy(this.invInertiaWorld));
                  }),
                  (n.prototype.pointToLocalFrame = function (t, e) {
                    return (
                      (e = e || new r()),
                      t.vsub(this.position, e),
                      this.quaternion.conjugate().vmult(e, e),
                      e
                    );
                  }),
                  (n.prototype.vectorToLocalFrame = function (t, e) {
                    return (
                      (e = e || new r()),
                      this.quaternion.conjugate().vmult(t, e),
                      e
                    );
                  }),
                  (n.prototype.pointToWorldFrame = function (t, e) {
                    return (
                      (e = e || new r()),
                      this.quaternion.vmult(t, e),
                      e.vadd(this.position, e),
                      e
                    );
                  }),
                  (n.prototype.vectorToWorldFrame = function (t, e) {
                    return (e = e || new r()), this.quaternion.vmult(t, e), e;
                  });
                var c = new r(),
                  u = new s();
                (n.prototype.addShape = function (t, e, n) {
                  var i = new r(),
                    o = new s();
                  return (
                    e && i.copy(e),
                    n && o.copy(n),
                    this.shapes.push(t),
                    this.shapeOffsets.push(i),
                    this.shapeOrientations.push(o),
                    this.updateMassProperties(),
                    this.updateBoundingRadius(),
                    (this.aabbNeedsUpdate = !0),
                    this
                  );
                }),
                  (n.prototype.updateBoundingRadius = function () {
                    for (
                      var t = this.shapes,
                        e = this.shapeOffsets,
                        n = t.length,
                        i = 0,
                        r = 0;
                      r !== n;
                      r++
                    ) {
                      var o = t[r];
                      o.updateBoundingSphereRadius();
                      var s = e[r].norm(),
                        a = o.boundingSphereRadius;
                      s + a > i && (i = s + a);
                    }
                    this.boundingRadius = i;
                  });
                var h = new a();
                n.prototype.computeAABB = function () {
                  for (
                    var t = this.shapes,
                      e = this.shapeOffsets,
                      n = this.shapeOrientations,
                      i = t.length,
                      r = c,
                      o = u,
                      s = this.quaternion,
                      a = this.aabb,
                      l = h,
                      d = 0;
                    d !== i;
                    d++
                  ) {
                    var p = t[d];
                    n[d].mult(s, o),
                      o.vmult(e[d], r),
                      r.vadd(this.position, r),
                      p.calculateWorldAABB(r, o, l.lowerBound, l.upperBound),
                      0 === d ? a.copy(l) : a.extend(l);
                  }
                  this.aabbNeedsUpdate = !1;
                };
                var d = new o(),
                  p = new o();
                new o(),
                  (n.prototype.updateInertiaWorld = function (t) {
                    var e = this.invInertia;
                    if (e.x !== e.y || e.y !== e.z || t) {
                      var n = d,
                        i = p;
                      n.setRotationFromQuaternion(this.quaternion),
                        n.transpose(i),
                        n.scale(e, n),
                        n.mmult(i, this.invInertiaWorld);
                    }
                  });
                var f = new r(),
                  m = new r();
                n.prototype.applyForce = function (t, e) {
                  if (this.type === n.DYNAMIC) {
                    var i = f;
                    e.vsub(this.position, i);
                    var r = m;
                    i.cross(t, r),
                      this.force.vadd(t, this.force),
                      this.torque.vadd(r, this.torque);
                  }
                };
                var g = new r(),
                  v = new r();
                n.prototype.applyLocalForce = function (t, e) {
                  if (this.type === n.DYNAMIC) {
                    var i = g,
                      r = v;
                    this.vectorToWorldFrame(t, i),
                      this.pointToWorldFrame(e, r),
                      this.applyForce(i, r);
                  }
                };
                var y = new r(),
                  x = new r(),
                  b = new r();
                n.prototype.applyImpulse = function (t, e) {
                  if (this.type === n.DYNAMIC) {
                    var i = y;
                    e.vsub(this.position, i);
                    var r = x;
                    r.copy(t),
                      r.mult(this.invMass, r),
                      this.velocity.vadd(r, this.velocity);
                    var o = b;
                    i.cross(t, o),
                      this.invInertiaWorld.vmult(o, o),
                      this.angularVelocity.vadd(o, this.angularVelocity);
                  }
                };
                var w = new r(),
                  _ = new r();
                n.prototype.applyLocalImpulse = function (t, e) {
                  if (this.type === n.DYNAMIC) {
                    var i = w,
                      r = _;
                    this.vectorToWorldFrame(t, i),
                      this.pointToWorldFrame(e, r),
                      this.applyImpulse(i, r);
                  }
                };
                var M = new r();
                (n.prototype.updateMassProperties = function () {
                  var t = M;
                  this.invMass = this.mass > 0 ? 1 / this.mass : 0;
                  var e = this.inertia,
                    n = this.fixedRotation;
                  this.computeAABB(),
                    t.set(
                      (this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2,
                      (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2,
                      (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2
                    ),
                    l.calculateInertia(t, this.mass, e),
                    this.invInertia.set(
                      e.x > 0 && !n ? 1 / e.x : 0,
                      e.y > 0 && !n ? 1 / e.y : 0,
                      e.z > 0 && !n ? 1 / e.z : 0
                    ),
                    this.updateInertiaWorld(!0);
                }),
                  (n.prototype.getVelocityAtWorldPoint = function (t, e) {
                    var n = new r();
                    return (
                      t.vsub(this.position, n),
                      this.angularVelocity.cross(n, e),
                      this.velocity.vadd(e, e),
                      e
                    );
                  });
              },
              {
                "../collision/AABB": 3,
                "../material/Material": 25,
                "../math/Mat3": 27,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../shapes/Box": 37,
                "../shapes/Shape": 43,
                "../utils/EventTarget": 49,
              },
            ],
            32: [
              function (t, e) {
                function n(t) {
                  (this.chassisBody = t.chassisBody),
                    (this.wheelInfos = []),
                    (this.sliding = !1),
                    (this.world = null),
                    (this.indexRightAxis =
                      void 0 !== t.indexRightAxis ? t.indexRightAxis : 1),
                    (this.indexForwardAxis =
                      void 0 !== t.indexForwardAxis ? t.indexForwardAxis : 0),
                    (this.indexUpAxis =
                      void 0 !== t.indexUpAxis ? t.indexUpAxis : 2);
                }
                function i(t, e, n, i, o) {
                  var s = 0,
                    a = n,
                    l = x,
                    c = b,
                    u = w;
                  return (
                    t.getVelocityAtWorldPoint(a, l),
                    e.getVelocityAtWorldPoint(a, c),
                    l.vsub(c, u),
                    (s = -i.dot(u) * (1 / (r(t, n, i) + r(e, n, i)))) > o &&
                      (s = o),
                    -o > s && (s = -o),
                    s
                  );
                }
                function r(t, e, n) {
                  var i = _,
                    r = M,
                    o = S,
                    s = E;
                  return (
                    e.vsub(t.position, i),
                    i.cross(n, r),
                    t.invInertiaWorld.vmult(r, s),
                    s.cross(i, o),
                    t.invMass + n.dot(o)
                  );
                }
                function o(t, e, n, i, r, o) {
                  if (r.norm2() > 1.1) return 0;
                  var s = T,
                    a = A,
                    l = C;
                  return (
                    t.getVelocityAtWorldPoint(e, s),
                    n.getVelocityAtWorldPoint(i, a),
                    s.vsub(a, l),
                    -0.2 * r.dot(l) * (1 / (t.invMass + n.invMass))
                  );
                }
                var s = (t("./Body"), t("../math/Vec3")),
                  a = t("../math/Quaternion"),
                  l = (t("../collision/RaycastResult"), t("../collision/Ray")),
                  c = t("../objects/WheelInfo");
                e.exports = n;
                var u = (new s(), new s(), new s(), new s()),
                  h = new s(),
                  d = new s();
                new l(),
                  (n.prototype.addWheel = function (t) {
                    var e = new c((t = t || {})),
                      n = this.wheelInfos.length;
                    return this.wheelInfos.push(e), n;
                  }),
                  (n.prototype.setSteeringValue = function (t, e) {
                    this.wheelInfos[e].steering = t;
                  }),
                  new s(),
                  (n.prototype.applyEngineForce = function (t, e) {
                    this.wheelInfos[e].engineForce = t;
                  }),
                  (n.prototype.setBrake = function (t, e) {
                    this.wheelInfos[e].brake = t;
                  }),
                  (n.prototype.addToWorld = function (t) {
                    this.constraints, t.add(this.chassisBody);
                    var e = this;
                    (this.preStepCallback = function () {
                      e.updateVehicle(t.dt);
                    }),
                      t.addEventListener("preStep", this.preStepCallback),
                      (this.world = t);
                  }),
                  (n.prototype.getVehicleAxisWorld = function (t, e) {
                    e.set(0 === t ? 1 : 0, 1 === t ? 1 : 0, 2 === t ? 1 : 0),
                      this.chassisBody.vectorToWorldFrame(e, e);
                  }),
                  (n.prototype.updateVehicle = function (t) {
                    for (
                      var e = this.wheelInfos,
                        n = e.length,
                        i = this.chassisBody,
                        r = 0;
                      n > r;
                      r++
                    )
                      this.updateWheelTransform(r);
                    this.currentVehicleSpeedKmHour = 3.6 * i.velocity.norm();
                    var o = new s();
                    for (
                      this.getVehicleAxisWorld(this.indexForwardAxis, o),
                        o.dot(i.velocity) < 0 &&
                          (this.currentVehicleSpeedKmHour *= -1),
                        r = 0;
                      n > r;
                      r++
                    )
                      this.castRay(e[r]);
                    this.updateSuspension(t);
                    var a = new s(),
                      l = new s();
                    for (r = 0; n > r; r++) {
                      var c = (p = e[r]).suspensionForce;
                      c > p.maxSuspensionForce && (c = p.maxSuspensionForce),
                        p.raycastResult.hitNormalWorld.scale(c * t, a),
                        p.raycastResult.hitPointWorld.vsub(i.position, l),
                        i.applyImpulse(a, p.raycastResult.hitPointWorld);
                    }
                    this.updateFriction(t);
                    var u = new s(),
                      h = new s(),
                      d = new s();
                    for (r = 0; n > r; r++) {
                      var p = e[r];
                      i.getVelocityAtWorldPoint(
                        p.chassisConnectionPointWorld,
                        d
                      );
                      var f = 1;
                      switch (this.indexUpAxis) {
                        case 1:
                          f = -1;
                      }
                      if (p.isInContact) {
                        this.getVehicleAxisWorld(this.indexForwardAxis, h);
                        var m = h.dot(p.raycastResult.hitNormalWorld);
                        p.raycastResult.hitNormalWorld.scale(m, u),
                          h.vsub(u, h);
                        var g = h.dot(d);
                        p.deltaRotation = (f * g * t) / p.radius;
                      }
                      (!p.sliding && p.isInContact) ||
                        0 === p.engineForce ||
                        !p.useCustomSlidingRotationalSpeed ||
                        (p.deltaRotation =
                          (p.engineForce > 0 ? 1 : -1) *
                          p.customSlidingRotationalSpeed *
                          t),
                        Math.abs(p.brake) > Math.abs(p.engineForce) &&
                          (p.deltaRotation = 0),
                        (p.rotation += p.deltaRotation),
                        (p.deltaRotation *= 0.99);
                    }
                  }),
                  (n.prototype.updateSuspension = function () {
                    for (
                      var t = this.chassisBody.mass,
                        e = this.wheelInfos,
                        n = e.length,
                        i = 0;
                      n > i;
                      i++
                    ) {
                      var r = e[i];
                      if (r.isInContact) {
                        var o,
                          s = r.suspensionRestLength - r.suspensionLength;
                        o =
                          r.suspensionStiffness *
                          s *
                          r.clippedInvContactDotSuspension;
                        var a = r.suspensionRelativeVelocity;
                        (o -=
                          (0 > a ? r.dampingCompression : r.dampingRelaxation) *
                          a),
                          (r.suspensionForce = o * t),
                          r.suspensionForce < 0 && (r.suspensionForce = 0);
                      } else r.suspensionForce = 0;
                    }
                  }),
                  (n.prototype.removeFromWorld = function (t) {
                    this.constraints,
                      t.remove(this.chassisBody),
                      t.removeEventListener("preStep", this.preStepCallback),
                      (this.world = null);
                  });
                var p = new s(),
                  f = new s();
                (n.prototype.castRay = function (t) {
                  var e = p,
                    n = f;
                  this.updateWheelTransformWorld(t);
                  var i = this.chassisBody,
                    r = -1,
                    o = t.suspensionRestLength + t.radius;
                  t.directionWorld.scale(o, e);
                  var a = t.chassisConnectionPointWorld;
                  a.vadd(e, n);
                  var l = t.raycastResult;
                  l.reset();
                  var c = i.collisionResponse;
                  (i.collisionResponse = !1),
                    this.world.rayTest(a, n, l),
                    (i.collisionResponse = c);
                  var u = l.body;
                  if (((t.raycastResult.groundObject = 0), u)) {
                    (r = l.distance),
                      (t.raycastResult.hitNormalWorld = l.hitNormalWorld),
                      (t.isInContact = !0);
                    var h = l.distance;
                    t.suspensionLength = h - t.radius;
                    var d = t.suspensionRestLength - t.maxSuspensionTravel,
                      m = t.suspensionRestLength + t.maxSuspensionTravel;
                    t.suspensionLength < d && (t.suspensionLength = d),
                      t.suspensionLength > m &&
                        ((t.suspensionLength = m), t.raycastResult.reset());
                    var g = t.raycastResult.hitNormalWorld.dot(
                        t.directionWorld
                      ),
                      v = new s();
                    i.getVelocityAtWorldPoint(t.raycastResult.hitPointWorld, v);
                    var y = t.raycastResult.hitNormalWorld.dot(v);
                    if (g >= -0.1)
                      (t.suspensionRelativeVelocity = 0),
                        (t.clippedInvContactDotSuspension = 10);
                    else {
                      var x = -1 / g;
                      (t.suspensionRelativeVelocity = y * x),
                        (t.clippedInvContactDotSuspension = x);
                    }
                  } else
                    (t.suspensionLength =
                      t.suspensionRestLength + 0 * t.maxSuspensionTravel),
                      (t.suspensionRelativeVelocity = 0),
                      t.directionWorld.scale(
                        -1,
                        t.raycastResult.hitNormalWorld
                      ),
                      (t.clippedInvContactDotSuspension = 1);
                  return r;
                }),
                  (n.prototype.updateWheelTransformWorld = function (t) {
                    t.isInContact = !1;
                    var e = this.chassisBody;
                    e.pointToWorldFrame(
                      t.chassisConnectionPointLocal,
                      t.chassisConnectionPointWorld
                    ),
                      e.vectorToWorldFrame(t.directionLocal, t.directionWorld),
                      e.vectorToWorldFrame(t.axleLocal, t.axleWorld);
                  }),
                  (n.prototype.updateWheelTransform = function (t) {
                    var e = u,
                      n = h,
                      i = d,
                      r = this.wheelInfos[t];
                    this.updateWheelTransformWorld(r),
                      r.directionLocal.scale(-1, e),
                      n.copy(r.axleLocal),
                      e.cross(n, i),
                      i.normalize(),
                      n.normalize();
                    var o = r.steering,
                      s = new a();
                    s.setFromAxisAngle(e, o);
                    var l = new a();
                    l.setFromAxisAngle(n, r.rotation);
                    var c = r.worldTransform.quaternion;
                    this.chassisBody.quaternion.mult(s, c),
                      c.mult(l, c),
                      c.normalize();
                    var p = r.worldTransform.position;
                    p.copy(r.directionWorld),
                      p.scale(r.suspensionLength, p),
                      p.vadd(r.chassisConnectionPointWorld, p);
                  });
                var m = [new s(1, 0, 0), new s(0, 1, 0), new s(0, 0, 1)];
                n.prototype.getWheelTransformWorld = function (t) {
                  return this.wheelInfos[t].worldTransform;
                };
                var g = new s(),
                  v = [],
                  y = [];
                n.prototype.updateFriction = function (t) {
                  for (
                    var e = g,
                      n = this.wheelInfos,
                      r = n.length,
                      a = this.chassisBody,
                      l = y,
                      c = v,
                      u = 0;
                    r > u;
                    u++
                  )
                    (f = (A = n[u]).raycastResult.body),
                      (A.sideImpulse = 0),
                      (A.forwardImpulse = 0),
                      l[u] || (l[u] = new s()),
                      c[u] || (c[u] = new s());
                  for (u = 0; r > u; u++)
                    if ((f = (A = n[u]).raycastResult.body)) {
                      var h = c[u];
                      this.getWheelTransformWorld(u).vectorToWorldFrame(
                        m[this.indexRightAxis],
                        h
                      );
                      var d = A.raycastResult.hitNormalWorld,
                        p = h.dot(d);
                      d.scale(p, e),
                        h.vsub(e, h),
                        h.normalize(),
                        d.cross(h, l[u]),
                        l[u].normalize(),
                        (A.sideImpulse = o(
                          a,
                          A.raycastResult.hitPointWorld,
                          f,
                          A.raycastResult.hitPointWorld,
                          h
                        )),
                        (A.sideImpulse *= 1);
                    }
                  for (this.sliding = !1, u = 0; r > u; u++) {
                    var f = (A = n[u]).raycastResult.body,
                      x = 0;
                    if (((A.slipInfo = 1), f)) {
                      var b = A.brake ? A.brake : 0;
                      x = i(a, f, A.raycastResult.hitPointWorld, l[u], b);
                      var w = b / (x += A.engineForce * t);
                      A.slipInfo *= w;
                    }
                    if (((A.forwardImpulse = 0), (A.skidInfo = 1), f)) {
                      A.skidInfo = 1;
                      var _ = A.suspensionForce * t * A.frictionSlip,
                        M = _ * _;
                      A.forwardImpulse = x;
                      var S = 0.5 * A.forwardImpulse,
                        E = 1 * A.sideImpulse,
                        T = S * S + E * E;
                      (A.sliding = !1),
                        T > M &&
                          ((this.sliding = !0),
                          (A.sliding = !0),
                          (w = _ / Math.sqrt(T)),
                          (A.skidInfo *= w));
                    }
                  }
                  if (this.sliding)
                    for (u = 0; r > u; u++)
                      0 !== (A = n[u]).sideImpulse &&
                        A.skidInfo < 1 &&
                        ((A.forwardImpulse *= A.skidInfo),
                        (A.sideImpulse *= A.skidInfo));
                  for (u = 0; r > u; u++) {
                    var A = n[u],
                      C = new s();
                    if (
                      (C.copy(A.raycastResult.hitPointWorld),
                      0 !== A.forwardImpulse)
                    ) {
                      var L = new s();
                      l[u].scale(A.forwardImpulse, L), a.applyImpulse(L, C);
                    }
                    if (0 !== A.sideImpulse) {
                      f = A.raycastResult.body;
                      var R = new s();
                      R.copy(A.raycastResult.hitPointWorld);
                      var P = new s();
                      c[u].scale(A.sideImpulse, P),
                        a.pointToLocalFrame(C, C),
                        (C["xyz"[this.indexUpAxis]] *= A.rollInfluence),
                        a.pointToWorldFrame(C, C),
                        a.applyImpulse(P, C),
                        P.scale(-1, P),
                        f.applyImpulse(P, R);
                    }
                  }
                };
                var x = new s(),
                  b = new s(),
                  w = new s(),
                  _ = new s(),
                  M = new s(),
                  S = new s(),
                  E = new s(),
                  T = new s(),
                  A = new s(),
                  C = new s();
              },
              {
                "../collision/Ray": 9,
                "../collision/RaycastResult": 10,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/WheelInfo": 36,
                "./Body": 31,
              },
            ],
            33: [
              function (t, e) {
                function n(t) {
                  if (
                    ((this.wheelBodies = []),
                    (this.coordinateSystem =
                      void 0 === t.coordinateSystem
                        ? new s(1, 2, 3)
                        : t.coordinateSystem.clone()),
                    (this.chassisBody = t.chassisBody),
                    !this.chassisBody)
                  ) {
                    var e = new o(new s(5, 2, 0.5));
                    this.chassisBody = new i(1, e);
                  }
                  (this.constraints = []),
                    (this.wheelAxes = []),
                    (this.wheelForces = []);
                }
                var i = t("./Body"),
                  r = t("../shapes/Sphere"),
                  o = t("../shapes/Box"),
                  s = t("../math/Vec3"),
                  a = t("../constraints/HingeConstraint");
                (e.exports = n),
                  (n.prototype.addWheel = function (t) {
                    var e = (t = t || {}).body;
                    e || (e = new i(1, new r(1.2))),
                      this.wheelBodies.push(e),
                      this.wheelForces.push(0);
                    var n =
                        (new s(),
                        void 0 !== t.position ? t.position.clone() : new s()),
                      o = new s();
                    this.chassisBody.pointToWorldFrame(n, o),
                      e.position.set(o.x, o.y, o.z);
                    var l = void 0 !== t.axis ? t.axis.clone() : new s(0, 1, 0);
                    this.wheelAxes.push(l);
                    var c = new a(this.chassisBody, e, {
                      pivotA: n,
                      axisA: l,
                      pivotB: s.ZERO,
                      axisB: l,
                      collideConnected: !1,
                    });
                    return (
                      this.constraints.push(c), this.wheelBodies.length - 1
                    );
                  }),
                  (n.prototype.setSteeringValue = function (t, e) {
                    var n = this.wheelAxes[e],
                      i = Math.cos(t),
                      r = Math.sin(t),
                      o = n.x,
                      s = n.y;
                    this.constraints[e].axisA.set(
                      i * o - r * s,
                      r * o + i * s,
                      0
                    );
                  }),
                  (n.prototype.setMotorSpeed = function (t, e) {
                    var n = this.constraints[e];
                    n.enableMotor(), (n.motorTargetVelocity = t);
                  }),
                  (n.prototype.disableMotor = function (t) {
                    this.constraints[t].disableMotor();
                  });
                var l = new s();
                (n.prototype.setWheelForce = function (t, e) {
                  this.wheelForces[e] = t;
                }),
                  (n.prototype.applyWheelForce = function (t, e) {
                    var n = this.wheelAxes[e],
                      i = this.wheelBodies[e],
                      r = i.torque;
                    n.scale(t, l), i.vectorToWorldFrame(l, l), r.vadd(l, r);
                  }),
                  (n.prototype.addToWorld = function (t) {
                    for (
                      var e = this.constraints,
                        n = this.wheelBodies.concat([this.chassisBody]),
                        i = 0;
                      i < n.length;
                      i++
                    )
                      t.add(n[i]);
                    for (i = 0; i < e.length; i++) t.addConstraint(e[i]);
                    t.addEventListener("preStep", this._update.bind(this));
                  }),
                  (n.prototype._update = function () {
                    for (var t = this.wheelForces, e = 0; e < t.length; e++)
                      this.applyWheelForce(t[e], e);
                  }),
                  (n.prototype.removeFromWorld = function (t) {
                    for (
                      var e = this.constraints,
                        n = this.wheelBodies.concat([this.chassisBody]),
                        i = 0;
                      i < n.length;
                      i++
                    )
                      t.remove(n[i]);
                    for (i = 0; i < e.length; i++) t.removeConstraint(e[i]);
                  });
                var c = new s();
                n.prototype.getWheelSpeed = function (t) {
                  var e = this.wheelAxes[t],
                    n = this.wheelBodies[t].angularVelocity;
                  return this.chassisBody.vectorToWorldFrame(e, c), n.dot(c);
                };
              },
              {
                "../constraints/HingeConstraint": 15,
                "../math/Vec3": 30,
                "../shapes/Box": 37,
                "../shapes/Sphere": 44,
                "./Body": 31,
              },
            ],
            34: [
              function (t, e) {
                function n() {
                  (this.particles = []),
                    (this.density = 1),
                    (this.smoothingRadius = 1),
                    (this.speedOfSound = 1),
                    (this.viscosity = 0.01),
                    (this.eps = 1e-6),
                    (this.pressures = []),
                    (this.densities = []),
                    (this.neighbors = []);
                }
                e.exports = n;
                var i = (t("../shapes/Shape"), t("../math/Vec3"));
                t("../math/Quaternion"),
                  t("../shapes/Particle"),
                  t("../objects/Body"),
                  t("../material/Material"),
                  (n.prototype.add = function (t) {
                    this.particles.push(t),
                      this.neighbors.length < this.particles.length &&
                        this.neighbors.push([]);
                  }),
                  (n.prototype.remove = function (t) {
                    var e = this.particles.indexOf(t);
                    -1 !== e &&
                      (this.particles.splice(e, 1),
                      this.neighbors.length > this.particles.length &&
                        this.neighbors.pop());
                  });
                var r = new i();
                n.prototype.getNeighbors = function (t, e) {
                  for (
                    var n = this.particles.length,
                      i = t.id,
                      o = this.smoothingRadius * this.smoothingRadius,
                      s = r,
                      a = 0;
                    a !== n;
                    a++
                  ) {
                    var l = this.particles[a];
                    l.position.vsub(t.position, s),
                      i !== l.id && s.norm2() < o && e.push(l);
                  }
                };
                var o = new i(),
                  s = new i(),
                  a = new i(),
                  l = new i(),
                  c = new i(),
                  u = new i();
                (n.prototype.update = function () {
                  for (
                    var t = this.particles.length,
                      e = o,
                      n = this.speedOfSound,
                      i = this.eps,
                      r = 0;
                    r !== t;
                    r++
                  ) {
                    var h = this.particles[r];
                    ((S = this.neighbors[r]).length = 0),
                      this.getNeighbors(h, S),
                      S.push(this.particles[r]);
                    for (var d = S.length, p = 0, f = 0; f !== d; f++) {
                      h.position.vsub(S[f].position, e);
                      var m = e.norm(),
                        g = this.w(m);
                      p += S[f].mass * g;
                    }
                    (this.densities[r] = p),
                      (this.pressures[r] =
                        n * n * (this.densities[r] - this.density));
                  }
                  var v = s,
                    y = a,
                    x = l,
                    b = c,
                    w = u;
                  for (r = 0; r !== t; r++) {
                    var _,
                      M,
                      S,
                      E = this.particles[r];
                    for (
                      v.set(0, 0, 0),
                        y.set(0, 0, 0),
                        d = (S = this.neighbors[r]).length,
                        f = 0;
                      f !== d;
                      f++
                    ) {
                      var T = S[f];
                      E.position.vsub(T.position, b);
                      var A = b.norm();
                      (_ =
                        -T.mass *
                        (this.pressures[r] /
                          (this.densities[r] * this.densities[r] + i) +
                          this.pressures[f] /
                            (this.densities[f] * this.densities[f] + i))),
                        this.gradw(b, x),
                        x.mult(_, x),
                        v.vadd(x, v),
                        T.velocity.vsub(E.velocity, w),
                        w.mult(
                          (1 / (1e-4 + this.densities[r] * this.densities[f])) *
                            this.viscosity *
                            T.mass,
                          w
                        ),
                        (M = this.nablaw(A)),
                        w.mult(M, w),
                        y.vadd(w, y);
                    }
                    y.mult(E.mass, y),
                      v.mult(E.mass, v),
                      E.force.vadd(y, E.force),
                      E.force.vadd(v, E.force);
                  }
                }),
                  (n.prototype.w = function (t) {
                    var e = this.smoothingRadius;
                    return (
                      (315 / (64 * Math.PI * Math.pow(e, 9))) *
                      Math.pow(e * e - t * t, 3)
                    );
                  }),
                  (n.prototype.gradw = function (t, e) {
                    var n = t.norm(),
                      i = this.smoothingRadius;
                    t.mult(
                      (945 / (32 * Math.PI * Math.pow(i, 9))) *
                        Math.pow(i * i - n * n, 2),
                      e
                    );
                  }),
                  (n.prototype.nablaw = function (t) {
                    var e = this.smoothingRadius;
                    return (
                      (945 / (32 * Math.PI * Math.pow(e, 9))) *
                      (e * e - t * t) *
                      (7 * t * t - 3 * e * e)
                    );
                  });
              },
              {
                "../material/Material": 25,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/Body": 31,
                "../shapes/Particle": 41,
                "../shapes/Shape": 43,
              },
            ],
            35: [
              function (t, e) {
                function n(t, e, n) {
                  (n = n || {}),
                    (this.restLength =
                      "number" == typeof n.restLength ? n.restLength : 1),
                    (this.stiffness = n.stiffness || 100),
                    (this.damping = n.damping || 1),
                    (this.bodyA = t),
                    (this.bodyB = e),
                    (this.localAnchorA = new i()),
                    (this.localAnchorB = new i()),
                    n.localAnchorA && this.localAnchorA.copy(n.localAnchorA),
                    n.localAnchorB && this.localAnchorB.copy(n.localAnchorB),
                    n.worldAnchorA && this.setWorldAnchorA(n.worldAnchorA),
                    n.worldAnchorB && this.setWorldAnchorB(n.worldAnchorB);
                }
                var i = t("../math/Vec3");
                (e.exports = n),
                  (n.prototype.setWorldAnchorA = function (t) {
                    this.bodyA.pointToLocalFrame(t, this.localAnchorA);
                  }),
                  (n.prototype.setWorldAnchorB = function (t) {
                    this.bodyB.pointToLocalFrame(t, this.localAnchorB);
                  }),
                  (n.prototype.getWorldAnchorA = function (t) {
                    this.bodyA.pointToWorldFrame(this.localAnchorA, t);
                  }),
                  (n.prototype.getWorldAnchorB = function (t) {
                    this.bodyB.pointToWorldFrame(this.localAnchorB, t);
                  });
                var r = new i(),
                  o = new i(),
                  s = new i(),
                  a = new i(),
                  l = new i(),
                  c = new i(),
                  u = new i(),
                  h = new i(),
                  d = new i(),
                  p = new i(),
                  f = new i();
                n.prototype.applyForce = function () {
                  var t = this.stiffness,
                    e = this.damping,
                    n = this.restLength,
                    i = this.bodyA,
                    m = this.bodyB,
                    g = r,
                    v = o,
                    y = s,
                    x = a,
                    b = f,
                    w = l,
                    _ = c,
                    M = u,
                    S = h,
                    E = d,
                    T = p;
                  this.getWorldAnchorA(w),
                    this.getWorldAnchorB(_),
                    w.vsub(i.position, M),
                    _.vsub(m.position, S),
                    _.vsub(w, g);
                  var A = g.norm();
                  v.copy(g),
                    v.normalize(),
                    m.velocity.vsub(i.velocity, y),
                    m.angularVelocity.cross(S, b),
                    y.vadd(b, y),
                    i.angularVelocity.cross(M, b),
                    y.vsub(b, y),
                    v.mult(-t * (A - n) - e * y.dot(v), x),
                    i.force.vsub(x, i.force),
                    m.force.vadd(x, m.force),
                    M.cross(x, E),
                    S.cross(x, T),
                    i.torque.vsub(E, i.torque),
                    m.torque.vadd(T, m.torque);
                };
              },
              { "../math/Vec3": 30 },
            ],
            36: [
              function (t, e) {
                function n(t) {
                  (t = s.defaults(t, {
                    chassisConnectionPointLocal: new i(),
                    chassisConnectionPointWorld: new i(),
                    directionLocal: new i(),
                    directionWorld: new i(),
                    axleLocal: new i(),
                    axleWorld: new i(),
                    suspensionRestLength: 1,
                    suspensionMaxLength: 2,
                    radius: 1,
                    suspensionStiffness: 100,
                    dampingCompression: 10,
                    dampingRelaxation: 10,
                    frictionSlip: 1e4,
                    steering: 0,
                    rotation: 0,
                    deltaRotation: 0,
                    rollInfluence: 0.01,
                    maxSuspensionForce: Number.MAX_VALUE,
                    isFrontWheel: !0,
                    clippedInvContactDotSuspension: 1,
                    suspensionRelativeVelocity: 0,
                    suspensionForce: 0,
                    skidInfo: 0,
                    suspensionLength: 0,
                    maxSuspensionTravel: 1,
                    useCustomSlidingRotationalSpeed: !1,
                    customSlidingRotationalSpeed: -0.1,
                  })),
                    (this.maxSuspensionTravel = t.maxSuspensionTravel),
                    (this.customSlidingRotationalSpeed =
                      t.customSlidingRotationalSpeed),
                    (this.useCustomSlidingRotationalSpeed =
                      t.useCustomSlidingRotationalSpeed),
                    (this.sliding = !1),
                    (this.chassisConnectionPointLocal =
                      t.chassisConnectionPointLocal.clone()),
                    (this.chassisConnectionPointWorld =
                      t.chassisConnectionPointWorld.clone()),
                    (this.directionLocal = t.directionLocal.clone()),
                    (this.directionWorld = t.directionWorld.clone()),
                    (this.axleLocal = t.axleLocal.clone()),
                    (this.axleWorld = t.axleWorld.clone()),
                    (this.suspensionRestLength = t.suspensionRestLength),
                    (this.suspensionMaxLength = t.suspensionMaxLength),
                    (this.radius = t.radius),
                    (this.suspensionStiffness = t.suspensionStiffness),
                    (this.dampingCompression = t.dampingCompression),
                    (this.dampingRelaxation = t.dampingRelaxation),
                    (this.frictionSlip = t.frictionSlip),
                    (this.steering = 0),
                    (this.rotation = 0),
                    (this.deltaRotation = 0),
                    (this.rollInfluence = t.rollInfluence),
                    (this.maxSuspensionForce = t.maxSuspensionForce),
                    (this.engineForce = 0),
                    (this.brake = 0),
                    (this.isFrontWheel = t.isFrontWheel),
                    (this.clippedInvContactDotSuspension = 1),
                    (this.suspensionRelativeVelocity = 0),
                    (this.suspensionForce = 0),
                    (this.skidInfo = 0),
                    (this.suspensionLength = 0),
                    (this.sideImpulse = 0),
                    (this.forwardImpulse = 0),
                    (this.raycastResult = new o()),
                    (this.worldTransform = new r()),
                    (this.isInContact = !1);
                }
                var i = t("../math/Vec3"),
                  r = t("../math/Transform"),
                  o = t("../collision/RaycastResult"),
                  s = t("../utils/Utils");
                e.exports = n;
                var a = new i(),
                  l = new i();
                (a = new i()),
                  (n.prototype.updateWheel = function (t) {
                    var e = this.raycastResult;
                    if (this.isInContact) {
                      var n = e.hitNormalWorld.dot(e.directionWorld);
                      e.hitPointWorld.vsub(t.position, l),
                        t.getVelocityAtWorldPoint(l, a);
                      var i = e.hitNormalWorld.dot(a);
                      if (n >= -0.1)
                        (this.suspensionRelativeVelocity = 0),
                          (this.clippedInvContactDotSuspension = 10);
                      else {
                        var r = -1 / n;
                        (this.suspensionRelativeVelocity = i * r),
                          (this.clippedInvContactDotSuspension = r);
                      }
                    } else
                      (e.suspensionLength = this.suspensionRestLength),
                        (this.suspensionRelativeVelocity = 0),
                        e.directionWorld.scale(-1, e.hitNormalWorld),
                        (this.clippedInvContactDotSuspension = 1);
                  });
              },
              {
                "../collision/RaycastResult": 10,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "../utils/Utils": 53,
              },
            ],
            37: [
              function (t, e) {
                function n(t) {
                  i.call(this),
                    (this.type = i.types.BOX),
                    (this.halfExtents = t),
                    (this.convexPolyhedronRepresentation = null),
                    this.updateConvexPolyhedronRepresentation(),
                    this.updateBoundingSphereRadius();
                }
                e.exports = n;
                var i = t("./Shape"),
                  r = t("../math/Vec3"),
                  o = t("./ConvexPolyhedron");
                (n.prototype = new i()),
                  (n.prototype.constructor = n),
                  (n.prototype.updateConvexPolyhedronRepresentation =
                    function () {
                      var t = this.halfExtents.x,
                        e = this.halfExtents.y,
                        n = this.halfExtents.z,
                        i = r,
                        s = [
                          new i(-t, -e, -n),
                          new i(t, -e, -n),
                          new i(t, e, -n),
                          new i(-t, e, -n),
                          new i(-t, -e, n),
                          new i(t, -e, n),
                          new i(t, e, n),
                          new i(-t, e, n),
                        ],
                        a =
                          (new i(0, 0, 1),
                          new i(0, 1, 0),
                          new i(1, 0, 0),
                          new o(s, [
                            [3, 2, 1, 0],
                            [4, 5, 6, 7],
                            [5, 4, 0, 1],
                            [2, 3, 7, 6],
                            [0, 4, 7, 3],
                            [1, 2, 6, 5],
                          ]));
                      (this.convexPolyhedronRepresentation = a),
                        (a.material = this.material);
                    }),
                  (n.prototype.calculateLocalInertia = function (t, e) {
                    return (
                      (e = e || new r()),
                      n.calculateInertia(this.halfExtents, t, e),
                      e
                    );
                  }),
                  (n.calculateInertia = function (t, e, n) {
                    var i = t;
                    (n.x =
                      (1 / 12) * e * (2 * i.y * 2 * i.y + 2 * i.z * 2 * i.z)),
                      (n.y =
                        (1 / 12) * e * (2 * i.x * 2 * i.x + 2 * i.z * 2 * i.z)),
                      (n.z =
                        (1 / 12) * e * (2 * i.y * 2 * i.y + 2 * i.x * 2 * i.x));
                  }),
                  (n.prototype.getSideNormals = function (t, e) {
                    var n = t,
                      i = this.halfExtents;
                    if (
                      (n[0].set(i.x, 0, 0),
                      n[1].set(0, i.y, 0),
                      n[2].set(0, 0, i.z),
                      n[3].set(-i.x, 0, 0),
                      n[4].set(0, -i.y, 0),
                      n[5].set(0, 0, -i.z),
                      void 0 !== e)
                    )
                      for (var r = 0; r !== n.length; r++) e.vmult(n[r], n[r]);
                    return n;
                  }),
                  (n.prototype.volume = function () {
                    return (
                      8 *
                      this.halfExtents.x *
                      this.halfExtents.y *
                      this.halfExtents.z
                    );
                  }),
                  (n.prototype.updateBoundingSphereRadius = function () {
                    this.boundingSphereRadius = this.halfExtents.norm();
                  });
                var s = new r();
                new r(),
                  (n.prototype.forEachWorldCorner = function (t, e, n) {
                    for (
                      var i = this.halfExtents,
                        r = [
                          [i.x, i.y, i.z],
                          [-i.x, i.y, i.z],
                          [-i.x, -i.y, i.z],
                          [-i.x, -i.y, -i.z],
                          [i.x, -i.y, -i.z],
                          [i.x, i.y, -i.z],
                          [-i.x, i.y, -i.z],
                          [i.x, -i.y, i.z],
                        ],
                        o = 0;
                      o < r.length;
                      o++
                    )
                      s.set(r[o][0], r[o][1], r[o][2]),
                        e.vmult(s, s),
                        t.vadd(s, s),
                        n(s.x, s.y, s.z);
                  });
                var a = [
                  new r(),
                  new r(),
                  new r(),
                  new r(),
                  new r(),
                  new r(),
                  new r(),
                  new r(),
                ];
                n.prototype.calculateWorldAABB = function (t, e, n, i) {
                  var r = this.halfExtents;
                  a[0].set(r.x, r.y, r.z),
                    a[1].set(-r.x, r.y, r.z),
                    a[2].set(-r.x, -r.y, r.z),
                    a[3].set(-r.x, -r.y, -r.z),
                    a[4].set(r.x, -r.y, -r.z),
                    a[5].set(r.x, r.y, -r.z),
                    a[6].set(-r.x, r.y, -r.z),
                    a[7].set(r.x, -r.y, r.z);
                  var o = a[0];
                  e.vmult(o, o), t.vadd(o, o), i.copy(o), n.copy(o);
                  for (var s = 1; 8 > s; s++) {
                    (o = a[s]), e.vmult(o, o), t.vadd(o, o);
                    var l = o.x,
                      c = o.y,
                      u = o.z;
                    l > i.x && (i.x = l),
                      c > i.y && (i.y = c),
                      u > i.z && (i.z = u),
                      l < n.x && (n.x = l),
                      c < n.y && (n.y = c),
                      u < n.z && (n.z = u);
                  }
                };
              },
              { "../math/Vec3": 30, "./ConvexPolyhedron": 38, "./Shape": 43 },
            ],
            38: [
              function (t, e) {
                function n(t, e, n) {
                  i.call(this),
                    (this.type = i.types.CONVEXPOLYHEDRON),
                    (this.vertices = t || []),
                    (this.worldVertices = []),
                    (this.worldVerticesNeedsUpdate = !0),
                    (this.faces = e || []),
                    (this.faceNormals = []),
                    this.computeNormals(),
                    (this.worldFaceNormalsNeedsUpdate = !0),
                    (this.worldFaceNormals = []),
                    (this.uniqueEdges = []),
                    (this.uniqueAxes = n ? n.slice() : null),
                    this.computeEdges(),
                    this.updateBoundingSphereRadius();
                }
                e.exports = n;
                var i = t("./Shape"),
                  r = t("../math/Vec3"),
                  o = (t("../math/Quaternion"), t("../math/Transform"));
                (n.prototype = new i()), (n.prototype.constructor = n);
                var s = new r();
                (n.prototype.computeEdges = function () {
                  var t = this.faces,
                    e = this.vertices,
                    n = (e.length, this.uniqueEdges);
                  n.length = 0;
                  for (var i = s, r = 0; r !== t.length; r++)
                    for (var o = t[r], a = o.length, l = 0; l !== a; l++) {
                      var c = (l + 1) % a;
                      e[o[l]].vsub(e[o[c]], i), i.normalize();
                      for (var u = !1, h = 0; h !== n.length; h++)
                        if (n[h].almostEquals(i) || n[h].almostEquals(i)) {
                          u = !0;
                          break;
                        }
                      u || n.push(i.clone());
                    }
                }),
                  (n.prototype.computeNormals = function () {
                    this.faceNormals.length = this.faces.length;
                    for (var t = 0; t < this.faces.length; t++) {
                      for (var e = 0; e < this.faces[t].length; e++)
                        if (!this.vertices[this.faces[t][e]])
                          throw new Error(
                            "Vertex " + this.faces[t][e] + " not found!"
                          );
                      var n = this.faceNormals[t] || new r();
                      this.getFaceNormal(t, n),
                        n.negate(n),
                        (this.faceNormals[t] = n);
                      var i = this.vertices[this.faces[t][0]];
                      if (n.dot(i) < 0)
                        for (
                          console.error(
                            ".faceNormals[" +
                              t +
                              "] = Vec3(" +
                              n.toString() +
                              ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."
                          ),
                            e = 0;
                          e < this.faces[t].length;
                          e++
                        )
                          console.warn(
                            ".vertices[" +
                              this.faces[t][e] +
                              "] = Vec3(" +
                              this.vertices[this.faces[t][e]].toString() +
                              ")"
                          );
                    }
                  });
                var a = new r(),
                  l = new r();
                (n.computeNormal = function (t, e, n, i) {
                  e.vsub(t, l),
                    n.vsub(e, a),
                    a.cross(l, i),
                    i.isZero() || i.normalize();
                }),
                  (n.prototype.getFaceNormal = function (t, e) {
                    var i = this.faces[t],
                      r = this.vertices[i[0]],
                      o = this.vertices[i[1]],
                      s = this.vertices[i[2]];
                    return n.computeNormal(r, o, s, e);
                  });
                var c = new r();
                n.prototype.clipAgainstHull = function (
                  t,
                  e,
                  n,
                  i,
                  o,
                  s,
                  a,
                  l,
                  u
                ) {
                  for (
                    var h = c, d = -1, p = -Number.MAX_VALUE, f = 0;
                    f < n.faces.length;
                    f++
                  ) {
                    h.copy(n.faceNormals[f]), o.vmult(h, h);
                    var m = h.dot(s);
                    m > p && ((p = m), (d = f));
                  }
                  for (
                    var g = [], v = n.faces[d], y = v.length, x = 0;
                    y > x;
                    x++
                  ) {
                    var b = n.vertices[v[x]],
                      w = new r();
                    w.copy(b), o.vmult(w, w), i.vadd(w, w), g.push(w);
                  }
                  d >= 0 && this.clipFaceAgainstHull(s, t, e, g, a, l, u);
                };
                var u = new r(),
                  h = new r(),
                  d = new r(),
                  p = new r(),
                  f = new r(),
                  m = new r();
                n.prototype.findSeparatingAxis = function (
                  t,
                  e,
                  n,
                  i,
                  r,
                  o,
                  s,
                  a
                ) {
                  var l = u,
                    c = h,
                    g = d,
                    v = p,
                    y = f,
                    x = m,
                    b = Number.MAX_VALUE,
                    w = this;
                  if (w.uniqueAxes)
                    for (var _ = 0; _ !== w.uniqueAxes.length; _++) {
                      if (
                        (n.vmult(w.uniqueAxes[_], l),
                        !1 === (T = w.testSepAxis(l, t, e, n, i, r)))
                      )
                        return !1;
                      b > T && ((b = T), o.copy(l));
                    }
                  else {
                    var M = s ? s.length : w.faces.length;
                    for (_ = 0; M > _; _++) {
                      var S = s ? s[_] : _;
                      if (
                        (l.copy(w.faceNormals[S]),
                        n.vmult(l, l),
                        !1 === (T = w.testSepAxis(l, t, e, n, i, r)))
                      )
                        return !1;
                      b > T && ((b = T), o.copy(l));
                    }
                  }
                  if (t.uniqueAxes)
                    for (_ = 0; _ !== t.uniqueAxes.length; _++) {
                      if (
                        (r.vmult(t.uniqueAxes[_], c),
                        !1 === (T = w.testSepAxis(c, t, e, n, i, r)))
                      )
                        return !1;
                      b > T && ((b = T), o.copy(c));
                    }
                  else {
                    var E = a ? a.length : t.faces.length;
                    for (_ = 0; E > _; _++) {
                      var T;
                      if (
                        ((S = a ? a[_] : _),
                        c.copy(t.faceNormals[S]),
                        r.vmult(c, c),
                        !1 === (T = w.testSepAxis(c, t, e, n, i, r)))
                      )
                        return !1;
                      b > T && ((b = T), o.copy(c));
                    }
                  }
                  for (var A = 0; A !== w.uniqueEdges.length; A++) {
                    n.vmult(w.uniqueEdges[A], v);
                    for (var C = 0; C !== t.uniqueEdges.length; C++)
                      if (
                        (r.vmult(t.uniqueEdges[C], y),
                        v.cross(y, x),
                        !x.almostZero())
                      ) {
                        x.normalize();
                        var L = w.testSepAxis(x, t, e, n, i, r);
                        if (!1 === L) return !1;
                        b > L && ((b = L), o.copy(x));
                      }
                  }
                  return i.vsub(e, g), g.dot(o) > 0 && o.negate(o), !0;
                };
                var g = [],
                  v = [];
                n.prototype.testSepAxis = function (t, e, i, r, o, s) {
                  n.project(this, t, i, r, g), n.project(e, t, o, s, v);
                  var a = g[0],
                    l = g[1],
                    c = v[0],
                    u = v[1];
                  if (u > a || l > c) return !1;
                  var h = a - u,
                    d = c - l;
                  return d > h ? h : d;
                };
                var y = new r(),
                  x = new r();
                (n.prototype.calculateLocalInertia = function (t, e) {
                  this.computeLocalAABB(y, x);
                  var n = x.x - y.x,
                    i = x.y - y.y,
                    r = x.z - y.z;
                  (e.x = (1 / 12) * t * (2 * i * 2 * i + 2 * r * 2 * r)),
                    (e.y = (1 / 12) * t * (2 * n * 2 * n + 2 * r * 2 * r)),
                    (e.z = (1 / 12) * t * (2 * i * 2 * i + 2 * n * 2 * n));
                }),
                  (n.prototype.getPlaneConstantOfFace = function (t) {
                    var e = this.faces[t],
                      n = this.faceNormals[t],
                      i = this.vertices[e[0]];
                    return -n.dot(i);
                  });
                var b = new r(),
                  w = new r(),
                  _ = new r(),
                  M = new r(),
                  S = new r(),
                  E = new r(),
                  T = new r(),
                  A = new r();
                (n.prototype.clipFaceAgainstHull = function (
                  t,
                  e,
                  n,
                  i,
                  r,
                  o,
                  s
                ) {
                  for (
                    var a = b,
                      l = w,
                      c = _,
                      u = M,
                      h = S,
                      d = E,
                      p = T,
                      f = A,
                      m = this,
                      g = i,
                      v = [],
                      y = -1,
                      x = Number.MAX_VALUE,
                      C = 0;
                    C < m.faces.length;
                    C++
                  ) {
                    a.copy(m.faceNormals[C]), n.vmult(a, a);
                    var L = a.dot(t);
                    x > L && ((x = L), (y = C));
                  }
                  if (!(0 > y)) {
                    var R = m.faces[y];
                    R.connectedFaces = [];
                    for (var P = 0; P < m.faces.length; P++)
                      for (var N = 0; N < m.faces[P].length; N++)
                        -1 !== R.indexOf(m.faces[P][N]) &&
                          P !== y &&
                          -1 === R.connectedFaces.indexOf(P) &&
                          R.connectedFaces.push(P);
                    for (var I = (g.length, R.length), B = 0; I > B; B++) {
                      var O = m.vertices[R[B]],
                        D = m.vertices[R[(B + 1) % I]];
                      O.vsub(D, l),
                        c.copy(l),
                        n.vmult(c, c),
                        e.vadd(c, c),
                        u.copy(this.faceNormals[y]),
                        n.vmult(u, u),
                        e.vadd(u, u),
                        c.cross(u, h),
                        h.negate(h),
                        d.copy(O),
                        n.vmult(d, d),
                        e.vadd(d, d);
                      var k = (d.dot(h), R.connectedFaces[B]);
                      p.copy(this.faceNormals[k]);
                      var F = this.getPlaneConstantOfFace(k);
                      f.copy(p), n.vmult(f, f);
                      var z = F - f.dot(e);
                      for (this.clipFaceAgainstPlane(g, v, f, z); g.length; )
                        g.shift();
                      for (; v.length; ) g.push(v.shift());
                    }
                    for (
                      p.copy(this.faceNormals[y]),
                        F = this.getPlaneConstantOfFace(y),
                        f.copy(p),
                        n.vmult(f, f),
                        z = F - f.dot(e),
                        P = 0;
                      P < g.length;
                      P++
                    ) {
                      var H = f.dot(g[P]) + z;
                      if (
                        (r >= H &&
                          (console.log(
                            "clamped: depth=" + H + " to minDist=" + r
                          ),
                          (H = r)),
                        o >= H)
                      ) {
                        var U = g[P];
                        if (0 >= H) {
                          var V = { point: U, normal: f, depth: H };
                          s.push(V);
                        }
                      }
                    }
                  }
                }),
                  (n.prototype.clipFaceAgainstPlane = function (t, e, n, i) {
                    var o,
                      s,
                      a = t.length;
                    if (2 > a) return e;
                    var l = t[t.length - 1],
                      c = t[0];
                    o = n.dot(l) + i;
                    for (var u = 0; a > u; u++) {
                      if (((c = t[u]), (s = n.dot(c) + i), 0 > o))
                        if (0 > s) (h = new r()).copy(c), e.push(h);
                        else {
                          var h = new r();
                          l.lerp(c, o / (o - s), h), e.push(h);
                        }
                      else
                        0 > s &&
                          ((h = new r()),
                          l.lerp(c, o / (o - s), h),
                          e.push(h),
                          e.push(c));
                      (l = c), (o = s);
                    }
                    return e;
                  }),
                  (n.prototype.computeWorldVertices = function (t, e) {
                    for (
                      var n = this.vertices.length;
                      this.worldVertices.length < n;

                    )
                      this.worldVertices.push(new r());
                    for (
                      var i = this.vertices, o = this.worldVertices, s = 0;
                      s !== n;
                      s++
                    )
                      e.vmult(i[s], o[s]), t.vadd(o[s], o[s]);
                    this.worldVerticesNeedsUpdate = !1;
                  }),
                  new r(),
                  (n.prototype.computeLocalAABB = function (t, e) {
                    var n = this.vertices.length,
                      i = this.vertices;
                    t.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
                      e.set(
                        -Number.MAX_VALUE,
                        -Number.MAX_VALUE,
                        -Number.MAX_VALUE
                      );
                    for (var r = 0; n > r; r++) {
                      var o = i[r];
                      o.x < t.x ? (t.x = o.x) : o.x > e.x && (e.x = o.x),
                        o.y < t.y ? (t.y = o.y) : o.y > e.y && (e.y = o.y),
                        o.z < t.z ? (t.z = o.z) : o.z > e.z && (e.z = o.z);
                    }
                  }),
                  (n.prototype.computeWorldFaceNormals = function (t) {
                    for (
                      var e = this.faceNormals.length;
                      this.worldFaceNormals.length < e;

                    )
                      this.worldFaceNormals.push(new r());
                    for (
                      var n = this.faceNormals,
                        i = this.worldFaceNormals,
                        o = 0;
                      o !== e;
                      o++
                    )
                      t.vmult(n[o], i[o]);
                    this.worldFaceNormalsNeedsUpdate = !1;
                  }),
                  (n.prototype.updateBoundingSphereRadius = function () {
                    for (
                      var t = 0, e = this.vertices, n = 0, i = e.length;
                      n !== i;
                      n++
                    ) {
                      var r = e[n].norm2();
                      r > t && (t = r);
                    }
                    this.boundingSphereRadius = Math.sqrt(t);
                  });
                var C = new r();
                (n.prototype.calculateWorldAABB = function (t, e, n, i) {
                  for (
                    var r,
                      o,
                      s,
                      a,
                      l,
                      c,
                      u = this.vertices.length,
                      h = this.vertices,
                      d = 0;
                    u > d;
                    d++
                  ) {
                    C.copy(h[d]), e.vmult(C, C), t.vadd(C, C);
                    var p = C;
                    p.x < r || void 0 === r
                      ? (r = p.x)
                      : (p.x > a || void 0 === a) && (a = p.x),
                      p.y < o || void 0 === o
                        ? (o = p.y)
                        : (p.y > l || void 0 === l) && (l = p.y),
                      p.z < s || void 0 === s
                        ? (s = p.z)
                        : (p.z > c || void 0 === c) && (c = p.z);
                  }
                  n.set(r, o, s), i.set(a, l, c);
                }),
                  (n.prototype.volume = function () {
                    return (4 * Math.PI * this.boundingSphereRadius) / 3;
                  }),
                  (n.prototype.getAveragePointLocal = function (t) {
                    t = t || new r();
                    for (
                      var e = this.vertices.length, n = this.vertices, i = 0;
                      e > i;
                      i++
                    )
                      t.vadd(n[i], t);
                    return t.mult(1 / e, t), t;
                  }),
                  (n.prototype.transformAllPoints = function (t, e) {
                    var n = this.vertices.length,
                      i = this.vertices;
                    if (e) {
                      for (var r = 0; n > r; r++) {
                        var o = i[r];
                        e.vmult(o, o);
                      }
                      for (r = 0; r < this.faceNormals.length; r++)
                        (o = this.faceNormals[r]), e.vmult(o, o);
                    }
                    if (t) for (r = 0; n > r; r++) (o = i[r]).vadd(t, o);
                  });
                var L = new r(),
                  R = new r(),
                  P = new r();
                n.prototype.pointIsInside = function (t) {
                  var e = this.vertices.length,
                    n = this.vertices,
                    i = this.faces,
                    r = this.faceNormals,
                    o = this.faces.length,
                    s = L;
                  this.getAveragePointLocal(s);
                  for (var a = 0; o > a; a++) {
                    this.faces[a].length, (e = r[a]);
                    var l = n[i[a][0]],
                      c = R;
                    t.vsub(l, c);
                    var u = e.dot(c),
                      h = P;
                    s.vsub(l, h);
                    var d = e.dot(h);
                    if ((0 > u && d > 0) || (u > 0 && 0 > d)) return !1;
                  }
                  return -1;
                };
                var N = (new r(), new r()),
                  I = new r();
                n.project = function (t, e, n, i, r) {
                  var s = t.vertices.length,
                    a = N,
                    l = 0,
                    c = 0,
                    u = I,
                    h = t.vertices;
                  u.setZero(),
                    o.vectorToLocalFrame(n, i, e, a),
                    o.pointToLocalFrame(n, i, u, u);
                  var d = u.dot(a);
                  c = l = h[0].dot(a);
                  for (var p = 1; s > p; p++) {
                    var f = h[p].dot(a);
                    f > l && (l = f), c > f && (c = f);
                  }
                  if ((c -= d) > (l -= d)) {
                    var m = c;
                    (c = l), (l = m);
                  }
                  (r[0] = l), (r[1] = c);
                };
              },
              {
                "../math/Quaternion": 28,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "./Shape": 43,
              },
            ],
            39: [
              function (t, e) {
                function n(t, e, n, s) {
                  var a = s,
                    l = [],
                    c = [],
                    u = [],
                    h = [],
                    d = [],
                    p = Math.cos,
                    f = Math.sin;
                  l.push(new r(e * p(0), e * f(0), 0.5 * -n)),
                    h.push(0),
                    l.push(new r(t * p(0), t * f(0), 0.5 * n)),
                    d.push(1);
                  for (var m = 0; a > m; m++) {
                    var g = ((2 * Math.PI) / a) * (m + 1),
                      v = ((2 * Math.PI) / a) * (m + 0.5);
                    a - 1 > m
                      ? (l.push(new r(e * p(g), e * f(g), 0.5 * -n)),
                        h.push(2 * m + 2),
                        l.push(new r(t * p(g), t * f(g), 0.5 * n)),
                        d.push(2 * m + 3),
                        u.push([2 * m + 2, 2 * m + 3, 2 * m + 1, 2 * m]))
                      : u.push([0, 1, 2 * m + 1, 2 * m]),
                      (a % 2 == 1 || a / 2 > m) && c.push(new r(p(v), f(v), 0));
                  }
                  u.push(d), c.push(new r(0, 0, 1));
                  var y = [];
                  for (m = 0; m < h.length; m++) y.push(h[h.length - m - 1]);
                  u.push(y),
                    (this.type = i.types.CONVEXPOLYHEDRON),
                    o.call(this, l, u, c);
                }
                e.exports = n;
                var i = t("./Shape"),
                  r = t("../math/Vec3"),
                  o = (t("../math/Quaternion"), t("./ConvexPolyhedron"));
                n.prototype = new o();
              },
              {
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "./ConvexPolyhedron": 38,
                "./Shape": 43,
              },
            ],
            40: [
              function (t, e) {
                function n(t, e) {
                  (e = s.defaults(e, {
                    maxValue: null,
                    minValue: null,
                    elementSize: 1,
                  })),
                    (this.data = t),
                    (this.maxValue = e.maxValue),
                    (this.minValue = e.minValue),
                    (this.elementSize = e.elementSize),
                    null === e.minValue && this.updateMinValue(),
                    null === e.maxValue && this.updateMaxValue(),
                    (this.cacheEnabled = !0),
                    i.call(this),
                    (this.pillarConvex = new r()),
                    (this.pillarOffset = new o()),
                    (this.type = i.types.HEIGHTFIELD),
                    this.updateBoundingSphereRadius(),
                    (this._cachedPillars = {});
                }
                var i = t("./Shape"),
                  r = t("./ConvexPolyhedron"),
                  o = t("../math/Vec3"),
                  s = t("../utils/Utils");
                (e.exports = n),
                  (n.prototype = new i()),
                  (n.prototype.update = function () {
                    this._cachedPillars = {};
                  }),
                  (n.prototype.updateMinValue = function () {
                    for (
                      var t = this.data, e = t[0][0], n = 0;
                      n !== t.length;
                      n++
                    )
                      for (var i = 0; i !== t[n].length; i++) {
                        var r = t[n][i];
                        e > r && (e = r);
                      }
                    this.minValue = e;
                  }),
                  (n.prototype.updateMaxValue = function () {
                    for (
                      var t = this.data, e = t[0][0], n = 0;
                      n !== t.length;
                      n++
                    )
                      for (var i = 0; i !== t[n].length; i++) {
                        var r = t[n][i];
                        r > e && (e = r);
                      }
                    this.maxValue = e;
                  }),
                  (n.prototype.setHeightValueAtIndex = function (t, e, n) {
                    (this.data[t][e] = n),
                      this.clearCachedConvexTrianglePillar(t, e, !1),
                      t > 0 &&
                        (this.clearCachedConvexTrianglePillar(t - 1, e, !0),
                        this.clearCachedConvexTrianglePillar(t - 1, e, !1)),
                      e > 0 &&
                        (this.clearCachedConvexTrianglePillar(t, e - 1, !0),
                        this.clearCachedConvexTrianglePillar(t, e - 1, !1)),
                      e > 0 &&
                        t > 0 &&
                        this.clearCachedConvexTrianglePillar(t - 1, e - 1, !0);
                  }),
                  (n.prototype.getRectMinMax = function (t, e, n, i, r) {
                    r = r || [];
                    for (
                      var o = this.data, s = this.minValue, a = t;
                      n >= a;
                      a++
                    )
                      for (var l = e; i >= l; l++) {
                        var c = o[a][l];
                        c > s && (s = c);
                      }
                    (r[0] = this.minValue), (r[1] = s);
                  }),
                  (n.prototype.getIndexOfPosition = function (t, e, n, i) {
                    var r = this.elementSize,
                      o = this.data,
                      s = Math.floor(t / r),
                      a = Math.floor(e / r);
                    return (
                      (n[0] = s),
                      (n[1] = a),
                      i &&
                        (0 > s && (s = 0),
                        0 > a && (a = 0),
                        s >= o.length - 1 && (s = o.length - 1),
                        a >= o[0].length - 1 && (a = o[0].length - 1)),
                      !(
                        0 > s ||
                        0 > a ||
                        s >= o.length - 1 ||
                        a >= o[0].length - 1
                      )
                    );
                  }),
                  (n.prototype.getHeightAt = function (t, e, n) {
                    var i = [];
                    this.getIndexOfPosition(t, e, i, n);
                    var r = [];
                    return (
                      this.getRectMinMax(i[0], i[1] + 1, i[0], i[1] + 1, r),
                      (r[0] + r[1]) / 2
                    );
                  }),
                  (n.prototype.getCacheConvexTrianglePillarKey = function (
                    t,
                    e,
                    n
                  ) {
                    return t + "_" + e + "_" + (n ? 1 : 0);
                  }),
                  (n.prototype.getCachedConvexTrianglePillar = function (
                    t,
                    e,
                    n
                  ) {
                    return this._cachedPillars[
                      this.getCacheConvexTrianglePillarKey(t, e, n)
                    ];
                  }),
                  (n.prototype.setCachedConvexTrianglePillar = function (
                    t,
                    e,
                    n,
                    i,
                    r
                  ) {
                    this._cachedPillars[
                      this.getCacheConvexTrianglePillarKey(t, e, n)
                    ] = { convex: i, offset: r };
                  }),
                  (n.prototype.clearCachedConvexTrianglePillar = function (
                    t,
                    e,
                    n
                  ) {
                    delete this._cachedPillars[
                      this.getCacheConvexTrianglePillarKey(t, e, n)
                    ];
                  }),
                  (n.prototype.getConvexTrianglePillar = function (t, e, n) {
                    var i = this.pillarConvex,
                      s = this.pillarOffset;
                    if (this.cacheEnabled) {
                      if ((a = this.getCachedConvexTrianglePillar(t, e, n)))
                        return (
                          (this.pillarConvex = a.convex),
                          void (this.pillarOffset = a.offset)
                        );
                      (i = new r()),
                        (s = new o()),
                        (this.pillarConvex = i),
                        (this.pillarOffset = s);
                    }
                    var a = this.data,
                      l = this.elementSize,
                      c = i.faces;
                    i.vertices.length = 6;
                    for (var u = 0; 6 > u; u++)
                      i.vertices[u] || (i.vertices[u] = new o());
                    for (c.length = 5, u = 0; 5 > u; u++) c[u] || (c[u] = []);
                    var h = i.vertices,
                      d =
                        (Math.min(
                          a[t][e],
                          a[t + 1][e],
                          a[t][e + 1],
                          a[t + 1][e + 1]
                        ) -
                          this.minValue) /
                          2 +
                        this.minValue;
                    n
                      ? (s.set((t + 0.75) * l, (e + 0.75) * l, d),
                        h[0].set(0.25 * l, 0.25 * l, a[t + 1][e + 1] - d),
                        h[1].set(-0.75 * l, 0.25 * l, a[t][e + 1] - d),
                        h[2].set(0.25 * l, -0.75 * l, a[t + 1][e] - d),
                        h[3].set(0.25 * l, 0.25 * l, -d - 1),
                        h[4].set(-0.75 * l, 0.25 * l, -d - 1),
                        h[5].set(0.25 * l, -0.75 * l, -d - 1),
                        (c[0][0] = 0),
                        (c[0][1] = 1),
                        (c[0][2] = 2),
                        (c[1][0] = 5),
                        (c[1][1] = 4),
                        (c[1][2] = 3),
                        (c[2][0] = 2),
                        (c[2][1] = 5),
                        (c[2][2] = 3),
                        (c[2][3] = 0),
                        (c[3][0] = 3),
                        (c[3][1] = 4),
                        (c[3][2] = 1),
                        (c[3][3] = 0),
                        (c[4][0] = 1),
                        (c[4][1] = 4),
                        (c[4][2] = 5),
                        (c[4][3] = 2))
                      : (s.set((t + 0.25) * l, (e + 0.25) * l, d),
                        h[0].set(-0.25 * l, -0.25 * l, a[t][e] - d),
                        h[1].set(0.75 * l, -0.25 * l, a[t + 1][e] - d),
                        h[2].set(-0.25 * l, 0.75 * l, a[t][e + 1] - d),
                        h[3].set(-0.25 * l, -0.25 * l, -d - 1),
                        h[4].set(0.75 * l, -0.25 * l, -d - 1),
                        h[5].set(-0.25 * l, 0.75 * l, -d - 1),
                        (c[0][0] = 0),
                        (c[0][1] = 1),
                        (c[0][2] = 2),
                        (c[1][0] = 5),
                        (c[1][1] = 4),
                        (c[1][2] = 3),
                        (c[2][0] = 0),
                        (c[2][1] = 2),
                        (c[2][2] = 5),
                        (c[2][3] = 3),
                        (c[3][0] = 1),
                        (c[3][1] = 0),
                        (c[3][2] = 3),
                        (c[3][3] = 4),
                        (c[4][0] = 4),
                        (c[4][1] = 5),
                        (c[4][2] = 2),
                        (c[4][3] = 1)),
                      i.computeNormals(),
                      i.computeEdges(),
                      i.updateBoundingSphereRadius(),
                      this.setCachedConvexTrianglePillar(t, e, n, i, s);
                  }),
                  (n.prototype.calculateLocalInertia = function (t, e) {
                    return (e = e || new o()).set(0, 0, 0), e;
                  }),
                  (n.prototype.volume = function () {
                    return Number.MAX_VALUE;
                  }),
                  (n.prototype.calculateWorldAABB = function (t, e, n, i) {
                    n.set(
                      -Number.MAX_VALUE,
                      -Number.MAX_VALUE,
                      -Number.MAX_VALUE
                    ),
                      i.set(
                        Number.MAX_VALUE,
                        Number.MAX_VALUE,
                        Number.MAX_VALUE
                      );
                  }),
                  (n.prototype.updateBoundingSphereRadius = function () {
                    var t = this.data,
                      e = this.elementSize;
                    this.boundingSphereRadius = new o(
                      t.length * e,
                      t[0].length * e,
                      Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))
                    ).norm();
                  });
              },
              {
                "../math/Vec3": 30,
                "../utils/Utils": 53,
                "./ConvexPolyhedron": 38,
                "./Shape": 43,
              },
            ],
            41: [
              function (t, e) {
                function n() {
                  i.call(this), (this.type = i.types.PARTICLE);
                }
                e.exports = n;
                var i = t("./Shape"),
                  r = t("../math/Vec3");
                (n.prototype = new i()),
                  (n.prototype.constructor = n),
                  (n.prototype.calculateLocalInertia = function (t, e) {
                    return (e = e || new r()).set(0, 0, 0), e;
                  }),
                  (n.prototype.volume = function () {
                    return 0;
                  }),
                  (n.prototype.updateBoundingSphereRadius = function () {
                    this.boundingSphereRadius = 0;
                  }),
                  (n.prototype.calculateWorldAABB = function (t, e, n, i) {
                    n.copy(t), i.copy(t);
                  });
              },
              { "../math/Vec3": 30, "./Shape": 43 },
            ],
            42: [
              function (t, e) {
                function n() {
                  i.call(this),
                    (this.type = i.types.PLANE),
                    (this.worldNormal = new r()),
                    (this.worldNormalNeedsUpdate = !0),
                    (this.boundingSphereRadius = Number.MAX_VALUE);
                }
                e.exports = n;
                var i = t("./Shape"),
                  r = t("../math/Vec3");
                (n.prototype = new i()),
                  (n.prototype.constructor = n),
                  (n.prototype.computeWorldNormal = function (t) {
                    var e = this.worldNormal;
                    e.set(0, 0, 1),
                      t.vmult(e, e),
                      (this.worldNormalNeedsUpdate = !1);
                  }),
                  (n.prototype.calculateLocalInertia = function (t, e) {
                    return e || new r();
                  }),
                  (n.prototype.volume = function () {
                    return Number.MAX_VALUE;
                  });
                var o = new r();
                (n.prototype.calculateWorldAABB = function (t, e, n, i) {
                  o.set(0, 0, 1), e.vmult(o, o);
                  var r = Number.MAX_VALUE;
                  n.set(-r, -r, -r),
                    i.set(r, r, r),
                    1 === o.x && (i.x = t.x),
                    1 === o.y && (i.y = t.y),
                    1 === o.z && (i.z = t.z),
                    -1 === o.x && (n.x = t.x),
                    -1 === o.y && (n.y = t.y),
                    -1 === o.z && (n.z = t.z);
                }),
                  (n.prototype.updateBoundingSphereRadius = function () {
                    this.boundingSphereRadius = Number.MAX_VALUE;
                  });
              },
              { "../math/Vec3": 30, "./Shape": 43 },
            ],
            43: [
              function (t, e) {
                function n() {
                  (this.id = n.idCounter++),
                    (this.type = 0),
                    (this.boundingSphereRadius = 0),
                    (this.collisionResponse = !0),
                    (this.material = null);
                }
                e.exports = n;
                var n = t("./Shape");
                t("../math/Vec3"),
                  t("../math/Quaternion"),
                  t("../material/Material"),
                  (n.prototype.constructor = n),
                  (n.prototype.updateBoundingSphereRadius = function () {
                    throw (
                      "computeBoundingSphereRadius() not implemented for shape type " +
                      this.type
                    );
                  }),
                  (n.prototype.volume = function () {
                    throw (
                      "volume() not implemented for shape type " + this.type
                    );
                  }),
                  (n.prototype.calculateLocalInertia = function () {
                    throw (
                      "calculateLocalInertia() not implemented for shape type " +
                      this.type
                    );
                  }),
                  (n.idCounter = 0),
                  (n.types = {
                    SPHERE: 1,
                    PLANE: 2,
                    BOX: 4,
                    COMPOUND: 8,
                    CONVEXPOLYHEDRON: 16,
                    HEIGHTFIELD: 32,
                    PARTICLE: 64,
                    CYLINDER: 128,
                    TRIMESH: 256,
                  });
              },
              {
                "../material/Material": 25,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "./Shape": 43,
              },
            ],
            44: [
              function (t, e) {
                function n(t) {
                  if (
                    (i.call(this),
                    (this.radius = void 0 !== t ? Number(t) : 1),
                    (this.type = i.types.SPHERE),
                    this.radius < 0)
                  )
                    throw new Error("The sphere radius cannot be negative.");
                  this.updateBoundingSphereRadius();
                }
                e.exports = n;
                var i = t("./Shape"),
                  r = t("../math/Vec3");
                (n.prototype = new i()),
                  (n.prototype.constructor = n),
                  (n.prototype.calculateLocalInertia = function (t, e) {
                    e = e || new r();
                    var n = (2 * t * this.radius * this.radius) / 5;
                    return (e.x = n), (e.y = n), (e.z = n), e;
                  }),
                  (n.prototype.volume = function () {
                    return (4 * Math.PI * this.radius) / 3;
                  }),
                  (n.prototype.updateBoundingSphereRadius = function () {
                    this.boundingSphereRadius = this.radius;
                  }),
                  (n.prototype.calculateWorldAABB = function (t, e, n, i) {
                    for (
                      var r = this.radius, o = ["x", "y", "z"], s = 0;
                      s < o.length;
                      s++
                    ) {
                      var a = o[s];
                      (n[a] = t[a] - r), (i[a] = t[a] + r);
                    }
                  });
              },
              { "../math/Vec3": 30, "./Shape": 43 },
            ],
            45: [
              function (t, e) {
                function n(t, e) {
                  i.call(this),
                    (this.type = i.types.TRIMESH),
                    (this.vertices = new Float32Array(t)),
                    (this.indices = new Int16Array(e)),
                    (this.normals = new Float32Array(e.length)),
                    (this.aabb = new s()),
                    (this.edges = null),
                    (this.scale = new r(1, 1, 1)),
                    (this.tree = new a()),
                    this.updateEdges(),
                    this.updateNormals(),
                    this.updateAABB(),
                    this.updateBoundingSphereRadius(),
                    this.updateTree();
                }
                e.exports = n;
                var i = t("./Shape"),
                  r = t("../math/Vec3"),
                  o = (t("../math/Quaternion"), t("../math/Transform")),
                  s = t("../collision/AABB"),
                  a = t("../utils/Octree");
                (n.prototype = new i()), (n.prototype.constructor = n);
                var l = new r();
                n.prototype.updateTree = function () {
                  var t = this.tree;
                  t.reset(), t.aabb.copy(this.aabb);
                  var e = this.scale;
                  (t.aabb.lowerBound.x *= 1 / e.x),
                    (t.aabb.lowerBound.y *= 1 / e.y),
                    (t.aabb.lowerBound.z *= 1 / e.z),
                    (t.aabb.upperBound.x *= 1 / e.x),
                    (t.aabb.upperBound.y *= 1 / e.y),
                    (t.aabb.upperBound.z *= 1 / e.z);
                  for (
                    var n = new s(),
                      i = new r(),
                      o = new r(),
                      a = new r(),
                      l = [i, o, a],
                      c = 0;
                    c < this.indices.length / 3;
                    c++
                  ) {
                    var u = 3 * c;
                    this._getUnscaledVertex(this.indices[u], i),
                      this._getUnscaledVertex(this.indices[u + 1], o),
                      this._getUnscaledVertex(this.indices[u + 2], a),
                      n.setFromPoints(l),
                      t.insert(n, c);
                  }
                  t.removeEmptyNodes();
                };
                var c = new s();
                (n.prototype.getTrianglesInAABB = function (t, e) {
                  c.copy(t);
                  var n = this.scale,
                    i = n.x,
                    r = n.y,
                    o = n.z,
                    s = c.lowerBound,
                    a = c.upperBound;
                  return (
                    (s.x /= i),
                    (s.y /= r),
                    (s.z /= o),
                    (a.x /= i),
                    (a.y /= r),
                    (a.z /= o),
                    this.tree.aabbQuery(c, e)
                  );
                }),
                  (n.prototype.setScale = function (t) {
                    var e = (this.scale.x === this.scale.y) === this.scale.z,
                      n = (t.x === t.y) === t.z;
                    (e && n) || this.updateNormals(),
                      this.scale.copy(t),
                      this.updateAABB(),
                      this.updateBoundingSphereRadius();
                  }),
                  (n.prototype.updateNormals = function () {
                    for (
                      var t = l, e = this.normals, i = 0;
                      i < this.indices.length / 3;
                      i++
                    ) {
                      var r = 3 * i,
                        o = this.indices[r],
                        s = this.indices[r + 1],
                        a = this.indices[r + 2];
                      this.getVertex(o, f),
                        this.getVertex(s, m),
                        this.getVertex(a, g),
                        n.computeNormal(m, f, g, t),
                        (e[r] = t.x),
                        (e[r + 1] = t.y),
                        (e[r + 2] = t.z);
                    }
                  }),
                  (n.prototype.updateEdges = function () {
                    for (
                      var t = {},
                        e = function () {
                          t[o > r ? r + "_" + o : o + "_" + r] = !0;
                        },
                        n = 0;
                      n < this.indices.length / 3;
                      n++
                    ) {
                      var i = 3 * n,
                        r = this.indices[i],
                        o = this.indices[i + 1];
                      this.indices[i + 2];
                      e(), e(), e();
                    }
                    var s = Object.keys(t);
                    for (
                      this.edges = new Int16Array(2 * s.length), n = 0;
                      n < s.length;
                      n++
                    ) {
                      var a = s[n].split("_");
                      (this.edges[2 * n] = parseInt(a[0], 10)),
                        (this.edges[2 * n + 1] = parseInt(a[1], 10));
                    }
                  }),
                  (n.prototype.getEdgeVertex = function (t, e, n) {
                    var i = this.edges[2 * t + (e ? 1 : 0)];
                    this.getVertex(i, n);
                  });
                var u = new r(),
                  h = new r();
                n.prototype.getEdgeVector = function (t, e) {
                  var n = u,
                    i = h;
                  this.getEdgeVertex(t, 0, n),
                    this.getEdgeVertex(t, 1, i),
                    i.vsub(n, e);
                };
                var d = new r(),
                  p = new r();
                n.computeNormal = function (t, e, n, i) {
                  e.vsub(t, p),
                    n.vsub(e, d),
                    d.cross(p, i),
                    i.isZero() || i.normalize();
                };
                var f = new r(),
                  m = new r(),
                  g = new r();
                (n.prototype.getVertex = function (t, e) {
                  var n = this.scale;
                  return (
                    this._getUnscaledVertex(t, e),
                    (e.x *= n.x),
                    (e.y *= n.y),
                    (e.z *= n.z),
                    e
                  );
                }),
                  (n.prototype._getUnscaledVertex = function (t, e) {
                    var n = 3 * t,
                      i = this.vertices;
                    return e.set(i[n], i[n + 1], i[n + 2]);
                  }),
                  (n.prototype.getWorldVertex = function (t, e, n, i) {
                    return (
                      this.getVertex(t, i), o.pointToWorldFrame(e, n, i, i), i
                    );
                  }),
                  (n.prototype.getTriangleVertices = function (t, e, n, i) {
                    var r = 3 * t;
                    this.getVertex(this.indices[r], e),
                      this.getVertex(this.indices[r + 1], n),
                      this.getVertex(this.indices[r + 2], i);
                  }),
                  (n.prototype.getNormal = function (t, e) {
                    var n = 3 * t;
                    return e.set(
                      this.normals[n],
                      this.normals[n + 1],
                      this.normals[n + 2]
                    );
                  });
                var v = new s();
                n.prototype.calculateLocalInertia = function (t, e) {
                  this.computeLocalAABB(v);
                  var n = v.upperBound.x - v.lowerBound.x,
                    i = v.upperBound.y - v.lowerBound.y,
                    r = v.upperBound.z - v.lowerBound.z;
                  return e.set(
                    (1 / 12) * t * (2 * i * 2 * i + 2 * r * 2 * r),
                    (1 / 12) * t * (2 * n * 2 * n + 2 * r * 2 * r),
                    (1 / 12) * t * (2 * i * 2 * i + 2 * n * 2 * n)
                  );
                };
                var y = new r();
                (n.prototype.computeLocalAABB = function (t) {
                  var e = t.lowerBound,
                    n = t.upperBound,
                    i = this.vertices.length,
                    r = (this.vertices, y);
                  this.getVertex(0, r), e.copy(r), n.copy(r);
                  for (var o = 0; o !== i; o++)
                    this.getVertex(o, r),
                      r.x < e.x ? (e.x = r.x) : r.x > n.x && (n.x = r.x),
                      r.y < e.y ? (e.y = r.y) : r.y > n.y && (n.y = r.y),
                      r.z < e.z ? (e.z = r.z) : r.z > n.z && (n.z = r.z);
                }),
                  (n.prototype.updateAABB = function () {
                    this.computeLocalAABB(this.aabb);
                  }),
                  (n.prototype.updateBoundingSphereRadius = function () {
                    for (
                      var t = 0,
                        e = this.vertices,
                        n = new r(),
                        i = 0,
                        o = e.length / 3;
                      i !== o;
                      i++
                    ) {
                      this.getVertex(i, n);
                      var s = n.norm2();
                      s > t && (t = s);
                    }
                    this.boundingSphereRadius = Math.sqrt(t);
                  });
                var x = (new r(), new o()),
                  b = new s();
                (n.prototype.calculateWorldAABB = function (t, e, n, i) {
                  var r = x,
                    o = b;
                  (r.position = t),
                    (r.quaternion = e),
                    this.aabb.toWorldFrame(r, o),
                    n.copy(o.lowerBound),
                    i.copy(o.upperBound);
                }),
                  (n.prototype.volume = function () {
                    return (4 * Math.PI * this.boundingSphereRadius) / 3;
                  }),
                  (n.createTorus = function (t, e, i, r, o) {
                    (t = t || 1),
                      (e = e || 0.5),
                      (i = i || 8),
                      (r = r || 6),
                      (o = o || 2 * Math.PI);
                    for (var s = [], a = [], l = 0; i >= l; l++)
                      for (var c = 0; r >= c; c++) {
                        var u = (c / r) * o,
                          h = (l / i) * Math.PI * 2,
                          d = (t + e * Math.cos(h)) * Math.cos(u),
                          p = (t + e * Math.cos(h)) * Math.sin(u),
                          f = e * Math.sin(h);
                        s.push(d, p, f);
                      }
                    for (l = 1; i >= l; l++)
                      for (c = 1; r >= c; c++) {
                        var m = (r + 1) * l + c - 1,
                          g = (r + 1) * (l - 1) + c - 1,
                          v = (r + 1) * (l - 1) + c,
                          y = (r + 1) * l + c;
                        a.push(m, g, y), a.push(g, v, y);
                      }
                    return new n(s, a);
                  });
              },
              {
                "../collision/AABB": 3,
                "../math/Quaternion": 28,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "../utils/Octree": 50,
                "./Shape": 43,
              },
            ],
            46: [
              function (t, e) {
                function n() {
                  i.call(this), (this.iterations = 10), (this.tolerance = 1e-7);
                }
                e.exports = n;
                var i =
                  (t("../math/Vec3"), t("../math/Quaternion"), t("./Solver"));
                n.prototype = new i();
                var r = [],
                  o = [],
                  s = [];
                n.prototype.solve = function (t, e) {
                  var n,
                    i,
                    a,
                    l,
                    c,
                    u = 0,
                    h = this.iterations,
                    d = this.tolerance * this.tolerance,
                    p = this.equations,
                    f = p.length,
                    m = e.bodies,
                    g = m.length,
                    v = t;
                  if (0 !== f)
                    for (var y = 0; y !== g; y++)
                      m[y].updateSolveMassProperties();
                  var x = o,
                    b = s,
                    w = r;
                  for (
                    x.length = f, b.length = f, w.length = f, y = 0;
                    y !== f;
                    y++
                  ) {
                    var _ = p[y];
                    (w[y] = 0),
                      (b[y] = _.computeB(v)),
                      (x[y] = 1 / _.computeC());
                  }
                  if (0 !== f) {
                    for (y = 0; y !== g; y++) {
                      var M = (T = m[y]).vlambda,
                        S = T.wlambda;
                      M.set(0, 0, 0), S && S.set(0, 0, 0);
                    }
                    for (u = 0; u !== h; u++) {
                      l = 0;
                      for (var E = 0; E !== f; E++)
                        (_ = p[E]),
                          (n = b[E]),
                          (i = x[E]),
                          (c = w[E]) +
                            (a = i * (n - _.computeGWlambda() - _.eps * c)) <
                          _.minForce
                            ? (a = _.minForce - c)
                            : c + a > _.maxForce && (a = _.maxForce - c),
                          (w[E] += a),
                          (l += a > 0 ? a : -a),
                          _.addToWlambda(a);
                      if (d > l * l) break;
                    }
                    for (y = 0; y !== g; y++) {
                      var T,
                        A = (T = m[y]).velocity,
                        C = T.angularVelocity;
                      A.vadd(T.vlambda, A), C && C.vadd(T.wlambda, C);
                    }
                  }
                  return u;
                };
              },
              { "../math/Quaternion": 28, "../math/Vec3": 30, "./Solver": 47 },
            ],
            47: [
              function (t, e) {
                function n() {
                  this.equations = [];
                }
                (e.exports = n),
                  (n.prototype.solve = function () {
                    return 0;
                  }),
                  (n.prototype.addEquation = function (t) {
                    t.enabled && this.equations.push(t);
                  }),
                  (n.prototype.removeEquation = function (t) {
                    var e = this.equations,
                      n = e.indexOf(t);
                    -1 !== n && e.splice(n, 1);
                  }),
                  (n.prototype.removeAllEquations = function () {
                    this.equations.length = 0;
                  });
              },
              {},
            ],
            48: [
              function (t, e) {
                function n(t) {
                  for (
                    a.call(this),
                      this.iterations = 10,
                      this.tolerance = 1e-7,
                      this.subsolver = t,
                      this.nodes = [],
                      this.nodePool = [];
                    this.nodePool.length < 128;

                  )
                    this.nodePool.push(this.createNode());
                }
                function i(t) {
                  for (var e = t.length, n = 0; n !== e; n++) {
                    var i = t[n];
                    if (!(i.visited || i.body.type & d)) return i;
                  }
                  return !1;
                }
                function r(t, e, n, r) {
                  for (p.push(t), t.visited = !0, e(t, n, r); p.length; )
                    for (var o, s = p.pop(); (o = i(s.children)); )
                      (o.visited = !0), e(o, n, r), p.push(o);
                }
                function o(t, e, n) {
                  e.push(t.body);
                  for (var i = t.eqs.length, r = 0; r !== i; r++) {
                    var o = t.eqs[r];
                    -1 === n.indexOf(o) && n.push(o);
                  }
                }
                function s(t, e) {
                  return e.id - t.id;
                }
                e.exports = n;
                var a =
                    (t("../math/Vec3"), t("../math/Quaternion"), t("./Solver")),
                  l = t("../objects/Body");
                n.prototype = new a();
                var c = [],
                  u = [],
                  h = { bodies: [] },
                  d = l.STATIC,
                  p = [];
                (n.prototype.createNode = function () {
                  return { body: null, children: [], eqs: [], visited: !1 };
                }),
                  (n.prototype.solve = function (t, e) {
                    for (
                      var n = c,
                        a = this.nodePool,
                        l = e.bodies,
                        d = this.equations,
                        p = d.length,
                        f = l.length,
                        m = this.subsolver;
                      a.length < f;

                    )
                      a.push(this.createNode());
                    n.length = f;
                    for (var g = 0; f > g; g++) n[g] = a[g];
                    for (g = 0; g !== f; g++) {
                      var v = n[g];
                      (v.body = l[g]),
                        (v.children.length = 0),
                        (v.eqs.length = 0),
                        (v.visited = !1);
                    }
                    for (var y = 0; y !== p; y++) {
                      var x = d[y],
                        b = ((g = l.indexOf(x.bi)), l.indexOf(x.bj)),
                        w = n[g],
                        _ = n[b];
                      w.children.push(_),
                        w.eqs.push(x),
                        _.children.push(w),
                        _.eqs.push(x);
                    }
                    var M,
                      S = 0,
                      E = u;
                    (m.tolerance = this.tolerance),
                      (m.iterations = this.iterations);
                    for (var T = h; (M = i(n)); ) {
                      (E.length = 0),
                        (T.bodies.length = 0),
                        r(M, o, T.bodies, E);
                      var A = E.length;
                      for (E = E.sort(s), g = 0; g !== A; g++)
                        m.addEquation(E[g]);
                      m.solve(t, T), m.removeAllEquations(), S++;
                    }
                    return S;
                  });
              },
              {
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/Body": 31,
                "./Solver": 47,
              },
            ],
            49: [
              function (t, e) {
                var n = function () {};
                (e.exports = n),
                  (n.prototype = {
                    constructor: n,
                    addEventListener: function (t, e) {
                      void 0 === this._listeners && (this._listeners = {});
                      var n = this._listeners;
                      return (
                        void 0 === n[t] && (n[t] = []),
                        -1 === n[t].indexOf(e) && n[t].push(e),
                        this
                      );
                    },
                    hasEventListener: function (t, e) {
                      if (void 0 === this._listeners) return !1;
                      var n = this._listeners;
                      return void 0 !== n[t] && -1 !== n[t].indexOf(e);
                    },
                    removeEventListener: function (t, e) {
                      if (void 0 === this._listeners) return this;
                      var n = this._listeners;
                      if (void 0 === n[t]) return this;
                      var i = n[t].indexOf(e);
                      return -1 !== i && n[t].splice(i, 1), this;
                    },
                    dispatchEvent: function (t) {
                      if (void 0 === this._listeners) return this;
                      var e = this._listeners[t.type];
                      if (void 0 !== e) {
                        t.target = this;
                        for (var n = 0, i = e.length; i > n; n++)
                          e[n].call(this, t);
                      }
                      return this;
                    },
                  });
              },
              {},
            ],
            50: [
              function (t, e) {
                function n(t) {
                  (t = t || {}),
                    (this.root = t.root || null),
                    (this.aabb = t.aabb ? t.aabb.clone() : new r()),
                    (this.data = []),
                    (this.children = []);
                }
                function i(t, e) {
                  ((e = e || {}).root = null),
                    (e.aabb = t),
                    n.call(this, e),
                    (this.maxDepth = void 0 !== e.maxDepth ? e.maxDepth : 8);
                }
                var r = t("../collision/AABB"),
                  o = t("../math/Vec3");
                (e.exports = i),
                  (i.prototype = new n()),
                  (n.prototype.reset = function () {
                    this.children.length = this.data.length = 0;
                  }),
                  (n.prototype.insert = function (t, e, n) {
                    var i = this.data;
                    if (((n = n || 0), !this.aabb.contains(t))) return !1;
                    var r = this.children;
                    if (n < (this.maxDepth || this.root.maxDepth)) {
                      var o = !1;
                      r.length || (this.subdivide(), (o = !0));
                      for (var s = 0; 8 !== s; s++)
                        if (r[s].insert(t, e, n + 1)) return !0;
                      o && (r.length = 0);
                    }
                    return i.push(e), !0;
                  });
                var s = new o();
                (n.prototype.subdivide = function () {
                  var t = this.aabb,
                    e = t.lowerBound,
                    i = t.upperBound,
                    a = this.children;
                  a.push(
                    new n({ aabb: new r({ lowerBound: new o(0, 0, 0) }) }),
                    new n({ aabb: new r({ lowerBound: new o(1, 0, 0) }) }),
                    new n({ aabb: new r({ lowerBound: new o(1, 1, 0) }) }),
                    new n({ aabb: new r({ lowerBound: new o(1, 1, 1) }) }),
                    new n({ aabb: new r({ lowerBound: new o(0, 1, 1) }) }),
                    new n({ aabb: new r({ lowerBound: new o(0, 0, 1) }) }),
                    new n({ aabb: new r({ lowerBound: new o(1, 0, 1) }) }),
                    new n({ aabb: new r({ lowerBound: new o(0, 1, 0) }) })
                  ),
                    i.vsub(e, s),
                    s.scale(0.5, s);
                  for (var l = this.root || this, c = 0; 8 !== c; c++) {
                    var u = a[c];
                    u.root = l;
                    var h = u.aabb.lowerBound;
                    (h.x *= s.x),
                      (h.y *= s.y),
                      (h.z *= s.z),
                      h.vadd(e, h),
                      h.vadd(s, u.aabb.upperBound);
                  }
                }),
                  (n.prototype.aabbQuery = function (t, e) {
                    for (
                      var n = (this.data, this.children, [this]);
                      n.length;

                    ) {
                      var i = n.pop();
                      i.aabb.overlaps(t) &&
                        Array.prototype.push.apply(e, i.data),
                        Array.prototype.push.apply(n, i.children);
                    }
                    return e;
                  });
                var a = new r();
                (n.prototype.rayQuery = function (t, e, n) {
                  return (
                    t.getAABB(a), a.toLocalFrame(e, a), this.aabbQuery(a, n), n
                  );
                }),
                  (n.prototype.removeEmptyNodes = function () {
                    for (var t = [this]; t.length; ) {
                      for (
                        var e = t.pop(), n = e.children.length - 1;
                        n >= 0;
                        n--
                      )
                        e.children[n].data.length || e.children.splice(n, 1);
                      Array.prototype.push.apply(t, e.children);
                    }
                  });
              },
              { "../collision/AABB": 3, "../math/Vec3": 30 },
            ],
            51: [
              function (t, e) {
                function n() {
                  (this.objects = []), (this.type = Object);
                }
                (e.exports = n),
                  (n.prototype.release = function () {
                    for (var t = arguments.length, e = 0; e !== t; e++)
                      this.objects.push(arguments[e]);
                  }),
                  (n.prototype.get = function () {
                    return 0 === this.objects.length
                      ? this.constructObject()
                      : this.objects.pop();
                  }),
                  (n.prototype.constructObject = function () {
                    throw new Error(
                      "constructObject() not implemented in this Pool subclass yet!"
                    );
                  });
              },
              {},
            ],
            52: [
              function (t, e) {
                function n() {
                  this.data = { keys: [] };
                }
                (e.exports = n),
                  (n.prototype.get = function (t, e) {
                    if (t > e) {
                      var n = e;
                      (e = t), (t = n);
                    }
                    return this.data[t + "-" + e];
                  }),
                  (n.prototype.set = function (t, e, n) {
                    if (t > e) {
                      var i = e;
                      (e = t), (t = i);
                    }
                    var r = t + "-" + e;
                    this.get(t, e) || this.data.keys.push(r),
                      (this.data[r] = n);
                  }),
                  (n.prototype.reset = function () {
                    for (var t = this.data, e = t.keys; e.length > 0; )
                      delete t[e.pop()];
                  });
              },
              {},
            ],
            53: [
              function (t, e) {
                function n() {}
                (e.exports = n),
                  (n.defaults = function (t, e) {
                    for (var n in ((t = t || {}), e)) n in t || (t[n] = e[n]);
                    return t;
                  });
              },
              {},
            ],
            54: [
              function (t, e) {
                function n() {
                  r.call(this), (this.type = i);
                }
                e.exports = n;
                var i = t("../math/Vec3"),
                  r = t("./Pool");
                (n.prototype = new r()),
                  (n.prototype.constructObject = function () {
                    return new i();
                  });
              },
              { "../math/Vec3": 30, "./Pool": 51 },
            ],
            55: [
              function (t, e) {
                function n(t) {
                  (this.contactPointPool = []),
                    (this.frictionEquationPool = []),
                    (this.result = []),
                    (this.frictionResult = []),
                    (this.v3pool = new u()),
                    (this.world = t),
                    (this.currentContactMaterial = null),
                    (this.enableFrictionReduction = !1);
                }
                function i(t, e, n) {
                  for (var i = null, r = t.length, o = 0; o !== r; o++) {
                    var s = t[o],
                      a = H;
                    t[(o + 1) % r].vsub(s, a);
                    var l = U;
                    a.cross(e, l);
                    var c = V;
                    n.vsub(s, c);
                    var u = l.dot(c);
                    if (
                      !(
                        null === i ||
                        (u > 0 && !0 === i) ||
                        (0 >= u && !1 === i)
                      )
                    )
                      return !1;
                    null === i && (i = u > 0);
                  }
                  return !0;
                }
                e.exports = n;
                var r = t("../collision/AABB"),
                  o = t("../shapes/Shape"),
                  s = t("../collision/Ray"),
                  a = t("../math/Vec3"),
                  l = t("../math/Transform"),
                  c =
                    (t("../shapes/ConvexPolyhedron"), t("../math/Quaternion")),
                  u = (t("../solver/Solver"), t("../utils/Vec3Pool")),
                  h = t("../equations/ContactEquation"),
                  d = t("../equations/FrictionEquation");
                (n.prototype.createContactEquation = function (
                  t,
                  e,
                  n,
                  i,
                  r,
                  o
                ) {
                  var s;
                  this.contactPointPool.length
                    ? (((s = this.contactPointPool.pop()).bi = t), (s.bj = e))
                    : (s = new h(t, e)),
                    (s.enabled =
                      t.collisionResponse &&
                      e.collisionResponse &&
                      n.collisionResponse &&
                      i.collisionResponse);
                  var a = this.currentContactMaterial;
                  (s.restitution = a.restitution),
                    s.setSpookParams(
                      a.contactEquationStiffness,
                      a.contactEquationRelaxation,
                      this.world.dt
                    );
                  var l = n.material || t.material,
                    c = i.material || e.material;
                  return (
                    l &&
                      c &&
                      l.restitution >= 0 &&
                      c.restitution >= 0 &&
                      (s.restitution = l.restitution * c.restitution),
                    (s.si = r || n),
                    (s.sj = o || i),
                    s
                  );
                }),
                  (n.prototype.createFrictionEquationsFromContact = function (
                    t,
                    e
                  ) {
                    var n = t.bi,
                      i = t.bj,
                      r = t.si,
                      o = t.sj,
                      s = this.world,
                      a = this.currentContactMaterial,
                      l = a.friction,
                      c = r.material || n.material,
                      u = o.material || i.material;
                    if (
                      (c &&
                        u &&
                        c.friction >= 0 &&
                        u.friction >= 0 &&
                        (l = c.friction * u.friction),
                      l > 0)
                    ) {
                      var h = l * s.gravity.length(),
                        p = n.invMass + i.invMass;
                      p > 0 && (p = 1 / p);
                      var f = this.frictionEquationPool,
                        m = f.length ? f.pop() : new d(n, i, h * p),
                        g = f.length ? f.pop() : new d(n, i, h * p);
                      return (
                        (m.bi = g.bi = n),
                        (m.bj = g.bj = i),
                        (m.minForce = g.minForce = -h * p),
                        (m.maxForce = g.maxForce = h * p),
                        m.ri.copy(t.ri),
                        m.rj.copy(t.rj),
                        g.ri.copy(t.ri),
                        g.rj.copy(t.rj),
                        t.ni.tangents(m.t, g.t),
                        m.setSpookParams(
                          a.frictionEquationStiffness,
                          a.frictionEquationRelaxation,
                          s.dt
                        ),
                        g.setSpookParams(
                          a.frictionEquationStiffness,
                          a.frictionEquationRelaxation,
                          s.dt
                        ),
                        (m.enabled = g.enabled = t.enabled),
                        e.push(m, g),
                        !0
                      );
                    }
                    return !1;
                  });
                var p = new a(),
                  f = new a(),
                  m = new a();
                n.prototype.createFrictionFromAverage = function (t) {
                  var e = this.result[this.result.length - 1];
                  if (
                    this.createFrictionEquationsFromContact(
                      e,
                      this.frictionResult
                    ) &&
                    1 !== t
                  ) {
                    var n = this.frictionResult[this.frictionResult.length - 2],
                      i = this.frictionResult[this.frictionResult.length - 1];
                    p.setZero(), f.setZero(), m.setZero();
                    for (var r = e.bi, o = (e.bj, 0); o !== t; o++)
                      (e = this.result[this.result.length - 1 - o]).bodyA !== r
                        ? (p.vadd(e.ni, p), f.vadd(e.ri, f), m.vadd(e.rj, m))
                        : (p.vsub(e.ni, p), f.vadd(e.rj, f), m.vadd(e.ri, m));
                    var s = 1 / t;
                    f.scale(s, n.ri),
                      m.scale(s, n.rj),
                      i.ri.copy(n.ri),
                      i.rj.copy(n.rj),
                      p.normalize(),
                      p.tangents(n.t, i.t);
                  }
                };
                var g = new a(),
                  v = new a(),
                  y = new c(),
                  x = new c();
                (n.prototype.getContacts = function (t, e, n, i, r, o, s) {
                  (this.contactPointPool = r),
                    (this.frictionEquationPool = s),
                    (this.result = i),
                    (this.frictionResult = o);
                  for (
                    var a = y, l = x, c = g, u = v, h = 0, d = t.length;
                    h !== d;
                    h++
                  ) {
                    var p = t[h],
                      f = e[h],
                      m = null;
                    p.material &&
                      f.material &&
                      (m =
                        n.getContactMaterial(p.material, f.material) || null);
                    for (var b = 0; b < p.shapes.length; b++) {
                      p.quaternion.mult(p.shapeOrientations[b], a),
                        p.quaternion.vmult(p.shapeOffsets[b], c),
                        c.vadd(p.position, c);
                      for (
                        var w = p.shapes[b], _ = 0;
                        _ < f.shapes.length;
                        _++
                      ) {
                        f.quaternion.mult(f.shapeOrientations[_], l),
                          f.quaternion.vmult(f.shapeOffsets[_], u),
                          u.vadd(f.position, u);
                        var M = f.shapes[_];
                        if (
                          !(
                            c.distanceTo(u) >
                            w.boundingSphereRadius + M.boundingSphereRadius
                          )
                        ) {
                          var S = null;
                          w.material &&
                            M.material &&
                            (S =
                              n.getContactMaterial(w.material, M.material) ||
                              null),
                            (this.currentContactMaterial =
                              S || m || n.defaultContactMaterial);
                          var E = this[w.type | M.type];
                          E &&
                            (w.type < M.type
                              ? E.call(this, w, M, c, u, a, l, p, f, w, M)
                              : E.call(this, M, w, u, c, l, a, f, p, w, M));
                        }
                      }
                    }
                  }
                }),
                  (n.prototype[o.types.BOX | o.types.BOX] = n.prototype.boxBox =
                    function (t, e, n, i, r, o, s, a) {
                      (t.convexPolyhedronRepresentation.material = t.material),
                        (e.convexPolyhedronRepresentation.material =
                          e.material),
                        (t.convexPolyhedronRepresentation.collisionResponse =
                          t.collisionResponse),
                        (e.convexPolyhedronRepresentation.collisionResponse =
                          e.collisionResponse),
                        this.convexConvex(
                          t.convexPolyhedronRepresentation,
                          e.convexPolyhedronRepresentation,
                          n,
                          i,
                          r,
                          o,
                          s,
                          a,
                          t,
                          e
                        );
                    }),
                  (n.prototype[o.types.BOX | o.types.CONVEXPOLYHEDRON] =
                    n.prototype.boxConvex =
                      function (t, e, n, i, r, o, s, a) {
                        (t.convexPolyhedronRepresentation.material =
                          t.material),
                          (t.convexPolyhedronRepresentation.collisionResponse =
                            t.collisionResponse),
                          this.convexConvex(
                            t.convexPolyhedronRepresentation,
                            e,
                            n,
                            i,
                            r,
                            o,
                            s,
                            a,
                            t,
                            e
                          );
                      }),
                  (n.prototype[o.types.BOX | o.types.PARTICLE] =
                    n.prototype.boxParticle =
                      function (t, e, n, i, r, o, s, a) {
                        (t.convexPolyhedronRepresentation.material =
                          t.material),
                          (t.convexPolyhedronRepresentation.collisionResponse =
                            t.collisionResponse),
                          this.convexParticle(
                            t.convexPolyhedronRepresentation,
                            e,
                            n,
                            i,
                            r,
                            o,
                            s,
                            a,
                            t,
                            e
                          );
                      }),
                  (n.prototype[o.types.SPHERE] = n.prototype.sphereSphere =
                    function (t, e, n, i, r, o, s, a) {
                      var l = this.createContactEquation(s, a, t, e);
                      i.vsub(n, l.ni),
                        l.ni.normalize(),
                        l.ri.copy(l.ni),
                        l.rj.copy(l.ni),
                        l.ri.mult(t.radius, l.ri),
                        l.rj.mult(-e.radius, l.rj),
                        l.ri.vadd(n, l.ri),
                        l.ri.vsub(s.position, l.ri),
                        l.rj.vadd(i, l.rj),
                        l.rj.vsub(a.position, l.rj),
                        this.result.push(l),
                        this.createFrictionEquationsFromContact(
                          l,
                          this.frictionResult
                        );
                    });
                var b = new a(),
                  w = new a(),
                  _ = new a();
                n.prototype[o.types.PLANE | o.types.TRIMESH] =
                  n.prototype.planeTrimesh = function (t, e, n, i, r, o, s, c) {
                    var u = new a(),
                      h = b;
                    h.set(0, 0, 1), r.vmult(h, h);
                    for (var d = 0; d < e.vertices.length / 3; d++) {
                      e.getVertex(d, u);
                      var p = new a();
                      p.copy(u), l.pointToWorldFrame(i, o, p, u);
                      var f = w;
                      if ((u.vsub(n, f), 0 >= h.dot(f))) {
                        var m = this.createContactEquation(s, c, t, e);
                        m.ni.copy(h);
                        var g = _;
                        h.scale(f.dot(h), g),
                          u.vsub(g, g),
                          m.ri.copy(g),
                          m.ri.vsub(s.position, m.ri),
                          m.rj.copy(u),
                          m.rj.vsub(c.position, m.rj),
                          this.result.push(m),
                          this.createFrictionEquationsFromContact(
                            m,
                            this.frictionResult
                          );
                      }
                    }
                  };
                var M = new a(),
                  S = new a(),
                  E = (new a(), new a()),
                  T = new a(),
                  A = new a(),
                  C = new a(),
                  L = new a(),
                  R = new a(),
                  P = new a(),
                  N = new a(),
                  I = new a(),
                  B = new a(),
                  O = new a(),
                  D = new r(),
                  k = [];
                n.prototype[o.types.SPHERE | o.types.TRIMESH] =
                  n.prototype.sphereTrimesh = function (
                    t,
                    e,
                    n,
                    i,
                    r,
                    o,
                    a,
                    c
                  ) {
                    var u = A,
                      h = C,
                      d = L,
                      p = R,
                      f = P,
                      m = N,
                      g = D,
                      v = T,
                      y = S,
                      x = k;
                    l.pointToLocalFrame(i, o, n, f);
                    var b = t.radius;
                    g.lowerBound.set(f.x - b, f.y - b, f.z - b),
                      g.upperBound.set(f.x + b, f.y + b, f.z + b),
                      e.getTrianglesInAABB(g, x);
                    for (
                      var w = E, _ = t.radius * t.radius, F = 0;
                      F < x.length;
                      F++
                    )
                      for (var z = 0; 3 > z; z++)
                        e.getVertex(e.indices[3 * x[F] + z], w),
                          w.vsub(f, y),
                          y.norm2() <= _ &&
                            (v.copy(w),
                            l.pointToWorldFrame(i, o, v, w),
                            w.vsub(n, y),
                            (V = this.createContactEquation(
                              a,
                              c,
                              t,
                              e
                            )).ni.copy(y),
                            V.ni.normalize(),
                            V.ri.copy(V.ni),
                            V.ri.scale(t.radius, V.ri),
                            V.ri.vadd(n, V.ri),
                            V.ri.vsub(a.position, V.ri),
                            V.rj.copy(w),
                            V.rj.vsub(c.position, V.rj),
                            this.result.push(V),
                            this.createFrictionEquationsFromContact(
                              V,
                              this.frictionResult
                            ));
                    for (F = 0; F < x.length; F++)
                      for (z = 0; 3 > z; z++) {
                        e.getVertex(e.indices[3 * x[F] + z], u),
                          e.getVertex(e.indices[3 * x[F] + ((z + 1) % 3)], h),
                          h.vsub(u, d),
                          f.vsub(h, m);
                        var H = m.dot(d);
                        f.vsub(u, m);
                        var U = m.dot(d);
                        if (
                          U > 0 &&
                          0 > H &&
                          (f.vsub(u, m),
                          p.copy(d),
                          p.normalize(),
                          (U = m.dot(p)),
                          p.scale(U, m),
                          m.vadd(u, m),
                          (Y = m.distanceTo(f)) < t.radius)
                        ) {
                          var V = this.createContactEquation(a, c, t, e);
                          m.vsub(f, V.ni),
                            V.ni.normalize(),
                            V.ni.scale(t.radius, V.ri),
                            l.pointToWorldFrame(i, o, m, m),
                            m.vsub(c.position, V.rj),
                            l.vectorToWorldFrame(o, V.ni, V.ni),
                            l.vectorToWorldFrame(o, V.ri, V.ri),
                            this.result.push(V),
                            this.createFrictionEquationsFromContact(
                              V,
                              this.frictionResult
                            );
                        }
                      }
                    for (
                      var G = I, j = B, W = O, q = M, X = ((F = 0), x.length);
                      F !== X;
                      F++
                    ) {
                      e.getTriangleVertices(x[F], G, j, W),
                        e.getNormal(x[F], q),
                        f.vsub(G, m);
                      var Y = m.dot(q);
                      q.scale(Y, m),
                        f.vsub(m, m),
                        (Y = m.distanceTo(f)),
                        s.pointInTriangle(m, G, j, W) &&
                          Y < t.radius &&
                          ((V = this.createContactEquation(a, c, t, e)),
                          m.vsub(f, V.ni),
                          V.ni.normalize(),
                          V.ni.scale(t.radius, V.ri),
                          l.pointToWorldFrame(i, o, m, m),
                          m.vsub(c.position, V.rj),
                          l.vectorToWorldFrame(o, V.ni, V.ni),
                          l.vectorToWorldFrame(o, V.ri, V.ri),
                          this.result.push(V),
                          this.createFrictionEquationsFromContact(
                            V,
                            this.frictionResult
                          ));
                    }
                    x.length = 0;
                  };
                var F = new a(),
                  z = new a();
                n.prototype[o.types.SPHERE | o.types.PLANE] =
                  n.prototype.spherePlane = function (t, e, n, i, r, o, s, a) {
                    var l = this.createContactEquation(s, a, t, e);
                    if (
                      (l.ni.set(0, 0, 1),
                      o.vmult(l.ni, l.ni),
                      l.ni.negate(l.ni),
                      l.ni.normalize(),
                      l.ni.mult(t.radius, l.ri),
                      n.vsub(i, F),
                      l.ni.mult(l.ni.dot(F), z),
                      F.vsub(z, l.rj),
                      -F.dot(l.ni) <= t.radius)
                    ) {
                      var c = l.ri,
                        u = l.rj;
                      c.vadd(n, c),
                        c.vsub(s.position, c),
                        u.vadd(i, u),
                        u.vsub(a.position, u),
                        this.result.push(l),
                        this.createFrictionEquationsFromContact(
                          l,
                          this.frictionResult
                        );
                    }
                  };
                var H = new a(),
                  U = new a(),
                  V = new a(),
                  G = new a(),
                  j = new a(),
                  W = new a(),
                  q = new a(),
                  X = [new a(), new a(), new a(), new a(), new a(), new a()],
                  Y = new a(),
                  Z = new a(),
                  J = new a(),
                  K = new a();
                n.prototype[o.types.SPHERE | o.types.BOX] =
                  n.prototype.sphereBox = function (t, e, n, i, r, o, s, a) {
                    var l = this.v3pool,
                      c = X;
                    n.vsub(i, G), e.getSideNormals(c, o);
                    for (
                      var u = t.radius,
                        h = !1,
                        d = Z,
                        p = J,
                        f = K,
                        m = null,
                        g = 0,
                        v = 0,
                        y = 0,
                        x = null,
                        b = 0,
                        w = c.length;
                      b !== w && !1 === h;
                      b++
                    ) {
                      var _ = j;
                      _.copy(c[b]);
                      var M = _.norm();
                      _.normalize();
                      var S = G.dot(_);
                      if (M + u > S && S > 0) {
                        var E = W,
                          T = q;
                        E.copy(c[(b + 1) % 3]), T.copy(c[(b + 2) % 3]);
                        var A = E.norm(),
                          C = T.norm();
                        E.normalize(), T.normalize();
                        var L = G.dot(E),
                          R = G.dot(T);
                        if (A > L && L > -A && C > R && R > -C) {
                          var P = Math.abs(S - M - u);
                          (null === x || x > P) &&
                            ((x = P),
                            (v = L),
                            (y = R),
                            (m = M),
                            d.copy(_),
                            p.copy(E),
                            f.copy(T),
                            g++);
                        }
                      }
                    }
                    if (g) {
                      h = !0;
                      var N = this.createContactEquation(s, a, t, e);
                      d.mult(-u, N.ri),
                        N.ni.copy(d),
                        N.ni.negate(N.ni),
                        d.mult(m, d),
                        p.mult(v, p),
                        d.vadd(p, d),
                        f.mult(y, f),
                        d.vadd(f, N.rj),
                        N.ri.vadd(n, N.ri),
                        N.ri.vsub(s.position, N.ri),
                        N.rj.vadd(i, N.rj),
                        N.rj.vsub(a.position, N.rj),
                        this.result.push(N),
                        this.createFrictionEquationsFromContact(
                          N,
                          this.frictionResult
                        );
                    }
                    for (var I = l.get(), B = Y, O = 0; 2 !== O && !h; O++)
                      for (var D = 0; 2 !== D && !h; D++)
                        for (var k = 0; 2 !== k && !h; k++)
                          I.set(0, 0, 0),
                            O ? I.vadd(c[0], I) : I.vsub(c[0], I),
                            D ? I.vadd(c[1], I) : I.vsub(c[1], I),
                            k ? I.vadd(c[2], I) : I.vsub(c[2], I),
                            i.vadd(I, B),
                            B.vsub(n, B),
                            B.norm2() < u * u &&
                              ((h = !0),
                              (N = this.createContactEquation(
                                s,
                                a,
                                t,
                                e
                              )).ri.copy(B),
                              N.ri.normalize(),
                              N.ni.copy(N.ri),
                              N.ri.mult(u, N.ri),
                              N.rj.copy(I),
                              N.ri.vadd(n, N.ri),
                              N.ri.vsub(s.position, N.ri),
                              N.rj.vadd(i, N.rj),
                              N.rj.vsub(a.position, N.rj),
                              this.result.push(N),
                              this.createFrictionEquationsFromContact(
                                N,
                                this.frictionResult
                              ));
                    l.release(I), (I = null);
                    var F = l.get(),
                      z = l.get(),
                      H = ((N = l.get()), l.get()),
                      U = ((P = l.get()), c.length);
                    for (O = 0; O !== U && !h; O++)
                      for (D = 0; D !== U && !h; D++)
                        if (O % 3 != D % 3) {
                          c[D].cross(c[O], F),
                            F.normalize(),
                            c[O].vadd(c[D], z),
                            N.copy(n),
                            N.vsub(z, N),
                            N.vsub(i, N);
                          var V = N.dot(F);
                          for (
                            F.mult(V, H), k = 0;
                            k === O % 3 || k === D % 3;

                          )
                            k++;
                          P.copy(n), P.vsub(H, P), P.vsub(z, P), P.vsub(i, P);
                          var Q = Math.abs(V),
                            $ = P.norm();
                          if (Q < c[k].norm() && u > $) {
                            h = !0;
                            var tt = this.createContactEquation(s, a, t, e);
                            z.vadd(H, tt.rj),
                              tt.rj.copy(tt.rj),
                              P.negate(tt.ni),
                              tt.ni.normalize(),
                              tt.ri.copy(tt.rj),
                              tt.ri.vadd(i, tt.ri),
                              tt.ri.vsub(n, tt.ri),
                              tt.ri.normalize(),
                              tt.ri.mult(u, tt.ri),
                              tt.ri.vadd(n, tt.ri),
                              tt.ri.vsub(s.position, tt.ri),
                              tt.rj.vadd(i, tt.rj),
                              tt.rj.vsub(a.position, tt.rj),
                              this.result.push(tt),
                              this.createFrictionEquationsFromContact(
                                tt,
                                this.frictionResult
                              );
                          }
                        }
                    l.release(F, z, N, H, P);
                  };
                var Q = new a(),
                  $ = new a(),
                  tt = new a(),
                  et = new a(),
                  nt = new a(),
                  it = new a(),
                  rt = new a(),
                  ot = new a(),
                  st = new a(),
                  at = new a();
                (n.prototype[o.types.SPHERE | o.types.CONVEXPOLYHEDRON] =
                  n.prototype.sphereConvex =
                    function (t, e, n, r, o, s, a, l) {
                      var c = this.v3pool;
                      n.vsub(r, Q);
                      for (
                        var u = e.faceNormals,
                          h = e.faces,
                          d = e.vertices,
                          p = t.radius,
                          f = 0;
                        f !== d.length;
                        f++
                      ) {
                        var m = d[f],
                          g = nt;
                        s.vmult(m, g), r.vadd(g, g);
                        var v = et;
                        if ((g.vsub(n, v), v.norm2() < p * p))
                          return (
                            (y = !0),
                            (N = this.createContactEquation(
                              a,
                              l,
                              t,
                              e
                            )).ri.copy(v),
                            N.ri.normalize(),
                            N.ni.copy(N.ri),
                            N.ri.mult(p, N.ri),
                            g.vsub(r, N.rj),
                            N.ri.vadd(n, N.ri),
                            N.ri.vsub(a.position, N.ri),
                            N.rj.vadd(r, N.rj),
                            N.rj.vsub(l.position, N.rj),
                            this.result.push(N),
                            void this.createFrictionEquationsFromContact(
                              N,
                              this.frictionResult
                            )
                          );
                      }
                      for (
                        var y = !1, x = ((f = 0), h.length);
                        f !== x && !1 === y;
                        f++
                      ) {
                        var b = u[f],
                          w = h[f],
                          _ = it;
                        s.vmult(b, _);
                        var M = rt;
                        s.vmult(d[w[0]], M), M.vadd(r, M);
                        var S = ot;
                        _.mult(-p, S), n.vadd(S, S);
                        var E = st;
                        S.vsub(M, E);
                        var T = E.dot(_),
                          A = at;
                        if ((n.vsub(M, A), 0 > T && A.dot(_) > 0)) {
                          for (var C = [], L = 0, R = w.length; L !== R; L++) {
                            var P = c.get();
                            s.vmult(d[w[L]], P), r.vadd(P, P), C.push(P);
                          }
                          if (i(C, _, n)) {
                            y = !0;
                            var N = this.createContactEquation(a, l, t, e);
                            _.mult(-p, N.ri), _.negate(N.ni);
                            var I = c.get();
                            _.mult(-T, I);
                            var B = c.get();
                            _.mult(-p, B),
                              n.vsub(r, N.rj),
                              N.rj.vadd(B, N.rj),
                              N.rj.vadd(I, N.rj),
                              N.rj.vadd(r, N.rj),
                              N.rj.vsub(l.position, N.rj),
                              N.ri.vadd(n, N.ri),
                              N.ri.vsub(a.position, N.ri),
                              c.release(I),
                              c.release(B),
                              this.result.push(N),
                              this.createFrictionEquationsFromContact(
                                N,
                                this.frictionResult
                              ),
                              (L = 0);
                            for (var O = C.length; L !== O; L++)
                              c.release(C[L]);
                            return;
                          }
                          for (L = 0; L !== w.length; L++) {
                            var D = c.get(),
                              k = c.get();
                            s.vmult(d[w[(L + 1) % w.length]], D),
                              s.vmult(d[w[(L + 2) % w.length]], k),
                              r.vadd(D, D),
                              r.vadd(k, k);
                            var F = $;
                            k.vsub(D, F);
                            var z = tt;
                            F.unit(z);
                            var H = c.get(),
                              U = c.get();
                            n.vsub(D, U);
                            var V = U.dot(z);
                            z.mult(V, H), H.vadd(D, H);
                            var G = c.get();
                            if (
                              (H.vsub(n, G),
                              V > 0 && V * V < F.norm2() && G.norm2() < p * p)
                            ) {
                              for (
                                N = this.createContactEquation(a, l, t, e),
                                  H.vsub(r, N.rj),
                                  H.vsub(n, N.ni),
                                  N.ni.normalize(),
                                  N.ni.mult(p, N.ri),
                                  N.rj.vadd(r, N.rj),
                                  N.rj.vsub(l.position, N.rj),
                                  N.ri.vadd(n, N.ri),
                                  N.ri.vsub(a.position, N.ri),
                                  this.result.push(N),
                                  this.createFrictionEquationsFromContact(
                                    N,
                                    this.frictionResult
                                  ),
                                  L = 0,
                                  O = C.length;
                                L !== O;
                                L++
                              )
                                c.release(C[L]);
                              return (
                                c.release(D),
                                c.release(k),
                                c.release(H),
                                c.release(G),
                                void c.release(U)
                              );
                            }
                            c.release(D),
                              c.release(k),
                              c.release(H),
                              c.release(G),
                              c.release(U);
                          }
                          for (L = 0, O = C.length; L !== O; L++)
                            c.release(C[L]);
                        }
                      }
                    }),
                  new a(),
                  new a(),
                  (n.prototype[o.types.PLANE | o.types.BOX] =
                    n.prototype.planeBox =
                      function (t, e, n, i, r, o, s, a) {
                        (e.convexPolyhedronRepresentation.material =
                          e.material),
                          (e.convexPolyhedronRepresentation.collisionResponse =
                            e.collisionResponse),
                          this.planeConvex(
                            t,
                            e.convexPolyhedronRepresentation,
                            n,
                            i,
                            r,
                            o,
                            s,
                            a
                          );
                      });
                var lt = new a(),
                  ct = new a(),
                  ut = new a(),
                  ht = new a();
                n.prototype[o.types.PLANE | o.types.CONVEXPOLYHEDRON] =
                  n.prototype.planeConvex = function (t, e, n, i, r, o, s, a) {
                    var l = lt,
                      c = ct;
                    c.set(0, 0, 1), r.vmult(c, c);
                    for (var u = 0, h = ut, d = 0; d !== e.vertices.length; d++)
                      if (
                        (l.copy(e.vertices[d]),
                        o.vmult(l, l),
                        i.vadd(l, l),
                        l.vsub(n, h),
                        0 >= c.dot(h))
                      ) {
                        var p = this.createContactEquation(s, a, t, e),
                          f = ht;
                        c.mult(c.dot(h), f),
                          l.vsub(f, f),
                          f.vsub(n, p.ri),
                          p.ni.copy(c),
                          l.vsub(i, p.rj),
                          p.ri.vadd(n, p.ri),
                          p.ri.vsub(s.position, p.ri),
                          p.rj.vadd(i, p.rj),
                          p.rj.vsub(a.position, p.rj),
                          this.result.push(p),
                          u++,
                          this.enableFrictionReduction ||
                            this.createFrictionEquationsFromContact(
                              p,
                              this.frictionResult
                            );
                      }
                    this.enableFrictionReduction &&
                      u &&
                      this.createFrictionFromAverage(u);
                  };
                var dt = new a(),
                  pt = new a();
                n.prototype[o.types.CONVEXPOLYHEDRON] =
                  n.prototype.convexConvex = function (
                    t,
                    e,
                    n,
                    i,
                    r,
                    o,
                    s,
                    a,
                    l,
                    c,
                    u,
                    h
                  ) {
                    var d = dt;
                    if (
                      !(
                        n.distanceTo(i) >
                        t.boundingSphereRadius + e.boundingSphereRadius
                      ) &&
                      t.findSeparatingAxis(e, n, r, i, o, d, u, h)
                    ) {
                      var p = [],
                        f = pt;
                      t.clipAgainstHull(n, r, e, i, o, d, -100, 100, p);
                      for (var m = 0, g = 0; g !== p.length; g++) {
                        var v = this.createContactEquation(s, a, t, e, l, c),
                          y = v.ri,
                          x = v.rj;
                        d.negate(v.ni),
                          p[g].normal.negate(f),
                          f.mult(p[g].depth, f),
                          p[g].point.vadd(f, y),
                          x.copy(p[g].point),
                          y.vsub(n, y),
                          x.vsub(i, x),
                          y.vadd(n, y),
                          y.vsub(s.position, y),
                          x.vadd(i, x),
                          x.vsub(a.position, x),
                          this.result.push(v),
                          m++,
                          this.enableFrictionReduction ||
                            this.createFrictionEquationsFromContact(
                              v,
                              this.frictionResult
                            );
                      }
                      this.enableFrictionReduction &&
                        m &&
                        this.createFrictionFromAverage(m);
                    }
                  };
                var ft = new a(),
                  mt = new a(),
                  gt = new a();
                n.prototype[o.types.PLANE | o.types.PARTICLE] =
                  n.prototype.planeParticle = function (
                    t,
                    e,
                    n,
                    i,
                    r,
                    o,
                    s,
                    a
                  ) {
                    var l = ft;
                    l.set(0, 0, 1), s.quaternion.vmult(l, l);
                    var c = mt;
                    if ((i.vsub(s.position, c), 0 >= l.dot(c))) {
                      var u = this.createContactEquation(a, s, e, t);
                      u.ni.copy(l), u.ni.negate(u.ni), u.ri.set(0, 0, 0);
                      var h = gt;
                      l.mult(l.dot(i), h),
                        i.vsub(h, h),
                        u.rj.copy(h),
                        this.result.push(u),
                        this.createFrictionEquationsFromContact(
                          u,
                          this.frictionResult
                        );
                    }
                  };
                var vt = new a();
                n.prototype[o.types.PARTICLE | o.types.SPHERE] =
                  n.prototype.sphereParticle = function (
                    t,
                    e,
                    n,
                    i,
                    r,
                    o,
                    s,
                    a
                  ) {
                    var l = vt;
                    if (
                      (l.set(0, 0, 1),
                      i.vsub(n, l),
                      l.norm2() <= t.radius * t.radius)
                    ) {
                      var c = this.createContactEquation(a, s, e, t);
                      l.normalize(),
                        c.rj.copy(l),
                        c.rj.mult(t.radius, c.rj),
                        c.ni.copy(l),
                        c.ni.negate(c.ni),
                        c.ri.set(0, 0, 0),
                        this.result.push(c),
                        this.createFrictionEquationsFromContact(
                          c,
                          this.frictionResult
                        );
                    }
                  };
                var yt = new c(),
                  xt = new a(),
                  bt = (new a(), new a()),
                  wt = new a(),
                  _t = new a();
                (n.prototype[o.types.PARTICLE | o.types.CONVEXPOLYHEDRON] =
                  n.prototype.convexParticle =
                    function (t, e, n, i, r, o, s, a) {
                      var l = -1,
                        c = bt,
                        u = _t,
                        h = null,
                        d = xt;
                      if (
                        (d.copy(i),
                        d.vsub(n, d),
                        r.conjugate(yt),
                        yt.vmult(d, d),
                        t.pointIsInside(d))
                      ) {
                        t.worldVerticesNeedsUpdate &&
                          t.computeWorldVertices(n, r),
                          t.worldFaceNormalsNeedsUpdate &&
                            t.computeWorldFaceNormals(r);
                        for (var p = 0, f = t.faces.length; p !== f; p++) {
                          var m = [t.worldVertices[t.faces[p][0]]],
                            g = t.worldFaceNormals[p];
                          i.vsub(m[0], wt);
                          var v = -g.dot(wt);
                          (null === h || Math.abs(v) < Math.abs(h)) &&
                            ((h = v), (l = p), c.copy(g));
                        }
                        if (-1 !== l) {
                          var y = this.createContactEquation(a, s, e, t);
                          c.mult(h, u),
                            u.vadd(i, u),
                            u.vsub(n, u),
                            y.rj.copy(u),
                            c.negate(y.ni),
                            y.ri.set(0, 0, 0);
                          var x = y.ri,
                            b = y.rj;
                          x.vadd(i, x),
                            x.vsub(a.position, x),
                            b.vadd(n, b),
                            b.vsub(s.position, b),
                            this.result.push(y),
                            this.createFrictionEquationsFromContact(
                              y,
                              this.frictionResult
                            );
                        } else
                          console.warn(
                            "Point found inside convex, but did not find penetrating face!"
                          );
                      }
                    }),
                  (n.prototype[o.types.BOX | o.types.HEIGHTFIELD] =
                    n.prototype.boxHeightfield =
                      function (t, e, n, i, r, o, s, a) {
                        (t.convexPolyhedronRepresentation.material =
                          t.material),
                          (t.convexPolyhedronRepresentation.collisionResponse =
                            t.collisionResponse),
                          this.convexHeightfield(
                            t.convexPolyhedronRepresentation,
                            e,
                            n,
                            i,
                            r,
                            o,
                            s,
                            a
                          );
                      });
                var Mt = new a(),
                  St = new a(),
                  Et = [0];
                n.prototype[o.types.CONVEXPOLYHEDRON | o.types.HEIGHTFIELD] =
                  n.prototype.convexHeightfield = function (
                    t,
                    e,
                    n,
                    i,
                    r,
                    o,
                    s,
                    a
                  ) {
                    var c = e.data,
                      u = e.elementSize,
                      h = t.boundingSphereRadius,
                      d = St,
                      p = Et,
                      f = Mt;
                    l.pointToLocalFrame(i, o, n, f);
                    var m = Math.floor((f.x - h) / u) - 1,
                      g = Math.ceil((f.x + h) / u) + 1,
                      v = Math.floor((f.y - h) / u) - 1,
                      y = Math.ceil((f.y + h) / u) + 1;
                    if (!(0 > g || 0 > y || m > c.length || v > c[0].length)) {
                      0 > m && (m = 0),
                        0 > g && (g = 0),
                        0 > v && (v = 0),
                        0 > y && (y = 0),
                        m >= c.length && (m = c.length - 1),
                        g >= c.length && (g = c.length - 1),
                        y >= c[0].length && (y = c[0].length - 1),
                        v >= c[0].length && (v = c[0].length - 1);
                      var x = [];
                      e.getRectMinMax(m, v, g, y, x);
                      var b = x[0],
                        w = x[1];
                      if (!(f.z - h > w || f.z + h < b))
                        for (var _ = m; g > _; _++)
                          for (var M = v; y > M; M++)
                            e.getConvexTrianglePillar(_, M, !1),
                              l.pointToWorldFrame(i, o, e.pillarOffset, d),
                              n.distanceTo(d) <
                                e.pillarConvex.boundingSphereRadius +
                                  t.boundingSphereRadius &&
                                this.convexConvex(
                                  t,
                                  e.pillarConvex,
                                  n,
                                  d,
                                  r,
                                  o,
                                  s,
                                  a,
                                  null,
                                  null,
                                  p,
                                  null
                                ),
                              e.getConvexTrianglePillar(_, M, !0),
                              l.pointToWorldFrame(i, o, e.pillarOffset, d),
                              n.distanceTo(d) <
                                e.pillarConvex.boundingSphereRadius +
                                  t.boundingSphereRadius &&
                                this.convexConvex(
                                  t,
                                  e.pillarConvex,
                                  n,
                                  d,
                                  r,
                                  o,
                                  s,
                                  a,
                                  null,
                                  null,
                                  p,
                                  null
                                );
                    }
                  };
                var Tt = new a(),
                  At = new a();
                n.prototype[o.types.SPHERE | o.types.HEIGHTFIELD] =
                  n.prototype.sphereHeightfield = function (
                    t,
                    e,
                    n,
                    i,
                    r,
                    o,
                    s,
                    a
                  ) {
                    var c = e.data,
                      u = t.radius,
                      h = e.elementSize,
                      d = At,
                      p = Tt;
                    l.pointToLocalFrame(i, o, n, p);
                    var f = Math.floor((p.x - u) / h) - 1,
                      m = Math.ceil((p.x + u) / h) + 1,
                      g = Math.floor((p.y - u) / h) - 1,
                      v = Math.ceil((p.y + u) / h) + 1;
                    if (!(0 > m || 0 > v || f > c.length || v > c[0].length)) {
                      0 > f && (f = 0),
                        0 > m && (m = 0),
                        0 > g && (g = 0),
                        0 > v && (v = 0),
                        f >= c.length && (f = c.length - 1),
                        m >= c.length && (m = c.length - 1),
                        v >= c[0].length && (v = c[0].length - 1),
                        g >= c[0].length && (g = c[0].length - 1);
                      var y = [];
                      e.getRectMinMax(f, g, m, v, y);
                      var x = y[0],
                        b = y[1];
                      if (!(p.z - u > b || p.z + u < x))
                        for (var w = this.result, _ = f; m > _; _++)
                          for (var M = g; v > M; M++) {
                            var S = w.length;
                            if (
                              (e.getConvexTrianglePillar(_, M, !1),
                              l.pointToWorldFrame(i, o, e.pillarOffset, d),
                              n.distanceTo(d) <
                                e.pillarConvex.boundingSphereRadius +
                                  t.boundingSphereRadius &&
                                this.sphereConvex(
                                  t,
                                  e.pillarConvex,
                                  n,
                                  d,
                                  r,
                                  o,
                                  s,
                                  a
                                ),
                              e.getConvexTrianglePillar(_, M, !0),
                              l.pointToWorldFrame(i, o, e.pillarOffset, d),
                              n.distanceTo(d) <
                                e.pillarConvex.boundingSphereRadius +
                                  t.boundingSphereRadius &&
                                this.sphereConvex(
                                  t,
                                  e.pillarConvex,
                                  n,
                                  d,
                                  r,
                                  o,
                                  s,
                                  a
                                ),
                              w.length - S > 2)
                            )
                              return;
                          }
                    }
                  };
              },
              {
                "../collision/AABB": 3,
                "../collision/Ray": 9,
                "../equations/ContactEquation": 19,
                "../equations/FrictionEquation": 21,
                "../math/Quaternion": 28,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "../shapes/ConvexPolyhedron": 38,
                "../shapes/Shape": 43,
                "../solver/Solver": 47,
                "../utils/Vec3Pool": 54,
              },
            ],
            56: [
              function (t, e) {
                function n() {
                  l.apply(this),
                    (this.dt = -1),
                    (this.allowSleep = !1),
                    (this.contacts = []),
                    (this.frictionEquations = []),
                    (this.quatNormalizeSkip = 0),
                    (this.quatNormalizeFast = !1),
                    (this.time = 0),
                    (this.stepnumber = 0),
                    (this.default_dt = 1 / 60),
                    (this.nextId = 0),
                    (this.gravity = new r()),
                    (this.broadphase = new v()),
                    (this.bodies = []),
                    (this.solver = new s()),
                    (this.constraints = []),
                    (this.narrowphase = new a(this)),
                    (this.collisionMatrix = new c()),
                    (this.collisionMatrixPrevious = new c()),
                    (this.materials = []),
                    (this.contactmaterials = []),
                    (this.contactMaterialTable = new p()),
                    (this.defaultMaterial = new u("default")),
                    (this.defaultContactMaterial = new h(
                      this.defaultMaterial,
                      this.defaultMaterial,
                      { friction: 0.3, restitution: 0 }
                    )),
                    (this.doProfiling = !1),
                    (this.profile = {
                      solve: 0,
                      makeContactConstraints: 0,
                      broadphase: 0,
                      integrate: 0,
                      narrowphase: 0,
                    }),
                    (this.subsystems = []),
                    (this.addBodyEvent = { type: "addBody", body: null }),
                    (this.removeBodyEvent = { type: "removeBody", body: null });
                }
                e.exports = n;
                var i = t("../shapes/Shape"),
                  r = t("../math/Vec3"),
                  o = t("../math/Quaternion"),
                  s = t("../solver/GSSolver"),
                  a =
                    (t("../utils/Vec3Pool"),
                    t("../equations/ContactEquation"),
                    t("../equations/FrictionEquation"),
                    t("./Narrowphase")),
                  l = t("../utils/EventTarget"),
                  c = t("../collision/ArrayCollisionMatrix"),
                  u = t("../material/Material"),
                  h = t("../material/ContactMaterial"),
                  d = t("../objects/Body"),
                  p = t("../utils/TupleDictionary"),
                  f = t("../collision/RaycastResult"),
                  m = t("../collision/AABB"),
                  g = t("../collision/Ray"),
                  v = t("../collision/NaiveBroadphase");
                n.prototype = new l();
                var y = (new m(), new g());
                if (
                  ((n.prototype.getContactMaterial = function (t, e) {
                    return this.contactMaterialTable.get(t.id, e.id);
                  }),
                  (n.prototype.numObjects = function () {
                    return this.bodies.length;
                  }),
                  (n.prototype.collisionMatrixTick = function () {
                    var t = this.collisionMatrixPrevious;
                    (this.collisionMatrixPrevious = this.collisionMatrix),
                      (this.collisionMatrix = t),
                      this.collisionMatrix.reset();
                  }),
                  (n.prototype.add = n.prototype.addBody =
                    function (t) {
                      -1 === this.bodies.indexOf(t) &&
                        ((t.index = this.bodies.length),
                        this.bodies.push(t),
                        (t.world = this),
                        t.initPosition.copy(t.position),
                        t.initVelocity.copy(t.velocity),
                        (t.timeLastSleepy = this.time),
                        t instanceof d &&
                          (t.initAngularVelocity.copy(t.angularVelocity),
                          t.initQuaternion.copy(t.quaternion)),
                        this.collisionMatrix.setNumObjects(this.bodies.length),
                        (this.addBodyEvent.body = t),
                        this.dispatchEvent(this.addBodyEvent));
                    }),
                  (n.prototype.addConstraint = function (t) {
                    this.constraints.push(t);
                  }),
                  (n.prototype.removeConstraint = function (t) {
                    var e = this.constraints.indexOf(t);
                    -1 !== e && this.constraints.splice(e, 1);
                  }),
                  (n.prototype.rayTest = function (t, e, n) {
                    n instanceof f
                      ? this.raycastClosest(t, e, { skipBackfaces: !0 }, n)
                      : this.raycastAll(t, e, { skipBackfaces: !0 }, n);
                  }),
                  (n.prototype.raycastAll = function (t, e, n, i) {
                    return (
                      (n.mode = g.ALL),
                      (n.from = t),
                      (n.to = e),
                      (n.callback = i),
                      y.intersectWorld(this, n)
                    );
                  }),
                  (n.prototype.raycastAny = function (t, e, n, i) {
                    return (
                      (n.mode = g.ANY),
                      (n.from = t),
                      (n.to = e),
                      (n.result = i),
                      y.intersectWorld(this, n)
                    );
                  }),
                  (n.prototype.raycastClosest = function (t, e, n, i) {
                    return (
                      (n.mode = g.CLOSEST),
                      (n.from = t),
                      (n.to = e),
                      (n.result = i),
                      y.intersectWorld(this, n)
                    );
                  }),
                  (n.prototype.remove = function (t) {
                    t.world = null;
                    var e = this.bodies.length - 1,
                      n = this.bodies,
                      i = n.indexOf(t);
                    if (-1 !== i) {
                      n.splice(i, 1);
                      for (var r = 0; r !== n.length; r++) n[r].index = r;
                      this.collisionMatrix.setNumObjects(e),
                        (this.removeBodyEvent.body = t),
                        this.dispatchEvent(this.removeBodyEvent);
                    }
                  }),
                  (n.prototype.removeBody = n.prototype.remove),
                  (n.prototype.addMaterial = function (t) {
                    this.materials.push(t);
                  }),
                  (n.prototype.addContactMaterial = function (t) {
                    this.contactmaterials.push(t),
                      this.contactMaterialTable.set(
                        t.materials[0].id,
                        t.materials[1].id,
                        t
                      );
                  }),
                  "undefined" == typeof performance && (performance = {}),
                  !performance.now)
                ) {
                  var x = Date.now();
                  performance.timing &&
                    performance.timing.navigationStart &&
                    (x = performance.timing.navigationStart),
                    (performance.now = function () {
                      return Date.now() - x;
                    });
                }
                var b = new r();
                n.prototype.step = function (t, e, n) {
                  if (((n = n || 10), 0 === (e = e || 0)))
                    this.internalStep(t), (this.time += t);
                  else {
                    var i =
                      Math.floor((this.time + e) / t) -
                      Math.floor(this.time / t);
                    i = Math.min(i, n);
                    for (
                      var r = performance.now(), o = 0;
                      o !== i &&
                      (this.internalStep(t),
                      !(performance.now() - r > 1e3 * t));
                      o++
                    );
                    this.time += e;
                    for (
                      var s = (this.time % t) / t,
                        a = b,
                        l = this.bodies,
                        c = 0;
                      c !== l.length;
                      c++
                    ) {
                      var u = l[c];
                      u.type !== d.STATIC && u.sleepState !== d.SLEEPING
                        ? (u.position.vsub(u.previousPosition, a),
                          a.scale(s, a),
                          u.position.vadd(a, u.interpolatedPosition))
                        : (u.interpolatedPosition.copy(u.position),
                          u.interpolatedQuaternion.copy(u.quaternion));
                    }
                  }
                };
                var w = { type: "postStep" },
                  _ = { type: "preStep" },
                  M = { type: "collide", body: null, contact: null },
                  S = [],
                  E = [],
                  T = [],
                  A = [],
                  C =
                    (new r(),
                    new r(),
                    new r(),
                    new r(),
                    new r(),
                    new r(),
                    new r(),
                    new r(),
                    new r(),
                    new o(),
                    new o()),
                  L = new o(),
                  R = new r();
                (n.prototype.internalStep = function (t) {
                  this.dt = t;
                  var e,
                    n = this.contacts,
                    r = T,
                    o = A,
                    s = this.numObjects(),
                    a = this.bodies,
                    l = this.solver,
                    c = this.gravity,
                    u = this.doProfiling,
                    h = this.profile,
                    p = d.DYNAMIC,
                    f = this.constraints,
                    m = E,
                    g = (c.norm(), c.x),
                    v = c.y,
                    y = c.z,
                    x = 0;
                  for (u && (e = performance.now()), x = 0; x !== s; x++)
                    if ((H = a[x]).type & p) {
                      var b = H.force,
                        P = H.mass;
                      (b.x += P * g), (b.y += P * v), (b.z += P * y);
                    }
                  x = 0;
                  for (var N = this.subsystems.length; x !== N; x++)
                    this.subsystems[x].update();
                  u && (e = performance.now()),
                    (r.length = 0),
                    (o.length = 0),
                    this.broadphase.collisionPairs(this, r, o),
                    u && (h.broadphase = performance.now() - e);
                  var I = f.length;
                  for (x = 0; x !== I; x++)
                    if (!(V = f[x]).collideConnected)
                      for (var B = r.length - 1; B >= 0; B -= 1)
                        ((V.bodyA === r[B] && V.bodyB === o[B]) ||
                          (V.bodyB === r[B] && V.bodyA === o[B])) &&
                          (r.splice(B, 1), o.splice(B, 1));
                  this.collisionMatrixTick(), u && (e = performance.now());
                  var O = S,
                    D = n.length;
                  for (x = 0; x !== D; x++) O.push(n[x]);
                  n.length = 0;
                  var k = this.frictionEquations.length;
                  for (x = 0; x !== k; x++) m.push(this.frictionEquations[x]);
                  for (
                    this.frictionEquations.length = 0,
                      this.narrowphase.getContacts(
                        r,
                        o,
                        this,
                        n,
                        O,
                        this.frictionEquations,
                        m
                      ),
                      u && (h.narrowphase = performance.now() - e),
                      u && (e = performance.now()),
                      x = 0;
                    x < this.frictionEquations.length;
                    x++
                  )
                    l.addEquation(this.frictionEquations[x]);
                  for (var F = n.length, z = 0; z !== F; z++) {
                    var H = (V = n[z]).bi,
                      U = V.bj;
                    V.si,
                      V.sj,
                      (
                        (H.material &&
                          U.material &&
                          this.getContactMaterial(H.material, U.material)) ||
                        this.defaultContactMaterial
                      ).friction,
                      H.material &&
                        U.material &&
                        (H.material.friction >= 0 &&
                          U.material.friction >= 0 &&
                          (H.material.friction, U.material.friction),
                        H.material.restitution >= 0 &&
                          U.material.restitution >= 0 &&
                          (V.restitution =
                            H.material.restitution * U.material.restitution)),
                      l.addEquation(V),
                      H.allowSleep &&
                        H.type === d.DYNAMIC &&
                        H.sleepState === d.SLEEPING &&
                        U.sleepState === d.AWAKE &&
                        U.type !== d.STATIC &&
                        U.velocity.norm2() + U.angularVelocity.norm2() >=
                          2 * Math.pow(U.sleepSpeedLimit, 2) &&
                        (H._wakeUpAfterNarrowphase = !0),
                      U.allowSleep &&
                        U.type === d.DYNAMIC &&
                        U.sleepState === d.SLEEPING &&
                        H.sleepState === d.AWAKE &&
                        H.type !== d.STATIC &&
                        H.velocity.norm2() + H.angularVelocity.norm2() >=
                          2 * Math.pow(H.sleepSpeedLimit, 2) &&
                        (U._wakeUpAfterNarrowphase = !0),
                      this.collisionMatrix.set(H, U, !0),
                      this.collisionMatrixPrevious.get(H, U) ||
                        ((M.body = U),
                        (M.contact = V),
                        H.dispatchEvent(M),
                        (M.body = H),
                        U.dispatchEvent(M));
                  }
                  for (
                    u &&
                      ((h.makeContactConstraints = performance.now() - e),
                      (e = performance.now())),
                      x = 0;
                    x !== s;
                    x++
                  )
                    (H = a[x])._wakeUpAfterNarrowphase &&
                      (H.wakeUp(), (H._wakeUpAfterNarrowphase = !1));
                  for (I = f.length, x = 0; x !== I; x++) {
                    var V;
                    (V = f[x]).update(), (B = 0);
                    for (var G = V.equations.length; B !== G; B++) {
                      var j = V.equations[B];
                      l.addEquation(j);
                    }
                  }
                  l.solve(t, this),
                    u && (h.solve = performance.now() - e),
                    l.removeAllEquations();
                  var W = Math.pow;
                  for (x = 0; x !== s; x++)
                    if ((H = a[x]).type & p) {
                      var q = W(1 - H.linearDamping, t),
                        X = H.velocity;
                      X.mult(q, X);
                      var Y = H.angularVelocity;
                      if (Y) {
                        var Z = W(1 - H.angularDamping, t);
                        Y.mult(Z, Y);
                      }
                    }
                  for (this.dispatchEvent(_), x = 0; x !== s; x++)
                    (H = a[x]).preStep && H.preStep.call(H);
                  u && (e = performance.now());
                  var J = C,
                    K = L,
                    Q = this.stepnumber,
                    $ = d.DYNAMIC | d.KINEMATIC,
                    tt = Q % (this.quatNormalizeSkip + 1) == 0,
                    et = this.quatNormalizeFast,
                    nt = 0.5 * t;
                  for (
                    i.types.PLANE, i.types.CONVEXPOLYHEDRON, x = 0;
                    x !== s;
                    x++
                  ) {
                    var it = a[x],
                      rt = it.force,
                      ot = it.torque;
                    if (it.type & $ && it.sleepState !== d.SLEEPING) {
                      var st = it.velocity,
                        at = it.angularVelocity,
                        lt = it.position,
                        ct = it.quaternion,
                        ut = it.invMass,
                        ht = it.invInertiaWorld;
                      (st.x += rt.x * ut * t),
                        (st.y += rt.y * ut * t),
                        (st.z += rt.z * ut * t),
                        it.angularVelocity &&
                          (ht.vmult(ot, R), R.mult(t, R), R.vadd(at, at)),
                        (lt.x += st.x * t),
                        (lt.y += st.y * t),
                        (lt.z += st.z * t),
                        it.angularVelocity &&
                          (J.set(at.x, at.y, at.z, 0),
                          J.mult(ct, K),
                          (ct.x += nt * K.x),
                          (ct.y += nt * K.y),
                          (ct.z += nt * K.z),
                          (ct.w += nt * K.w),
                          tt && (et ? ct.normalizeFast() : ct.normalize())),
                        it.aabb && (it.aabbNeedsUpdate = !0),
                        it.updateInertiaWorld && it.updateInertiaWorld();
                    }
                  }
                  for (
                    this.clearForces(),
                      this.broadphase.dirty = !0,
                      u && (h.integrate = performance.now() - e),
                      this.time += t,
                      this.stepnumber += 1,
                      this.dispatchEvent(w),
                      x = 0;
                    x !== s;
                    x++
                  ) {
                    var dt = (H = a[x]).postStep;
                    dt && dt.call(H);
                  }
                  if (this.allowSleep)
                    for (x = 0; x !== s; x++) a[x].sleepTick(this.time);
                }),
                  (n.prototype.clearForces = function () {
                    for (
                      var t = this.bodies, e = t.length, n = 0;
                      n !== e;
                      n++
                    ) {
                      var i = t[n];
                      i.force,
                        i.torque,
                        i.force.set(0, 0, 0),
                        i.torque.set(0, 0, 0);
                    }
                  });
              },
              {
                "../collision/AABB": 3,
                "../collision/ArrayCollisionMatrix": 4,
                "../collision/NaiveBroadphase": 7,
                "../collision/Ray": 9,
                "../collision/RaycastResult": 10,
                "../equations/ContactEquation": 19,
                "../equations/FrictionEquation": 21,
                "../material/ContactMaterial": 24,
                "../material/Material": 25,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/Body": 31,
                "../shapes/Shape": 43,
                "../solver/GSSolver": 46,
                "../utils/EventTarget": 49,
                "../utils/TupleDictionary": 52,
                "../utils/Vec3Pool": 54,
                "./Narrowphase": 55,
              },
            ],
          },
          {},
          [2]
        )(2);
      },
      191: function (t, e) {
        var n;
        !(function (e, n) {
          "use strict";
          "object" == typeof t.exports
            ? (t.exports = e.document
                ? n(e, !0)
                : function (t) {
                    if (!t.document)
                      throw new Error(
                        "jQuery requires a window with a document"
                      );
                    return n(t);
                  })
            : n(e);
        })("undefined" != typeof window ? window : this, function (i, r) {
          "use strict";
          var o = [],
            s = Object.getPrototypeOf,
            a = o.slice,
            l = o.flat
              ? function (t) {
                  return o.flat.call(t);
                }
              : function (t) {
                  return o.concat.apply([], t);
                },
            c = o.push,
            u = o.indexOf,
            h = {},
            d = h.toString,
            p = h.hasOwnProperty,
            f = p.toString,
            m = f.call(Object),
            g = {},
            v = function (t) {
              return (
                "function" == typeof t &&
                "number" != typeof t.nodeType &&
                "function" != typeof t.item
              );
            },
            y = function (t) {
              return null != t && t === t.window;
            },
            x = i.document,
            b = { type: !0, src: !0, nonce: !0, noModule: !0 };
          function w(t, e, n) {
            var i,
              r,
              o = (n = n || x).createElement("script");
            if (((o.text = t), e))
              for (i in b)
                (r = e[i] || (e.getAttribute && e.getAttribute(i))) &&
                  o.setAttribute(i, r);
            n.head.appendChild(o).parentNode.removeChild(o);
          }
          function _(t) {
            return null == t
              ? t + ""
              : "object" == typeof t || "function" == typeof t
              ? h[d.call(t)] || "object"
              : typeof t;
          }
          var M = "3.6.0",
            S = function (t, e) {
              return new S.fn.init(t, e);
            };
          function E(t) {
            var e = !!t && "length" in t && t.length,
              n = _(t);
            return (
              !v(t) &&
              !y(t) &&
              ("array" === n ||
                0 === e ||
                ("number" == typeof e && e > 0 && e - 1 in t))
            );
          }
          (S.fn = S.prototype =
            {
              jquery: M,
              constructor: S,
              length: 0,
              toArray: function () {
                return a.call(this);
              },
              get: function (t) {
                return null == t
                  ? a.call(this)
                  : t < 0
                  ? this[t + this.length]
                  : this[t];
              },
              pushStack: function (t) {
                var e = S.merge(this.constructor(), t);
                return (e.prevObject = this), e;
              },
              each: function (t) {
                return S.each(this, t);
              },
              map: function (t) {
                return this.pushStack(
                  S.map(this, function (e, n) {
                    return t.call(e, n, e);
                  })
                );
              },
              slice: function () {
                return this.pushStack(a.apply(this, arguments));
              },
              first: function () {
                return this.eq(0);
              },
              last: function () {
                return this.eq(-1);
              },
              even: function () {
                return this.pushStack(
                  S.grep(this, function (t, e) {
                    return (e + 1) % 2;
                  })
                );
              },
              odd: function () {
                return this.pushStack(
                  S.grep(this, function (t, e) {
                    return e % 2;
                  })
                );
              },
              eq: function (t) {
                var e = this.length,
                  n = +t + (t < 0 ? e : 0);
                return this.pushStack(n >= 0 && n < e ? [this[n]] : []);
              },
              end: function () {
                return this.prevObject || this.constructor();
              },
              push: c,
              sort: o.sort,
              splice: o.splice,
            }),
            (S.extend = S.fn.extend =
              function () {
                var t,
                  e,
                  n,
                  i,
                  r,
                  o,
                  s = arguments[0] || {},
                  a = 1,
                  l = arguments.length,
                  c = !1;
                for (
                  "boolean" == typeof s &&
                    ((c = s), (s = arguments[a] || {}), a++),
                    "object" == typeof s || v(s) || (s = {}),
                    a === l && ((s = this), a--);
                  a < l;
                  a++
                )
                  if (null != (t = arguments[a]))
                    for (e in t)
                      (i = t[e]),
                        "__proto__" !== e &&
                          s !== i &&
                          (c &&
                          i &&
                          (S.isPlainObject(i) || (r = Array.isArray(i)))
                            ? ((n = s[e]),
                              (o =
                                r && !Array.isArray(n)
                                  ? []
                                  : r || S.isPlainObject(n)
                                  ? n
                                  : {}),
                              (r = !1),
                              (s[e] = S.extend(c, o, i)))
                            : void 0 !== i && (s[e] = i));
                return s;
              }),
            S.extend({
              expando: "jQuery" + (M + Math.random()).replace(/\D/g, ""),
              isReady: !0,
              error: function (t) {
                throw new Error(t);
              },
              noop: function () {},
              isPlainObject: function (t) {
                var e, n;
                return !(
                  !t ||
                  "[object Object]" !== d.call(t) ||
                  ((e = s(t)) &&
                    ("function" !=
                      typeof (n = p.call(e, "constructor") && e.constructor) ||
                      f.call(n) !== m))
                );
              },
              isEmptyObject: function (t) {
                var e;
                for (e in t) return !1;
                return !0;
              },
              globalEval: function (t, e, n) {
                w(t, { nonce: e && e.nonce }, n);
              },
              each: function (t, e) {
                var n,
                  i = 0;
                if (E(t))
                  for (
                    n = t.length;
                    i < n && !1 !== e.call(t[i], i, t[i]);
                    i++
                  );
                else for (i in t) if (!1 === e.call(t[i], i, t[i])) break;
                return t;
              },
              makeArray: function (t, e) {
                var n = e || [];
                return (
                  null != t &&
                    (E(Object(t))
                      ? S.merge(n, "string" == typeof t ? [t] : t)
                      : c.call(n, t)),
                  n
                );
              },
              inArray: function (t, e, n) {
                return null == e ? -1 : u.call(e, t, n);
              },
              merge: function (t, e) {
                for (var n = +e.length, i = 0, r = t.length; i < n; i++)
                  t[r++] = e[i];
                return (t.length = r), t;
              },
              grep: function (t, e, n) {
                for (var i = [], r = 0, o = t.length, s = !n; r < o; r++)
                  !e(t[r], r) !== s && i.push(t[r]);
                return i;
              },
              map: function (t, e, n) {
                var i,
                  r,
                  o = 0,
                  s = [];
                if (E(t))
                  for (i = t.length; o < i; o++)
                    null != (r = e(t[o], o, n)) && s.push(r);
                else for (o in t) null != (r = e(t[o], o, n)) && s.push(r);
                return l(s);
              },
              guid: 1,
              support: g,
            }),
            "function" == typeof Symbol &&
              (S.fn[Symbol.iterator] = o[Symbol.iterator]),
            S.each(
              "Boolean Number String Function Array Date RegExp Object Error Symbol".split(
                " "
              ),
              function (t, e) {
                h["[object " + e + "]"] = e.toLowerCase();
              }
            );
          var T = (function (t) {
            var e,
              n,
              i,
              r,
              o,
              s,
              a,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m,
              g,
              v,
              y,
              x,
              b = "sizzle" + 1 * new Date(),
              w = t.document,
              _ = 0,
              M = 0,
              S = lt(),
              E = lt(),
              T = lt(),
              A = lt(),
              C = function (t, e) {
                return t === e && (h = !0), 0;
              },
              L = {}.hasOwnProperty,
              R = [],
              P = R.pop,
              N = R.push,
              I = R.push,
              B = R.slice,
              O = function (t, e) {
                for (var n = 0, i = t.length; n < i; n++)
                  if (t[n] === e) return n;
                return -1;
              },
              D =
                "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
              k = "[\\x20\\t\\r\\n\\f]",
              F =
                "(?:\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
              z =
                "\\[[\\x20\\t\\r\\n\\f]*(" +
                F +
                ")(?:" +
                k +
                "*([*^$|!~]?=)" +
                k +
                "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
                F +
                "))|)" +
                k +
                "*\\]",
              H =
                ":(" +
                F +
                ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" +
                z +
                ")*)|.*)\\)|)",
              U = new RegExp(k + "+", "g"),
              V = new RegExp(
                "^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$",
                "g"
              ),
              G = new RegExp("^[\\x20\\t\\r\\n\\f]*,[\\x20\\t\\r\\n\\f]*"),
              j = new RegExp(
                "^[\\x20\\t\\r\\n\\f]*([>+~]|[\\x20\\t\\r\\n\\f])[\\x20\\t\\r\\n\\f]*"
              ),
              W = new RegExp(k + "|>"),
              q = new RegExp(H),
              X = new RegExp("^" + F + "$"),
              Y = {
                ID: new RegExp("^#(" + F + ")"),
                CLASS: new RegExp("^\\.(" + F + ")"),
                TAG: new RegExp("^(" + F + "|[*])"),
                ATTR: new RegExp("^" + z),
                PSEUDO: new RegExp("^" + H),
                CHILD: new RegExp(
                  "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\([\\x20\\t\\r\\n\\f]*(even|odd|(([+-]|)(\\d*)n|)[\\x20\\t\\r\\n\\f]*(?:([+-]|)[\\x20\\t\\r\\n\\f]*(\\d+)|))[\\x20\\t\\r\\n\\f]*\\)|)",
                  "i"
                ),
                bool: new RegExp("^(?:" + D + ")$", "i"),
                needsContext: new RegExp(
                  "^[\\x20\\t\\r\\n\\f]*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\([\\x20\\t\\r\\n\\f]*((?:-\\d)?\\d*)[\\x20\\t\\r\\n\\f]*\\)|)(?=[^-]|$)",
                  "i"
                ),
              },
              Z = /HTML$/i,
              J = /^(?:input|select|textarea|button)$/i,
              K = /^h\d$/i,
              Q = /^[^{]+\{\s*\[native \w/,
              $ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
              tt = /[+~]/,
              et = new RegExp(
                "\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\([^\\r\\n\\f])",
                "g"
              ),
              nt = function (t, e) {
                var n = "0x" + t.slice(1) - 65536;
                return (
                  e ||
                  (n < 0
                    ? String.fromCharCode(n + 65536)
                    : String.fromCharCode(
                        (n >> 10) | 55296,
                        (1023 & n) | 56320
                      ))
                );
              },
              it = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
              rt = function (t, e) {
                return e
                  ? "\0" === t
                    ? "�"
                    : t.slice(0, -1) +
                      "\\" +
                      t.charCodeAt(t.length - 1).toString(16) +
                      " "
                  : "\\" + t;
              },
              ot = function () {
                d();
              },
              st = bt(
                function (t) {
                  return (
                    !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase()
                  );
                },
                { dir: "parentNode", next: "legend" }
              );
            try {
              I.apply((R = B.call(w.childNodes)), w.childNodes),
                R[w.childNodes.length].nodeType;
            } catch (t) {
              I = {
                apply: R.length
                  ? function (t, e) {
                      N.apply(t, B.call(e));
                    }
                  : function (t, e) {
                      for (var n = t.length, i = 0; (t[n++] = e[i++]); );
                      t.length = n - 1;
                    },
              };
            }
            function at(t, e, i, r) {
              var o,
                a,
                c,
                u,
                h,
                f,
                v,
                y = e && e.ownerDocument,
                w = e ? e.nodeType : 9;
              if (
                ((i = i || []),
                "string" != typeof t || !t || (1 !== w && 9 !== w && 11 !== w))
              )
                return i;
              if (!r && (d(e), (e = e || p), m)) {
                if (11 !== w && (h = $.exec(t)))
                  if ((o = h[1])) {
                    if (9 === w) {
                      if (!(c = e.getElementById(o))) return i;
                      if (c.id === o) return i.push(c), i;
                    } else if (
                      y &&
                      (c = y.getElementById(o)) &&
                      x(e, c) &&
                      c.id === o
                    )
                      return i.push(c), i;
                  } else {
                    if (h[2]) return I.apply(i, e.getElementsByTagName(t)), i;
                    if (
                      (o = h[3]) &&
                      n.getElementsByClassName &&
                      e.getElementsByClassName
                    )
                      return I.apply(i, e.getElementsByClassName(o)), i;
                  }
                if (
                  n.qsa &&
                  !A[t + " "] &&
                  (!g || !g.test(t)) &&
                  (1 !== w || "object" !== e.nodeName.toLowerCase())
                ) {
                  if (((v = t), (y = e), 1 === w && (W.test(t) || j.test(t)))) {
                    for (
                      ((y = (tt.test(t) && vt(e.parentNode)) || e) === e &&
                        n.scope) ||
                        ((u = e.getAttribute("id"))
                          ? (u = u.replace(it, rt))
                          : e.setAttribute("id", (u = b))),
                        a = (f = s(t)).length;
                      a--;

                    )
                      f[a] = (u ? "#" + u : ":scope") + " " + xt(f[a]);
                    v = f.join(",");
                  }
                  try {
                    return I.apply(i, y.querySelectorAll(v)), i;
                  } catch (e) {
                    A(t, !0);
                  } finally {
                    u === b && e.removeAttribute("id");
                  }
                }
              }
              return l(t.replace(V, "$1"), e, i, r);
            }
            function lt() {
              var t = [];
              return function e(n, r) {
                return (
                  t.push(n + " ") > i.cacheLength && delete e[t.shift()],
                  (e[n + " "] = r)
                );
              };
            }
            function ct(t) {
              return (t[b] = !0), t;
            }
            function ut(t) {
              var e = p.createElement("fieldset");
              try {
                return !!t(e);
              } catch (t) {
                return !1;
              } finally {
                e.parentNode && e.parentNode.removeChild(e), (e = null);
              }
            }
            function ht(t, e) {
              for (var n = t.split("|"), r = n.length; r--; )
                i.attrHandle[n[r]] = e;
            }
            function dt(t, e) {
              var n = e && t,
                i =
                  n &&
                  1 === t.nodeType &&
                  1 === e.nodeType &&
                  t.sourceIndex - e.sourceIndex;
              if (i) return i;
              if (n) for (; (n = n.nextSibling); ) if (n === e) return -1;
              return t ? 1 : -1;
            }
            function pt(t) {
              return function (e) {
                return "input" === e.nodeName.toLowerCase() && e.type === t;
              };
            }
            function ft(t) {
              return function (e) {
                var n = e.nodeName.toLowerCase();
                return ("input" === n || "button" === n) && e.type === t;
              };
            }
            function mt(t) {
              return function (e) {
                return "form" in e
                  ? e.parentNode && !1 === e.disabled
                    ? "label" in e
                      ? "label" in e.parentNode
                        ? e.parentNode.disabled === t
                        : e.disabled === t
                      : e.isDisabled === t ||
                        (e.isDisabled !== !t && st(e) === t)
                    : e.disabled === t
                  : "label" in e && e.disabled === t;
              };
            }
            function gt(t) {
              return ct(function (e) {
                return (
                  (e = +e),
                  ct(function (n, i) {
                    for (var r, o = t([], n.length, e), s = o.length; s--; )
                      n[(r = o[s])] && (n[r] = !(i[r] = n[r]));
                  })
                );
              });
            }
            function vt(t) {
              return t && void 0 !== t.getElementsByTagName && t;
            }
            for (e in ((n = at.support = {}),
            (o = at.isXML =
              function (t) {
                var e = t && t.namespaceURI,
                  n = t && (t.ownerDocument || t).documentElement;
                return !Z.test(e || (n && n.nodeName) || "HTML");
              }),
            (d = at.setDocument =
              function (t) {
                var e,
                  r,
                  s = t ? t.ownerDocument || t : w;
                return s != p && 9 === s.nodeType && s.documentElement
                  ? ((f = (p = s).documentElement),
                    (m = !o(p)),
                    w != p &&
                      (r = p.defaultView) &&
                      r.top !== r &&
                      (r.addEventListener
                        ? r.addEventListener("unload", ot, !1)
                        : r.attachEvent && r.attachEvent("onunload", ot)),
                    (n.scope = ut(function (t) {
                      return (
                        f.appendChild(t).appendChild(p.createElement("div")),
                        void 0 !== t.querySelectorAll &&
                          !t.querySelectorAll(":scope fieldset div").length
                      );
                    })),
                    (n.attributes = ut(function (t) {
                      return (t.className = "i"), !t.getAttribute("className");
                    })),
                    (n.getElementsByTagName = ut(function (t) {
                      return (
                        t.appendChild(p.createComment("")),
                        !t.getElementsByTagName("*").length
                      );
                    })),
                    (n.getElementsByClassName = Q.test(
                      p.getElementsByClassName
                    )),
                    (n.getById = ut(function (t) {
                      return (
                        (f.appendChild(t).id = b),
                        !p.getElementsByName || !p.getElementsByName(b).length
                      );
                    })),
                    n.getById
                      ? ((i.filter.ID = function (t) {
                          var e = t.replace(et, nt);
                          return function (t) {
                            return t.getAttribute("id") === e;
                          };
                        }),
                        (i.find.ID = function (t, e) {
                          if (void 0 !== e.getElementById && m) {
                            var n = e.getElementById(t);
                            return n ? [n] : [];
                          }
                        }))
                      : ((i.filter.ID = function (t) {
                          var e = t.replace(et, nt);
                          return function (t) {
                            var n =
                              void 0 !== t.getAttributeNode &&
                              t.getAttributeNode("id");
                            return n && n.value === e;
                          };
                        }),
                        (i.find.ID = function (t, e) {
                          if (void 0 !== e.getElementById && m) {
                            var n,
                              i,
                              r,
                              o = e.getElementById(t);
                            if (o) {
                              if (
                                (n = o.getAttributeNode("id")) &&
                                n.value === t
                              )
                                return [o];
                              for (
                                r = e.getElementsByName(t), i = 0;
                                (o = r[i++]);

                              )
                                if (
                                  (n = o.getAttributeNode("id")) &&
                                  n.value === t
                                )
                                  return [o];
                            }
                            return [];
                          }
                        })),
                    (i.find.TAG = n.getElementsByTagName
                      ? function (t, e) {
                          return void 0 !== e.getElementsByTagName
                            ? e.getElementsByTagName(t)
                            : n.qsa
                            ? e.querySelectorAll(t)
                            : void 0;
                        }
                      : function (t, e) {
                          var n,
                            i = [],
                            r = 0,
                            o = e.getElementsByTagName(t);
                          if ("*" === t) {
                            for (; (n = o[r++]); )
                              1 === n.nodeType && i.push(n);
                            return i;
                          }
                          return o;
                        }),
                    (i.find.CLASS =
                      n.getElementsByClassName &&
                      function (t, e) {
                        if (void 0 !== e.getElementsByClassName && m)
                          return e.getElementsByClassName(t);
                      }),
                    (v = []),
                    (g = []),
                    (n.qsa = Q.test(p.querySelectorAll)) &&
                      (ut(function (t) {
                        var e;
                        (f.appendChild(t).innerHTML =
                          "<a id='" +
                          b +
                          "'></a><select id='" +
                          b +
                          "-\r\\' msallowcapture=''><option selected=''></option></select>"),
                          t.querySelectorAll("[msallowcapture^='']").length &&
                            g.push("[*^$]=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"),
                          t.querySelectorAll("[selected]").length ||
                            g.push(
                              "\\[[\\x20\\t\\r\\n\\f]*(?:value|" + D + ")"
                            ),
                          t.querySelectorAll("[id~=" + b + "-]").length ||
                            g.push("~="),
                          (e = p.createElement("input")).setAttribute(
                            "name",
                            ""
                          ),
                          t.appendChild(e),
                          t.querySelectorAll("[name='']").length ||
                            g.push(
                              "\\[[\\x20\\t\\r\\n\\f]*name[\\x20\\t\\r\\n\\f]*=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"
                            ),
                          t.querySelectorAll(":checked").length ||
                            g.push(":checked"),
                          t.querySelectorAll("a#" + b + "+*").length ||
                            g.push(".#.+[+~]"),
                          t.querySelectorAll("\\\f"),
                          g.push("[\\r\\n\\f]");
                      }),
                      ut(function (t) {
                        t.innerHTML =
                          "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                        var e = p.createElement("input");
                        e.setAttribute("type", "hidden"),
                          t.appendChild(e).setAttribute("name", "D"),
                          t.querySelectorAll("[name=d]").length &&
                            g.push("name[\\x20\\t\\r\\n\\f]*[*^$|!~]?="),
                          2 !== t.querySelectorAll(":enabled").length &&
                            g.push(":enabled", ":disabled"),
                          (f.appendChild(t).disabled = !0),
                          2 !== t.querySelectorAll(":disabled").length &&
                            g.push(":enabled", ":disabled"),
                          t.querySelectorAll("*,:x"),
                          g.push(",.*:");
                      })),
                    (n.matchesSelector = Q.test(
                      (y =
                        f.matches ||
                        f.webkitMatchesSelector ||
                        f.mozMatchesSelector ||
                        f.oMatchesSelector ||
                        f.msMatchesSelector)
                    )) &&
                      ut(function (t) {
                        (n.disconnectedMatch = y.call(t, "*")),
                          y.call(t, "[s!='']:x"),
                          v.push("!=", H);
                      }),
                    (g = g.length && new RegExp(g.join("|"))),
                    (v = v.length && new RegExp(v.join("|"))),
                    (e = Q.test(f.compareDocumentPosition)),
                    (x =
                      e || Q.test(f.contains)
                        ? function (t, e) {
                            var n = 9 === t.nodeType ? t.documentElement : t,
                              i = e && e.parentNode;
                            return (
                              t === i ||
                              !(
                                !i ||
                                1 !== i.nodeType ||
                                !(n.contains
                                  ? n.contains(i)
                                  : t.compareDocumentPosition &&
                                    16 & t.compareDocumentPosition(i))
                              )
                            );
                          }
                        : function (t, e) {
                            if (e)
                              for (; (e = e.parentNode); )
                                if (e === t) return !0;
                            return !1;
                          }),
                    (C = e
                      ? function (t, e) {
                          if (t === e) return (h = !0), 0;
                          var i =
                            !t.compareDocumentPosition -
                            !e.compareDocumentPosition;
                          return (
                            i ||
                            (1 &
                              (i =
                                (t.ownerDocument || t) == (e.ownerDocument || e)
                                  ? t.compareDocumentPosition(e)
                                  : 1) ||
                            (!n.sortDetached &&
                              e.compareDocumentPosition(t) === i)
                              ? t == p || (t.ownerDocument == w && x(w, t))
                                ? -1
                                : e == p || (e.ownerDocument == w && x(w, e))
                                ? 1
                                : u
                                ? O(u, t) - O(u, e)
                                : 0
                              : 4 & i
                              ? -1
                              : 1)
                          );
                        }
                      : function (t, e) {
                          if (t === e) return (h = !0), 0;
                          var n,
                            i = 0,
                            r = t.parentNode,
                            o = e.parentNode,
                            s = [t],
                            a = [e];
                          if (!r || !o)
                            return t == p
                              ? -1
                              : e == p
                              ? 1
                              : r
                              ? -1
                              : o
                              ? 1
                              : u
                              ? O(u, t) - O(u, e)
                              : 0;
                          if (r === o) return dt(t, e);
                          for (n = t; (n = n.parentNode); ) s.unshift(n);
                          for (n = e; (n = n.parentNode); ) a.unshift(n);
                          for (; s[i] === a[i]; ) i++;
                          return i
                            ? dt(s[i], a[i])
                            : s[i] == w
                            ? -1
                            : a[i] == w
                            ? 1
                            : 0;
                        }),
                    p)
                  : p;
              }),
            (at.matches = function (t, e) {
              return at(t, null, null, e);
            }),
            (at.matchesSelector = function (t, e) {
              if (
                (d(t),
                n.matchesSelector &&
                  m &&
                  !A[e + " "] &&
                  (!v || !v.test(e)) &&
                  (!g || !g.test(e)))
              )
                try {
                  var i = y.call(t, e);
                  if (
                    i ||
                    n.disconnectedMatch ||
                    (t.document && 11 !== t.document.nodeType)
                  )
                    return i;
                } catch (t) {
                  A(e, !0);
                }
              return at(e, p, null, [t]).length > 0;
            }),
            (at.contains = function (t, e) {
              return (t.ownerDocument || t) != p && d(t), x(t, e);
            }),
            (at.attr = function (t, e) {
              (t.ownerDocument || t) != p && d(t);
              var r = i.attrHandle[e.toLowerCase()],
                o =
                  r && L.call(i.attrHandle, e.toLowerCase())
                    ? r(t, e, !m)
                    : void 0;
              return void 0 !== o
                ? o
                : n.attributes || !m
                ? t.getAttribute(e)
                : (o = t.getAttributeNode(e)) && o.specified
                ? o.value
                : null;
            }),
            (at.escape = function (t) {
              return (t + "").replace(it, rt);
            }),
            (at.error = function (t) {
              throw new Error("Syntax error, unrecognized expression: " + t);
            }),
            (at.uniqueSort = function (t) {
              var e,
                i = [],
                r = 0,
                o = 0;
              if (
                ((h = !n.detectDuplicates),
                (u = !n.sortStable && t.slice(0)),
                t.sort(C),
                h)
              ) {
                for (; (e = t[o++]); ) e === t[o] && (r = i.push(o));
                for (; r--; ) t.splice(i[r], 1);
              }
              return (u = null), t;
            }),
            (r = at.getText =
              function (t) {
                var e,
                  n = "",
                  i = 0,
                  o = t.nodeType;
                if (o) {
                  if (1 === o || 9 === o || 11 === o) {
                    if ("string" == typeof t.textContent) return t.textContent;
                    for (t = t.firstChild; t; t = t.nextSibling) n += r(t);
                  } else if (3 === o || 4 === o) return t.nodeValue;
                } else for (; (e = t[i++]); ) n += r(e);
                return n;
              }),
            ((i = at.selectors =
              {
                cacheLength: 50,
                createPseudo: ct,
                match: Y,
                attrHandle: {},
                find: {},
                relative: {
                  ">": { dir: "parentNode", first: !0 },
                  " ": { dir: "parentNode" },
                  "+": { dir: "previousSibling", first: !0 },
                  "~": { dir: "previousSibling" },
                },
                preFilter: {
                  ATTR: function (t) {
                    return (
                      (t[1] = t[1].replace(et, nt)),
                      (t[3] = (t[3] || t[4] || t[5] || "").replace(et, nt)),
                      "~=" === t[2] && (t[3] = " " + t[3] + " "),
                      t.slice(0, 4)
                    );
                  },
                  CHILD: function (t) {
                    return (
                      (t[1] = t[1].toLowerCase()),
                      "nth" === t[1].slice(0, 3)
                        ? (t[3] || at.error(t[0]),
                          (t[4] = +(t[4]
                            ? t[5] + (t[6] || 1)
                            : 2 * ("even" === t[3] || "odd" === t[3]))),
                          (t[5] = +(t[7] + t[8] || "odd" === t[3])))
                        : t[3] && at.error(t[0]),
                      t
                    );
                  },
                  PSEUDO: function (t) {
                    var e,
                      n = !t[6] && t[2];
                    return Y.CHILD.test(t[0])
                      ? null
                      : (t[3]
                          ? (t[2] = t[4] || t[5] || "")
                          : n &&
                            q.test(n) &&
                            (e = s(n, !0)) &&
                            (e = n.indexOf(")", n.length - e) - n.length) &&
                            ((t[0] = t[0].slice(0, e)), (t[2] = n.slice(0, e))),
                        t.slice(0, 3));
                  },
                },
                filter: {
                  TAG: function (t) {
                    var e = t.replace(et, nt).toLowerCase();
                    return "*" === t
                      ? function () {
                          return !0;
                        }
                      : function (t) {
                          return t.nodeName && t.nodeName.toLowerCase() === e;
                        };
                  },
                  CLASS: function (t) {
                    var e = S[t + " "];
                    return (
                      e ||
                      ((e = new RegExp(
                        "(^|[\\x20\\t\\r\\n\\f])" + t + "(" + k + "|$)"
                      )) &&
                        S(t, function (t) {
                          return e.test(
                            ("string" == typeof t.className && t.className) ||
                              (void 0 !== t.getAttribute &&
                                t.getAttribute("class")) ||
                              ""
                          );
                        }))
                    );
                  },
                  ATTR: function (t, e, n) {
                    return function (i) {
                      var r = at.attr(i, t);
                      return null == r
                        ? "!=" === e
                        : !e ||
                            ((r += ""),
                            "=" === e
                              ? r === n
                              : "!=" === e
                              ? r !== n
                              : "^=" === e
                              ? n && 0 === r.indexOf(n)
                              : "*=" === e
                              ? n && r.indexOf(n) > -1
                              : "$=" === e
                              ? n && r.slice(-n.length) === n
                              : "~=" === e
                              ? (" " + r.replace(U, " ") + " ").indexOf(n) > -1
                              : "|=" === e &&
                                (r === n ||
                                  r.slice(0, n.length + 1) === n + "-"));
                    };
                  },
                  CHILD: function (t, e, n, i, r) {
                    var o = "nth" !== t.slice(0, 3),
                      s = "last" !== t.slice(-4),
                      a = "of-type" === e;
                    return 1 === i && 0 === r
                      ? function (t) {
                          return !!t.parentNode;
                        }
                      : function (e, n, l) {
                          var c,
                            u,
                            h,
                            d,
                            p,
                            f,
                            m = o !== s ? "nextSibling" : "previousSibling",
                            g = e.parentNode,
                            v = a && e.nodeName.toLowerCase(),
                            y = !l && !a,
                            x = !1;
                          if (g) {
                            if (o) {
                              for (; m; ) {
                                for (d = e; (d = d[m]); )
                                  if (
                                    a
                                      ? d.nodeName.toLowerCase() === v
                                      : 1 === d.nodeType
                                  )
                                    return !1;
                                f = m = "only" === t && !f && "nextSibling";
                              }
                              return !0;
                            }
                            if (
                              ((f = [s ? g.firstChild : g.lastChild]), s && y)
                            ) {
                              for (
                                x =
                                  (p =
                                    (c =
                                      (u =
                                        (h = (d = g)[b] || (d[b] = {}))[
                                          d.uniqueID
                                        ] || (h[d.uniqueID] = {}))[t] ||
                                      [])[0] === _ && c[1]) && c[2],
                                  d = p && g.childNodes[p];
                                (d =
                                  (++p && d && d[m]) || (x = p = 0) || f.pop());

                              )
                                if (1 === d.nodeType && ++x && d === e) {
                                  u[t] = [_, p, x];
                                  break;
                                }
                            } else if (
                              (y &&
                                (x = p =
                                  (c =
                                    (u =
                                      (h = (d = e)[b] || (d[b] = {}))[
                                        d.uniqueID
                                      ] || (h[d.uniqueID] = {}))[t] ||
                                    [])[0] === _ && c[1]),
                              !1 === x)
                            )
                              for (
                                ;
                                (d =
                                  (++p && d && d[m]) ||
                                  (x = p = 0) ||
                                  f.pop()) &&
                                ((a
                                  ? d.nodeName.toLowerCase() !== v
                                  : 1 !== d.nodeType) ||
                                  !++x ||
                                  (y &&
                                    ((u =
                                      (h = d[b] || (d[b] = {}))[d.uniqueID] ||
                                      (h[d.uniqueID] = {}))[t] = [_, x]),
                                  d !== e));

                              );
                            return (x -= r) === i || (x % i == 0 && x / i >= 0);
                          }
                        };
                  },
                  PSEUDO: function (t, e) {
                    var n,
                      r =
                        i.pseudos[t] ||
                        i.setFilters[t.toLowerCase()] ||
                        at.error("unsupported pseudo: " + t);
                    return r[b]
                      ? r(e)
                      : r.length > 1
                      ? ((n = [t, t, "", e]),
                        i.setFilters.hasOwnProperty(t.toLowerCase())
                          ? ct(function (t, n) {
                              for (var i, o = r(t, e), s = o.length; s--; )
                                t[(i = O(t, o[s]))] = !(n[i] = o[s]);
                            })
                          : function (t) {
                              return r(t, 0, n);
                            })
                      : r;
                  },
                },
                pseudos: {
                  not: ct(function (t) {
                    var e = [],
                      n = [],
                      i = a(t.replace(V, "$1"));
                    return i[b]
                      ? ct(function (t, e, n, r) {
                          for (
                            var o, s = i(t, null, r, []), a = t.length;
                            a--;

                          )
                            (o = s[a]) && (t[a] = !(e[a] = o));
                        })
                      : function (t, r, o) {
                          return (
                            (e[0] = t),
                            i(e, null, o, n),
                            (e[0] = null),
                            !n.pop()
                          );
                        };
                  }),
                  has: ct(function (t) {
                    return function (e) {
                      return at(t, e).length > 0;
                    };
                  }),
                  contains: ct(function (t) {
                    return (
                      (t = t.replace(et, nt)),
                      function (e) {
                        return (e.textContent || r(e)).indexOf(t) > -1;
                      }
                    );
                  }),
                  lang: ct(function (t) {
                    return (
                      X.test(t || "") || at.error("unsupported lang: " + t),
                      (t = t.replace(et, nt).toLowerCase()),
                      function (e) {
                        var n;
                        do {
                          if (
                            (n = m
                              ? e.lang
                              : e.getAttribute("xml:lang") ||
                                e.getAttribute("lang"))
                          )
                            return (
                              (n = n.toLowerCase()) === t ||
                              0 === n.indexOf(t + "-")
                            );
                        } while ((e = e.parentNode) && 1 === e.nodeType);
                        return !1;
                      }
                    );
                  }),
                  target: function (e) {
                    var n = t.location && t.location.hash;
                    return n && n.slice(1) === e.id;
                  },
                  root: function (t) {
                    return t === f;
                  },
                  focus: function (t) {
                    return (
                      t === p.activeElement &&
                      (!p.hasFocus || p.hasFocus()) &&
                      !!(t.type || t.href || ~t.tabIndex)
                    );
                  },
                  enabled: mt(!1),
                  disabled: mt(!0),
                  checked: function (t) {
                    var e = t.nodeName.toLowerCase();
                    return (
                      ("input" === e && !!t.checked) ||
                      ("option" === e && !!t.selected)
                    );
                  },
                  selected: function (t) {
                    return (
                      t.parentNode && t.parentNode.selectedIndex,
                      !0 === t.selected
                    );
                  },
                  empty: function (t) {
                    for (t = t.firstChild; t; t = t.nextSibling)
                      if (t.nodeType < 6) return !1;
                    return !0;
                  },
                  parent: function (t) {
                    return !i.pseudos.empty(t);
                  },
                  header: function (t) {
                    return K.test(t.nodeName);
                  },
                  input: function (t) {
                    return J.test(t.nodeName);
                  },
                  button: function (t) {
                    var e = t.nodeName.toLowerCase();
                    return (
                      ("input" === e && "button" === t.type) || "button" === e
                    );
                  },
                  text: function (t) {
                    var e;
                    return (
                      "input" === t.nodeName.toLowerCase() &&
                      "text" === t.type &&
                      (null == (e = t.getAttribute("type")) ||
                        "text" === e.toLowerCase())
                    );
                  },
                  first: gt(function () {
                    return [0];
                  }),
                  last: gt(function (t, e) {
                    return [e - 1];
                  }),
                  eq: gt(function (t, e, n) {
                    return [n < 0 ? n + e : n];
                  }),
                  even: gt(function (t, e) {
                    for (var n = 0; n < e; n += 2) t.push(n);
                    return t;
                  }),
                  odd: gt(function (t, e) {
                    for (var n = 1; n < e; n += 2) t.push(n);
                    return t;
                  }),
                  lt: gt(function (t, e, n) {
                    for (var i = n < 0 ? n + e : n > e ? e : n; --i >= 0; )
                      t.push(i);
                    return t;
                  }),
                  gt: gt(function (t, e, n) {
                    for (var i = n < 0 ? n + e : n; ++i < e; ) t.push(i);
                    return t;
                  }),
                },
              }).pseudos.nth = i.pseudos.eq),
            { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }))
              i.pseudos[e] = pt(e);
            for (e in { submit: !0, reset: !0 }) i.pseudos[e] = ft(e);
            function yt() {}
            function xt(t) {
              for (var e = 0, n = t.length, i = ""; e < n; e++) i += t[e].value;
              return i;
            }
            function bt(t, e, n) {
              var i = e.dir,
                r = e.next,
                o = r || i,
                s = n && "parentNode" === o,
                a = M++;
              return e.first
                ? function (e, n, r) {
                    for (; (e = e[i]); )
                      if (1 === e.nodeType || s) return t(e, n, r);
                    return !1;
                  }
                : function (e, n, l) {
                    var c,
                      u,
                      h,
                      d = [_, a];
                    if (l) {
                      for (; (e = e[i]); )
                        if ((1 === e.nodeType || s) && t(e, n, l)) return !0;
                    } else
                      for (; (e = e[i]); )
                        if (1 === e.nodeType || s)
                          if (
                            ((u =
                              (h = e[b] || (e[b] = {}))[e.uniqueID] ||
                              (h[e.uniqueID] = {})),
                            r && r === e.nodeName.toLowerCase())
                          )
                            e = e[i] || e;
                          else {
                            if ((c = u[o]) && c[0] === _ && c[1] === a)
                              return (d[2] = c[2]);
                            if (((u[o] = d), (d[2] = t(e, n, l)))) return !0;
                          }
                    return !1;
                  };
            }
            function wt(t) {
              return t.length > 1
                ? function (e, n, i) {
                    for (var r = t.length; r--; ) if (!t[r](e, n, i)) return !1;
                    return !0;
                  }
                : t[0];
            }
            function _t(t, e, n, i, r) {
              for (
                var o, s = [], a = 0, l = t.length, c = null != e;
                a < l;
                a++
              )
                (o = t[a]) &&
                  ((n && !n(o, i, r)) || (s.push(o), c && e.push(a)));
              return s;
            }
            function Mt(t, e, n, i, r, o) {
              return (
                i && !i[b] && (i = Mt(i)),
                r && !r[b] && (r = Mt(r, o)),
                ct(function (o, s, a, l) {
                  var c,
                    u,
                    h,
                    d = [],
                    p = [],
                    f = s.length,
                    m =
                      o ||
                      (function (t, e, n) {
                        for (var i = 0, r = e.length; i < r; i++)
                          at(t, e[i], n);
                        return n;
                      })(e || "*", a.nodeType ? [a] : a, []),
                    g = !t || (!o && e) ? m : _t(m, d, t, a, l),
                    v = n ? (r || (o ? t : f || i) ? [] : s) : g;
                  if ((n && n(g, v, a, l), i))
                    for (c = _t(v, p), i(c, [], a, l), u = c.length; u--; )
                      (h = c[u]) && (v[p[u]] = !(g[p[u]] = h));
                  if (o) {
                    if (r || t) {
                      if (r) {
                        for (c = [], u = v.length; u--; )
                          (h = v[u]) && c.push((g[u] = h));
                        r(null, (v = []), c, l);
                      }
                      for (u = v.length; u--; )
                        (h = v[u]) &&
                          (c = r ? O(o, h) : d[u]) > -1 &&
                          (o[c] = !(s[c] = h));
                    }
                  } else (v = _t(v === s ? v.splice(f, v.length) : v)), r ? r(null, s, v, l) : I.apply(s, v);
                })
              );
            }
            function St(t) {
              for (
                var e,
                  n,
                  r,
                  o = t.length,
                  s = i.relative[t[0].type],
                  a = s || i.relative[" "],
                  l = s ? 1 : 0,
                  u = bt(
                    function (t) {
                      return t === e;
                    },
                    a,
                    !0
                  ),
                  h = bt(
                    function (t) {
                      return O(e, t) > -1;
                    },
                    a,
                    !0
                  ),
                  d = [
                    function (t, n, i) {
                      var r =
                        (!s && (i || n !== c)) ||
                        ((e = n).nodeType ? u(t, n, i) : h(t, n, i));
                      return (e = null), r;
                    },
                  ];
                l < o;
                l++
              )
                if ((n = i.relative[t[l].type])) d = [bt(wt(d), n)];
                else {
                  if ((n = i.filter[t[l].type].apply(null, t[l].matches))[b]) {
                    for (r = ++l; r < o && !i.relative[t[r].type]; r++);
                    return Mt(
                      l > 1 && wt(d),
                      l > 1 &&
                        xt(
                          t
                            .slice(0, l - 1)
                            .concat({ value: " " === t[l - 2].type ? "*" : "" })
                        ).replace(V, "$1"),
                      n,
                      l < r && St(t.slice(l, r)),
                      r < o && St((t = t.slice(r))),
                      r < o && xt(t)
                    );
                  }
                  d.push(n);
                }
              return wt(d);
            }
            return (
              (yt.prototype = i.filters = i.pseudos),
              (i.setFilters = new yt()),
              (s = at.tokenize =
                function (t, e) {
                  var n,
                    r,
                    o,
                    s,
                    a,
                    l,
                    c,
                    u = E[t + " "];
                  if (u) return e ? 0 : u.slice(0);
                  for (a = t, l = [], c = i.preFilter; a; ) {
                    for (s in ((n && !(r = G.exec(a))) ||
                      (r && (a = a.slice(r[0].length) || a), l.push((o = []))),
                    (n = !1),
                    (r = j.exec(a)) &&
                      ((n = r.shift()),
                      o.push({ value: n, type: r[0].replace(V, " ") }),
                      (a = a.slice(n.length))),
                    i.filter))
                      !(r = Y[s].exec(a)) ||
                        (c[s] && !(r = c[s](r))) ||
                        ((n = r.shift()),
                        o.push({ value: n, type: s, matches: r }),
                        (a = a.slice(n.length)));
                    if (!n) break;
                  }
                  return e ? a.length : a ? at.error(t) : E(t, l).slice(0);
                }),
              (a = at.compile =
                function (t, e) {
                  var n,
                    r = [],
                    o = [],
                    a = T[t + " "];
                  if (!a) {
                    for (e || (e = s(t)), n = e.length; n--; )
                      (a = St(e[n]))[b] ? r.push(a) : o.push(a);
                    (a = T(
                      t,
                      (function (t, e) {
                        var n = e.length > 0,
                          r = t.length > 0,
                          o = function (o, s, a, l, u) {
                            var h,
                              f,
                              g,
                              v = 0,
                              y = "0",
                              x = o && [],
                              b = [],
                              w = c,
                              M = o || (r && i.find.TAG("*", u)),
                              S = (_ += null == w ? 1 : Math.random() || 0.1),
                              E = M.length;
                            for (
                              u && (c = s == p || s || u);
                              y !== E && null != (h = M[y]);
                              y++
                            ) {
                              if (r && h) {
                                for (
                                  f = 0,
                                    s ||
                                      h.ownerDocument == p ||
                                      (d(h), (a = !m));
                                  (g = t[f++]);

                                )
                                  if (g(h, s || p, a)) {
                                    l.push(h);
                                    break;
                                  }
                                u && (_ = S);
                              }
                              n && ((h = !g && h) && v--, o && x.push(h));
                            }
                            if (((v += y), n && y !== v)) {
                              for (f = 0; (g = e[f++]); ) g(x, b, s, a);
                              if (o) {
                                if (v > 0)
                                  for (; y--; )
                                    x[y] || b[y] || (b[y] = P.call(l));
                                b = _t(b);
                              }
                              I.apply(l, b),
                                u &&
                                  !o &&
                                  b.length > 0 &&
                                  v + e.length > 1 &&
                                  at.uniqueSort(l);
                            }
                            return u && ((_ = S), (c = w)), x;
                          };
                        return n ? ct(o) : o;
                      })(o, r)
                    )).selector = t;
                  }
                  return a;
                }),
              (l = at.select =
                function (t, e, n, r) {
                  var o,
                    l,
                    c,
                    u,
                    h,
                    d = "function" == typeof t && t,
                    p = !r && s((t = d.selector || t));
                  if (((n = n || []), 1 === p.length)) {
                    if (
                      (l = p[0] = p[0].slice(0)).length > 2 &&
                      "ID" === (c = l[0]).type &&
                      9 === e.nodeType &&
                      m &&
                      i.relative[l[1].type]
                    ) {
                      if (
                        !(e = (i.find.ID(c.matches[0].replace(et, nt), e) ||
                          [])[0])
                      )
                        return n;
                      d && (e = e.parentNode),
                        (t = t.slice(l.shift().value.length));
                    }
                    for (
                      o = Y.needsContext.test(t) ? 0 : l.length;
                      o-- && ((c = l[o]), !i.relative[(u = c.type)]);

                    )
                      if (
                        (h = i.find[u]) &&
                        (r = h(
                          c.matches[0].replace(et, nt),
                          (tt.test(l[0].type) && vt(e.parentNode)) || e
                        ))
                      ) {
                        if ((l.splice(o, 1), !(t = r.length && xt(l))))
                          return I.apply(n, r), n;
                        break;
                      }
                  }
                  return (
                    (d || a(t, p))(
                      r,
                      e,
                      !m,
                      n,
                      !e || (tt.test(t) && vt(e.parentNode)) || e
                    ),
                    n
                  );
                }),
              (n.sortStable = b.split("").sort(C).join("") === b),
              (n.detectDuplicates = !!h),
              d(),
              (n.sortDetached = ut(function (t) {
                return (
                  1 & t.compareDocumentPosition(p.createElement("fieldset"))
                );
              })),
              ut(function (t) {
                return (
                  (t.innerHTML = "<a href='#'></a>"),
                  "#" === t.firstChild.getAttribute("href")
                );
              }) ||
                ht("type|href|height|width", function (t, e, n) {
                  if (!n)
                    return t.getAttribute(
                      e,
                      "type" === e.toLowerCase() ? 1 : 2
                    );
                }),
              (n.attributes &&
                ut(function (t) {
                  return (
                    (t.innerHTML = "<input/>"),
                    t.firstChild.setAttribute("value", ""),
                    "" === t.firstChild.getAttribute("value")
                  );
                })) ||
                ht("value", function (t, e, n) {
                  if (!n && "input" === t.nodeName.toLowerCase())
                    return t.defaultValue;
                }),
              ut(function (t) {
                return null == t.getAttribute("disabled");
              }) ||
                ht(D, function (t, e, n) {
                  var i;
                  if (!n)
                    return !0 === t[e]
                      ? e.toLowerCase()
                      : (i = t.getAttributeNode(e)) && i.specified
                      ? i.value
                      : null;
                }),
              at
            );
          })(i);
          (S.find = T),
            (S.expr = T.selectors),
            (S.expr[":"] = S.expr.pseudos),
            (S.uniqueSort = S.unique = T.uniqueSort),
            (S.text = T.getText),
            (S.isXMLDoc = T.isXML),
            (S.contains = T.contains),
            (S.escapeSelector = T.escape);
          var A = function (t, e, n) {
              for (
                var i = [], r = void 0 !== n;
                (t = t[e]) && 9 !== t.nodeType;

              )
                if (1 === t.nodeType) {
                  if (r && S(t).is(n)) break;
                  i.push(t);
                }
              return i;
            },
            C = function (t, e) {
              for (var n = []; t; t = t.nextSibling)
                1 === t.nodeType && t !== e && n.push(t);
              return n;
            },
            L = S.expr.match.needsContext;
          function R(t, e) {
            return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase();
          }
          var P =
            /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
          function N(t, e, n) {
            return v(e)
              ? S.grep(t, function (t, i) {
                  return !!e.call(t, i, t) !== n;
                })
              : e.nodeType
              ? S.grep(t, function (t) {
                  return (t === e) !== n;
                })
              : "string" != typeof e
              ? S.grep(t, function (t) {
                  return u.call(e, t) > -1 !== n;
                })
              : S.filter(e, t, n);
          }
          (S.filter = function (t, e, n) {
            var i = e[0];
            return (
              n && (t = ":not(" + t + ")"),
              1 === e.length && 1 === i.nodeType
                ? S.find.matchesSelector(i, t)
                  ? [i]
                  : []
                : S.find.matches(
                    t,
                    S.grep(e, function (t) {
                      return 1 === t.nodeType;
                    })
                  )
            );
          }),
            S.fn.extend({
              find: function (t) {
                var e,
                  n,
                  i = this.length,
                  r = this;
                if ("string" != typeof t)
                  return this.pushStack(
                    S(t).filter(function () {
                      for (e = 0; e < i; e++)
                        if (S.contains(r[e], this)) return !0;
                    })
                  );
                for (n = this.pushStack([]), e = 0; e < i; e++)
                  S.find(t, r[e], n);
                return i > 1 ? S.uniqueSort(n) : n;
              },
              filter: function (t) {
                return this.pushStack(N(this, t || [], !1));
              },
              not: function (t) {
                return this.pushStack(N(this, t || [], !0));
              },
              is: function (t) {
                return !!N(
                  this,
                  "string" == typeof t && L.test(t) ? S(t) : t || [],
                  !1
                ).length;
              },
            });
          var I,
            B = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
          ((S.fn.init = function (t, e, n) {
            var i, r;
            if (!t) return this;
            if (((n = n || I), "string" == typeof t)) {
              if (
                !(i =
                  "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3
                    ? [null, t, null]
                    : B.exec(t)) ||
                (!i[1] && e)
              )
                return !e || e.jquery
                  ? (e || n).find(t)
                  : this.constructor(e).find(t);
              if (i[1]) {
                if (
                  ((e = e instanceof S ? e[0] : e),
                  S.merge(
                    this,
                    S.parseHTML(
                      i[1],
                      e && e.nodeType ? e.ownerDocument || e : x,
                      !0
                    )
                  ),
                  P.test(i[1]) && S.isPlainObject(e))
                )
                  for (i in e) v(this[i]) ? this[i](e[i]) : this.attr(i, e[i]);
                return this;
              }
              return (
                (r = x.getElementById(i[2])) &&
                  ((this[0] = r), (this.length = 1)),
                this
              );
            }
            return t.nodeType
              ? ((this[0] = t), (this.length = 1), this)
              : v(t)
              ? void 0 !== n.ready
                ? n.ready(t)
                : t(S)
              : S.makeArray(t, this);
          }).prototype = S.fn),
            (I = S(x));
          var O = /^(?:parents|prev(?:Until|All))/,
            D = { children: !0, contents: !0, next: !0, prev: !0 };
          function k(t, e) {
            for (; (t = t[e]) && 1 !== t.nodeType; );
            return t;
          }
          S.fn.extend({
            has: function (t) {
              var e = S(t, this),
                n = e.length;
              return this.filter(function () {
                for (var t = 0; t < n; t++)
                  if (S.contains(this, e[t])) return !0;
              });
            },
            closest: function (t, e) {
              var n,
                i = 0,
                r = this.length,
                o = [],
                s = "string" != typeof t && S(t);
              if (!L.test(t))
                for (; i < r; i++)
                  for (n = this[i]; n && n !== e; n = n.parentNode)
                    if (
                      n.nodeType < 11 &&
                      (s
                        ? s.index(n) > -1
                        : 1 === n.nodeType && S.find.matchesSelector(n, t))
                    ) {
                      o.push(n);
                      break;
                    }
              return this.pushStack(o.length > 1 ? S.uniqueSort(o) : o);
            },
            index: function (t) {
              return t
                ? "string" == typeof t
                  ? u.call(S(t), this[0])
                  : u.call(this, t.jquery ? t[0] : t)
                : this[0] && this[0].parentNode
                ? this.first().prevAll().length
                : -1;
            },
            add: function (t, e) {
              return this.pushStack(S.uniqueSort(S.merge(this.get(), S(t, e))));
            },
            addBack: function (t) {
              return this.add(
                null == t ? this.prevObject : this.prevObject.filter(t)
              );
            },
          }),
            S.each(
              {
                parent: function (t) {
                  var e = t.parentNode;
                  return e && 11 !== e.nodeType ? e : null;
                },
                parents: function (t) {
                  return A(t, "parentNode");
                },
                parentsUntil: function (t, e, n) {
                  return A(t, "parentNode", n);
                },
                next: function (t) {
                  return k(t, "nextSibling");
                },
                prev: function (t) {
                  return k(t, "previousSibling");
                },
                nextAll: function (t) {
                  return A(t, "nextSibling");
                },
                prevAll: function (t) {
                  return A(t, "previousSibling");
                },
                nextUntil: function (t, e, n) {
                  return A(t, "nextSibling", n);
                },
                prevUntil: function (t, e, n) {
                  return A(t, "previousSibling", n);
                },
                siblings: function (t) {
                  return C((t.parentNode || {}).firstChild, t);
                },
                children: function (t) {
                  return C(t.firstChild);
                },
                contents: function (t) {
                  return null != t.contentDocument && s(t.contentDocument)
                    ? t.contentDocument
                    : (R(t, "template") && (t = t.content || t),
                      S.merge([], t.childNodes));
                },
              },
              function (t, e) {
                S.fn[t] = function (n, i) {
                  var r = S.map(this, e, n);
                  return (
                    "Until" !== t.slice(-5) && (i = n),
                    i && "string" == typeof i && (r = S.filter(i, r)),
                    this.length > 1 &&
                      (D[t] || S.uniqueSort(r), O.test(t) && r.reverse()),
                    this.pushStack(r)
                  );
                };
              }
            );
          var F = /[^\x20\t\r\n\f]+/g;
          function z(t) {
            return t;
          }
          function H(t) {
            throw t;
          }
          function U(t, e, n, i) {
            var r;
            try {
              t && v((r = t.promise))
                ? r.call(t).done(e).fail(n)
                : t && v((r = t.then))
                ? r.call(t, e, n)
                : e.apply(void 0, [t].slice(i));
            } catch (t) {
              n.apply(void 0, [t]);
            }
          }
          (S.Callbacks = function (t) {
            t =
              "string" == typeof t
                ? (function (t) {
                    var e = {};
                    return (
                      S.each(t.match(F) || [], function (t, n) {
                        e[n] = !0;
                      }),
                      e
                    );
                  })(t)
                : S.extend({}, t);
            var e,
              n,
              i,
              r,
              o = [],
              s = [],
              a = -1,
              l = function () {
                for (r = r || t.once, i = e = !0; s.length; a = -1)
                  for (n = s.shift(); ++a < o.length; )
                    !1 === o[a].apply(n[0], n[1]) &&
                      t.stopOnFalse &&
                      ((a = o.length), (n = !1));
                t.memory || (n = !1), (e = !1), r && (o = n ? [] : "");
              },
              c = {
                add: function () {
                  return (
                    o &&
                      (n && !e && ((a = o.length - 1), s.push(n)),
                      (function e(n) {
                        S.each(n, function (n, i) {
                          v(i)
                            ? (t.unique && c.has(i)) || o.push(i)
                            : i && i.length && "string" !== _(i) && e(i);
                        });
                      })(arguments),
                      n && !e && l()),
                    this
                  );
                },
                remove: function () {
                  return (
                    S.each(arguments, function (t, e) {
                      for (var n; (n = S.inArray(e, o, n)) > -1; )
                        o.splice(n, 1), n <= a && a--;
                    }),
                    this
                  );
                },
                has: function (t) {
                  return t ? S.inArray(t, o) > -1 : o.length > 0;
                },
                empty: function () {
                  return o && (o = []), this;
                },
                disable: function () {
                  return (r = s = []), (o = n = ""), this;
                },
                disabled: function () {
                  return !o;
                },
                lock: function () {
                  return (r = s = []), n || e || (o = n = ""), this;
                },
                locked: function () {
                  return !!r;
                },
                fireWith: function (t, n) {
                  return (
                    r ||
                      ((n = [t, (n = n || []).slice ? n.slice() : n]),
                      s.push(n),
                      e || l()),
                    this
                  );
                },
                fire: function () {
                  return c.fireWith(this, arguments), this;
                },
                fired: function () {
                  return !!i;
                },
              };
            return c;
          }),
            S.extend({
              Deferred: function (t) {
                var e = [
                    [
                      "notify",
                      "progress",
                      S.Callbacks("memory"),
                      S.Callbacks("memory"),
                      2,
                    ],
                    [
                      "resolve",
                      "done",
                      S.Callbacks("once memory"),
                      S.Callbacks("once memory"),
                      0,
                      "resolved",
                    ],
                    [
                      "reject",
                      "fail",
                      S.Callbacks("once memory"),
                      S.Callbacks("once memory"),
                      1,
                      "rejected",
                    ],
                  ],
                  n = "pending",
                  r = {
                    state: function () {
                      return n;
                    },
                    always: function () {
                      return o.done(arguments).fail(arguments), this;
                    },
                    catch: function (t) {
                      return r.then(null, t);
                    },
                    pipe: function () {
                      var t = arguments;
                      return S.Deferred(function (n) {
                        S.each(e, function (e, i) {
                          var r = v(t[i[4]]) && t[i[4]];
                          o[i[1]](function () {
                            var t = r && r.apply(this, arguments);
                            t && v(t.promise)
                              ? t
                                  .promise()
                                  .progress(n.notify)
                                  .done(n.resolve)
                                  .fail(n.reject)
                              : n[i[0] + "With"](this, r ? [t] : arguments);
                          });
                        }),
                          (t = null);
                      }).promise();
                    },
                    then: function (t, n, r) {
                      var o = 0;
                      function s(t, e, n, r) {
                        return function () {
                          var a = this,
                            l = arguments,
                            c = function () {
                              var i, c;
                              if (!(t < o)) {
                                if ((i = n.apply(a, l)) === e.promise())
                                  throw new TypeError(
                                    "Thenable self-resolution"
                                  );
                                (c =
                                  i &&
                                  ("object" == typeof i ||
                                    "function" == typeof i) &&
                                  i.then),
                                  v(c)
                                    ? r
                                      ? c.call(i, s(o, e, z, r), s(o, e, H, r))
                                      : (o++,
                                        c.call(
                                          i,
                                          s(o, e, z, r),
                                          s(o, e, H, r),
                                          s(o, e, z, e.notifyWith)
                                        ))
                                    : (n !== z && ((a = void 0), (l = [i])),
                                      (r || e.resolveWith)(a, l));
                              }
                            },
                            u = r
                              ? c
                              : function () {
                                  try {
                                    c();
                                  } catch (i) {
                                    S.Deferred.exceptionHook &&
                                      S.Deferred.exceptionHook(i, u.stackTrace),
                                      t + 1 >= o &&
                                        (n !== H && ((a = void 0), (l = [i])),
                                        e.rejectWith(a, l));
                                  }
                                };
                          t
                            ? u()
                            : (S.Deferred.getStackHook &&
                                (u.stackTrace = S.Deferred.getStackHook()),
                              i.setTimeout(u));
                        };
                      }
                      return S.Deferred(function (i) {
                        e[0][3].add(s(0, i, v(r) ? r : z, i.notifyWith)),
                          e[1][3].add(s(0, i, v(t) ? t : z)),
                          e[2][3].add(s(0, i, v(n) ? n : H));
                      }).promise();
                    },
                    promise: function (t) {
                      return null != t ? S.extend(t, r) : r;
                    },
                  },
                  o = {};
                return (
                  S.each(e, function (t, i) {
                    var s = i[2],
                      a = i[5];
                    (r[i[1]] = s.add),
                      a &&
                        s.add(
                          function () {
                            n = a;
                          },
                          e[3 - t][2].disable,
                          e[3 - t][3].disable,
                          e[0][2].lock,
                          e[0][3].lock
                        ),
                      s.add(i[3].fire),
                      (o[i[0]] = function () {
                        return (
                          o[i[0] + "With"](
                            this === o ? void 0 : this,
                            arguments
                          ),
                          this
                        );
                      }),
                      (o[i[0] + "With"] = s.fireWith);
                  }),
                  r.promise(o),
                  t && t.call(o, o),
                  o
                );
              },
              when: function (t) {
                var e = arguments.length,
                  n = e,
                  i = Array(n),
                  r = a.call(arguments),
                  o = S.Deferred(),
                  s = function (t) {
                    return function (n) {
                      (i[t] = this),
                        (r[t] = arguments.length > 1 ? a.call(arguments) : n),
                        --e || o.resolveWith(i, r);
                    };
                  };
                if (
                  e <= 1 &&
                  (U(t, o.done(s(n)).resolve, o.reject, !e),
                  "pending" === o.state() || v(r[n] && r[n].then))
                )
                  return o.then();
                for (; n--; ) U(r[n], s(n), o.reject);
                return o.promise();
              },
            });
          var V = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
          (S.Deferred.exceptionHook = function (t, e) {
            i.console &&
              i.console.warn &&
              t &&
              V.test(t.name) &&
              i.console.warn(
                "jQuery.Deferred exception: " + t.message,
                t.stack,
                e
              );
          }),
            (S.readyException = function (t) {
              i.setTimeout(function () {
                throw t;
              });
            });
          var G = S.Deferred();
          function j() {
            x.removeEventListener("DOMContentLoaded", j),
              i.removeEventListener("load", j),
              S.ready();
          }
          (S.fn.ready = function (t) {
            return (
              G.then(t).catch(function (t) {
                S.readyException(t);
              }),
              this
            );
          }),
            S.extend({
              isReady: !1,
              readyWait: 1,
              ready: function (t) {
                (!0 === t ? --S.readyWait : S.isReady) ||
                  ((S.isReady = !0),
                  (!0 !== t && --S.readyWait > 0) || G.resolveWith(x, [S]));
              },
            }),
            (S.ready.then = G.then),
            "complete" === x.readyState ||
            ("loading" !== x.readyState && !x.documentElement.doScroll)
              ? i.setTimeout(S.ready)
              : (x.addEventListener("DOMContentLoaded", j),
                i.addEventListener("load", j));
          var W = function (t, e, n, i, r, o, s) {
              var a = 0,
                l = t.length,
                c = null == n;
              if ("object" === _(n))
                for (a in ((r = !0), n)) W(t, e, a, n[a], !0, o, s);
              else if (
                void 0 !== i &&
                ((r = !0),
                v(i) || (s = !0),
                c &&
                  (s
                    ? (e.call(t, i), (e = null))
                    : ((c = e),
                      (e = function (t, e, n) {
                        return c.call(S(t), n);
                      }))),
                e)
              )
                for (; a < l; a++)
                  e(t[a], n, s ? i : i.call(t[a], a, e(t[a], n)));
              return r ? t : c ? e.call(t) : l ? e(t[0], n) : o;
            },
            q = /^-ms-/,
            X = /-([a-z])/g;
          function Y(t, e) {
            return e.toUpperCase();
          }
          function Z(t) {
            return t.replace(q, "ms-").replace(X, Y);
          }
          var J = function (t) {
            return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType;
          };
          function K() {
            this.expando = S.expando + K.uid++;
          }
          (K.uid = 1),
            (K.prototype = {
              cache: function (t) {
                var e = t[this.expando];
                return (
                  e ||
                    ((e = {}),
                    J(t) &&
                      (t.nodeType
                        ? (t[this.expando] = e)
                        : Object.defineProperty(t, this.expando, {
                            value: e,
                            configurable: !0,
                          }))),
                  e
                );
              },
              set: function (t, e, n) {
                var i,
                  r = this.cache(t);
                if ("string" == typeof e) r[Z(e)] = n;
                else for (i in e) r[Z(i)] = e[i];
                return r;
              },
              get: function (t, e) {
                return void 0 === e
                  ? this.cache(t)
                  : t[this.expando] && t[this.expando][Z(e)];
              },
              access: function (t, e, n) {
                return void 0 === e ||
                  (e && "string" == typeof e && void 0 === n)
                  ? this.get(t, e)
                  : (this.set(t, e, n), void 0 !== n ? n : e);
              },
              remove: function (t, e) {
                var n,
                  i = t[this.expando];
                if (void 0 !== i) {
                  if (void 0 !== e) {
                    n = (e = Array.isArray(e)
                      ? e.map(Z)
                      : (e = Z(e)) in i
                      ? [e]
                      : e.match(F) || []).length;
                    for (; n--; ) delete i[e[n]];
                  }
                  (void 0 === e || S.isEmptyObject(i)) &&
                    (t.nodeType
                      ? (t[this.expando] = void 0)
                      : delete t[this.expando]);
                }
              },
              hasData: function (t) {
                var e = t[this.expando];
                return void 0 !== e && !S.isEmptyObject(e);
              },
            });
          var Q = new K(),
            $ = new K(),
            tt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            et = /[A-Z]/g;
          function nt(t, e, n) {
            var i;
            if (void 0 === n && 1 === t.nodeType)
              if (
                ((i = "data-" + e.replace(et, "-$&").toLowerCase()),
                "string" == typeof (n = t.getAttribute(i)))
              ) {
                try {
                  n = (function (t) {
                    return (
                      "true" === t ||
                      ("false" !== t &&
                        ("null" === t
                          ? null
                          : t === +t + ""
                          ? +t
                          : tt.test(t)
                          ? JSON.parse(t)
                          : t))
                    );
                  })(n);
                } catch (t) {}
                $.set(t, e, n);
              } else n = void 0;
            return n;
          }
          S.extend({
            hasData: function (t) {
              return $.hasData(t) || Q.hasData(t);
            },
            data: function (t, e, n) {
              return $.access(t, e, n);
            },
            removeData: function (t, e) {
              $.remove(t, e);
            },
            _data: function (t, e, n) {
              return Q.access(t, e, n);
            },
            _removeData: function (t, e) {
              Q.remove(t, e);
            },
          }),
            S.fn.extend({
              data: function (t, e) {
                var n,
                  i,
                  r,
                  o = this[0],
                  s = o && o.attributes;
                if (void 0 === t) {
                  if (
                    this.length &&
                    ((r = $.get(o)),
                    1 === o.nodeType && !Q.get(o, "hasDataAttrs"))
                  ) {
                    for (n = s.length; n--; )
                      s[n] &&
                        0 === (i = s[n].name).indexOf("data-") &&
                        ((i = Z(i.slice(5))), nt(o, i, r[i]));
                    Q.set(o, "hasDataAttrs", !0);
                  }
                  return r;
                }
                return "object" == typeof t
                  ? this.each(function () {
                      $.set(this, t);
                    })
                  : W(
                      this,
                      function (e) {
                        var n;
                        if (o && void 0 === e)
                          return void 0 !== (n = $.get(o, t)) ||
                            void 0 !== (n = nt(o, t))
                            ? n
                            : void 0;
                        this.each(function () {
                          $.set(this, t, e);
                        });
                      },
                      null,
                      e,
                      arguments.length > 1,
                      null,
                      !0
                    );
              },
              removeData: function (t) {
                return this.each(function () {
                  $.remove(this, t);
                });
              },
            }),
            S.extend({
              queue: function (t, e, n) {
                var i;
                if (t)
                  return (
                    (e = (e || "fx") + "queue"),
                    (i = Q.get(t, e)),
                    n &&
                      (!i || Array.isArray(n)
                        ? (i = Q.access(t, e, S.makeArray(n)))
                        : i.push(n)),
                    i || []
                  );
              },
              dequeue: function (t, e) {
                e = e || "fx";
                var n = S.queue(t, e),
                  i = n.length,
                  r = n.shift(),
                  o = S._queueHooks(t, e);
                "inprogress" === r && ((r = n.shift()), i--),
                  r &&
                    ("fx" === e && n.unshift("inprogress"),
                    delete o.stop,
                    r.call(
                      t,
                      function () {
                        S.dequeue(t, e);
                      },
                      o
                    )),
                  !i && o && o.empty.fire();
              },
              _queueHooks: function (t, e) {
                var n = e + "queueHooks";
                return (
                  Q.get(t, n) ||
                  Q.access(t, n, {
                    empty: S.Callbacks("once memory").add(function () {
                      Q.remove(t, [e + "queue", n]);
                    }),
                  })
                );
              },
            }),
            S.fn.extend({
              queue: function (t, e) {
                var n = 2;
                return (
                  "string" != typeof t && ((e = t), (t = "fx"), n--),
                  arguments.length < n
                    ? S.queue(this[0], t)
                    : void 0 === e
                    ? this
                    : this.each(function () {
                        var n = S.queue(this, t, e);
                        S._queueHooks(this, t),
                          "fx" === t &&
                            "inprogress" !== n[0] &&
                            S.dequeue(this, t);
                      })
                );
              },
              dequeue: function (t) {
                return this.each(function () {
                  S.dequeue(this, t);
                });
              },
              clearQueue: function (t) {
                return this.queue(t || "fx", []);
              },
              promise: function (t, e) {
                var n,
                  i = 1,
                  r = S.Deferred(),
                  o = this,
                  s = this.length,
                  a = function () {
                    --i || r.resolveWith(o, [o]);
                  };
                for (
                  "string" != typeof t && ((e = t), (t = void 0)),
                    t = t || "fx";
                  s--;

                )
                  (n = Q.get(o[s], t + "queueHooks")) &&
                    n.empty &&
                    (i++, n.empty.add(a));
                return a(), r.promise(e);
              },
            });
          var it = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            rt = new RegExp("^(?:([+-])=|)(" + it + ")([a-z%]*)$", "i"),
            ot = ["Top", "Right", "Bottom", "Left"],
            st = x.documentElement,
            at = function (t) {
              return S.contains(t.ownerDocument, t);
            },
            lt = { composed: !0 };
          st.getRootNode &&
            (at = function (t) {
              return (
                S.contains(t.ownerDocument, t) ||
                t.getRootNode(lt) === t.ownerDocument
              );
            });
          var ct = function (t, e) {
            return (
              "none" === (t = e || t).style.display ||
              ("" === t.style.display &&
                at(t) &&
                "none" === S.css(t, "display"))
            );
          };
          function ut(t, e, n, i) {
            var r,
              o,
              s = 20,
              a = i
                ? function () {
                    return i.cur();
                  }
                : function () {
                    return S.css(t, e, "");
                  },
              l = a(),
              c = (n && n[3]) || (S.cssNumber[e] ? "" : "px"),
              u =
                t.nodeType &&
                (S.cssNumber[e] || ("px" !== c && +l)) &&
                rt.exec(S.css(t, e));
            if (u && u[3] !== c) {
              for (l /= 2, c = c || u[3], u = +l || 1; s--; )
                S.style(t, e, u + c),
                  (1 - o) * (1 - (o = a() / l || 0.5)) <= 0 && (s = 0),
                  (u /= o);
              (u *= 2), S.style(t, e, u + c), (n = n || []);
            }
            return (
              n &&
                ((u = +u || +l || 0),
                (r = n[1] ? u + (n[1] + 1) * n[2] : +n[2]),
                i && ((i.unit = c), (i.start = u), (i.end = r))),
              r
            );
          }
          var ht = {};
          function dt(t) {
            var e,
              n = t.ownerDocument,
              i = t.nodeName,
              r = ht[i];
            return (
              r ||
              ((e = n.body.appendChild(n.createElement(i))),
              (r = S.css(e, "display")),
              e.parentNode.removeChild(e),
              "none" === r && (r = "block"),
              (ht[i] = r),
              r)
            );
          }
          function pt(t, e) {
            for (var n, i, r = [], o = 0, s = t.length; o < s; o++)
              (i = t[o]).style &&
                ((n = i.style.display),
                e
                  ? ("none" === n &&
                      ((r[o] = Q.get(i, "display") || null),
                      r[o] || (i.style.display = "")),
                    "" === i.style.display && ct(i) && (r[o] = dt(i)))
                  : "none" !== n && ((r[o] = "none"), Q.set(i, "display", n)));
            for (o = 0; o < s; o++) null != r[o] && (t[o].style.display = r[o]);
            return t;
          }
          S.fn.extend({
            show: function () {
              return pt(this, !0);
            },
            hide: function () {
              return pt(this);
            },
            toggle: function (t) {
              return "boolean" == typeof t
                ? t
                  ? this.show()
                  : this.hide()
                : this.each(function () {
                    ct(this) ? S(this).show() : S(this).hide();
                  });
            },
          });
          var ft,
            mt,
            gt = /^(?:checkbox|radio)$/i,
            vt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
            yt = /^$|^module$|\/(?:java|ecma)script/i;
          (ft = x.createDocumentFragment().appendChild(x.createElement("div"))),
            (mt = x.createElement("input")).setAttribute("type", "radio"),
            mt.setAttribute("checked", "checked"),
            mt.setAttribute("name", "t"),
            ft.appendChild(mt),
            (g.checkClone = ft.cloneNode(!0).cloneNode(!0).lastChild.checked),
            (ft.innerHTML = "<textarea>x</textarea>"),
            (g.noCloneChecked = !!ft.cloneNode(!0).lastChild.defaultValue),
            (ft.innerHTML = "<option></option>"),
            (g.option = !!ft.lastChild);
          var xt = {
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""],
          };
          function bt(t, e) {
            var n;
            return (
              (n =
                void 0 !== t.getElementsByTagName
                  ? t.getElementsByTagName(e || "*")
                  : void 0 !== t.querySelectorAll
                  ? t.querySelectorAll(e || "*")
                  : []),
              void 0 === e || (e && R(t, e)) ? S.merge([t], n) : n
            );
          }
          function wt(t, e) {
            for (var n = 0, i = t.length; n < i; n++)
              Q.set(t[n], "globalEval", !e || Q.get(e[n], "globalEval"));
          }
          (xt.tbody = xt.tfoot = xt.colgroup = xt.caption = xt.thead),
            (xt.th = xt.td),
            g.option ||
              (xt.optgroup = xt.option =
                [1, "<select multiple='multiple'>", "</select>"]);
          var _t = /<|&#?\w+;/;
          function Mt(t, e, n, i, r) {
            for (
              var o,
                s,
                a,
                l,
                c,
                u,
                h = e.createDocumentFragment(),
                d = [],
                p = 0,
                f = t.length;
              p < f;
              p++
            )
              if ((o = t[p]) || 0 === o)
                if ("object" === _(o)) S.merge(d, o.nodeType ? [o] : o);
                else if (_t.test(o)) {
                  for (
                    s = s || h.appendChild(e.createElement("div")),
                      a = (vt.exec(o) || ["", ""])[1].toLowerCase(),
                      l = xt[a] || xt._default,
                      s.innerHTML = l[1] + S.htmlPrefilter(o) + l[2],
                      u = l[0];
                    u--;

                  )
                    s = s.lastChild;
                  S.merge(d, s.childNodes),
                    ((s = h.firstChild).textContent = "");
                } else d.push(e.createTextNode(o));
            for (h.textContent = "", p = 0; (o = d[p++]); )
              if (i && S.inArray(o, i) > -1) r && r.push(o);
              else if (
                ((c = at(o)),
                (s = bt(h.appendChild(o), "script")),
                c && wt(s),
                n)
              )
                for (u = 0; (o = s[u++]); ) yt.test(o.type || "") && n.push(o);
            return h;
          }
          var St = /^([^.]*)(?:\.(.+)|)/;
          function Et() {
            return !0;
          }
          function Tt() {
            return !1;
          }
          function At(t, e) {
            return (
              (t ===
                (function () {
                  try {
                    return x.activeElement;
                  } catch (t) {}
                })()) ==
              ("focus" === e)
            );
          }
          function Ct(t, e, n, i, r, o) {
            var s, a;
            if ("object" == typeof e) {
              for (a in ("string" != typeof n && ((i = i || n), (n = void 0)),
              e))
                Ct(t, a, n, i, e[a], o);
              return t;
            }
            if (
              (null == i && null == r
                ? ((r = n), (i = n = void 0))
                : null == r &&
                  ("string" == typeof n
                    ? ((r = i), (i = void 0))
                    : ((r = i), (i = n), (n = void 0))),
              !1 === r)
            )
              r = Tt;
            else if (!r) return t;
            return (
              1 === o &&
                ((s = r),
                ((r = function (t) {
                  return S().off(t), s.apply(this, arguments);
                }).guid = s.guid || (s.guid = S.guid++))),
              t.each(function () {
                S.event.add(this, e, r, i, n);
              })
            );
          }
          function Lt(t, e, n) {
            n
              ? (Q.set(t, e, !1),
                S.event.add(t, e, {
                  namespace: !1,
                  handler: function (t) {
                    var i,
                      r,
                      o = Q.get(this, e);
                    if (1 & t.isTrigger && this[e]) {
                      if (o.length)
                        (S.event.special[e] || {}).delegateType &&
                          t.stopPropagation();
                      else if (
                        ((o = a.call(arguments)),
                        Q.set(this, e, o),
                        (i = n(this, e)),
                        this[e](),
                        o !== (r = Q.get(this, e)) || i
                          ? Q.set(this, e, !1)
                          : (r = {}),
                        o !== r)
                      )
                        return (
                          t.stopImmediatePropagation(),
                          t.preventDefault(),
                          r && r.value
                        );
                    } else
                      o.length &&
                        (Q.set(this, e, {
                          value: S.event.trigger(
                            S.extend(o[0], S.Event.prototype),
                            o.slice(1),
                            this
                          ),
                        }),
                        t.stopImmediatePropagation());
                  },
                }))
              : void 0 === Q.get(t, e) && S.event.add(t, e, Et);
          }
          (S.event = {
            global: {},
            add: function (t, e, n, i, r) {
              var o,
                s,
                a,
                l,
                c,
                u,
                h,
                d,
                p,
                f,
                m,
                g = Q.get(t);
              if (J(t))
                for (
                  n.handler && ((n = (o = n).handler), (r = o.selector)),
                    r && S.find.matchesSelector(st, r),
                    n.guid || (n.guid = S.guid++),
                    (l = g.events) || (l = g.events = Object.create(null)),
                    (s = g.handle) ||
                      (s = g.handle =
                        function (e) {
                          return void 0 !== S && S.event.triggered !== e.type
                            ? S.event.dispatch.apply(t, arguments)
                            : void 0;
                        }),
                    c = (e = (e || "").match(F) || [""]).length;
                  c--;

                )
                  (p = m = (a = St.exec(e[c]) || [])[1]),
                    (f = (a[2] || "").split(".").sort()),
                    p &&
                      ((h = S.event.special[p] || {}),
                      (p = (r ? h.delegateType : h.bindType) || p),
                      (h = S.event.special[p] || {}),
                      (u = S.extend(
                        {
                          type: p,
                          origType: m,
                          data: i,
                          handler: n,
                          guid: n.guid,
                          selector: r,
                          needsContext: r && S.expr.match.needsContext.test(r),
                          namespace: f.join("."),
                        },
                        o
                      )),
                      (d = l[p]) ||
                        (((d = l[p] = []).delegateCount = 0),
                        (h.setup && !1 !== h.setup.call(t, i, f, s)) ||
                          (t.addEventListener && t.addEventListener(p, s))),
                      h.add &&
                        (h.add.call(t, u),
                        u.handler.guid || (u.handler.guid = n.guid)),
                      r ? d.splice(d.delegateCount++, 0, u) : d.push(u),
                      (S.event.global[p] = !0));
            },
            remove: function (t, e, n, i, r) {
              var o,
                s,
                a,
                l,
                c,
                u,
                h,
                d,
                p,
                f,
                m,
                g = Q.hasData(t) && Q.get(t);
              if (g && (l = g.events)) {
                for (c = (e = (e || "").match(F) || [""]).length; c--; )
                  if (
                    ((p = m = (a = St.exec(e[c]) || [])[1]),
                    (f = (a[2] || "").split(".").sort()),
                    p)
                  ) {
                    for (
                      h = S.event.special[p] || {},
                        d =
                          l[(p = (i ? h.delegateType : h.bindType) || p)] || [],
                        a =
                          a[2] &&
                          new RegExp(
                            "(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"
                          ),
                        s = o = d.length;
                      o--;

                    )
                      (u = d[o]),
                        (!r && m !== u.origType) ||
                          (n && n.guid !== u.guid) ||
                          (a && !a.test(u.namespace)) ||
                          (i &&
                            i !== u.selector &&
                            ("**" !== i || !u.selector)) ||
                          (d.splice(o, 1),
                          u.selector && d.delegateCount--,
                          h.remove && h.remove.call(t, u));
                    s &&
                      !d.length &&
                      ((h.teardown && !1 !== h.teardown.call(t, f, g.handle)) ||
                        S.removeEvent(t, p, g.handle),
                      delete l[p]);
                  } else for (p in l) S.event.remove(t, p + e[c], n, i, !0);
                S.isEmptyObject(l) && Q.remove(t, "handle events");
              }
            },
            dispatch: function (t) {
              var e,
                n,
                i,
                r,
                o,
                s,
                a = new Array(arguments.length),
                l = S.event.fix(t),
                c =
                  (Q.get(this, "events") || Object.create(null))[l.type] || [],
                u = S.event.special[l.type] || {};
              for (a[0] = l, e = 1; e < arguments.length; e++)
                a[e] = arguments[e];
              if (
                ((l.delegateTarget = this),
                !u.preDispatch || !1 !== u.preDispatch.call(this, l))
              ) {
                for (
                  s = S.event.handlers.call(this, l, c), e = 0;
                  (r = s[e++]) && !l.isPropagationStopped();

                )
                  for (
                    l.currentTarget = r.elem, n = 0;
                    (o = r.handlers[n++]) && !l.isImmediatePropagationStopped();

                  )
                    (l.rnamespace &&
                      !1 !== o.namespace &&
                      !l.rnamespace.test(o.namespace)) ||
                      ((l.handleObj = o),
                      (l.data = o.data),
                      void 0 !==
                        (i = (
                          (S.event.special[o.origType] || {}).handle ||
                          o.handler
                        ).apply(r.elem, a)) &&
                        !1 === (l.result = i) &&
                        (l.preventDefault(), l.stopPropagation()));
                return u.postDispatch && u.postDispatch.call(this, l), l.result;
              }
            },
            handlers: function (t, e) {
              var n,
                i,
                r,
                o,
                s,
                a = [],
                l = e.delegateCount,
                c = t.target;
              if (l && c.nodeType && !("click" === t.type && t.button >= 1))
                for (; c !== this; c = c.parentNode || this)
                  if (
                    1 === c.nodeType &&
                    ("click" !== t.type || !0 !== c.disabled)
                  ) {
                    for (o = [], s = {}, n = 0; n < l; n++)
                      void 0 === s[(r = (i = e[n]).selector + " ")] &&
                        (s[r] = i.needsContext
                          ? S(r, this).index(c) > -1
                          : S.find(r, this, null, [c]).length),
                        s[r] && o.push(i);
                    o.length && a.push({ elem: c, handlers: o });
                  }
              return (
                (c = this),
                l < e.length && a.push({ elem: c, handlers: e.slice(l) }),
                a
              );
            },
            addProp: function (t, e) {
              Object.defineProperty(S.Event.prototype, t, {
                enumerable: !0,
                configurable: !0,
                get: v(e)
                  ? function () {
                      if (this.originalEvent) return e(this.originalEvent);
                    }
                  : function () {
                      if (this.originalEvent) return this.originalEvent[t];
                    },
                set: function (e) {
                  Object.defineProperty(this, t, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: e,
                  });
                },
              });
            },
            fix: function (t) {
              return t[S.expando] ? t : new S.Event(t);
            },
            special: {
              load: { noBubble: !0 },
              click: {
                setup: function (t) {
                  var e = this || t;
                  return (
                    gt.test(e.type) &&
                      e.click &&
                      R(e, "input") &&
                      Lt(e, "click", Et),
                    !1
                  );
                },
                trigger: function (t) {
                  var e = this || t;
                  return (
                    gt.test(e.type) &&
                      e.click &&
                      R(e, "input") &&
                      Lt(e, "click"),
                    !0
                  );
                },
                _default: function (t) {
                  var e = t.target;
                  return (
                    (gt.test(e.type) &&
                      e.click &&
                      R(e, "input") &&
                      Q.get(e, "click")) ||
                    R(e, "a")
                  );
                },
              },
              beforeunload: {
                postDispatch: function (t) {
                  void 0 !== t.result &&
                    t.originalEvent &&
                    (t.originalEvent.returnValue = t.result);
                },
              },
            },
          }),
            (S.removeEvent = function (t, e, n) {
              t.removeEventListener && t.removeEventListener(e, n);
            }),
            (S.Event = function (t, e) {
              if (!(this instanceof S.Event)) return new S.Event(t, e);
              t && t.type
                ? ((this.originalEvent = t),
                  (this.type = t.type),
                  (this.isDefaultPrevented =
                    t.defaultPrevented ||
                    (void 0 === t.defaultPrevented && !1 === t.returnValue)
                      ? Et
                      : Tt),
                  (this.target =
                    t.target && 3 === t.target.nodeType
                      ? t.target.parentNode
                      : t.target),
                  (this.currentTarget = t.currentTarget),
                  (this.relatedTarget = t.relatedTarget))
                : (this.type = t),
                e && S.extend(this, e),
                (this.timeStamp = (t && t.timeStamp) || Date.now()),
                (this[S.expando] = !0);
            }),
            (S.Event.prototype = {
              constructor: S.Event,
              isDefaultPrevented: Tt,
              isPropagationStopped: Tt,
              isImmediatePropagationStopped: Tt,
              isSimulated: !1,
              preventDefault: function () {
                var t = this.originalEvent;
                (this.isDefaultPrevented = Et),
                  t && !this.isSimulated && t.preventDefault();
              },
              stopPropagation: function () {
                var t = this.originalEvent;
                (this.isPropagationStopped = Et),
                  t && !this.isSimulated && t.stopPropagation();
              },
              stopImmediatePropagation: function () {
                var t = this.originalEvent;
                (this.isImmediatePropagationStopped = Et),
                  t && !this.isSimulated && t.stopImmediatePropagation(),
                  this.stopPropagation();
              },
            }),
            S.each(
              {
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                char: !0,
                code: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: !0,
              },
              S.event.addProp
            ),
            S.each({ focus: "focusin", blur: "focusout" }, function (t, e) {
              S.event.special[t] = {
                setup: function () {
                  return Lt(this, t, At), !1;
                },
                trigger: function () {
                  return Lt(this, t), !0;
                },
                _default: function () {
                  return !0;
                },
                delegateType: e,
              };
            }),
            S.each(
              {
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout",
              },
              function (t, e) {
                S.event.special[t] = {
                  delegateType: e,
                  bindType: e,
                  handle: function (t) {
                    var n,
                      i = this,
                      r = t.relatedTarget,
                      o = t.handleObj;
                    return (
                      (r && (r === i || S.contains(i, r))) ||
                        ((t.type = o.origType),
                        (n = o.handler.apply(this, arguments)),
                        (t.type = e)),
                      n
                    );
                  },
                };
              }
            ),
            S.fn.extend({
              on: function (t, e, n, i) {
                return Ct(this, t, e, n, i);
              },
              one: function (t, e, n, i) {
                return Ct(this, t, e, n, i, 1);
              },
              off: function (t, e, n) {
                var i, r;
                if (t && t.preventDefault && t.handleObj)
                  return (
                    (i = t.handleObj),
                    S(t.delegateTarget).off(
                      i.namespace ? i.origType + "." + i.namespace : i.origType,
                      i.selector,
                      i.handler
                    ),
                    this
                  );
                if ("object" == typeof t) {
                  for (r in t) this.off(r, e, t[r]);
                  return this;
                }
                return (
                  (!1 !== e && "function" != typeof e) ||
                    ((n = e), (e = void 0)),
                  !1 === n && (n = Tt),
                  this.each(function () {
                    S.event.remove(this, t, n, e);
                  })
                );
              },
            });
          var Rt = /<script|<style|<link/i,
            Pt = /checked\s*(?:[^=]|=\s*.checked.)/i,
            Nt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
          function It(t, e) {
            return (
              (R(t, "table") &&
                R(11 !== e.nodeType ? e : e.firstChild, "tr") &&
                S(t).children("tbody")[0]) ||
              t
            );
          }
          function Bt(t) {
            return (
              (t.type = (null !== t.getAttribute("type")) + "/" + t.type), t
            );
          }
          function Ot(t) {
            return (
              "true/" === (t.type || "").slice(0, 5)
                ? (t.type = t.type.slice(5))
                : t.removeAttribute("type"),
              t
            );
          }
          function Dt(t, e) {
            var n, i, r, o, s, a;
            if (1 === e.nodeType) {
              if (Q.hasData(t) && (a = Q.get(t).events))
                for (r in (Q.remove(e, "handle events"), a))
                  for (n = 0, i = a[r].length; n < i; n++)
                    S.event.add(e, r, a[r][n]);
              $.hasData(t) &&
                ((o = $.access(t)), (s = S.extend({}, o)), $.set(e, s));
            }
          }
          function kt(t, e) {
            var n = e.nodeName.toLowerCase();
            "input" === n && gt.test(t.type)
              ? (e.checked = t.checked)
              : ("input" !== n && "textarea" !== n) ||
                (e.defaultValue = t.defaultValue);
          }
          function Ft(t, e, n, i) {
            e = l(e);
            var r,
              o,
              s,
              a,
              c,
              u,
              h = 0,
              d = t.length,
              p = d - 1,
              f = e[0],
              m = v(f);
            if (
              m ||
              (d > 1 && "string" == typeof f && !g.checkClone && Pt.test(f))
            )
              return t.each(function (r) {
                var o = t.eq(r);
                m && (e[0] = f.call(this, r, o.html())), Ft(o, e, n, i);
              });
            if (
              d &&
              ((o = (r = Mt(e, t[0].ownerDocument, !1, t, i)).firstChild),
              1 === r.childNodes.length && (r = o),
              o || i)
            ) {
              for (a = (s = S.map(bt(r, "script"), Bt)).length; h < d; h++)
                (c = r),
                  h !== p &&
                    ((c = S.clone(c, !0, !0)),
                    a && S.merge(s, bt(c, "script"))),
                  n.call(t[h], c, h);
              if (a)
                for (
                  u = s[s.length - 1].ownerDocument, S.map(s, Ot), h = 0;
                  h < a;
                  h++
                )
                  (c = s[h]),
                    yt.test(c.type || "") &&
                      !Q.access(c, "globalEval") &&
                      S.contains(u, c) &&
                      (c.src && "module" !== (c.type || "").toLowerCase()
                        ? S._evalUrl &&
                          !c.noModule &&
                          S._evalUrl(
                            c.src,
                            { nonce: c.nonce || c.getAttribute("nonce") },
                            u
                          )
                        : w(c.textContent.replace(Nt, ""), c, u));
            }
            return t;
          }
          function zt(t, e, n) {
            for (
              var i, r = e ? S.filter(e, t) : t, o = 0;
              null != (i = r[o]);
              o++
            )
              n || 1 !== i.nodeType || S.cleanData(bt(i)),
                i.parentNode &&
                  (n && at(i) && wt(bt(i, "script")),
                  i.parentNode.removeChild(i));
            return t;
          }
          S.extend({
            htmlPrefilter: function (t) {
              return t;
            },
            clone: function (t, e, n) {
              var i,
                r,
                o,
                s,
                a = t.cloneNode(!0),
                l = at(t);
              if (
                !(
                  g.noCloneChecked ||
                  (1 !== t.nodeType && 11 !== t.nodeType) ||
                  S.isXMLDoc(t)
                )
              )
                for (s = bt(a), i = 0, r = (o = bt(t)).length; i < r; i++)
                  kt(o[i], s[i]);
              if (e)
                if (n)
                  for (
                    o = o || bt(t), s = s || bt(a), i = 0, r = o.length;
                    i < r;
                    i++
                  )
                    Dt(o[i], s[i]);
                else Dt(t, a);
              return (
                (s = bt(a, "script")).length > 0 &&
                  wt(s, !l && bt(t, "script")),
                a
              );
            },
            cleanData: function (t) {
              for (
                var e, n, i, r = S.event.special, o = 0;
                void 0 !== (n = t[o]);
                o++
              )
                if (J(n)) {
                  if ((e = n[Q.expando])) {
                    if (e.events)
                      for (i in e.events)
                        r[i]
                          ? S.event.remove(n, i)
                          : S.removeEvent(n, i, e.handle);
                    n[Q.expando] = void 0;
                  }
                  n[$.expando] && (n[$.expando] = void 0);
                }
            },
          }),
            S.fn.extend({
              detach: function (t) {
                return zt(this, t, !0);
              },
              remove: function (t) {
                return zt(this, t);
              },
              text: function (t) {
                return W(
                  this,
                  function (t) {
                    return void 0 === t
                      ? S.text(this)
                      : this.empty().each(function () {
                          (1 !== this.nodeType &&
                            11 !== this.nodeType &&
                            9 !== this.nodeType) ||
                            (this.textContent = t);
                        });
                  },
                  null,
                  t,
                  arguments.length
                );
              },
              append: function () {
                return Ft(this, arguments, function (t) {
                  (1 !== this.nodeType &&
                    11 !== this.nodeType &&
                    9 !== this.nodeType) ||
                    It(this, t).appendChild(t);
                });
              },
              prepend: function () {
                return Ft(this, arguments, function (t) {
                  if (
                    1 === this.nodeType ||
                    11 === this.nodeType ||
                    9 === this.nodeType
                  ) {
                    var e = It(this, t);
                    e.insertBefore(t, e.firstChild);
                  }
                });
              },
              before: function () {
                return Ft(this, arguments, function (t) {
                  this.parentNode && this.parentNode.insertBefore(t, this);
                });
              },
              after: function () {
                return Ft(this, arguments, function (t) {
                  this.parentNode &&
                    this.parentNode.insertBefore(t, this.nextSibling);
                });
              },
              empty: function () {
                for (var t, e = 0; null != (t = this[e]); e++)
                  1 === t.nodeType &&
                    (S.cleanData(bt(t, !1)), (t.textContent = ""));
                return this;
              },
              clone: function (t, e) {
                return (
                  (t = null != t && t),
                  (e = null == e ? t : e),
                  this.map(function () {
                    return S.clone(this, t, e);
                  })
                );
              },
              html: function (t) {
                return W(
                  this,
                  function (t) {
                    var e = this[0] || {},
                      n = 0,
                      i = this.length;
                    if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
                    if (
                      "string" == typeof t &&
                      !Rt.test(t) &&
                      !xt[(vt.exec(t) || ["", ""])[1].toLowerCase()]
                    ) {
                      t = S.htmlPrefilter(t);
                      try {
                        for (; n < i; n++)
                          1 === (e = this[n] || {}).nodeType &&
                            (S.cleanData(bt(e, !1)), (e.innerHTML = t));
                        e = 0;
                      } catch (t) {}
                    }
                    e && this.empty().append(t);
                  },
                  null,
                  t,
                  arguments.length
                );
              },
              replaceWith: function () {
                var t = [];
                return Ft(
                  this,
                  arguments,
                  function (e) {
                    var n = this.parentNode;
                    S.inArray(this, t) < 0 &&
                      (S.cleanData(bt(this)), n && n.replaceChild(e, this));
                  },
                  t
                );
              },
            }),
            S.each(
              {
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith",
              },
              function (t, e) {
                S.fn[t] = function (t) {
                  for (
                    var n, i = [], r = S(t), o = r.length - 1, s = 0;
                    s <= o;
                    s++
                  )
                    (n = s === o ? this : this.clone(!0)),
                      S(r[s])[e](n),
                      c.apply(i, n.get());
                  return this.pushStack(i);
                };
              }
            );
          var Ht = new RegExp("^(" + it + ")(?!px)[a-z%]+$", "i"),
            Ut = function (t) {
              var e = t.ownerDocument.defaultView;
              return (e && e.opener) || (e = i), e.getComputedStyle(t);
            },
            Vt = function (t, e, n) {
              var i,
                r,
                o = {};
              for (r in e) (o[r] = t.style[r]), (t.style[r] = e[r]);
              for (r in ((i = n.call(t)), e)) t.style[r] = o[r];
              return i;
            },
            Gt = new RegExp(ot.join("|"), "i");
          function jt(t, e, n) {
            var i,
              r,
              o,
              s,
              a = t.style;
            return (
              (n = n || Ut(t)) &&
                ("" !== (s = n.getPropertyValue(e) || n[e]) ||
                  at(t) ||
                  (s = S.style(t, e)),
                !g.pixelBoxStyles() &&
                  Ht.test(s) &&
                  Gt.test(e) &&
                  ((i = a.width),
                  (r = a.minWidth),
                  (o = a.maxWidth),
                  (a.minWidth = a.maxWidth = a.width = s),
                  (s = n.width),
                  (a.width = i),
                  (a.minWidth = r),
                  (a.maxWidth = o))),
              void 0 !== s ? s + "" : s
            );
          }
          function Wt(t, e) {
            return {
              get: function () {
                if (!t()) return (this.get = e).apply(this, arguments);
                delete this.get;
              },
            };
          }
          !(function () {
            function t() {
              if (u) {
                (c.style.cssText =
                  "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0"),
                  (u.style.cssText =
                    "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%"),
                  st.appendChild(c).appendChild(u);
                var t = i.getComputedStyle(u);
                (n = "1%" !== t.top),
                  (l = 12 === e(t.marginLeft)),
                  (u.style.right = "60%"),
                  (s = 36 === e(t.right)),
                  (r = 36 === e(t.width)),
                  (u.style.position = "absolute"),
                  (o = 12 === e(u.offsetWidth / 3)),
                  st.removeChild(c),
                  (u = null);
              }
            }
            function e(t) {
              return Math.round(parseFloat(t));
            }
            var n,
              r,
              o,
              s,
              a,
              l,
              c = x.createElement("div"),
              u = x.createElement("div");
            u.style &&
              ((u.style.backgroundClip = "content-box"),
              (u.cloneNode(!0).style.backgroundClip = ""),
              (g.clearCloneStyle = "content-box" === u.style.backgroundClip),
              S.extend(g, {
                boxSizingReliable: function () {
                  return t(), r;
                },
                pixelBoxStyles: function () {
                  return t(), s;
                },
                pixelPosition: function () {
                  return t(), n;
                },
                reliableMarginLeft: function () {
                  return t(), l;
                },
                scrollboxSize: function () {
                  return t(), o;
                },
                reliableTrDimensions: function () {
                  var t, e, n, r;
                  return (
                    null == a &&
                      ((t = x.createElement("table")),
                      (e = x.createElement("tr")),
                      (n = x.createElement("div")),
                      (t.style.cssText =
                        "position:absolute;left:-11111px;border-collapse:separate"),
                      (e.style.cssText = "border:1px solid"),
                      (e.style.height = "1px"),
                      (n.style.height = "9px"),
                      (n.style.display = "block"),
                      st.appendChild(t).appendChild(e).appendChild(n),
                      (r = i.getComputedStyle(e)),
                      (a =
                        parseInt(r.height, 10) +
                          parseInt(r.borderTopWidth, 10) +
                          parseInt(r.borderBottomWidth, 10) ===
                        e.offsetHeight),
                      st.removeChild(t)),
                    a
                  );
                },
              }));
          })();
          var qt = ["Webkit", "Moz", "ms"],
            Xt = x.createElement("div").style,
            Yt = {};
          function Zt(t) {
            return (
              S.cssProps[t] ||
              Yt[t] ||
              (t in Xt
                ? t
                : (Yt[t] =
                    (function (t) {
                      for (
                        var e = t[0].toUpperCase() + t.slice(1), n = qt.length;
                        n--;

                      )
                        if ((t = qt[n] + e) in Xt) return t;
                    })(t) || t))
            );
          }
          var Jt = /^(none|table(?!-c[ea]).+)/,
            Kt = /^--/,
            Qt = {
              position: "absolute",
              visibility: "hidden",
              display: "block",
            },
            $t = { letterSpacing: "0", fontWeight: "400" };
          function te(t, e, n) {
            var i = rt.exec(e);
            return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : e;
          }
          function ee(t, e, n, i, r, o) {
            var s = "width" === e ? 1 : 0,
              a = 0,
              l = 0;
            if (n === (i ? "border" : "content")) return 0;
            for (; s < 4; s += 2)
              "margin" === n && (l += S.css(t, n + ot[s], !0, r)),
                i
                  ? ("content" === n &&
                      (l -= S.css(t, "padding" + ot[s], !0, r)),
                    "margin" !== n &&
                      (l -= S.css(t, "border" + ot[s] + "Width", !0, r)))
                  : ((l += S.css(t, "padding" + ot[s], !0, r)),
                    "padding" !== n
                      ? (l += S.css(t, "border" + ot[s] + "Width", !0, r))
                      : (a += S.css(t, "border" + ot[s] + "Width", !0, r)));
            return (
              !i &&
                o >= 0 &&
                (l +=
                  Math.max(
                    0,
                    Math.ceil(
                      t["offset" + e[0].toUpperCase() + e.slice(1)] -
                        o -
                        l -
                        a -
                        0.5
                    )
                  ) || 0),
              l
            );
          }
          function ne(t, e, n) {
            var i = Ut(t),
              r =
                (!g.boxSizingReliable() || n) &&
                "border-box" === S.css(t, "boxSizing", !1, i),
              o = r,
              s = jt(t, e, i),
              a = "offset" + e[0].toUpperCase() + e.slice(1);
            if (Ht.test(s)) {
              if (!n) return s;
              s = "auto";
            }
            return (
              ((!g.boxSizingReliable() && r) ||
                (!g.reliableTrDimensions() && R(t, "tr")) ||
                "auto" === s ||
                (!parseFloat(s) && "inline" === S.css(t, "display", !1, i))) &&
                t.getClientRects().length &&
                ((r = "border-box" === S.css(t, "boxSizing", !1, i)),
                (o = a in t) && (s = t[a])),
              (s = parseFloat(s) || 0) +
                ee(t, e, n || (r ? "border" : "content"), o, i, s) +
                "px"
            );
          }
          function ie(t, e, n, i, r) {
            return new ie.prototype.init(t, e, n, i, r);
          }
          S.extend({
            cssHooks: {
              opacity: {
                get: function (t, e) {
                  if (e) {
                    var n = jt(t, "opacity");
                    return "" === n ? "1" : n;
                  }
                },
              },
            },
            cssNumber: {
              animationIterationCount: !0,
              columnCount: !0,
              fillOpacity: !0,
              flexGrow: !0,
              flexShrink: !0,
              fontWeight: !0,
              gridArea: !0,
              gridColumn: !0,
              gridColumnEnd: !0,
              gridColumnStart: !0,
              gridRow: !0,
              gridRowEnd: !0,
              gridRowStart: !0,
              lineHeight: !0,
              opacity: !0,
              order: !0,
              orphans: !0,
              widows: !0,
              zIndex: !0,
              zoom: !0,
            },
            cssProps: {},
            style: function (t, e, n, i) {
              if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                var r,
                  o,
                  s,
                  a = Z(e),
                  l = Kt.test(e),
                  c = t.style;
                if (
                  (l || (e = Zt(a)),
                  (s = S.cssHooks[e] || S.cssHooks[a]),
                  void 0 === n)
                )
                  return s && "get" in s && void 0 !== (r = s.get(t, !1, i))
                    ? r
                    : c[e];
                "string" == (o = typeof n) &&
                  (r = rt.exec(n)) &&
                  r[1] &&
                  ((n = ut(t, e, r)), (o = "number")),
                  null != n &&
                    n == n &&
                    ("number" !== o ||
                      l ||
                      (n += (r && r[3]) || (S.cssNumber[a] ? "" : "px")),
                    g.clearCloneStyle ||
                      "" !== n ||
                      0 !== e.indexOf("background") ||
                      (c[e] = "inherit"),
                    (s && "set" in s && void 0 === (n = s.set(t, n, i))) ||
                      (l ? c.setProperty(e, n) : (c[e] = n)));
              }
            },
            css: function (t, e, n, i) {
              var r,
                o,
                s,
                a = Z(e);
              return (
                Kt.test(e) || (e = Zt(a)),
                (s = S.cssHooks[e] || S.cssHooks[a]) &&
                  "get" in s &&
                  (r = s.get(t, !0, n)),
                void 0 === r && (r = jt(t, e, i)),
                "normal" === r && e in $t && (r = $t[e]),
                "" === n || n
                  ? ((o = parseFloat(r)), !0 === n || isFinite(o) ? o || 0 : r)
                  : r
              );
            },
          }),
            S.each(["height", "width"], function (t, e) {
              S.cssHooks[e] = {
                get: function (t, n, i) {
                  if (n)
                    return !Jt.test(S.css(t, "display")) ||
                      (t.getClientRects().length &&
                        t.getBoundingClientRect().width)
                      ? ne(t, e, i)
                      : Vt(t, Qt, function () {
                          return ne(t, e, i);
                        });
                },
                set: function (t, n, i) {
                  var r,
                    o = Ut(t),
                    s = !g.scrollboxSize() && "absolute" === o.position,
                    a =
                      (s || i) && "border-box" === S.css(t, "boxSizing", !1, o),
                    l = i ? ee(t, e, i, a, o) : 0;
                  return (
                    a &&
                      s &&
                      (l -= Math.ceil(
                        t["offset" + e[0].toUpperCase() + e.slice(1)] -
                          parseFloat(o[e]) -
                          ee(t, e, "border", !1, o) -
                          0.5
                      )),
                    l &&
                      (r = rt.exec(n)) &&
                      "px" !== (r[3] || "px") &&
                      ((t.style[e] = n), (n = S.css(t, e))),
                    te(0, n, l)
                  );
                },
              };
            }),
            (S.cssHooks.marginLeft = Wt(g.reliableMarginLeft, function (t, e) {
              if (e)
                return (
                  (parseFloat(jt(t, "marginLeft")) ||
                    t.getBoundingClientRect().left -
                      Vt(t, { marginLeft: 0 }, function () {
                        return t.getBoundingClientRect().left;
                      })) + "px"
                );
            })),
            S.each(
              { margin: "", padding: "", border: "Width" },
              function (t, e) {
                (S.cssHooks[t + e] = {
                  expand: function (n) {
                    for (
                      var i = 0,
                        r = {},
                        o = "string" == typeof n ? n.split(" ") : [n];
                      i < 4;
                      i++
                    )
                      r[t + ot[i] + e] = o[i] || o[i - 2] || o[0];
                    return r;
                  },
                }),
                  "margin" !== t && (S.cssHooks[t + e].set = te);
              }
            ),
            S.fn.extend({
              css: function (t, e) {
                return W(
                  this,
                  function (t, e, n) {
                    var i,
                      r,
                      o = {},
                      s = 0;
                    if (Array.isArray(e)) {
                      for (i = Ut(t), r = e.length; s < r; s++)
                        o[e[s]] = S.css(t, e[s], !1, i);
                      return o;
                    }
                    return void 0 !== n ? S.style(t, e, n) : S.css(t, e);
                  },
                  t,
                  e,
                  arguments.length > 1
                );
              },
            }),
            (S.Tween = ie),
            (ie.prototype = {
              constructor: ie,
              init: function (t, e, n, i, r, o) {
                (this.elem = t),
                  (this.prop = n),
                  (this.easing = r || S.easing._default),
                  (this.options = e),
                  (this.start = this.now = this.cur()),
                  (this.end = i),
                  (this.unit = o || (S.cssNumber[n] ? "" : "px"));
              },
              cur: function () {
                var t = ie.propHooks[this.prop];
                return t && t.get
                  ? t.get(this)
                  : ie.propHooks._default.get(this);
              },
              run: function (t) {
                var e,
                  n = ie.propHooks[this.prop];
                return (
                  this.options.duration
                    ? (this.pos = e =
                        S.easing[this.easing](
                          t,
                          this.options.duration * t,
                          0,
                          1,
                          this.options.duration
                        ))
                    : (this.pos = e = t),
                  (this.now = (this.end - this.start) * e + this.start),
                  this.options.step &&
                    this.options.step.call(this.elem, this.now, this),
                  n && n.set ? n.set(this) : ie.propHooks._default.set(this),
                  this
                );
              },
            }),
            (ie.prototype.init.prototype = ie.prototype),
            (ie.propHooks = {
              _default: {
                get: function (t) {
                  var e;
                  return 1 !== t.elem.nodeType ||
                    (null != t.elem[t.prop] && null == t.elem.style[t.prop])
                    ? t.elem[t.prop]
                    : (e = S.css(t.elem, t.prop, "")) && "auto" !== e
                    ? e
                    : 0;
                },
                set: function (t) {
                  S.fx.step[t.prop]
                    ? S.fx.step[t.prop](t)
                    : 1 !== t.elem.nodeType ||
                      (!S.cssHooks[t.prop] && null == t.elem.style[Zt(t.prop)])
                    ? (t.elem[t.prop] = t.now)
                    : S.style(t.elem, t.prop, t.now + t.unit);
                },
              },
            }),
            (ie.propHooks.scrollTop = ie.propHooks.scrollLeft =
              {
                set: function (t) {
                  t.elem.nodeType &&
                    t.elem.parentNode &&
                    (t.elem[t.prop] = t.now);
                },
              }),
            (S.easing = {
              linear: function (t) {
                return t;
              },
              swing: function (t) {
                return 0.5 - Math.cos(t * Math.PI) / 2;
              },
              _default: "swing",
            }),
            (S.fx = ie.prototype.init),
            (S.fx.step = {});
          var re,
            oe,
            se = /^(?:toggle|show|hide)$/,
            ae = /queueHooks$/;
          function le() {
            oe &&
              (!1 === x.hidden && i.requestAnimationFrame
                ? i.requestAnimationFrame(le)
                : i.setTimeout(le, S.fx.interval),
              S.fx.tick());
          }
          function ce() {
            return (
              i.setTimeout(function () {
                re = void 0;
              }),
              (re = Date.now())
            );
          }
          function ue(t, e) {
            var n,
              i = 0,
              r = { height: t };
            for (e = e ? 1 : 0; i < 4; i += 2 - e)
              r["margin" + (n = ot[i])] = r["padding" + n] = t;
            return e && (r.opacity = r.width = t), r;
          }
          function he(t, e, n) {
            for (
              var i,
                r = (de.tweeners[e] || []).concat(de.tweeners["*"]),
                o = 0,
                s = r.length;
              o < s;
              o++
            )
              if ((i = r[o].call(n, e, t))) return i;
          }
          function de(t, e, n) {
            var i,
              r,
              o = 0,
              s = de.prefilters.length,
              a = S.Deferred().always(function () {
                delete l.elem;
              }),
              l = function () {
                if (r) return !1;
                for (
                  var e = re || ce(),
                    n = Math.max(0, c.startTime + c.duration - e),
                    i = 1 - (n / c.duration || 0),
                    o = 0,
                    s = c.tweens.length;
                  o < s;
                  o++
                )
                  c.tweens[o].run(i);
                return (
                  a.notifyWith(t, [c, i, n]),
                  i < 1 && s
                    ? n
                    : (s || a.notifyWith(t, [c, 1, 0]),
                      a.resolveWith(t, [c]),
                      !1)
                );
              },
              c = a.promise({
                elem: t,
                props: S.extend({}, e),
                opts: S.extend(
                  !0,
                  { specialEasing: {}, easing: S.easing._default },
                  n
                ),
                originalProperties: e,
                originalOptions: n,
                startTime: re || ce(),
                duration: n.duration,
                tweens: [],
                createTween: function (e, n) {
                  var i = S.Tween(
                    t,
                    c.opts,
                    e,
                    n,
                    c.opts.specialEasing[e] || c.opts.easing
                  );
                  return c.tweens.push(i), i;
                },
                stop: function (e) {
                  var n = 0,
                    i = e ? c.tweens.length : 0;
                  if (r) return this;
                  for (r = !0; n < i; n++) c.tweens[n].run(1);
                  return (
                    e
                      ? (a.notifyWith(t, [c, 1, 0]), a.resolveWith(t, [c, e]))
                      : a.rejectWith(t, [c, e]),
                    this
                  );
                },
              }),
              u = c.props;
            for (
              (function (t, e) {
                var n, i, r, o, s;
                for (n in t)
                  if (
                    ((r = e[(i = Z(n))]),
                    (o = t[n]),
                    Array.isArray(o) && ((r = o[1]), (o = t[n] = o[0])),
                    n !== i && ((t[i] = o), delete t[n]),
                    (s = S.cssHooks[i]) && ("expand" in s))
                  )
                    for (n in ((o = s.expand(o)), delete t[i], o))
                      (n in t) || ((t[n] = o[n]), (e[n] = r));
                  else e[i] = r;
              })(u, c.opts.specialEasing);
              o < s;
              o++
            )
              if ((i = de.prefilters[o].call(c, t, u, c.opts)))
                return (
                  v(i.stop) &&
                    (S._queueHooks(c.elem, c.opts.queue).stop = i.stop.bind(i)),
                  i
                );
            return (
              S.map(u, he, c),
              v(c.opts.start) && c.opts.start.call(t, c),
              c
                .progress(c.opts.progress)
                .done(c.opts.done, c.opts.complete)
                .fail(c.opts.fail)
                .always(c.opts.always),
              S.fx.timer(
                S.extend(l, { elem: t, anim: c, queue: c.opts.queue })
              ),
              c
            );
          }
          (S.Animation = S.extend(de, {
            tweeners: {
              "*": [
                function (t, e) {
                  var n = this.createTween(t, e);
                  return ut(n.elem, t, rt.exec(e), n), n;
                },
              ],
            },
            tweener: function (t, e) {
              v(t) ? ((e = t), (t = ["*"])) : (t = t.match(F));
              for (var n, i = 0, r = t.length; i < r; i++)
                (n = t[i]),
                  (de.tweeners[n] = de.tweeners[n] || []),
                  de.tweeners[n].unshift(e);
            },
            prefilters: [
              function (t, e, n) {
                var i,
                  r,
                  o,
                  s,
                  a,
                  l,
                  c,
                  u,
                  h = "width" in e || "height" in e,
                  d = this,
                  p = {},
                  f = t.style,
                  m = t.nodeType && ct(t),
                  g = Q.get(t, "fxshow");
                for (i in (n.queue ||
                  (null == (s = S._queueHooks(t, "fx")).unqueued &&
                    ((s.unqueued = 0),
                    (a = s.empty.fire),
                    (s.empty.fire = function () {
                      s.unqueued || a();
                    })),
                  s.unqueued++,
                  d.always(function () {
                    d.always(function () {
                      s.unqueued--, S.queue(t, "fx").length || s.empty.fire();
                    });
                  })),
                e))
                  if (((r = e[i]), se.test(r))) {
                    if (
                      (delete e[i],
                      (o = o || "toggle" === r),
                      r === (m ? "hide" : "show"))
                    ) {
                      if ("show" !== r || !g || void 0 === g[i]) continue;
                      m = !0;
                    }
                    p[i] = (g && g[i]) || S.style(t, i);
                  }
                if ((l = !S.isEmptyObject(e)) || !S.isEmptyObject(p))
                  for (i in (h &&
                    1 === t.nodeType &&
                    ((n.overflow = [f.overflow, f.overflowX, f.overflowY]),
                    null == (c = g && g.display) && (c = Q.get(t, "display")),
                    "none" === (u = S.css(t, "display")) &&
                      (c
                        ? (u = c)
                        : (pt([t], !0),
                          (c = t.style.display || c),
                          (u = S.css(t, "display")),
                          pt([t]))),
                    ("inline" === u || ("inline-block" === u && null != c)) &&
                      "none" === S.css(t, "float") &&
                      (l ||
                        (d.done(function () {
                          f.display = c;
                        }),
                        null == c &&
                          ((u = f.display), (c = "none" === u ? "" : u))),
                      (f.display = "inline-block"))),
                  n.overflow &&
                    ((f.overflow = "hidden"),
                    d.always(function () {
                      (f.overflow = n.overflow[0]),
                        (f.overflowX = n.overflow[1]),
                        (f.overflowY = n.overflow[2]);
                    })),
                  (l = !1),
                  p))
                    l ||
                      (g
                        ? "hidden" in g && (m = g.hidden)
                        : (g = Q.access(t, "fxshow", { display: c })),
                      o && (g.hidden = !m),
                      m && pt([t], !0),
                      d.done(function () {
                        for (i in (m || pt([t]), Q.remove(t, "fxshow"), p))
                          S.style(t, i, p[i]);
                      })),
                      (l = he(m ? g[i] : 0, i, d)),
                      i in g ||
                        ((g[i] = l.start),
                        m && ((l.end = l.start), (l.start = 0)));
              },
            ],
            prefilter: function (t, e) {
              e ? de.prefilters.unshift(t) : de.prefilters.push(t);
            },
          })),
            (S.speed = function (t, e, n) {
              var i =
                t && "object" == typeof t
                  ? S.extend({}, t)
                  : {
                      complete: n || (!n && e) || (v(t) && t),
                      duration: t,
                      easing: (n && e) || (e && !v(e) && e),
                    };
              return (
                S.fx.off
                  ? (i.duration = 0)
                  : "number" != typeof i.duration &&
                    (i.duration in S.fx.speeds
                      ? (i.duration = S.fx.speeds[i.duration])
                      : (i.duration = S.fx.speeds._default)),
                (null != i.queue && !0 !== i.queue) || (i.queue = "fx"),
                (i.old = i.complete),
                (i.complete = function () {
                  v(i.old) && i.old.call(this),
                    i.queue && S.dequeue(this, i.queue);
                }),
                i
              );
            }),
            S.fn.extend({
              fadeTo: function (t, e, n, i) {
                return this.filter(ct)
                  .css("opacity", 0)
                  .show()
                  .end()
                  .animate({ opacity: e }, t, n, i);
              },
              animate: function (t, e, n, i) {
                var r = S.isEmptyObject(t),
                  o = S.speed(e, n, i),
                  s = function () {
                    var e = de(this, S.extend({}, t), o);
                    (r || Q.get(this, "finish")) && e.stop(!0);
                  };
                return (
                  (s.finish = s),
                  r || !1 === o.queue ? this.each(s) : this.queue(o.queue, s)
                );
              },
              stop: function (t, e, n) {
                var i = function (t) {
                  var e = t.stop;
                  delete t.stop, e(n);
                };
                return (
                  "string" != typeof t && ((n = e), (e = t), (t = void 0)),
                  e && this.queue(t || "fx", []),
                  this.each(function () {
                    var e = !0,
                      r = null != t && t + "queueHooks",
                      o = S.timers,
                      s = Q.get(this);
                    if (r) s[r] && s[r].stop && i(s[r]);
                    else
                      for (r in s) s[r] && s[r].stop && ae.test(r) && i(s[r]);
                    for (r = o.length; r--; )
                      o[r].elem !== this ||
                        (null != t && o[r].queue !== t) ||
                        (o[r].anim.stop(n), (e = !1), o.splice(r, 1));
                    (!e && n) || S.dequeue(this, t);
                  })
                );
              },
              finish: function (t) {
                return (
                  !1 !== t && (t = t || "fx"),
                  this.each(function () {
                    var e,
                      n = Q.get(this),
                      i = n[t + "queue"],
                      r = n[t + "queueHooks"],
                      o = S.timers,
                      s = i ? i.length : 0;
                    for (
                      n.finish = !0,
                        S.queue(this, t, []),
                        r && r.stop && r.stop.call(this, !0),
                        e = o.length;
                      e--;

                    )
                      o[e].elem === this &&
                        o[e].queue === t &&
                        (o[e].anim.stop(!0), o.splice(e, 1));
                    for (e = 0; e < s; e++)
                      i[e] && i[e].finish && i[e].finish.call(this);
                    delete n.finish;
                  })
                );
              },
            }),
            S.each(["toggle", "show", "hide"], function (t, e) {
              var n = S.fn[e];
              S.fn[e] = function (t, i, r) {
                return null == t || "boolean" == typeof t
                  ? n.apply(this, arguments)
                  : this.animate(ue(e, !0), t, i, r);
              };
            }),
            S.each(
              {
                slideDown: ue("show"),
                slideUp: ue("hide"),
                slideToggle: ue("toggle"),
                fadeIn: { opacity: "show" },
                fadeOut: { opacity: "hide" },
                fadeToggle: { opacity: "toggle" },
              },
              function (t, e) {
                S.fn[t] = function (t, n, i) {
                  return this.animate(e, t, n, i);
                };
              }
            ),
            (S.timers = []),
            (S.fx.tick = function () {
              var t,
                e = 0,
                n = S.timers;
              for (re = Date.now(); e < n.length; e++)
                (t = n[e])() || n[e] !== t || n.splice(e--, 1);
              n.length || S.fx.stop(), (re = void 0);
            }),
            (S.fx.timer = function (t) {
              S.timers.push(t), S.fx.start();
            }),
            (S.fx.interval = 13),
            (S.fx.start = function () {
              oe || ((oe = !0), le());
            }),
            (S.fx.stop = function () {
              oe = null;
            }),
            (S.fx.speeds = { slow: 600, fast: 200, _default: 400 }),
            (S.fn.delay = function (t, e) {
              return (
                (t = (S.fx && S.fx.speeds[t]) || t),
                (e = e || "fx"),
                this.queue(e, function (e, n) {
                  var r = i.setTimeout(e, t);
                  n.stop = function () {
                    i.clearTimeout(r);
                  };
                })
              );
            }),
            (function () {
              var t = x.createElement("input"),
                e = x
                  .createElement("select")
                  .appendChild(x.createElement("option"));
              (t.type = "checkbox"),
                (g.checkOn = "" !== t.value),
                (g.optSelected = e.selected),
                ((t = x.createElement("input")).value = "t"),
                (t.type = "radio"),
                (g.radioValue = "t" === t.value);
            })();
          var pe,
            fe = S.expr.attrHandle;
          S.fn.extend({
            attr: function (t, e) {
              return W(this, S.attr, t, e, arguments.length > 1);
            },
            removeAttr: function (t) {
              return this.each(function () {
                S.removeAttr(this, t);
              });
            },
          }),
            S.extend({
              attr: function (t, e, n) {
                var i,
                  r,
                  o = t.nodeType;
                if (3 !== o && 8 !== o && 2 !== o)
                  return void 0 === t.getAttribute
                    ? S.prop(t, e, n)
                    : ((1 === o && S.isXMLDoc(t)) ||
                        (r =
                          S.attrHooks[e.toLowerCase()] ||
                          (S.expr.match.bool.test(e) ? pe : void 0)),
                      void 0 !== n
                        ? null === n
                          ? void S.removeAttr(t, e)
                          : r && "set" in r && void 0 !== (i = r.set(t, n, e))
                          ? i
                          : (t.setAttribute(e, n + ""), n)
                        : r && "get" in r && null !== (i = r.get(t, e))
                        ? i
                        : null == (i = S.find.attr(t, e))
                        ? void 0
                        : i);
              },
              attrHooks: {
                type: {
                  set: function (t, e) {
                    if (!g.radioValue && "radio" === e && R(t, "input")) {
                      var n = t.value;
                      return t.setAttribute("type", e), n && (t.value = n), e;
                    }
                  },
                },
              },
              removeAttr: function (t, e) {
                var n,
                  i = 0,
                  r = e && e.match(F);
                if (r && 1 === t.nodeType)
                  for (; (n = r[i++]); ) t.removeAttribute(n);
              },
            }),
            (pe = {
              set: function (t, e, n) {
                return !1 === e ? S.removeAttr(t, n) : t.setAttribute(n, n), n;
              },
            }),
            S.each(S.expr.match.bool.source.match(/\w+/g), function (t, e) {
              var n = fe[e] || S.find.attr;
              fe[e] = function (t, e, i) {
                var r,
                  o,
                  s = e.toLowerCase();
                return (
                  i ||
                    ((o = fe[s]),
                    (fe[s] = r),
                    (r = null != n(t, e, i) ? s : null),
                    (fe[s] = o)),
                  r
                );
              };
            });
          var me = /^(?:input|select|textarea|button)$/i,
            ge = /^(?:a|area)$/i;
          function ve(t) {
            return (t.match(F) || []).join(" ");
          }
          function ye(t) {
            return (t.getAttribute && t.getAttribute("class")) || "";
          }
          function xe(t) {
            return Array.isArray(t)
              ? t
              : ("string" == typeof t && t.match(F)) || [];
          }
          S.fn.extend({
            prop: function (t, e) {
              return W(this, S.prop, t, e, arguments.length > 1);
            },
            removeProp: function (t) {
              return this.each(function () {
                delete this[S.propFix[t] || t];
              });
            },
          }),
            S.extend({
              prop: function (t, e, n) {
                var i,
                  r,
                  o = t.nodeType;
                if (3 !== o && 8 !== o && 2 !== o)
                  return (
                    (1 === o && S.isXMLDoc(t)) ||
                      ((e = S.propFix[e] || e), (r = S.propHooks[e])),
                    void 0 !== n
                      ? r && "set" in r && void 0 !== (i = r.set(t, n, e))
                        ? i
                        : (t[e] = n)
                      : r && "get" in r && null !== (i = r.get(t, e))
                      ? i
                      : t[e]
                  );
              },
              propHooks: {
                tabIndex: {
                  get: function (t) {
                    var e = S.find.attr(t, "tabindex");
                    return e
                      ? parseInt(e, 10)
                      : me.test(t.nodeName) || (ge.test(t.nodeName) && t.href)
                      ? 0
                      : -1;
                  },
                },
              },
              propFix: { for: "htmlFor", class: "className" },
            }),
            g.optSelected ||
              (S.propHooks.selected = {
                get: function (t) {
                  var e = t.parentNode;
                  return e && e.parentNode && e.parentNode.selectedIndex, null;
                },
                set: function (t) {
                  var e = t.parentNode;
                  e &&
                    (e.selectedIndex,
                    e.parentNode && e.parentNode.selectedIndex);
                },
              }),
            S.each(
              [
                "tabIndex",
                "readOnly",
                "maxLength",
                "cellSpacing",
                "cellPadding",
                "rowSpan",
                "colSpan",
                "useMap",
                "frameBorder",
                "contentEditable",
              ],
              function () {
                S.propFix[this.toLowerCase()] = this;
              }
            ),
            S.fn.extend({
              addClass: function (t) {
                var e,
                  n,
                  i,
                  r,
                  o,
                  s,
                  a,
                  l = 0;
                if (v(t))
                  return this.each(function (e) {
                    S(this).addClass(t.call(this, e, ye(this)));
                  });
                if ((e = xe(t)).length)
                  for (; (n = this[l++]); )
                    if (
                      ((r = ye(n)), (i = 1 === n.nodeType && " " + ve(r) + " "))
                    ) {
                      for (s = 0; (o = e[s++]); )
                        i.indexOf(" " + o + " ") < 0 && (i += o + " ");
                      r !== (a = ve(i)) && n.setAttribute("class", a);
                    }
                return this;
              },
              removeClass: function (t) {
                var e,
                  n,
                  i,
                  r,
                  o,
                  s,
                  a,
                  l = 0;
                if (v(t))
                  return this.each(function (e) {
                    S(this).removeClass(t.call(this, e, ye(this)));
                  });
                if (!arguments.length) return this.attr("class", "");
                if ((e = xe(t)).length)
                  for (; (n = this[l++]); )
                    if (
                      ((r = ye(n)), (i = 1 === n.nodeType && " " + ve(r) + " "))
                    ) {
                      for (s = 0; (o = e[s++]); )
                        for (; i.indexOf(" " + o + " ") > -1; )
                          i = i.replace(" " + o + " ", " ");
                      r !== (a = ve(i)) && n.setAttribute("class", a);
                    }
                return this;
              },
              toggleClass: function (t, e) {
                var n = typeof t,
                  i = "string" === n || Array.isArray(t);
                return "boolean" == typeof e && i
                  ? e
                    ? this.addClass(t)
                    : this.removeClass(t)
                  : v(t)
                  ? this.each(function (n) {
                      S(this).toggleClass(t.call(this, n, ye(this), e), e);
                    })
                  : this.each(function () {
                      var e, r, o, s;
                      if (i)
                        for (r = 0, o = S(this), s = xe(t); (e = s[r++]); )
                          o.hasClass(e) ? o.removeClass(e) : o.addClass(e);
                      else
                        (void 0 !== t && "boolean" !== n) ||
                          ((e = ye(this)) && Q.set(this, "__className__", e),
                          this.setAttribute &&
                            this.setAttribute(
                              "class",
                              e || !1 === t
                                ? ""
                                : Q.get(this, "__className__") || ""
                            ));
                    });
              },
              hasClass: function (t) {
                var e,
                  n,
                  i = 0;
                for (e = " " + t + " "; (n = this[i++]); )
                  if (
                    1 === n.nodeType &&
                    (" " + ve(ye(n)) + " ").indexOf(e) > -1
                  )
                    return !0;
                return !1;
              },
            });
          var be = /\r/g;
          S.fn.extend({
            val: function (t) {
              var e,
                n,
                i,
                r = this[0];
              return arguments.length
                ? ((i = v(t)),
                  this.each(function (n) {
                    var r;
                    1 === this.nodeType &&
                      (null == (r = i ? t.call(this, n, S(this).val()) : t)
                        ? (r = "")
                        : "number" == typeof r
                        ? (r += "")
                        : Array.isArray(r) &&
                          (r = S.map(r, function (t) {
                            return null == t ? "" : t + "";
                          })),
                      ((e =
                        S.valHooks[this.type] ||
                        S.valHooks[this.nodeName.toLowerCase()]) &&
                        "set" in e &&
                        void 0 !== e.set(this, r, "value")) ||
                        (this.value = r));
                  }))
                : r
                ? (e =
                    S.valHooks[r.type] ||
                    S.valHooks[r.nodeName.toLowerCase()]) &&
                  "get" in e &&
                  void 0 !== (n = e.get(r, "value"))
                  ? n
                  : "string" == typeof (n = r.value)
                  ? n.replace(be, "")
                  : null == n
                  ? ""
                  : n
                : void 0;
            },
          }),
            S.extend({
              valHooks: {
                option: {
                  get: function (t) {
                    var e = S.find.attr(t, "value");
                    return null != e ? e : ve(S.text(t));
                  },
                },
                select: {
                  get: function (t) {
                    var e,
                      n,
                      i,
                      r = t.options,
                      o = t.selectedIndex,
                      s = "select-one" === t.type,
                      a = s ? null : [],
                      l = s ? o + 1 : r.length;
                    for (i = o < 0 ? l : s ? o : 0; i < l; i++)
                      if (
                        ((n = r[i]).selected || i === o) &&
                        !n.disabled &&
                        (!n.parentNode.disabled || !R(n.parentNode, "optgroup"))
                      ) {
                        if (((e = S(n).val()), s)) return e;
                        a.push(e);
                      }
                    return a;
                  },
                  set: function (t, e) {
                    for (
                      var n, i, r = t.options, o = S.makeArray(e), s = r.length;
                      s--;

                    )
                      ((i = r[s]).selected =
                        S.inArray(S.valHooks.option.get(i), o) > -1) &&
                        (n = !0);
                    return n || (t.selectedIndex = -1), o;
                  },
                },
              },
            }),
            S.each(["radio", "checkbox"], function () {
              (S.valHooks[this] = {
                set: function (t, e) {
                  if (Array.isArray(e))
                    return (t.checked = S.inArray(S(t).val(), e) > -1);
                },
              }),
                g.checkOn ||
                  (S.valHooks[this].get = function (t) {
                    return null === t.getAttribute("value") ? "on" : t.value;
                  });
            }),
            (g.focusin = "onfocusin" in i);
          var we = /^(?:focusinfocus|focusoutblur)$/,
            _e = function (t) {
              t.stopPropagation();
            };
          S.extend(S.event, {
            trigger: function (t, e, n, r) {
              var o,
                s,
                a,
                l,
                c,
                u,
                h,
                d,
                f = [n || x],
                m = p.call(t, "type") ? t.type : t,
                g = p.call(t, "namespace") ? t.namespace.split(".") : [];
              if (
                ((s = d = a = n = n || x),
                3 !== n.nodeType &&
                  8 !== n.nodeType &&
                  !we.test(m + S.event.triggered) &&
                  (m.indexOf(".") > -1 &&
                    ((g = m.split(".")), (m = g.shift()), g.sort()),
                  (c = m.indexOf(":") < 0 && "on" + m),
                  ((t = t[S.expando]
                    ? t
                    : new S.Event(m, "object" == typeof t && t)).isTrigger = r
                    ? 2
                    : 3),
                  (t.namespace = g.join(".")),
                  (t.rnamespace = t.namespace
                    ? new RegExp(
                        "(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)"
                      )
                    : null),
                  (t.result = void 0),
                  t.target || (t.target = n),
                  (e = null == e ? [t] : S.makeArray(e, [t])),
                  (h = S.event.special[m] || {}),
                  r || !h.trigger || !1 !== h.trigger.apply(n, e)))
              ) {
                if (!r && !h.noBubble && !y(n)) {
                  for (
                    l = h.delegateType || m,
                      we.test(l + m) || (s = s.parentNode);
                    s;
                    s = s.parentNode
                  )
                    f.push(s), (a = s);
                  a === (n.ownerDocument || x) &&
                    f.push(a.defaultView || a.parentWindow || i);
                }
                for (o = 0; (s = f[o++]) && !t.isPropagationStopped(); )
                  (d = s),
                    (t.type = o > 1 ? l : h.bindType || m),
                    (u =
                      (Q.get(s, "events") || Object.create(null))[t.type] &&
                      Q.get(s, "handle")) && u.apply(s, e),
                    (u = c && s[c]) &&
                      u.apply &&
                      J(s) &&
                      ((t.result = u.apply(s, e)),
                      !1 === t.result && t.preventDefault());
                return (
                  (t.type = m),
                  r ||
                    t.isDefaultPrevented() ||
                    (h._default && !1 !== h._default.apply(f.pop(), e)) ||
                    !J(n) ||
                    (c &&
                      v(n[m]) &&
                      !y(n) &&
                      ((a = n[c]) && (n[c] = null),
                      (S.event.triggered = m),
                      t.isPropagationStopped() && d.addEventListener(m, _e),
                      n[m](),
                      t.isPropagationStopped() && d.removeEventListener(m, _e),
                      (S.event.triggered = void 0),
                      a && (n[c] = a))),
                  t.result
                );
              }
            },
            simulate: function (t, e, n) {
              var i = S.extend(new S.Event(), n, { type: t, isSimulated: !0 });
              S.event.trigger(i, null, e);
            },
          }),
            S.fn.extend({
              trigger: function (t, e) {
                return this.each(function () {
                  S.event.trigger(t, e, this);
                });
              },
              triggerHandler: function (t, e) {
                var n = this[0];
                if (n) return S.event.trigger(t, e, n, !0);
              },
            }),
            g.focusin ||
              S.each({ focus: "focusin", blur: "focusout" }, function (t, e) {
                var n = function (t) {
                  S.event.simulate(e, t.target, S.event.fix(t));
                };
                S.event.special[e] = {
                  setup: function () {
                    var i = this.ownerDocument || this.document || this,
                      r = Q.access(i, e);
                    r || i.addEventListener(t, n, !0),
                      Q.access(i, e, (r || 0) + 1);
                  },
                  teardown: function () {
                    var i = this.ownerDocument || this.document || this,
                      r = Q.access(i, e) - 1;
                    r
                      ? Q.access(i, e, r)
                      : (i.removeEventListener(t, n, !0), Q.remove(i, e));
                  },
                };
              });
          var Me = i.location,
            Se = { guid: Date.now() },
            Ee = /\?/;
          S.parseXML = function (t) {
            var e, n;
            if (!t || "string" != typeof t) return null;
            try {
              e = new i.DOMParser().parseFromString(t, "text/xml");
            } catch (t) {}
            return (
              (n = e && e.getElementsByTagName("parsererror")[0]),
              (e && !n) ||
                S.error(
                  "Invalid XML: " +
                    (n
                      ? S.map(n.childNodes, function (t) {
                          return t.textContent;
                        }).join("\n")
                      : t)
                ),
              e
            );
          };
          var Te = /\[\]$/,
            Ae = /\r?\n/g,
            Ce = /^(?:submit|button|image|reset|file)$/i,
            Le = /^(?:input|select|textarea|keygen)/i;
          function Re(t, e, n, i) {
            var r;
            if (Array.isArray(e))
              S.each(e, function (e, r) {
                n || Te.test(t)
                  ? i(t, r)
                  : Re(
                      t +
                        "[" +
                        ("object" == typeof r && null != r ? e : "") +
                        "]",
                      r,
                      n,
                      i
                    );
              });
            else if (n || "object" !== _(e)) i(t, e);
            else for (r in e) Re(t + "[" + r + "]", e[r], n, i);
          }
          (S.param = function (t, e) {
            var n,
              i = [],
              r = function (t, e) {
                var n = v(e) ? e() : e;
                i[i.length] =
                  encodeURIComponent(t) +
                  "=" +
                  encodeURIComponent(null == n ? "" : n);
              };
            if (null == t) return "";
            if (Array.isArray(t) || (t.jquery && !S.isPlainObject(t)))
              S.each(t, function () {
                r(this.name, this.value);
              });
            else for (n in t) Re(n, t[n], e, r);
            return i.join("&");
          }),
            S.fn.extend({
              serialize: function () {
                return S.param(this.serializeArray());
              },
              serializeArray: function () {
                return this.map(function () {
                  var t = S.prop(this, "elements");
                  return t ? S.makeArray(t) : this;
                })
                  .filter(function () {
                    var t = this.type;
                    return (
                      this.name &&
                      !S(this).is(":disabled") &&
                      Le.test(this.nodeName) &&
                      !Ce.test(t) &&
                      (this.checked || !gt.test(t))
                    );
                  })
                  .map(function (t, e) {
                    var n = S(this).val();
                    return null == n
                      ? null
                      : Array.isArray(n)
                      ? S.map(n, function (t) {
                          return { name: e.name, value: t.replace(Ae, "\r\n") };
                        })
                      : { name: e.name, value: n.replace(Ae, "\r\n") };
                  })
                  .get();
              },
            });
          var Pe = /%20/g,
            Ne = /#.*$/,
            Ie = /([?&])_=[^&]*/,
            Be = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            Oe = /^(?:GET|HEAD)$/,
            De = /^\/\//,
            ke = {},
            Fe = {},
            ze = "*/".concat("*"),
            He = x.createElement("a");
          function Ue(t) {
            return function (e, n) {
              "string" != typeof e && ((n = e), (e = "*"));
              var i,
                r = 0,
                o = e.toLowerCase().match(F) || [];
              if (v(n))
                for (; (i = o[r++]); )
                  "+" === i[0]
                    ? ((i = i.slice(1) || "*"), (t[i] = t[i] || []).unshift(n))
                    : (t[i] = t[i] || []).push(n);
            };
          }
          function Ve(t, e, n, i) {
            var r = {},
              o = t === Fe;
            function s(a) {
              var l;
              return (
                (r[a] = !0),
                S.each(t[a] || [], function (t, a) {
                  var c = a(e, n, i);
                  return "string" != typeof c || o || r[c]
                    ? o
                      ? !(l = c)
                      : void 0
                    : (e.dataTypes.unshift(c), s(c), !1);
                }),
                l
              );
            }
            return s(e.dataTypes[0]) || (!r["*"] && s("*"));
          }
          function Ge(t, e) {
            var n,
              i,
              r = S.ajaxSettings.flatOptions || {};
            for (n in e)
              void 0 !== e[n] && ((r[n] ? t : i || (i = {}))[n] = e[n]);
            return i && S.extend(!0, t, i), t;
          }
          (He.href = Me.href),
            S.extend({
              active: 0,
              lastModified: {},
              etag: {},
              ajaxSettings: {
                url: Me.href,
                type: "GET",
                isLocal:
                  /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(
                    Me.protocol
                  ),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                  "*": ze,
                  text: "text/plain",
                  html: "text/html",
                  xml: "application/xml, text/xml",
                  json: "application/json, text/javascript",
                },
                contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ },
                responseFields: {
                  xml: "responseXML",
                  text: "responseText",
                  json: "responseJSON",
                },
                converters: {
                  "* text": String,
                  "text html": !0,
                  "text json": JSON.parse,
                  "text xml": S.parseXML,
                },
                flatOptions: { url: !0, context: !0 },
              },
              ajaxSetup: function (t, e) {
                return e ? Ge(Ge(t, S.ajaxSettings), e) : Ge(S.ajaxSettings, t);
              },
              ajaxPrefilter: Ue(ke),
              ajaxTransport: Ue(Fe),
              ajax: function (t, e) {
                "object" == typeof t && ((e = t), (t = void 0)), (e = e || {});
                var n,
                  r,
                  o,
                  s,
                  a,
                  l,
                  c,
                  u,
                  h,
                  d,
                  p = S.ajaxSetup({}, e),
                  f = p.context || p,
                  m = p.context && (f.nodeType || f.jquery) ? S(f) : S.event,
                  g = S.Deferred(),
                  v = S.Callbacks("once memory"),
                  y = p.statusCode || {},
                  b = {},
                  w = {},
                  _ = "canceled",
                  M = {
                    readyState: 0,
                    getResponseHeader: function (t) {
                      var e;
                      if (c) {
                        if (!s)
                          for (s = {}; (e = Be.exec(o)); )
                            s[e[1].toLowerCase() + " "] = (
                              s[e[1].toLowerCase() + " "] || []
                            ).concat(e[2]);
                        e = s[t.toLowerCase() + " "];
                      }
                      return null == e ? null : e.join(", ");
                    },
                    getAllResponseHeaders: function () {
                      return c ? o : null;
                    },
                    setRequestHeader: function (t, e) {
                      return (
                        null == c &&
                          ((t = w[t.toLowerCase()] = w[t.toLowerCase()] || t),
                          (b[t] = e)),
                        this
                      );
                    },
                    overrideMimeType: function (t) {
                      return null == c && (p.mimeType = t), this;
                    },
                    statusCode: function (t) {
                      var e;
                      if (t)
                        if (c) M.always(t[M.status]);
                        else for (e in t) y[e] = [y[e], t[e]];
                      return this;
                    },
                    abort: function (t) {
                      var e = t || _;
                      return n && n.abort(e), E(0, e), this;
                    },
                  };
                if (
                  (g.promise(M),
                  (p.url = ((t || p.url || Me.href) + "").replace(
                    De,
                    Me.protocol + "//"
                  )),
                  (p.type = e.method || e.type || p.method || p.type),
                  (p.dataTypes = (p.dataType || "*").toLowerCase().match(F) || [
                    "",
                  ]),
                  null == p.crossDomain)
                ) {
                  l = x.createElement("a");
                  try {
                    (l.href = p.url),
                      (l.href = l.href),
                      (p.crossDomain =
                        He.protocol + "//" + He.host !=
                        l.protocol + "//" + l.host);
                  } catch (t) {
                    p.crossDomain = !0;
                  }
                }
                if (
                  (p.data &&
                    p.processData &&
                    "string" != typeof p.data &&
                    (p.data = S.param(p.data, p.traditional)),
                  Ve(ke, p, e, M),
                  c)
                )
                  return M;
                for (h in ((u = S.event && p.global) &&
                  0 == S.active++ &&
                  S.event.trigger("ajaxStart"),
                (p.type = p.type.toUpperCase()),
                (p.hasContent = !Oe.test(p.type)),
                (r = p.url.replace(Ne, "")),
                p.hasContent
                  ? p.data &&
                    p.processData &&
                    0 ===
                      (p.contentType || "").indexOf(
                        "application/x-www-form-urlencoded"
                      ) &&
                    (p.data = p.data.replace(Pe, "+"))
                  : ((d = p.url.slice(r.length)),
                    p.data &&
                      (p.processData || "string" == typeof p.data) &&
                      ((r += (Ee.test(r) ? "&" : "?") + p.data), delete p.data),
                    !1 === p.cache &&
                      ((r = r.replace(Ie, "$1")),
                      (d = (Ee.test(r) ? "&" : "?") + "_=" + Se.guid++ + d)),
                    (p.url = r + d)),
                p.ifModified &&
                  (S.lastModified[r] &&
                    M.setRequestHeader("If-Modified-Since", S.lastModified[r]),
                  S.etag[r] && M.setRequestHeader("If-None-Match", S.etag[r])),
                ((p.data && p.hasContent && !1 !== p.contentType) ||
                  e.contentType) &&
                  M.setRequestHeader("Content-Type", p.contentType),
                M.setRequestHeader(
                  "Accept",
                  p.dataTypes[0] && p.accepts[p.dataTypes[0]]
                    ? p.accepts[p.dataTypes[0]] +
                        ("*" !== p.dataTypes[0] ? ", " + ze + "; q=0.01" : "")
                    : p.accepts["*"]
                ),
                p.headers))
                  M.setRequestHeader(h, p.headers[h]);
                if (p.beforeSend && (!1 === p.beforeSend.call(f, M, p) || c))
                  return M.abort();
                if (
                  ((_ = "abort"),
                  v.add(p.complete),
                  M.done(p.success),
                  M.fail(p.error),
                  (n = Ve(Fe, p, e, M)))
                ) {
                  if (
                    ((M.readyState = 1), u && m.trigger("ajaxSend", [M, p]), c)
                  )
                    return M;
                  p.async &&
                    p.timeout > 0 &&
                    (a = i.setTimeout(function () {
                      M.abort("timeout");
                    }, p.timeout));
                  try {
                    (c = !1), n.send(b, E);
                  } catch (t) {
                    if (c) throw t;
                    E(-1, t);
                  }
                } else E(-1, "No Transport");
                function E(t, e, s, l) {
                  var h,
                    d,
                    x,
                    b,
                    w,
                    _ = e;
                  c ||
                    ((c = !0),
                    a && i.clearTimeout(a),
                    (n = void 0),
                    (o = l || ""),
                    (M.readyState = t > 0 ? 4 : 0),
                    (h = (t >= 200 && t < 300) || 304 === t),
                    s &&
                      (b = (function (t, e, n) {
                        for (
                          var i, r, o, s, a = t.contents, l = t.dataTypes;
                          "*" === l[0];

                        )
                          l.shift(),
                            void 0 === i &&
                              (i =
                                t.mimeType ||
                                e.getResponseHeader("Content-Type"));
                        if (i)
                          for (r in a)
                            if (a[r] && a[r].test(i)) {
                              l.unshift(r);
                              break;
                            }
                        if (l[0] in n) o = l[0];
                        else {
                          for (r in n) {
                            if (!l[0] || t.converters[r + " " + l[0]]) {
                              o = r;
                              break;
                            }
                            s || (s = r);
                          }
                          o = o || s;
                        }
                        if (o) return o !== l[0] && l.unshift(o), n[o];
                      })(p, M, s)),
                    !h &&
                      S.inArray("script", p.dataTypes) > -1 &&
                      S.inArray("json", p.dataTypes) < 0 &&
                      (p.converters["text script"] = function () {}),
                    (b = (function (t, e, n, i) {
                      var r,
                        o,
                        s,
                        a,
                        l,
                        c = {},
                        u = t.dataTypes.slice();
                      if (u[1])
                        for (s in t.converters)
                          c[s.toLowerCase()] = t.converters[s];
                      for (o = u.shift(); o; )
                        if (
                          (t.responseFields[o] && (n[t.responseFields[o]] = e),
                          !l &&
                            i &&
                            t.dataFilter &&
                            (e = t.dataFilter(e, t.dataType)),
                          (l = o),
                          (o = u.shift()))
                        )
                          if ("*" === o) o = l;
                          else if ("*" !== l && l !== o) {
                            if (!(s = c[l + " " + o] || c["* " + o]))
                              for (r in c)
                                if (
                                  (a = r.split(" "))[1] === o &&
                                  (s = c[l + " " + a[0]] || c["* " + a[0]])
                                ) {
                                  !0 === s
                                    ? (s = c[r])
                                    : !0 !== c[r] &&
                                      ((o = a[0]), u.unshift(a[1]));
                                  break;
                                }
                            if (!0 !== s)
                              if (s && t.throws) e = s(e);
                              else
                                try {
                                  e = s(e);
                                } catch (t) {
                                  return {
                                    state: "parsererror",
                                    error: s
                                      ? t
                                      : "No conversion from " + l + " to " + o,
                                  };
                                }
                          }
                      return { state: "success", data: e };
                    })(p, b, M, h)),
                    h
                      ? (p.ifModified &&
                          ((w = M.getResponseHeader("Last-Modified")) &&
                            (S.lastModified[r] = w),
                          (w = M.getResponseHeader("etag")) && (S.etag[r] = w)),
                        204 === t || "HEAD" === p.type
                          ? (_ = "nocontent")
                          : 304 === t
                          ? (_ = "notmodified")
                          : ((_ = b.state), (d = b.data), (h = !(x = b.error))))
                      : ((x = _),
                        (!t && _) || ((_ = "error"), t < 0 && (t = 0))),
                    (M.status = t),
                    (M.statusText = (e || _) + ""),
                    h
                      ? g.resolveWith(f, [d, _, M])
                      : g.rejectWith(f, [M, _, x]),
                    M.statusCode(y),
                    (y = void 0),
                    u &&
                      m.trigger(h ? "ajaxSuccess" : "ajaxError", [
                        M,
                        p,
                        h ? d : x,
                      ]),
                    v.fireWith(f, [M, _]),
                    u &&
                      (m.trigger("ajaxComplete", [M, p]),
                      --S.active || S.event.trigger("ajaxStop")));
                }
                return M;
              },
              getJSON: function (t, e, n) {
                return S.get(t, e, n, "json");
              },
              getScript: function (t, e) {
                return S.get(t, void 0, e, "script");
              },
            }),
            S.each(["get", "post"], function (t, e) {
              S[e] = function (t, n, i, r) {
                return (
                  v(n) && ((r = r || i), (i = n), (n = void 0)),
                  S.ajax(
                    S.extend(
                      { url: t, type: e, dataType: r, data: n, success: i },
                      S.isPlainObject(t) && t
                    )
                  )
                );
              };
            }),
            S.ajaxPrefilter(function (t) {
              var e;
              for (e in t.headers)
                "content-type" === e.toLowerCase() &&
                  (t.contentType = t.headers[e] || "");
            }),
            (S._evalUrl = function (t, e, n) {
              return S.ajax({
                url: t,
                type: "GET",
                dataType: "script",
                cache: !0,
                async: !1,
                global: !1,
                converters: { "text script": function () {} },
                dataFilter: function (t) {
                  S.globalEval(t, e, n);
                },
              });
            }),
            S.fn.extend({
              wrapAll: function (t) {
                var e;
                return (
                  this[0] &&
                    (v(t) && (t = t.call(this[0])),
                    (e = S(t, this[0].ownerDocument).eq(0).clone(!0)),
                    this[0].parentNode && e.insertBefore(this[0]),
                    e
                      .map(function () {
                        for (var t = this; t.firstElementChild; )
                          t = t.firstElementChild;
                        return t;
                      })
                      .append(this)),
                  this
                );
              },
              wrapInner: function (t) {
                return v(t)
                  ? this.each(function (e) {
                      S(this).wrapInner(t.call(this, e));
                    })
                  : this.each(function () {
                      var e = S(this),
                        n = e.contents();
                      n.length ? n.wrapAll(t) : e.append(t);
                    });
              },
              wrap: function (t) {
                var e = v(t);
                return this.each(function (n) {
                  S(this).wrapAll(e ? t.call(this, n) : t);
                });
              },
              unwrap: function (t) {
                return (
                  this.parent(t)
                    .not("body")
                    .each(function () {
                      S(this).replaceWith(this.childNodes);
                    }),
                  this
                );
              },
            }),
            (S.expr.pseudos.hidden = function (t) {
              return !S.expr.pseudos.visible(t);
            }),
            (S.expr.pseudos.visible = function (t) {
              return !!(
                t.offsetWidth ||
                t.offsetHeight ||
                t.getClientRects().length
              );
            }),
            (S.ajaxSettings.xhr = function () {
              try {
                return new i.XMLHttpRequest();
              } catch (t) {}
            });
          var je = { 0: 200, 1223: 204 },
            We = S.ajaxSettings.xhr();
          (g.cors = !!We && "withCredentials" in We),
            (g.ajax = We = !!We),
            S.ajaxTransport(function (t) {
              var e, n;
              if (g.cors || (We && !t.crossDomain))
                return {
                  send: function (r, o) {
                    var s,
                      a = t.xhr();
                    if (
                      (a.open(t.type, t.url, t.async, t.username, t.password),
                      t.xhrFields)
                    )
                      for (s in t.xhrFields) a[s] = t.xhrFields[s];
                    for (s in (t.mimeType &&
                      a.overrideMimeType &&
                      a.overrideMimeType(t.mimeType),
                    t.crossDomain ||
                      r["X-Requested-With"] ||
                      (r["X-Requested-With"] = "XMLHttpRequest"),
                    r))
                      a.setRequestHeader(s, r[s]);
                    (e = function (t) {
                      return function () {
                        e &&
                          ((e =
                            n =
                            a.onload =
                            a.onerror =
                            a.onabort =
                            a.ontimeout =
                            a.onreadystatechange =
                              null),
                          "abort" === t
                            ? a.abort()
                            : "error" === t
                            ? "number" != typeof a.status
                              ? o(0, "error")
                              : o(a.status, a.statusText)
                            : o(
                                je[a.status] || a.status,
                                a.statusText,
                                "text" !== (a.responseType || "text") ||
                                  "string" != typeof a.responseText
                                  ? { binary: a.response }
                                  : { text: a.responseText },
                                a.getAllResponseHeaders()
                              ));
                      };
                    }),
                      (a.onload = e()),
                      (n = a.onerror = a.ontimeout = e("error")),
                      void 0 !== a.onabort
                        ? (a.onabort = n)
                        : (a.onreadystatechange = function () {
                            4 === a.readyState &&
                              i.setTimeout(function () {
                                e && n();
                              });
                          }),
                      (e = e("abort"));
                    try {
                      a.send((t.hasContent && t.data) || null);
                    } catch (t) {
                      if (e) throw t;
                    }
                  },
                  abort: function () {
                    e && e();
                  },
                };
            }),
            S.ajaxPrefilter(function (t) {
              t.crossDomain && (t.contents.script = !1);
            }),
            S.ajaxSetup({
              accepts: {
                script:
                  "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript",
              },
              contents: { script: /\b(?:java|ecma)script\b/ },
              converters: {
                "text script": function (t) {
                  return S.globalEval(t), t;
                },
              },
            }),
            S.ajaxPrefilter("script", function (t) {
              void 0 === t.cache && (t.cache = !1),
                t.crossDomain && (t.type = "GET");
            }),
            S.ajaxTransport("script", function (t) {
              var e, n;
              if (t.crossDomain || t.scriptAttrs)
                return {
                  send: function (i, r) {
                    (e = S("<script>")
                      .attr(t.scriptAttrs || {})
                      .prop({ charset: t.scriptCharset, src: t.url })
                      .on(
                        "load error",
                        (n = function (t) {
                          e.remove(),
                            (n = null),
                            t && r("error" === t.type ? 404 : 200, t.type);
                        })
                      )),
                      x.head.appendChild(e[0]);
                  },
                  abort: function () {
                    n && n();
                  },
                };
            });
          var qe,
            Xe = [],
            Ye = /(=)\?(?=&|$)|\?\?/;
          S.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function () {
              var t = Xe.pop() || S.expando + "_" + Se.guid++;
              return (this[t] = !0), t;
            },
          }),
            S.ajaxPrefilter("json jsonp", function (t, e, n) {
              var r,
                o,
                s,
                a =
                  !1 !== t.jsonp &&
                  (Ye.test(t.url)
                    ? "url"
                    : "string" == typeof t.data &&
                      0 ===
                        (t.contentType || "").indexOf(
                          "application/x-www-form-urlencoded"
                        ) &&
                      Ye.test(t.data) &&
                      "data");
              if (a || "jsonp" === t.dataTypes[0])
                return (
                  (r = t.jsonpCallback =
                    v(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback),
                  a
                    ? (t[a] = t[a].replace(Ye, "$1" + r))
                    : !1 !== t.jsonp &&
                      (t.url +=
                        (Ee.test(t.url) ? "&" : "?") + t.jsonp + "=" + r),
                  (t.converters["script json"] = function () {
                    return s || S.error(r + " was not called"), s[0];
                  }),
                  (t.dataTypes[0] = "json"),
                  (o = i[r]),
                  (i[r] = function () {
                    s = arguments;
                  }),
                  n.always(function () {
                    void 0 === o ? S(i).removeProp(r) : (i[r] = o),
                      t[r] && ((t.jsonpCallback = e.jsonpCallback), Xe.push(r)),
                      s && v(o) && o(s[0]),
                      (s = o = void 0);
                  }),
                  "script"
                );
            }),
            (g.createHTMLDocument =
              (((qe = x.implementation.createHTMLDocument("").body).innerHTML =
                "<form></form><form></form>"),
              2 === qe.childNodes.length)),
            (S.parseHTML = function (t, e, n) {
              return "string" != typeof t
                ? []
                : ("boolean" == typeof e && ((n = e), (e = !1)),
                  e ||
                    (g.createHTMLDocument
                      ? (((i = (e =
                          x.implementation.createHTMLDocument(
                            ""
                          )).createElement("base")).href = x.location.href),
                        e.head.appendChild(i))
                      : (e = x)),
                  (o = !n && []),
                  (r = P.exec(t))
                    ? [e.createElement(r[1])]
                    : ((r = Mt([t], e, o)),
                      o && o.length && S(o).remove(),
                      S.merge([], r.childNodes)));
              var i, r, o;
            }),
            (S.fn.load = function (t, e, n) {
              var i,
                r,
                o,
                s = this,
                a = t.indexOf(" ");
              return (
                a > -1 && ((i = ve(t.slice(a))), (t = t.slice(0, a))),
                v(e)
                  ? ((n = e), (e = void 0))
                  : e && "object" == typeof e && (r = "POST"),
                s.length > 0 &&
                  S.ajax({
                    url: t,
                    type: r || "GET",
                    dataType: "html",
                    data: e,
                  })
                    .done(function (t) {
                      (o = arguments),
                        s.html(
                          i ? S("<div>").append(S.parseHTML(t)).find(i) : t
                        );
                    })
                    .always(
                      n &&
                        function (t, e) {
                          s.each(function () {
                            n.apply(this, o || [t.responseText, e, t]);
                          });
                        }
                    ),
                this
              );
            }),
            (S.expr.pseudos.animated = function (t) {
              return S.grep(S.timers, function (e) {
                return t === e.elem;
              }).length;
            }),
            (S.offset = {
              setOffset: function (t, e, n) {
                var i,
                  r,
                  o,
                  s,
                  a,
                  l,
                  c = S.css(t, "position"),
                  u = S(t),
                  h = {};
                "static" === c && (t.style.position = "relative"),
                  (a = u.offset()),
                  (o = S.css(t, "top")),
                  (l = S.css(t, "left")),
                  ("absolute" === c || "fixed" === c) &&
                  (o + l).indexOf("auto") > -1
                    ? ((s = (i = u.position()).top), (r = i.left))
                    : ((s = parseFloat(o) || 0), (r = parseFloat(l) || 0)),
                  v(e) && (e = e.call(t, n, S.extend({}, a))),
                  null != e.top && (h.top = e.top - a.top + s),
                  null != e.left && (h.left = e.left - a.left + r),
                  "using" in e ? e.using.call(t, h) : u.css(h);
              },
            }),
            S.fn.extend({
              offset: function (t) {
                if (arguments.length)
                  return void 0 === t
                    ? this
                    : this.each(function (e) {
                        S.offset.setOffset(this, t, e);
                      });
                var e,
                  n,
                  i = this[0];
                return i
                  ? i.getClientRects().length
                    ? ((e = i.getBoundingClientRect()),
                      (n = i.ownerDocument.defaultView),
                      {
                        top: e.top + n.pageYOffset,
                        left: e.left + n.pageXOffset,
                      })
                    : { top: 0, left: 0 }
                  : void 0;
              },
              position: function () {
                if (this[0]) {
                  var t,
                    e,
                    n,
                    i = this[0],
                    r = { top: 0, left: 0 };
                  if ("fixed" === S.css(i, "position"))
                    e = i.getBoundingClientRect();
                  else {
                    for (
                      e = this.offset(),
                        n = i.ownerDocument,
                        t = i.offsetParent || n.documentElement;
                      t &&
                      (t === n.body || t === n.documentElement) &&
                      "static" === S.css(t, "position");

                    )
                      t = t.parentNode;
                    t &&
                      t !== i &&
                      1 === t.nodeType &&
                      (((r = S(t).offset()).top += S.css(
                        t,
                        "borderTopWidth",
                        !0
                      )),
                      (r.left += S.css(t, "borderLeftWidth", !0)));
                  }
                  return {
                    top: e.top - r.top - S.css(i, "marginTop", !0),
                    left: e.left - r.left - S.css(i, "marginLeft", !0),
                  };
                }
              },
              offsetParent: function () {
                return this.map(function () {
                  for (
                    var t = this.offsetParent;
                    t && "static" === S.css(t, "position");

                  )
                    t = t.offsetParent;
                  return t || st;
                });
              },
            }),
            S.each(
              { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
              function (t, e) {
                var n = "pageYOffset" === e;
                S.fn[t] = function (i) {
                  return W(
                    this,
                    function (t, i, r) {
                      var o;
                      if (
                        (y(t)
                          ? (o = t)
                          : 9 === t.nodeType && (o = t.defaultView),
                        void 0 === r)
                      )
                        return o ? o[e] : t[i];
                      o
                        ? o.scrollTo(
                            n ? o.pageXOffset : r,
                            n ? r : o.pageYOffset
                          )
                        : (t[i] = r);
                    },
                    t,
                    i,
                    arguments.length
                  );
                };
              }
            ),
            S.each(["top", "left"], function (t, e) {
              S.cssHooks[e] = Wt(g.pixelPosition, function (t, n) {
                if (n)
                  return (
                    (n = jt(t, e)), Ht.test(n) ? S(t).position()[e] + "px" : n
                  );
              });
            }),
            S.each({ Height: "height", Width: "width" }, function (t, e) {
              S.each(
                { padding: "inner" + t, content: e, "": "outer" + t },
                function (n, i) {
                  S.fn[i] = function (r, o) {
                    var s = arguments.length && (n || "boolean" != typeof r),
                      a = n || (!0 === r || !0 === o ? "margin" : "border");
                    return W(
                      this,
                      function (e, n, r) {
                        var o;
                        return y(e)
                          ? 0 === i.indexOf("outer")
                            ? e["inner" + t]
                            : e.document.documentElement["client" + t]
                          : 9 === e.nodeType
                          ? ((o = e.documentElement),
                            Math.max(
                              e.body["scroll" + t],
                              o["scroll" + t],
                              e.body["offset" + t],
                              o["offset" + t],
                              o["client" + t]
                            ))
                          : void 0 === r
                          ? S.css(e, n, a)
                          : S.style(e, n, r, a);
                      },
                      e,
                      s ? r : void 0,
                      s
                    );
                  };
                }
              );
            }),
            S.each(
              [
                "ajaxStart",
                "ajaxStop",
                "ajaxComplete",
                "ajaxError",
                "ajaxSuccess",
                "ajaxSend",
              ],
              function (t, e) {
                S.fn[e] = function (t) {
                  return this.on(e, t);
                };
              }
            ),
            S.fn.extend({
              bind: function (t, e, n) {
                return this.on(t, null, e, n);
              },
              unbind: function (t, e) {
                return this.off(t, null, e);
              },
              delegate: function (t, e, n, i) {
                return this.on(e, t, n, i);
              },
              undelegate: function (t, e, n) {
                return 1 === arguments.length
                  ? this.off(t, "**")
                  : this.off(e, t || "**", n);
              },
              hover: function (t, e) {
                return this.mouseenter(t).mouseleave(e || t);
              },
            }),
            S.each(
              "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(
                " "
              ),
              function (t, e) {
                S.fn[e] = function (t, n) {
                  return arguments.length > 0
                    ? this.on(e, null, t, n)
                    : this.trigger(e);
                };
              }
            );
          var Ze = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
          (S.proxy = function (t, e) {
            var n, i, r;
            if (("string" == typeof e && ((n = t[e]), (e = t), (t = n)), v(t)))
              return (
                (i = a.call(arguments, 2)),
                ((r = function () {
                  return t.apply(e || this, i.concat(a.call(arguments)));
                }).guid = t.guid =
                  t.guid || S.guid++),
                r
              );
          }),
            (S.holdReady = function (t) {
              t ? S.readyWait++ : S.ready(!0);
            }),
            (S.isArray = Array.isArray),
            (S.parseJSON = JSON.parse),
            (S.nodeName = R),
            (S.isFunction = v),
            (S.isWindow = y),
            (S.camelCase = Z),
            (S.type = _),
            (S.now = Date.now),
            (S.isNumeric = function (t) {
              var e = S.type(t);
              return (
                ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
              );
            }),
            (S.trim = function (t) {
              return null == t ? "" : (t + "").replace(Ze, "");
            }),
            void 0 ===
              (n = function () {
                return S;
              }.apply(e, [])) || (t.exports = n);
          var Je = i.jQuery,
            Ke = i.$;
          return (
            (S.noConflict = function (t) {
              return (
                i.$ === S && (i.$ = Ke),
                t && i.jQuery === S && (i.jQuery = Je),
                S
              );
            }),
            void 0 === r && (i.jQuery = i.$ = S),
            S
          );
        });
      },
      501: (t) => {
        var e;
        self,
          (e = function () {
            return (function (t) {
              var e = {};
              function n(i) {
                if (e[i]) return e[i].exports;
                var r = (e[i] = { i, l: !1, exports: {} });
                return (
                  t[i].call(r.exports, r, r.exports, n), (r.l = !0), r.exports
                );
              }
              return (
                (n.m = t),
                (n.c = e),
                (n.d = function (t, e, i) {
                  n.o(t, e) ||
                    Object.defineProperty(t, e, { enumerable: !0, get: i });
                }),
                (n.r = function (t) {
                  "undefined" != typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(t, Symbol.toStringTag, {
                      value: "Module",
                    }),
                    Object.defineProperty(t, "__esModule", { value: !0 });
                }),
                (n.t = function (t, e) {
                  if ((1 & e && (t = n(t)), 8 & e)) return t;
                  if (4 & e && "object" == typeof t && t && t.__esModule)
                    return t;
                  var i = Object.create(null);
                  if (
                    (n.r(i),
                    Object.defineProperty(i, "default", {
                      enumerable: !0,
                      value: t,
                    }),
                    2 & e && "string" != typeof t)
                  )
                    for (var r in t)
                      n.d(
                        i,
                        r,
                        function (e) {
                          return t[e];
                        }.bind(null, r)
                      );
                  return i;
                }),
                (n.n = function (t) {
                  var e =
                    t && t.__esModule
                      ? function () {
                          return t.default;
                        }
                      : function () {
                          return t;
                        };
                  return n.d(e, "a", e), e;
                }),
                (n.o = function (t, e) {
                  return Object.prototype.hasOwnProperty.call(t, e);
                }),
                (n.p = ""),
                n((n.s = "./build/index.js"))
              );
            })({
              "./build/index.js": function (t, e, n) {
                "use strict";
                function i(t) {
                  return (i =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                Object.defineProperty(e, "__esModule", { value: !0 }),
                  (e.io = e.Socket = e.Manager = e.protocol = void 0);
                var r = n("./build/url.js"),
                  o = n("./build/manager.js"),
                  s = n("./node_modules/debug/src/browser.js")(
                    "socket.io-client"
                  );
                t.exports = e = l;
                var a = (e.managers = {});
                function l(t, e) {
                  "object" === i(t) && ((e = t), (t = void 0)), (e = e || {});
                  var n,
                    l = r.url(t, e.path || "/socket.io"),
                    c = l.source,
                    u = l.id,
                    h = l.path,
                    d = a[u] && h in a[u].nsps;
                  return (
                    e.forceNew ||
                    e["force new connection"] ||
                    !1 === e.multiplex ||
                    d
                      ? (s("ignoring socket cache for %s", c),
                        (n = new o.Manager(c, e)))
                      : (a[u] ||
                          (s("new io instance for %s", c),
                          (a[u] = new o.Manager(c, e))),
                        (n = a[u])),
                    l.query && !e.query && (e.query = l.queryKey),
                    n.socket(l.path, e)
                  );
                }
                e.io = l;
                var c = n("./node_modules/socket.io-parser/dist/index.js");
                Object.defineProperty(e, "protocol", {
                  enumerable: !0,
                  get: function () {
                    return c.protocol;
                  },
                }),
                  (e.connect = l);
                var u = n("./build/manager.js");
                Object.defineProperty(e, "Manager", {
                  enumerable: !0,
                  get: function () {
                    return u.Manager;
                  },
                });
                var h = n("./build/socket.js");
                Object.defineProperty(e, "Socket", {
                  enumerable: !0,
                  get: function () {
                    return h.Socket;
                  },
                }),
                  (e.default = l);
              },
              "./build/manager.js": function (t, e, n) {
                "use strict";
                function i(t) {
                  return (i =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                function r(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    (i.enumerable = i.enumerable || !1),
                      (i.configurable = !0),
                      "value" in i && (i.writable = !0),
                      Object.defineProperty(t, i.key, i);
                  }
                }
                function o(t, e) {
                  return (o =
                    Object.setPrototypeOf ||
                    function (t, e) {
                      return (t.__proto__ = e), t;
                    })(t, e);
                }
                function s(t, e) {
                  return !e || ("object" !== i(e) && "function" != typeof e)
                    ? (function (t) {
                        if (void 0 === t)
                          throw new ReferenceError(
                            "this hasn't been initialised - super() hasn't been called"
                          );
                        return t;
                      })(t)
                    : e;
                }
                function a(t) {
                  return (a = Object.setPrototypeOf
                    ? Object.getPrototypeOf
                    : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t);
                      })(t);
                }
                Object.defineProperty(e, "__esModule", { value: !0 }),
                  (e.Manager = void 0);
                var l = n("./node_modules/engine.io-client/lib/index.js"),
                  c = n("./build/socket.js"),
                  u = n("./node_modules/socket.io-parser/dist/index.js"),
                  h = n("./build/on.js"),
                  d = n("./node_modules/backo2/index.js"),
                  p = n("./build/typed-events.js"),
                  f = n("./node_modules/debug/src/browser.js")(
                    "socket.io-client:manager"
                  ),
                  m = (function (t) {
                    !(function (t, e) {
                      if ("function" != typeof e && null !== e)
                        throw new TypeError(
                          "Super expression must either be null or a function"
                        );
                      (t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                          value: t,
                          writable: !0,
                          configurable: !0,
                        },
                      })),
                        e && o(t, e);
                    })(v, t);
                    var e,
                      n,
                      p,
                      m,
                      g =
                        ((p = v),
                        (m = (function () {
                          if (
                            "undefined" == typeof Reflect ||
                            !Reflect.construct
                          )
                            return !1;
                          if (Reflect.construct.sham) return !1;
                          if ("function" == typeof Proxy) return !0;
                          try {
                            return (
                              Boolean.prototype.valueOf.call(
                                Reflect.construct(Boolean, [], function () {})
                              ),
                              !0
                            );
                          } catch (t) {
                            return !1;
                          }
                        })()),
                        function () {
                          var t,
                            e = a(p);
                          if (m) {
                            var n = a(this).constructor;
                            t = Reflect.construct(e, arguments, n);
                          } else t = e.apply(this, arguments);
                          return s(this, t);
                        });
                    function v(t, e) {
                      var n;
                      !(function (t, e) {
                        if (!(t instanceof e))
                          throw new TypeError(
                            "Cannot call a class as a function"
                          );
                      })(this, v),
                        ((n = g.call(this)).nsps = {}),
                        (n.subs = []),
                        t && "object" === i(t) && ((e = t), (t = void 0)),
                        ((e = e || {}).path = e.path || "/socket.io"),
                        (n.opts = e),
                        n.reconnection(!1 !== e.reconnection),
                        n.reconnectionAttempts(e.reconnectionAttempts || 1 / 0),
                        n.reconnectionDelay(e.reconnectionDelay || 1e3),
                        n.reconnectionDelayMax(e.reconnectionDelayMax || 5e3),
                        n.randomizationFactor(e.randomizationFactor || 0.5),
                        (n.backoff = new d({
                          min: n.reconnectionDelay(),
                          max: n.reconnectionDelayMax(),
                          jitter: n.randomizationFactor(),
                        })),
                        n.timeout(null == e.timeout ? 2e4 : e.timeout),
                        (n._readyState = "closed"),
                        (n.uri = t);
                      var r = e.parser || u;
                      return (
                        (n.encoder = new r.Encoder()),
                        (n.decoder = new r.Decoder()),
                        (n._autoConnect = !1 !== e.autoConnect),
                        n._autoConnect && n.open(),
                        n
                      );
                    }
                    return (
                      (e = v),
                      (n = [
                        {
                          key: "reconnection",
                          value: function (t) {
                            return arguments.length
                              ? ((this._reconnection = !!t), this)
                              : this._reconnection;
                          },
                        },
                        {
                          key: "reconnectionAttempts",
                          value: function (t) {
                            return void 0 === t
                              ? this._reconnectionAttempts
                              : ((this._reconnectionAttempts = t), this);
                          },
                        },
                        {
                          key: "reconnectionDelay",
                          value: function (t) {
                            var e;
                            return void 0 === t
                              ? this._reconnectionDelay
                              : ((this._reconnectionDelay = t),
                                null === (e = this.backoff) ||
                                  void 0 === e ||
                                  e.setMin(t),
                                this);
                          },
                        },
                        {
                          key: "randomizationFactor",
                          value: function (t) {
                            var e;
                            return void 0 === t
                              ? this._randomizationFactor
                              : ((this._randomizationFactor = t),
                                null === (e = this.backoff) ||
                                  void 0 === e ||
                                  e.setJitter(t),
                                this);
                          },
                        },
                        {
                          key: "reconnectionDelayMax",
                          value: function (t) {
                            var e;
                            return void 0 === t
                              ? this._reconnectionDelayMax
                              : ((this._reconnectionDelayMax = t),
                                null === (e = this.backoff) ||
                                  void 0 === e ||
                                  e.setMax(t),
                                this);
                          },
                        },
                        {
                          key: "timeout",
                          value: function (t) {
                            return arguments.length
                              ? ((this._timeout = t), this)
                              : this._timeout;
                          },
                        },
                        {
                          key: "maybeReconnectOnOpen",
                          value: function () {
                            !this._reconnecting &&
                              this._reconnection &&
                              0 === this.backoff.attempts &&
                              this.reconnect();
                          },
                        },
                        {
                          key: "open",
                          value: function (t) {
                            var e = this;
                            if (
                              (f("readyState %s", this._readyState),
                              ~this._readyState.indexOf("open"))
                            )
                              return this;
                            f("opening %s", this.uri),
                              (this.engine = l(this.uri, this.opts));
                            var n = this.engine,
                              i = this;
                            (this._readyState = "opening"),
                              (this.skipReconnect = !1);
                            var r = h.on(n, "open", function () {
                                i.onopen(), t && t();
                              }),
                              o = h.on(n, "error", function (n) {
                                f("error"),
                                  i.cleanup(),
                                  (i._readyState = "closed"),
                                  e.emitReserved("error", n),
                                  t ? t(n) : i.maybeReconnectOnOpen();
                              });
                            if (!1 !== this._timeout) {
                              var s = this._timeout;
                              f("connect attempt will timeout after %d", s),
                                0 === s && r();
                              var a = setTimeout(function () {
                                f("connect attempt timed out after %d", s),
                                  r(),
                                  n.close(),
                                  n.emit("error", new Error("timeout"));
                              }, s);
                              this.opts.autoUnref && a.unref(),
                                this.subs.push(function () {
                                  clearTimeout(a);
                                });
                            }
                            return this.subs.push(r), this.subs.push(o), this;
                          },
                        },
                        {
                          key: "connect",
                          value: function (t) {
                            return this.open(t);
                          },
                        },
                        {
                          key: "onopen",
                          value: function () {
                            f("open"),
                              this.cleanup(),
                              (this._readyState = "open"),
                              this.emitReserved("open");
                            var t = this.engine;
                            this.subs.push(
                              h.on(t, "ping", this.onping.bind(this)),
                              h.on(t, "data", this.ondata.bind(this)),
                              h.on(t, "error", this.onerror.bind(this)),
                              h.on(t, "close", this.onclose.bind(this)),
                              h.on(
                                this.decoder,
                                "decoded",
                                this.ondecoded.bind(this)
                              )
                            );
                          },
                        },
                        {
                          key: "onping",
                          value: function () {
                            this.emitReserved("ping");
                          },
                        },
                        {
                          key: "ondata",
                          value: function (t) {
                            this.decoder.add(t);
                          },
                        },
                        {
                          key: "ondecoded",
                          value: function (t) {
                            this.emitReserved("packet", t);
                          },
                        },
                        {
                          key: "onerror",
                          value: function (t) {
                            f("error", t), this.emitReserved("error", t);
                          },
                        },
                        {
                          key: "socket",
                          value: function (t, e) {
                            var n = this.nsps[t];
                            return (
                              n ||
                                ((n = new c.Socket(this, t, e)),
                                (this.nsps[t] = n)),
                              n
                            );
                          },
                        },
                        {
                          key: "_destroy",
                          value: function (t) {
                            for (
                              var e = 0, n = Object.keys(this.nsps);
                              e < n.length;
                              e++
                            ) {
                              var i = n[e];
                              if (this.nsps[i].active)
                                return void f(
                                  "socket %s is still active, skipping close",
                                  i
                                );
                            }
                            this._close();
                          },
                        },
                        {
                          key: "_packet",
                          value: function (t) {
                            f("writing packet %j", t);
                            for (
                              var e = this.encoder.encode(t), n = 0;
                              n < e.length;
                              n++
                            )
                              this.engine.write(e[n], t.options);
                          },
                        },
                        {
                          key: "cleanup",
                          value: function () {
                            f("cleanup"),
                              this.subs.forEach(function (t) {
                                return t();
                              }),
                              (this.subs.length = 0),
                              this.decoder.destroy();
                          },
                        },
                        {
                          key: "_close",
                          value: function () {
                            f("disconnect"),
                              (this.skipReconnect = !0),
                              (this._reconnecting = !1),
                              "opening" === this._readyState && this.cleanup(),
                              this.backoff.reset(),
                              (this._readyState = "closed"),
                              this.engine && this.engine.close();
                          },
                        },
                        {
                          key: "disconnect",
                          value: function () {
                            return this._close();
                          },
                        },
                        {
                          key: "onclose",
                          value: function (t) {
                            f("onclose"),
                              this.cleanup(),
                              this.backoff.reset(),
                              (this._readyState = "closed"),
                              this.emitReserved("close", t),
                              this._reconnection &&
                                !this.skipReconnect &&
                                this.reconnect();
                          },
                        },
                        {
                          key: "reconnect",
                          value: function () {
                            var t = this;
                            if (this._reconnecting || this.skipReconnect)
                              return this;
                            var e = this;
                            if (
                              this.backoff.attempts >=
                              this._reconnectionAttempts
                            )
                              f("reconnect failed"),
                                this.backoff.reset(),
                                this.emitReserved("reconnect_failed"),
                                (this._reconnecting = !1);
                            else {
                              var n = this.backoff.duration();
                              f("will wait %dms before reconnect attempt", n),
                                (this._reconnecting = !0);
                              var i = setTimeout(function () {
                                e.skipReconnect ||
                                  (f("attempting reconnect"),
                                  t.emitReserved(
                                    "reconnect_attempt",
                                    e.backoff.attempts
                                  ),
                                  e.skipReconnect ||
                                    e.open(function (n) {
                                      n
                                        ? (f("reconnect attempt error"),
                                          (e._reconnecting = !1),
                                          e.reconnect(),
                                          t.emitReserved("reconnect_error", n))
                                        : (f("reconnect success"),
                                          e.onreconnect());
                                    }));
                              }, n);
                              this.opts.autoUnref && i.unref(),
                                this.subs.push(function () {
                                  clearTimeout(i);
                                });
                            }
                          },
                        },
                        {
                          key: "onreconnect",
                          value: function () {
                            var t = this.backoff.attempts;
                            (this._reconnecting = !1),
                              this.backoff.reset(),
                              this.emitReserved("reconnect", t);
                          },
                        },
                      ]) && r(e.prototype, n),
                      v
                    );
                  })(p.StrictEventEmitter);
                e.Manager = m;
              },
              "./build/on.js": function (t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", { value: !0 }),
                  (e.on = void 0),
                  (e.on = function (t, e, n) {
                    return (
                      t.on(e, n),
                      function () {
                        t.off(e, n);
                      }
                    );
                  });
              },
              "./build/socket.js": function (t, e, n) {
                "use strict";
                function i(t) {
                  return (i =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                function r(t, e) {
                  (null == e || e > t.length) && (e = t.length);
                  for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
                  return i;
                }
                function o(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    (i.enumerable = i.enumerable || !1),
                      (i.configurable = !0),
                      "value" in i && (i.writable = !0),
                      Object.defineProperty(t, i.key, i);
                  }
                }
                function s(t, e, n) {
                  return (s =
                    "undefined" != typeof Reflect && Reflect.get
                      ? Reflect.get
                      : function (t, e, n) {
                          var i = (function (t, e) {
                            for (
                              ;
                              !Object.prototype.hasOwnProperty.call(t, e) &&
                              null !== (t = c(t));

                            );
                            return t;
                          })(t, e);
                          if (i) {
                            var r = Object.getOwnPropertyDescriptor(i, e);
                            return r.get ? r.get.call(n) : r.value;
                          }
                        })(t, e, n || t);
                }
                function a(t, e) {
                  return (a =
                    Object.setPrototypeOf ||
                    function (t, e) {
                      return (t.__proto__ = e), t;
                    })(t, e);
                }
                function l(t, e) {
                  return !e || ("object" !== i(e) && "function" != typeof e)
                    ? (function (t) {
                        if (void 0 === t)
                          throw new ReferenceError(
                            "this hasn't been initialised - super() hasn't been called"
                          );
                        return t;
                      })(t)
                    : e;
                }
                function c(t) {
                  return (c = Object.setPrototypeOf
                    ? Object.getPrototypeOf
                    : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t);
                      })(t);
                }
                Object.defineProperty(e, "__esModule", { value: !0 }),
                  (e.Socket = void 0);
                var u = n("./node_modules/socket.io-parser/dist/index.js"),
                  h = n("./build/on.js"),
                  d = n("./build/typed-events.js"),
                  p = n("./node_modules/debug/src/browser.js")(
                    "socket.io-client:socket"
                  ),
                  f = Object.freeze({
                    connect: 1,
                    connect_error: 1,
                    disconnect: 1,
                    disconnecting: 1,
                    newListener: 1,
                    removeListener: 1,
                  }),
                  m = (function (t) {
                    !(function (t, e) {
                      if ("function" != typeof e && null !== e)
                        throw new TypeError(
                          "Super expression must either be null or a function"
                        );
                      (t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                          value: t,
                          writable: !0,
                          configurable: !0,
                        },
                      })),
                        e && a(t, e);
                    })(g, t);
                    var e,
                      n,
                      i,
                      d,
                      m =
                        ((i = g),
                        (d = (function () {
                          if (
                            "undefined" == typeof Reflect ||
                            !Reflect.construct
                          )
                            return !1;
                          if (Reflect.construct.sham) return !1;
                          if ("function" == typeof Proxy) return !0;
                          try {
                            return (
                              Boolean.prototype.valueOf.call(
                                Reflect.construct(Boolean, [], function () {})
                              ),
                              !0
                            );
                          } catch (t) {
                            return !1;
                          }
                        })()),
                        function () {
                          var t,
                            e = c(i);
                          if (d) {
                            var n = c(this).constructor;
                            t = Reflect.construct(e, arguments, n);
                          } else t = e.apply(this, arguments);
                          return l(this, t);
                        });
                    function g(t, e, n) {
                      var i;
                      return (
                        (function (t, e) {
                          if (!(t instanceof e))
                            throw new TypeError(
                              "Cannot call a class as a function"
                            );
                        })(this, g),
                        ((i = m.call(this)).receiveBuffer = []),
                        (i.sendBuffer = []),
                        (i.ids = 0),
                        (i.acks = {}),
                        (i.flags = {}),
                        (i.io = t),
                        (i.nsp = e),
                        (i.ids = 0),
                        (i.acks = {}),
                        (i.receiveBuffer = []),
                        (i.sendBuffer = []),
                        (i.connected = !1),
                        (i.disconnected = !0),
                        (i.flags = {}),
                        n && n.auth && (i.auth = n.auth),
                        i.io._autoConnect && i.open(),
                        i
                      );
                    }
                    return (
                      (e = g),
                      (n = [
                        {
                          key: "subEvents",
                          value: function () {
                            if (!this.subs) {
                              var t = this.io;
                              this.subs = [
                                h.on(t, "open", this.onopen.bind(this)),
                                h.on(t, "packet", this.onpacket.bind(this)),
                                h.on(t, "error", this.onerror.bind(this)),
                                h.on(t, "close", this.onclose.bind(this)),
                              ];
                            }
                          },
                        },
                        {
                          key: "active",
                          get: function () {
                            return !!this.subs;
                          },
                        },
                        {
                          key: "connect",
                          value: function () {
                            return (
                              this.connected ||
                                (this.subEvents(),
                                this.io._reconnecting || this.io.open(),
                                "open" === this.io._readyState &&
                                  this.onopen()),
                              this
                            );
                          },
                        },
                        {
                          key: "open",
                          value: function () {
                            return this.connect();
                          },
                        },
                        {
                          key: "send",
                          value: function () {
                            for (
                              var t = arguments.length, e = new Array(t), n = 0;
                              n < t;
                              n++
                            )
                              e[n] = arguments[n];
                            return (
                              e.unshift("message"),
                              this.emit.apply(this, e),
                              this
                            );
                          },
                        },
                        {
                          key: "emit",
                          value: function (t) {
                            if (f.hasOwnProperty(t))
                              throw new Error(
                                '"' + t + '" is a reserved event name'
                              );
                            for (
                              var e = arguments.length,
                                n = new Array(e > 1 ? e - 1 : 0),
                                i = 1;
                              i < e;
                              i++
                            )
                              n[i - 1] = arguments[i];
                            n.unshift(t);
                            var r = {
                              type: u.PacketType.EVENT,
                              data: n,
                              options: {},
                            };
                            (r.options.compress = !1 !== this.flags.compress),
                              "function" == typeof n[n.length - 1] &&
                                (p("emitting packet with ack id %d", this.ids),
                                (this.acks[this.ids] = n.pop()),
                                (r.id = this.ids++));
                            var o =
                                this.io.engine &&
                                this.io.engine.transport &&
                                this.io.engine.transport.writable,
                              s =
                                this.flags.volatile && (!o || !this.connected);
                            return (
                              s
                                ? p(
                                    "discard packet as the transport is not currently writable"
                                  )
                                : this.connected
                                ? this.packet(r)
                                : this.sendBuffer.push(r),
                              (this.flags = {}),
                              this
                            );
                          },
                        },
                        {
                          key: "packet",
                          value: function (t) {
                            (t.nsp = this.nsp), this.io._packet(t);
                          },
                        },
                        {
                          key: "onopen",
                          value: function () {
                            var t = this;
                            p("transport is open - connecting"),
                              "function" == typeof this.auth
                                ? this.auth(function (e) {
                                    t.packet({
                                      type: u.PacketType.CONNECT,
                                      data: e,
                                    });
                                  })
                                : this.packet({
                                    type: u.PacketType.CONNECT,
                                    data: this.auth,
                                  });
                          },
                        },
                        {
                          key: "onerror",
                          value: function (t) {
                            this.connected ||
                              this.emitReserved("connect_error", t);
                          },
                        },
                        {
                          key: "onclose",
                          value: function (t) {
                            p("close (%s)", t),
                              (this.connected = !1),
                              (this.disconnected = !0),
                              delete this.id,
                              this.emitReserved("disconnect", t);
                          },
                        },
                        {
                          key: "onpacket",
                          value: function (t) {
                            if (t.nsp === this.nsp)
                              switch (t.type) {
                                case u.PacketType.CONNECT:
                                  if (t.data && t.data.sid) {
                                    var e = t.data.sid;
                                    this.onconnect(e);
                                  } else
                                    this.emitReserved(
                                      "connect_error",
                                      new Error(
                                        "It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"
                                      )
                                    );
                                  break;
                                case u.PacketType.EVENT:
                                case u.PacketType.BINARY_EVENT:
                                  this.onevent(t);
                                  break;
                                case u.PacketType.ACK:
                                case u.PacketType.BINARY_ACK:
                                  this.onack(t);
                                  break;
                                case u.PacketType.DISCONNECT:
                                  this.ondisconnect();
                                  break;
                                case u.PacketType.CONNECT_ERROR:
                                  var n = new Error(t.data.message);
                                  (n.data = t.data.data),
                                    this.emitReserved("connect_error", n);
                              }
                          },
                        },
                        {
                          key: "onevent",
                          value: function (t) {
                            var e = t.data || [];
                            p("emitting event %j", e),
                              null != t.id &&
                                (p("attaching ack callback to event"),
                                e.push(this.ack(t.id))),
                              this.connected
                                ? this.emitEvent(e)
                                : this.receiveBuffer.push(Object.freeze(e));
                          },
                        },
                        {
                          key: "emitEvent",
                          value: function (t) {
                            if (
                              this._anyListeners &&
                              this._anyListeners.length
                            ) {
                              var e,
                                n = (function (t, e) {
                                  var n =
                                    ("undefined" != typeof Symbol &&
                                      t[Symbol.iterator]) ||
                                    t["@@iterator"];
                                  if (!n) {
                                    if (
                                      Array.isArray(t) ||
                                      (n = (function (t, e) {
                                        if (t) {
                                          if ("string" == typeof t)
                                            return r(t, e);
                                          var n = Object.prototype.toString
                                            .call(t)
                                            .slice(8, -1);
                                          return (
                                            "Object" === n &&
                                              t.constructor &&
                                              (n = t.constructor.name),
                                            "Map" === n || "Set" === n
                                              ? Array.from(t)
                                              : "Arguments" === n ||
                                                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                                                  n
                                                )
                                              ? r(t, e)
                                              : void 0
                                          );
                                        }
                                      })(t)) ||
                                      (e && t && "number" == typeof t.length)
                                    ) {
                                      n && (t = n);
                                      var i = 0,
                                        o = function () {};
                                      return {
                                        s: o,
                                        n: function () {
                                          return i >= t.length
                                            ? { done: !0 }
                                            : { done: !1, value: t[i++] };
                                        },
                                        e: function (t) {
                                          throw t;
                                        },
                                        f: o,
                                      };
                                    }
                                    throw new TypeError(
                                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                                    );
                                  }
                                  var s,
                                    a = !0,
                                    l = !1;
                                  return {
                                    s: function () {
                                      n = n.call(t);
                                    },
                                    n: function () {
                                      var t = n.next();
                                      return (a = t.done), t;
                                    },
                                    e: function (t) {
                                      (l = !0), (s = t);
                                    },
                                    f: function () {
                                      try {
                                        a || null == n.return || n.return();
                                      } finally {
                                        if (l) throw s;
                                      }
                                    },
                                  };
                                })(this._anyListeners.slice());
                              try {
                                for (n.s(); !(e = n.n()).done; )
                                  e.value.apply(this, t);
                              } catch (t) {
                                n.e(t);
                              } finally {
                                n.f();
                              }
                            }
                            s(c(g.prototype), "emit", this).apply(this, t);
                          },
                        },
                        {
                          key: "ack",
                          value: function (t) {
                            var e = this,
                              n = !1;
                            return function () {
                              if (!n) {
                                n = !0;
                                for (
                                  var i = arguments.length,
                                    r = new Array(i),
                                    o = 0;
                                  o < i;
                                  o++
                                )
                                  r[o] = arguments[o];
                                p("sending ack %j", r),
                                  e.packet({
                                    type: u.PacketType.ACK,
                                    id: t,
                                    data: r,
                                  });
                              }
                            };
                          },
                        },
                        {
                          key: "onack",
                          value: function (t) {
                            var e = this.acks[t.id];
                            "function" == typeof e
                              ? (p("calling ack %s with %j", t.id, t.data),
                                e.apply(this, t.data),
                                delete this.acks[t.id])
                              : p("bad ack %s", t.id);
                          },
                        },
                        {
                          key: "onconnect",
                          value: function (t) {
                            p("socket connected with id %s", t),
                              (this.id = t),
                              (this.connected = !0),
                              (this.disconnected = !1),
                              this.emitBuffered(),
                              this.emitReserved("connect");
                          },
                        },
                        {
                          key: "emitBuffered",
                          value: function () {
                            var t = this;
                            this.receiveBuffer.forEach(function (e) {
                              return t.emitEvent(e);
                            }),
                              (this.receiveBuffer = []),
                              this.sendBuffer.forEach(function (e) {
                                return t.packet(e);
                              }),
                              (this.sendBuffer = []);
                          },
                        },
                        {
                          key: "ondisconnect",
                          value: function () {
                            p("server disconnect (%s)", this.nsp),
                              this.destroy(),
                              this.onclose("io server disconnect");
                          },
                        },
                        {
                          key: "destroy",
                          value: function () {
                            this.subs &&
                              (this.subs.forEach(function (t) {
                                return t();
                              }),
                              (this.subs = void 0)),
                              this.io._destroy(this);
                          },
                        },
                        {
                          key: "disconnect",
                          value: function () {
                            return (
                              this.connected &&
                                (p("performing disconnect (%s)", this.nsp),
                                this.packet({ type: u.PacketType.DISCONNECT })),
                              this.destroy(),
                              this.connected &&
                                this.onclose("io client disconnect"),
                              this
                            );
                          },
                        },
                        {
                          key: "close",
                          value: function () {
                            return this.disconnect();
                          },
                        },
                        {
                          key: "compress",
                          value: function (t) {
                            return (this.flags.compress = t), this;
                          },
                        },
                        {
                          key: "volatile",
                          get: function () {
                            return (this.flags.volatile = !0), this;
                          },
                        },
                        {
                          key: "onAny",
                          value: function (t) {
                            return (
                              (this._anyListeners = this._anyListeners || []),
                              this._anyListeners.push(t),
                              this
                            );
                          },
                        },
                        {
                          key: "prependAny",
                          value: function (t) {
                            return (
                              (this._anyListeners = this._anyListeners || []),
                              this._anyListeners.unshift(t),
                              this
                            );
                          },
                        },
                        {
                          key: "offAny",
                          value: function (t) {
                            if (!this._anyListeners) return this;
                            if (t) {
                              for (
                                var e = this._anyListeners, n = 0;
                                n < e.length;
                                n++
                              )
                                if (t === e[n]) return e.splice(n, 1), this;
                            } else this._anyListeners = [];
                            return this;
                          },
                        },
                        {
                          key: "listenersAny",
                          value: function () {
                            return this._anyListeners || [];
                          },
                        },
                      ]) && o(e.prototype, n),
                      g
                    );
                  })(d.StrictEventEmitter);
                e.Socket = m;
              },
              "./build/typed-events.js": function (t, e, n) {
                "use strict";
                function i(t) {
                  return (i =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                function r(t, e) {
                  if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function");
                }
                function o(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    (i.enumerable = i.enumerable || !1),
                      (i.configurable = !0),
                      "value" in i && (i.writable = !0),
                      Object.defineProperty(t, i.key, i);
                  }
                }
                function s(t, e, n) {
                  return (s =
                    "undefined" != typeof Reflect && Reflect.get
                      ? Reflect.get
                      : function (t, e, n) {
                          var i = (function (t, e) {
                            for (
                              ;
                              !Object.prototype.hasOwnProperty.call(t, e) &&
                              null !== (t = c(t));

                            );
                            return t;
                          })(t, e);
                          if (i) {
                            var r = Object.getOwnPropertyDescriptor(i, e);
                            return r.get ? r.get.call(n) : r.value;
                          }
                        })(t, e, n || t);
                }
                function a(t, e) {
                  return (a =
                    Object.setPrototypeOf ||
                    function (t, e) {
                      return (t.__proto__ = e), t;
                    })(t, e);
                }
                function l(t, e) {
                  return !e || ("object" !== i(e) && "function" != typeof e)
                    ? (function (t) {
                        if (void 0 === t)
                          throw new ReferenceError(
                            "this hasn't been initialised - super() hasn't been called"
                          );
                        return t;
                      })(t)
                    : e;
                }
                function c(t) {
                  return (c = Object.setPrototypeOf
                    ? Object.getPrototypeOf
                    : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t);
                      })(t);
                }
                Object.defineProperty(e, "__esModule", { value: !0 }),
                  (e.StrictEventEmitter = void 0);
                var u = (function (t) {
                  !(function (t, e) {
                    if ("function" != typeof e && null !== e)
                      throw new TypeError(
                        "Super expression must either be null or a function"
                      );
                    (t.prototype = Object.create(e && e.prototype, {
                      constructor: { value: t, writable: !0, configurable: !0 },
                    })),
                      e && a(t, e);
                  })(d, t);
                  var e,
                    n,
                    i,
                    u,
                    h =
                      ((i = d),
                      (u = (function () {
                        if ("undefined" == typeof Reflect || !Reflect.construct)
                          return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                          return (
                            Boolean.prototype.valueOf.call(
                              Reflect.construct(Boolean, [], function () {})
                            ),
                            !0
                          );
                        } catch (t) {
                          return !1;
                        }
                      })()),
                      function () {
                        var t,
                          e = c(i);
                        if (u) {
                          var n = c(this).constructor;
                          t = Reflect.construct(e, arguments, n);
                        } else t = e.apply(this, arguments);
                        return l(this, t);
                      });
                  function d() {
                    return r(this, d), h.apply(this, arguments);
                  }
                  return (
                    (e = d),
                    (n = [
                      {
                        key: "on",
                        value: function (t, e) {
                          return (
                            s(c(d.prototype), "on", this).call(this, t, e), this
                          );
                        },
                      },
                      {
                        key: "once",
                        value: function (t, e) {
                          return (
                            s(c(d.prototype), "once", this).call(this, t, e),
                            this
                          );
                        },
                      },
                      {
                        key: "emit",
                        value: function (t) {
                          for (
                            var e,
                              n = arguments.length,
                              i = new Array(n > 1 ? n - 1 : 0),
                              r = 1;
                            r < n;
                            r++
                          )
                            i[r - 1] = arguments[r];
                          return (
                            (e = s(c(d.prototype), "emit", this)).call.apply(
                              e,
                              [this, t].concat(i)
                            ),
                            this
                          );
                        },
                      },
                      {
                        key: "emitReserved",
                        value: function (t) {
                          for (
                            var e,
                              n = arguments.length,
                              i = new Array(n > 1 ? n - 1 : 0),
                              r = 1;
                            r < n;
                            r++
                          )
                            i[r - 1] = arguments[r];
                          return (
                            (e = s(c(d.prototype), "emit", this)).call.apply(
                              e,
                              [this, t].concat(i)
                            ),
                            this
                          );
                        },
                      },
                      {
                        key: "listeners",
                        value: function (t) {
                          return s(c(d.prototype), "listeners", this).call(
                            this,
                            t
                          );
                        },
                      },
                    ]) && o(e.prototype, n),
                    d
                  );
                })(n("./node_modules/component-emitter/index.js"));
                e.StrictEventEmitter = u;
              },
              "./build/url.js": function (t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", { value: !0 }),
                  (e.url = void 0);
                var i = n("./node_modules/parseuri/index.js"),
                  r = n("./node_modules/debug/src/browser.js")(
                    "socket.io-client:url"
                  );
                e.url = function (t) {
                  var e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : "",
                    n = arguments.length > 2 ? arguments[2] : void 0,
                    o = t;
                  (n = n || ("undefined" != typeof location && location)),
                    null == t && (t = n.protocol + "//" + n.host),
                    "string" == typeof t &&
                      ("/" === t.charAt(0) &&
                        (t = "/" === t.charAt(1) ? n.protocol + t : n.host + t),
                      /^(https?|wss?):\/\//.test(t) ||
                        (r("protocol-less url %s", t),
                        (t =
                          void 0 !== n
                            ? n.protocol + "//" + t
                            : "https://" + t)),
                      r("parse %s", t),
                      (o = i(t))),
                    o.port ||
                      (/^(http|ws)$/.test(o.protocol)
                        ? (o.port = "80")
                        : /^(http|ws)s$/.test(o.protocol) && (o.port = "443")),
                    (o.path = o.path || "/");
                  var s = -1 !== o.host.indexOf(":"),
                    a = s ? "[" + o.host + "]" : o.host;
                  return (
                    (o.id = o.protocol + "://" + a + ":" + o.port + e),
                    (o.href =
                      o.protocol +
                      "://" +
                      a +
                      (n && n.port === o.port ? "" : ":" + o.port)),
                    o
                  );
                };
              },
              "./node_modules/backo2/index.js": function (t, e) {
                function n(t) {
                  (t = t || {}),
                    (this.ms = t.min || 100),
                    (this.max = t.max || 1e4),
                    (this.factor = t.factor || 2),
                    (this.jitter =
                      t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0),
                    (this.attempts = 0);
                }
                (t.exports = n),
                  (n.prototype.duration = function () {
                    var t = this.ms * Math.pow(this.factor, this.attempts++);
                    if (this.jitter) {
                      var e = Math.random(),
                        n = Math.floor(e * this.jitter * t);
                      t = 0 == (1 & Math.floor(10 * e)) ? t - n : t + n;
                    }
                    return 0 | Math.min(t, this.max);
                  }),
                  (n.prototype.reset = function () {
                    this.attempts = 0;
                  }),
                  (n.prototype.setMin = function (t) {
                    this.ms = t;
                  }),
                  (n.prototype.setMax = function (t) {
                    this.max = t;
                  }),
                  (n.prototype.setJitter = function (t) {
                    this.jitter = t;
                  });
              },
              "./node_modules/component-emitter/index.js": function (t, e, n) {
                function i(t) {
                  if (t)
                    return (function (t) {
                      for (var e in i.prototype) t[e] = i.prototype[e];
                      return t;
                    })(t);
                }
                (t.exports = i),
                  (i.prototype.on = i.prototype.addEventListener =
                    function (t, e) {
                      return (
                        (this._callbacks = this._callbacks || {}),
                        (this._callbacks["$" + t] =
                          this._callbacks["$" + t] || []).push(e),
                        this
                      );
                    }),
                  (i.prototype.once = function (t, e) {
                    function n() {
                      this.off(t, n), e.apply(this, arguments);
                    }
                    return (n.fn = e), this.on(t, n), this;
                  }),
                  (i.prototype.off =
                    i.prototype.removeListener =
                    i.prototype.removeAllListeners =
                    i.prototype.removeEventListener =
                      function (t, e) {
                        if (
                          ((this._callbacks = this._callbacks || {}),
                          0 == arguments.length)
                        )
                          return (this._callbacks = {}), this;
                        var n,
                          i = this._callbacks["$" + t];
                        if (!i) return this;
                        if (1 == arguments.length)
                          return delete this._callbacks["$" + t], this;
                        for (var r = 0; r < i.length; r++)
                          if ((n = i[r]) === e || n.fn === e) {
                            i.splice(r, 1);
                            break;
                          }
                        return (
                          0 === i.length && delete this._callbacks["$" + t],
                          this
                        );
                      }),
                  (i.prototype.emit = function (t) {
                    this._callbacks = this._callbacks || {};
                    for (
                      var e = new Array(arguments.length - 1),
                        n = this._callbacks["$" + t],
                        i = 1;
                      i < arguments.length;
                      i++
                    )
                      e[i - 1] = arguments[i];
                    if (n) {
                      i = 0;
                      for (var r = (n = n.slice(0)).length; i < r; ++i)
                        n[i].apply(this, e);
                    }
                    return this;
                  }),
                  (i.prototype.listeners = function (t) {
                    return (
                      (this._callbacks = this._callbacks || {}),
                      this._callbacks["$" + t] || []
                    );
                  }),
                  (i.prototype.hasListeners = function (t) {
                    return !!this.listeners(t).length;
                  });
              },
              "./node_modules/debug/src/browser.js": function (t, e, n) {
                var i;
                (e.formatArgs = function (e) {
                  if (
                    ((e[0] =
                      (this.useColors ? "%c" : "") +
                      this.namespace +
                      (this.useColors ? " %c" : " ") +
                      e[0] +
                      (this.useColors ? "%c " : " ") +
                      "+" +
                      t.exports.humanize(this.diff)),
                    this.useColors)
                  ) {
                    var n = "color: " + this.color;
                    e.splice(1, 0, n, "color: inherit");
                    var i = 0,
                      r = 0;
                    e[0].replace(/%[a-zA-Z%]/g, function (t) {
                      "%%" !== t && (i++, "%c" === t && (r = i));
                    }),
                      e.splice(r, 0, n);
                  }
                }),
                  (e.save = function (t) {
                    try {
                      t
                        ? e.storage.setItem("debug", t)
                        : e.storage.removeItem("debug");
                    } catch (t) {}
                  }),
                  (e.load = function () {
                    var t;
                    try {
                      t = e.storage.getItem("debug");
                    } catch (t) {}
                    return (
                      !t &&
                        "undefined" != typeof process &&
                        "env" in process &&
                        (t = process.env.DEBUG),
                      t
                    );
                  }),
                  (e.useColors = function () {
                    return (
                      !(
                        "undefined" == typeof window ||
                        !window.process ||
                        ("renderer" !== window.process.type &&
                          !window.process.__nwjs)
                      ) ||
                      (("undefined" == typeof navigator ||
                        !navigator.userAgent ||
                        !navigator.userAgent
                          .toLowerCase()
                          .match(/(edge|trident)\/(\d+)/)) &&
                        (("undefined" != typeof document &&
                          document.documentElement &&
                          document.documentElement.style &&
                          document.documentElement.style.WebkitAppearance) ||
                          ("undefined" != typeof window &&
                            window.console &&
                            (window.console.firebug ||
                              (window.console.exception &&
                                window.console.table))) ||
                          ("undefined" != typeof navigator &&
                            navigator.userAgent &&
                            navigator.userAgent
                              .toLowerCase()
                              .match(/firefox\/(\d+)/) &&
                            parseInt(RegExp.$1, 10) >= 31) ||
                          ("undefined" != typeof navigator &&
                            navigator.userAgent &&
                            navigator.userAgent
                              .toLowerCase()
                              .match(/applewebkit\/(\d+)/))))
                    );
                  }),
                  (e.storage = (function () {
                    try {
                      return localStorage;
                    } catch (t) {}
                  })()),
                  (e.destroy =
                    ((i = !1),
                    function () {
                      i ||
                        ((i = !0),
                        console.warn(
                          "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
                        ));
                    })),
                  (e.colors = [
                    "#0000CC",
                    "#0000FF",
                    "#0033CC",
                    "#0033FF",
                    "#0066CC",
                    "#0066FF",
                    "#0099CC",
                    "#0099FF",
                    "#00CC00",
                    "#00CC33",
                    "#00CC66",
                    "#00CC99",
                    "#00CCCC",
                    "#00CCFF",
                    "#3300CC",
                    "#3300FF",
                    "#3333CC",
                    "#3333FF",
                    "#3366CC",
                    "#3366FF",
                    "#3399CC",
                    "#3399FF",
                    "#33CC00",
                    "#33CC33",
                    "#33CC66",
                    "#33CC99",
                    "#33CCCC",
                    "#33CCFF",
                    "#6600CC",
                    "#6600FF",
                    "#6633CC",
                    "#6633FF",
                    "#66CC00",
                    "#66CC33",
                    "#9900CC",
                    "#9900FF",
                    "#9933CC",
                    "#9933FF",
                    "#99CC00",
                    "#99CC33",
                    "#CC0000",
                    "#CC0033",
                    "#CC0066",
                    "#CC0099",
                    "#CC00CC",
                    "#CC00FF",
                    "#CC3300",
                    "#CC3333",
                    "#CC3366",
                    "#CC3399",
                    "#CC33CC",
                    "#CC33FF",
                    "#CC6600",
                    "#CC6633",
                    "#CC9900",
                    "#CC9933",
                    "#CCCC00",
                    "#CCCC33",
                    "#FF0000",
                    "#FF0033",
                    "#FF0066",
                    "#FF0099",
                    "#FF00CC",
                    "#FF00FF",
                    "#FF3300",
                    "#FF3333",
                    "#FF3366",
                    "#FF3399",
                    "#FF33CC",
                    "#FF33FF",
                    "#FF6600",
                    "#FF6633",
                    "#FF9900",
                    "#FF9933",
                    "#FFCC00",
                    "#FFCC33",
                  ]),
                  (e.log = console.debug || console.log || function () {}),
                  (t.exports = n("./node_modules/debug/src/common.js")(e)),
                  (t.exports.formatters.j = function (t) {
                    try {
                      return JSON.stringify(t);
                    } catch (t) {
                      return "[UnexpectedJSONParseError]: " + t.message;
                    }
                  });
              },
              "./node_modules/debug/src/common.js": function (t, e, n) {
                function i(t) {
                  return (
                    (function (t) {
                      if (Array.isArray(t)) return r(t);
                    })(t) ||
                    (function (t) {
                      if (
                        ("undefined" != typeof Symbol &&
                          null != t[Symbol.iterator]) ||
                        null != t["@@iterator"]
                      )
                        return Array.from(t);
                    })(t) ||
                    (function (t, e) {
                      if (t) {
                        if ("string" == typeof t) return r(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return (
                          "Object" === n &&
                            t.constructor &&
                            (n = t.constructor.name),
                          "Map" === n || "Set" === n
                            ? Array.from(t)
                            : "Arguments" === n ||
                              /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                            ? r(t, e)
                            : void 0
                        );
                      }
                    })(t) ||
                    (function () {
                      throw new TypeError(
                        "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                      );
                    })()
                  );
                }
                function r(t, e) {
                  (null == e || e > t.length) && (e = t.length);
                  for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
                  return i;
                }
                t.exports = function (t) {
                  function e(t) {
                    var n,
                      i = null;
                    function o() {
                      for (
                        var t = arguments.length, i = new Array(t), r = 0;
                        r < t;
                        r++
                      )
                        i[r] = arguments[r];
                      if (o.enabled) {
                        var s = o,
                          a = Number(new Date()),
                          l = a - (n || a);
                        (s.diff = l),
                          (s.prev = n),
                          (s.curr = a),
                          (n = a),
                          (i[0] = e.coerce(i[0])),
                          "string" != typeof i[0] && i.unshift("%O");
                        var c = 0;
                        (i[0] = i[0].replace(/%([a-zA-Z%])/g, function (t, n) {
                          if ("%%" === t) return "%";
                          c++;
                          var r = e.formatters[n];
                          if ("function" == typeof r) {
                            var o = i[c];
                            (t = r.call(s, o)), i.splice(c, 1), c--;
                          }
                          return t;
                        })),
                          e.formatArgs.call(s, i);
                        var u = s.log || e.log;
                        u.apply(s, i);
                      }
                    }
                    return (
                      (o.namespace = t),
                      (o.useColors = e.useColors()),
                      (o.color = e.selectColor(t)),
                      (o.extend = r),
                      (o.destroy = e.destroy),
                      Object.defineProperty(o, "enabled", {
                        enumerable: !0,
                        configurable: !1,
                        get: function () {
                          return null === i ? e.enabled(t) : i;
                        },
                        set: function (t) {
                          i = t;
                        },
                      }),
                      "function" == typeof e.init && e.init(o),
                      o
                    );
                  }
                  function r(t, n) {
                    var i = e(this.namespace + (void 0 === n ? ":" : n) + t);
                    return (i.log = this.log), i;
                  }
                  function o(t) {
                    return t
                      .toString()
                      .substring(2, t.toString().length - 2)
                      .replace(/\.\*\?$/, "*");
                  }
                  return (
                    (e.debug = e),
                    (e.default = e),
                    (e.coerce = function (t) {
                      return t instanceof Error ? t.stack || t.message : t;
                    }),
                    (e.disable = function () {
                      var t = []
                        .concat(
                          i(e.names.map(o)),
                          i(
                            e.skips.map(o).map(function (t) {
                              return "-" + t;
                            })
                          )
                        )
                        .join(",");
                      return e.enable(""), t;
                    }),
                    (e.enable = function (t) {
                      var n;
                      e.save(t), (e.names = []), (e.skips = []);
                      var i = ("string" == typeof t ? t : "").split(/[\s,]+/),
                        r = i.length;
                      for (n = 0; n < r; n++)
                        i[n] &&
                          ("-" === (t = i[n].replace(/\*/g, ".*?"))[0]
                            ? e.skips.push(new RegExp("^" + t.substr(1) + "$"))
                            : e.names.push(new RegExp("^" + t + "$")));
                    }),
                    (e.enabled = function (t) {
                      if ("*" === t[t.length - 1]) return !0;
                      var n, i;
                      for (n = 0, i = e.skips.length; n < i; n++)
                        if (e.skips[n].test(t)) return !1;
                      for (n = 0, i = e.names.length; n < i; n++)
                        if (e.names[n].test(t)) return !0;
                      return !1;
                    }),
                    (e.humanize = n("./node_modules/ms/index.js")),
                    (e.destroy = function () {
                      console.warn(
                        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
                      );
                    }),
                    Object.keys(t).forEach(function (n) {
                      e[n] = t[n];
                    }),
                    (e.names = []),
                    (e.skips = []),
                    (e.formatters = {}),
                    (e.selectColor = function (t) {
                      for (var n = 0, i = 0; i < t.length; i++)
                        (n = (n << 5) - n + t.charCodeAt(i)), (n |= 0);
                      return e.colors[Math.abs(n) % e.colors.length];
                    }),
                    e.enable(e.load()),
                    e
                  );
                };
              },
              "./node_modules/engine.io-client/lib/globalThis.browser.js":
                function (t, e) {
                  t.exports =
                    "undefined" != typeof self
                      ? self
                      : "undefined" != typeof window
                      ? window
                      : Function("return this")();
                },
              "./node_modules/engine.io-client/lib/index.js": function (
                t,
                e,
                n
              ) {
                var i = n("./node_modules/engine.io-client/lib/socket.js");
                (t.exports = function (t, e) {
                  return new i(t, e);
                }),
                  (t.exports.Socket = i),
                  (t.exports.protocol = i.protocol),
                  (t.exports.Transport = n(
                    "./node_modules/engine.io-client/lib/transport.js"
                  )),
                  (t.exports.transports = n(
                    "./node_modules/engine.io-client/lib/transports/index.js"
                  )),
                  (t.exports.parser = n(
                    "./node_modules/engine.io-parser/lib/index.js"
                  ));
              },
              "./node_modules/engine.io-client/lib/socket.js": function (
                t,
                e,
                n
              ) {
                function i() {
                  return (i =
                    Object.assign ||
                    function (t) {
                      for (var e = 1; e < arguments.length; e++) {
                        var n = arguments[e];
                        for (var i in n)
                          Object.prototype.hasOwnProperty.call(n, i) &&
                            (t[i] = n[i]);
                      }
                      return t;
                    }).apply(this, arguments);
                }
                function r(t) {
                  return (r =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                function o(t, e) {
                  if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function");
                }
                function s(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    (i.enumerable = i.enumerable || !1),
                      (i.configurable = !0),
                      "value" in i && (i.writable = !0),
                      Object.defineProperty(t, i.key, i);
                  }
                }
                function a(t, e) {
                  return (a =
                    Object.setPrototypeOf ||
                    function (t, e) {
                      return (t.__proto__ = e), t;
                    })(t, e);
                }
                function l(t, e) {
                  return !e || ("object" !== r(e) && "function" != typeof e)
                    ? (function (t) {
                        if (void 0 === t)
                          throw new ReferenceError(
                            "this hasn't been initialised - super() hasn't been called"
                          );
                        return t;
                      })(t)
                    : e;
                }
                function c(t) {
                  return (c = Object.setPrototypeOf
                    ? Object.getPrototypeOf
                    : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t);
                      })(t);
                }
                var u = n(
                    "./node_modules/engine.io-client/lib/transports/index.js"
                  ),
                  h = n("./node_modules/component-emitter/index.js"),
                  d = n("./node_modules/debug/src/browser.js")(
                    "engine.io-client:socket"
                  ),
                  p = n("./node_modules/engine.io-parser/lib/index.js"),
                  f = n("./node_modules/parseuri/index.js"),
                  m = n("./node_modules/parseqs/index.js"),
                  g = (function (t) {
                    !(function (t, e) {
                      if ("function" != typeof e && null !== e)
                        throw new TypeError(
                          "Super expression must either be null or a function"
                        );
                      (t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                          value: t,
                          writable: !0,
                          configurable: !0,
                        },
                      })),
                        e && a(t, e);
                    })(y, t);
                    var e,
                      n,
                      h,
                      g,
                      v =
                        ((h = y),
                        (g = (function () {
                          if (
                            "undefined" == typeof Reflect ||
                            !Reflect.construct
                          )
                            return !1;
                          if (Reflect.construct.sham) return !1;
                          if ("function" == typeof Proxy) return !0;
                          try {
                            return (
                              Boolean.prototype.valueOf.call(
                                Reflect.construct(Boolean, [], function () {})
                              ),
                              !0
                            );
                          } catch (t) {
                            return !1;
                          }
                        })()),
                        function () {
                          var t,
                            e = c(h);
                          if (g) {
                            var n = c(this).constructor;
                            t = Reflect.construct(e, arguments, n);
                          } else t = e.apply(this, arguments);
                          return l(this, t);
                        });
                    function y(t) {
                      var e,
                        n =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : {};
                      return (
                        o(this, y),
                        (e = v.call(this)),
                        t && "object" === r(t) && ((n = t), (t = null)),
                        t
                          ? ((t = f(t)),
                            (n.hostname = t.host),
                            (n.secure =
                              "https" === t.protocol || "wss" === t.protocol),
                            (n.port = t.port),
                            t.query && (n.query = t.query))
                          : n.host && (n.hostname = f(n.host).host),
                        (e.secure =
                          null != n.secure
                            ? n.secure
                            : "undefined" != typeof location &&
                              "https:" === location.protocol),
                        n.hostname &&
                          !n.port &&
                          (n.port = e.secure ? "443" : "80"),
                        (e.hostname =
                          n.hostname ||
                          ("undefined" != typeof location
                            ? location.hostname
                            : "localhost")),
                        (e.port =
                          n.port ||
                          ("undefined" != typeof location && location.port
                            ? location.port
                            : e.secure
                            ? 443
                            : 80)),
                        (e.transports = n.transports || [
                          "polling",
                          "websocket",
                        ]),
                        (e.readyState = ""),
                        (e.writeBuffer = []),
                        (e.prevBufferLen = 0),
                        (e.opts = i(
                          {
                            path: "/engine.io",
                            agent: !1,
                            withCredentials: !1,
                            upgrade: !0,
                            jsonp: !0,
                            timestampParam: "t",
                            rememberUpgrade: !1,
                            rejectUnauthorized: !0,
                            perMessageDeflate: { threshold: 1024 },
                            transportOptions: {},
                            closeOnBeforeunload: !0,
                          },
                          n
                        )),
                        (e.opts.path = e.opts.path.replace(/\/$/, "") + "/"),
                        "string" == typeof e.opts.query &&
                          (e.opts.query = m.decode(e.opts.query)),
                        (e.id = null),
                        (e.upgrades = null),
                        (e.pingInterval = null),
                        (e.pingTimeout = null),
                        (e.pingTimeoutTimer = null),
                        "function" == typeof addEventListener &&
                          (e.opts.closeOnBeforeunload &&
                            addEventListener(
                              "beforeunload",
                              function () {
                                e.transport &&
                                  (e.transport.removeAllListeners(),
                                  e.transport.close());
                              },
                              !1
                            ),
                          "localhost" !== e.hostname &&
                            ((e.offlineEventListener = function () {
                              e.onClose("transport close");
                            }),
                            addEventListener(
                              "offline",
                              e.offlineEventListener,
                              !1
                            ))),
                        e.open(),
                        e
                      );
                    }
                    return (
                      (e = y),
                      (n = [
                        {
                          key: "createTransport",
                          value: function (t) {
                            d('creating transport "%s"', t);
                            var e = (function (t) {
                              var e = {};
                              for (var n in t)
                                t.hasOwnProperty(n) && (e[n] = t[n]);
                              return e;
                            })(this.opts.query);
                            (e.EIO = p.protocol),
                              (e.transport = t),
                              this.id && (e.sid = this.id);
                            var n = i(
                              {},
                              this.opts.transportOptions[t],
                              this.opts,
                              {
                                query: e,
                                socket: this,
                                hostname: this.hostname,
                                secure: this.secure,
                                port: this.port,
                              }
                            );
                            return d("options: %j", n), new u[t](n);
                          },
                        },
                        {
                          key: "open",
                          value: function () {
                            var t,
                              e = this;
                            if (
                              this.opts.rememberUpgrade &&
                              y.priorWebsocketSuccess &&
                              -1 !== this.transports.indexOf("websocket")
                            )
                              t = "websocket";
                            else {
                              if (0 === this.transports.length)
                                return void setTimeout(function () {
                                  e.emit("error", "No transports available");
                                }, 0);
                              t = this.transports[0];
                            }
                            this.readyState = "opening";
                            try {
                              t = this.createTransport(t);
                            } catch (t) {
                              return (
                                d("error while creating transport: %s", t),
                                this.transports.shift(),
                                void this.open()
                              );
                            }
                            t.open(), this.setTransport(t);
                          },
                        },
                        {
                          key: "setTransport",
                          value: function (t) {
                            var e = this;
                            d("setting transport %s", t.name),
                              this.transport &&
                                (d(
                                  "clearing existing transport %s",
                                  this.transport.name
                                ),
                                this.transport.removeAllListeners()),
                              (this.transport = t),
                              t
                                .on("drain", this.onDrain.bind(this))
                                .on("packet", this.onPacket.bind(this))
                                .on("error", this.onError.bind(this))
                                .on("close", function () {
                                  e.onClose("transport close");
                                });
                          },
                        },
                        {
                          key: "probe",
                          value: function (t) {
                            var e = this;
                            d('probing transport "%s"', t);
                            var n = this.createTransport(t, { probe: 1 }),
                              i = !1;
                            y.priorWebsocketSuccess = !1;
                            var r = function () {
                              i ||
                                (d('probe transport "%s" opened', t),
                                n.send([{ type: "ping", data: "probe" }]),
                                n.once("packet", function (r) {
                                  if (!i)
                                    if (
                                      "pong" === r.type &&
                                      "probe" === r.data
                                    ) {
                                      if (
                                        (d('probe transport "%s" pong', t),
                                        (e.upgrading = !0),
                                        e.emit("upgrading", n),
                                        !n)
                                      )
                                        return;
                                      (y.priorWebsocketSuccess =
                                        "websocket" === n.name),
                                        d(
                                          'pausing current transport "%s"',
                                          e.transport.name
                                        ),
                                        e.transport.pause(function () {
                                          i ||
                                            ("closed" !== e.readyState &&
                                              (d(
                                                "changing transport and sending upgrade packet"
                                              ),
                                              u(),
                                              e.setTransport(n),
                                              n.send([{ type: "upgrade" }]),
                                              e.emit("upgrade", n),
                                              (n = null),
                                              (e.upgrading = !1),
                                              e.flush()));
                                        });
                                    } else {
                                      d('probe transport "%s" failed', t);
                                      var o = new Error("probe error");
                                      (o.transport = n.name),
                                        e.emit("upgradeError", o);
                                    }
                                }));
                            };
                            function o() {
                              i || ((i = !0), u(), n.close(), (n = null));
                            }
                            var s = function (i) {
                              var r = new Error("probe error: " + i);
                              (r.transport = n.name),
                                o(),
                                d(
                                  'probe transport "%s" failed because of error: %s',
                                  t,
                                  i
                                ),
                                e.emit("upgradeError", r);
                            };
                            function a() {
                              s("transport closed");
                            }
                            function l() {
                              s("socket closed");
                            }
                            function c(t) {
                              n &&
                                t.name !== n.name &&
                                (d(
                                  '"%s" works - aborting "%s"',
                                  t.name,
                                  n.name
                                ),
                                o());
                            }
                            var u = function () {
                              n.removeListener("open", r),
                                n.removeListener("error", s),
                                n.removeListener("close", a),
                                e.removeListener("close", l),
                                e.removeListener("upgrading", c);
                            };
                            n.once("open", r),
                              n.once("error", s),
                              n.once("close", a),
                              this.once("close", l),
                              this.once("upgrading", c),
                              n.open();
                          },
                        },
                        {
                          key: "onOpen",
                          value: function () {
                            if (
                              (d("socket open"),
                              (this.readyState = "open"),
                              (y.priorWebsocketSuccess =
                                "websocket" === this.transport.name),
                              this.emit("open"),
                              this.flush(),
                              "open" === this.readyState &&
                                this.opts.upgrade &&
                                this.transport.pause)
                            ) {
                              d("starting upgrade probes");
                              for (
                                var t = 0, e = this.upgrades.length;
                                t < e;
                                t++
                              )
                                this.probe(this.upgrades[t]);
                            }
                          },
                        },
                        {
                          key: "onPacket",
                          value: function (t) {
                            if (
                              "opening" === this.readyState ||
                              "open" === this.readyState ||
                              "closing" === this.readyState
                            )
                              switch (
                                (d(
                                  'socket receive: type "%s", data "%s"',
                                  t.type,
                                  t.data
                                ),
                                this.emit("packet", t),
                                this.emit("heartbeat"),
                                t.type)
                              ) {
                                case "open":
                                  this.onHandshake(JSON.parse(t.data));
                                  break;
                                case "ping":
                                  this.resetPingTimeout(),
                                    this.sendPacket("pong"),
                                    this.emit("ping"),
                                    this.emit("pong");
                                  break;
                                case "error":
                                  var e = new Error("server error");
                                  (e.code = t.data), this.onError(e);
                                  break;
                                case "message":
                                  this.emit("data", t.data),
                                    this.emit("message", t.data);
                              }
                            else
                              d(
                                'packet received with socket readyState "%s"',
                                this.readyState
                              );
                          },
                        },
                        {
                          key: "onHandshake",
                          value: function (t) {
                            this.emit("handshake", t),
                              (this.id = t.sid),
                              (this.transport.query.sid = t.sid),
                              (this.upgrades = this.filterUpgrades(t.upgrades)),
                              (this.pingInterval = t.pingInterval),
                              (this.pingTimeout = t.pingTimeout),
                              this.onOpen(),
                              "closed" !== this.readyState &&
                                this.resetPingTimeout();
                          },
                        },
                        {
                          key: "resetPingTimeout",
                          value: function () {
                            var t = this;
                            clearTimeout(this.pingTimeoutTimer),
                              (this.pingTimeoutTimer = setTimeout(function () {
                                t.onClose("ping timeout");
                              }, this.pingInterval + this.pingTimeout)),
                              this.opts.autoUnref &&
                                this.pingTimeoutTimer.unref();
                          },
                        },
                        {
                          key: "onDrain",
                          value: function () {
                            this.writeBuffer.splice(0, this.prevBufferLen),
                              (this.prevBufferLen = 0),
                              0 === this.writeBuffer.length
                                ? this.emit("drain")
                                : this.flush();
                          },
                        },
                        {
                          key: "flush",
                          value: function () {
                            "closed" !== this.readyState &&
                              this.transport.writable &&
                              !this.upgrading &&
                              this.writeBuffer.length &&
                              (d(
                                "flushing %d packets in socket",
                                this.writeBuffer.length
                              ),
                              this.transport.send(this.writeBuffer),
                              (this.prevBufferLen = this.writeBuffer.length),
                              this.emit("flush"));
                          },
                        },
                        {
                          key: "write",
                          value: function (t, e, n) {
                            return this.sendPacket("message", t, e, n), this;
                          },
                        },
                        {
                          key: "send",
                          value: function (t, e, n) {
                            return this.sendPacket("message", t, e, n), this;
                          },
                        },
                        {
                          key: "sendPacket",
                          value: function (t, e, n, i) {
                            if (
                              ("function" == typeof e &&
                                ((i = e), (e = void 0)),
                              "function" == typeof n && ((i = n), (n = null)),
                              "closing" !== this.readyState &&
                                "closed" !== this.readyState)
                            ) {
                              (n = n || {}).compress = !1 !== n.compress;
                              var r = { type: t, data: e, options: n };
                              this.emit("packetCreate", r),
                                this.writeBuffer.push(r),
                                i && this.once("flush", i),
                                this.flush();
                            }
                          },
                        },
                        {
                          key: "close",
                          value: function () {
                            var t = this,
                              e = function () {
                                t.onClose("forced close"),
                                  d(
                                    "socket closing - telling transport to close"
                                  ),
                                  t.transport.close();
                              },
                              n = function n() {
                                t.removeListener("upgrade", n),
                                  t.removeListener("upgradeError", n),
                                  e();
                              },
                              i = function () {
                                t.once("upgrade", n), t.once("upgradeError", n);
                              };
                            return (
                              ("opening" !== this.readyState &&
                                "open" !== this.readyState) ||
                                ((this.readyState = "closing"),
                                this.writeBuffer.length
                                  ? this.once("drain", function () {
                                      t.upgrading ? i() : e();
                                    })
                                  : this.upgrading
                                  ? i()
                                  : e()),
                              this
                            );
                          },
                        },
                        {
                          key: "onError",
                          value: function (t) {
                            d("socket error %j", t),
                              (y.priorWebsocketSuccess = !1),
                              this.emit("error", t),
                              this.onClose("transport error", t);
                          },
                        },
                        {
                          key: "onClose",
                          value: function (t, e) {
                            ("opening" !== this.readyState &&
                              "open" !== this.readyState &&
                              "closing" !== this.readyState) ||
                              (d('socket close with reason: "%s"', t),
                              clearTimeout(this.pingIntervalTimer),
                              clearTimeout(this.pingTimeoutTimer),
                              this.transport.removeAllListeners("close"),
                              this.transport.close(),
                              this.transport.removeAllListeners(),
                              "function" == typeof removeEventListener &&
                                removeEventListener(
                                  "offline",
                                  this.offlineEventListener,
                                  !1
                                ),
                              (this.readyState = "closed"),
                              (this.id = null),
                              this.emit("close", t, e),
                              (this.writeBuffer = []),
                              (this.prevBufferLen = 0));
                          },
                        },
                        {
                          key: "filterUpgrades",
                          value: function (t) {
                            for (var e = [], n = 0, i = t.length; n < i; n++)
                              ~this.transports.indexOf(t[n]) && e.push(t[n]);
                            return e;
                          },
                        },
                      ]) && s(e.prototype, n),
                      y
                    );
                  })(h);
                (g.priorWebsocketSuccess = !1),
                  (g.protocol = p.protocol),
                  (t.exports = g);
              },
              "./node_modules/engine.io-client/lib/transport.js": function (
                t,
                e,
                n
              ) {
                function i(t) {
                  return (i =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                function r(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    (i.enumerable = i.enumerable || !1),
                      (i.configurable = !0),
                      "value" in i && (i.writable = !0),
                      Object.defineProperty(t, i.key, i);
                  }
                }
                function o(t, e) {
                  return (o =
                    Object.setPrototypeOf ||
                    function (t, e) {
                      return (t.__proto__ = e), t;
                    })(t, e);
                }
                function s(t, e) {
                  return !e || ("object" !== i(e) && "function" != typeof e)
                    ? (function (t) {
                        if (void 0 === t)
                          throw new ReferenceError(
                            "this hasn't been initialised - super() hasn't been called"
                          );
                        return t;
                      })(t)
                    : e;
                }
                function a(t) {
                  return (a = Object.setPrototypeOf
                    ? Object.getPrototypeOf
                    : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t);
                      })(t);
                }
                var l = n("./node_modules/engine.io-parser/lib/index.js"),
                  c = n("./node_modules/component-emitter/index.js"),
                  u = n("./node_modules/debug/src/browser.js")(
                    "engine.io-client:transport"
                  ),
                  h = (function (t) {
                    !(function (t, e) {
                      if ("function" != typeof e && null !== e)
                        throw new TypeError(
                          "Super expression must either be null or a function"
                        );
                      (t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                          value: t,
                          writable: !0,
                          configurable: !0,
                        },
                      })),
                        e && o(t, e);
                    })(d, t);
                    var e,
                      n,
                      i,
                      c,
                      h =
                        ((i = d),
                        (c = (function () {
                          if (
                            "undefined" == typeof Reflect ||
                            !Reflect.construct
                          )
                            return !1;
                          if (Reflect.construct.sham) return !1;
                          if ("function" == typeof Proxy) return !0;
                          try {
                            return (
                              Boolean.prototype.valueOf.call(
                                Reflect.construct(Boolean, [], function () {})
                              ),
                              !0
                            );
                          } catch (t) {
                            return !1;
                          }
                        })()),
                        function () {
                          var t,
                            e = a(i);
                          if (c) {
                            var n = a(this).constructor;
                            t = Reflect.construct(e, arguments, n);
                          } else t = e.apply(this, arguments);
                          return s(this, t);
                        });
                    function d(t) {
                      var e;
                      return (
                        (function (t, e) {
                          if (!(t instanceof e))
                            throw new TypeError(
                              "Cannot call a class as a function"
                            );
                        })(this, d),
                        ((e = h.call(this)).opts = t),
                        (e.query = t.query),
                        (e.readyState = ""),
                        (e.socket = t.socket),
                        e
                      );
                    }
                    return (
                      (e = d),
                      (n = [
                        {
                          key: "onError",
                          value: function (t, e) {
                            var n = new Error(t);
                            return (
                              (n.type = "TransportError"),
                              (n.description = e),
                              this.emit("error", n),
                              this
                            );
                          },
                        },
                        {
                          key: "open",
                          value: function () {
                            return (
                              ("closed" !== this.readyState &&
                                "" !== this.readyState) ||
                                ((this.readyState = "opening"), this.doOpen()),
                              this
                            );
                          },
                        },
                        {
                          key: "close",
                          value: function () {
                            return (
                              ("opening" !== this.readyState &&
                                "open" !== this.readyState) ||
                                (this.doClose(), this.onClose()),
                              this
                            );
                          },
                        },
                        {
                          key: "send",
                          value: function (t) {
                            "open" === this.readyState
                              ? this.write(t)
                              : u("transport is not open, discarding packets");
                          },
                        },
                        {
                          key: "onOpen",
                          value: function () {
                            (this.readyState = "open"),
                              (this.writable = !0),
                              this.emit("open");
                          },
                        },
                        {
                          key: "onData",
                          value: function (t) {
                            var e = l.decodePacket(t, this.socket.binaryType);
                            this.onPacket(e);
                          },
                        },
                        {
                          key: "onPacket",
                          value: function (t) {
                            this.emit("packet", t);
                          },
                        },
                        {
                          key: "onClose",
                          value: function () {
                            (this.readyState = "closed"), this.emit("close");
                          },
                        },
                      ]) && r(e.prototype, n),
                      d
                    );
                  })(c);
                t.exports = h;
              },
              "./node_modules/engine.io-client/lib/transports/index.js":
                function (t, e, n) {
                  var i = n(
                      "./node_modules/engine.io-client/lib/xmlhttprequest.js"
                    ),
                    r = n(
                      "./node_modules/engine.io-client/lib/transports/polling-xhr.js"
                    ),
                    o = n(
                      "./node_modules/engine.io-client/lib/transports/polling-jsonp.js"
                    ),
                    s = n(
                      "./node_modules/engine.io-client/lib/transports/websocket.js"
                    );
                  (e.polling = function (t) {
                    var e = !1,
                      n = !1,
                      s = !1 !== t.jsonp;
                    if ("undefined" != typeof location) {
                      var a = "https:" === location.protocol,
                        l = location.port;
                      l || (l = a ? 443 : 80),
                        (e = t.hostname !== location.hostname || l !== t.port),
                        (n = t.secure !== a);
                    }
                    if (
                      ((t.xdomain = e),
                      (t.xscheme = n),
                      "open" in new i(t) && !t.forceJSONP)
                    )
                      return new r(t);
                    if (!s) throw new Error("JSONP disabled");
                    return new o(t);
                  }),
                    (e.websocket = s);
                },
              "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
                function (t, e, n) {
                  function i(t) {
                    return (i =
                      "function" == typeof Symbol &&
                      "symbol" == typeof Symbol.iterator
                        ? function (t) {
                            return typeof t;
                          }
                        : function (t) {
                            return t &&
                              "function" == typeof Symbol &&
                              t.constructor === Symbol &&
                              t !== Symbol.prototype
                              ? "symbol"
                              : typeof t;
                          })(t);
                  }
                  function r(t, e) {
                    for (var n = 0; n < e.length; n++) {
                      var i = e[n];
                      (i.enumerable = i.enumerable || !1),
                        (i.configurable = !0),
                        "value" in i && (i.writable = !0),
                        Object.defineProperty(t, i.key, i);
                    }
                  }
                  function o(t, e, n) {
                    return (o =
                      "undefined" != typeof Reflect && Reflect.get
                        ? Reflect.get
                        : function (t, e, n) {
                            var i = (function (t, e) {
                              for (
                                ;
                                !Object.prototype.hasOwnProperty.call(t, e) &&
                                null !== (t = c(t));

                              );
                              return t;
                            })(t, e);
                            if (i) {
                              var r = Object.getOwnPropertyDescriptor(i, e);
                              return r.get ? r.get.call(n) : r.value;
                            }
                          })(t, e, n || t);
                  }
                  function s(t, e) {
                    return (s =
                      Object.setPrototypeOf ||
                      function (t, e) {
                        return (t.__proto__ = e), t;
                      })(t, e);
                  }
                  function a(t, e) {
                    return !e || ("object" !== i(e) && "function" != typeof e)
                      ? l(t)
                      : e;
                  }
                  function l(t) {
                    if (void 0 === t)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return t;
                  }
                  function c(t) {
                    return (c = Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function (t) {
                          return t.__proto__ || Object.getPrototypeOf(t);
                        })(t);
                  }
                  var u,
                    h = n(
                      "./node_modules/engine.io-client/lib/transports/polling.js"
                    ),
                    d = n(
                      "./node_modules/engine.io-client/lib/globalThis.browser.js"
                    ),
                    p = /\n/g,
                    f = /\\n/g,
                    m = (function (t) {
                      !(function (t, e) {
                        if ("function" != typeof e && null !== e)
                          throw new TypeError(
                            "Super expression must either be null or a function"
                          );
                        (t.prototype = Object.create(e && e.prototype, {
                          constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0,
                          },
                        })),
                          e && s(t, e);
                      })(g, t);
                      var e,
                        n,
                        i,
                        h,
                        m =
                          ((i = g),
                          (h = (function () {
                            if (
                              "undefined" == typeof Reflect ||
                              !Reflect.construct
                            )
                              return !1;
                            if (Reflect.construct.sham) return !1;
                            if ("function" == typeof Proxy) return !0;
                            try {
                              return (
                                Boolean.prototype.valueOf.call(
                                  Reflect.construct(Boolean, [], function () {})
                                ),
                                !0
                              );
                            } catch (t) {
                              return !1;
                            }
                          })()),
                          function () {
                            var t,
                              e = c(i);
                            if (h) {
                              var n = c(this).constructor;
                              t = Reflect.construct(e, arguments, n);
                            } else t = e.apply(this, arguments);
                            return a(this, t);
                          });
                      function g(t) {
                        var e;
                        return (
                          (function (t, e) {
                            if (!(t instanceof e))
                              throw new TypeError(
                                "Cannot call a class as a function"
                              );
                          })(this, g),
                          ((e = m.call(this, t)).query = e.query || {}),
                          u || (u = d.___eio = d.___eio || []),
                          (e.index = u.length),
                          u.push(e.onData.bind(l(e))),
                          (e.query.j = e.index),
                          e
                        );
                      }
                      return (
                        (e = g),
                        (n = [
                          {
                            key: "supportsBinary",
                            get: function () {
                              return !1;
                            },
                          },
                          {
                            key: "doClose",
                            value: function () {
                              this.script &&
                                ((this.script.onerror = function () {}),
                                this.script.parentNode.removeChild(this.script),
                                (this.script = null)),
                                this.form &&
                                  (this.form.parentNode.removeChild(this.form),
                                  (this.form = null),
                                  (this.iframe = null)),
                                o(c(g.prototype), "doClose", this).call(this);
                            },
                          },
                          {
                            key: "doPoll",
                            value: function () {
                              var t = this,
                                e = document.createElement("script");
                              this.script &&
                                (this.script.parentNode.removeChild(
                                  this.script
                                ),
                                (this.script = null)),
                                (e.async = !0),
                                (e.src = this.uri()),
                                (e.onerror = function (e) {
                                  t.onError("jsonp poll error", e);
                                });
                              var n =
                                document.getElementsByTagName("script")[0];
                              n
                                ? n.parentNode.insertBefore(e, n)
                                : (document.head || document.body).appendChild(
                                    e
                                  ),
                                (this.script = e),
                                "undefined" != typeof navigator &&
                                  /gecko/i.test(navigator.userAgent) &&
                                  setTimeout(function () {
                                    var t = document.createElement("iframe");
                                    document.body.appendChild(t),
                                      document.body.removeChild(t);
                                  }, 100);
                            },
                          },
                          {
                            key: "doWrite",
                            value: function (t, e) {
                              var n,
                                i = this;
                              if (!this.form) {
                                var r = document.createElement("form"),
                                  o = document.createElement("textarea"),
                                  s = (this.iframeId =
                                    "eio_iframe_" + this.index);
                                (r.className = "socketio"),
                                  (r.style.position = "absolute"),
                                  (r.style.top = "-1000px"),
                                  (r.style.left = "-1000px"),
                                  (r.target = s),
                                  (r.method = "POST"),
                                  r.setAttribute("accept-charset", "utf-8"),
                                  (o.name = "d"),
                                  r.appendChild(o),
                                  document.body.appendChild(r),
                                  (this.form = r),
                                  (this.area = o);
                              }
                              function a() {
                                l(), e();
                              }
                              this.form.action = this.uri();
                              var l = function () {
                                if (i.iframe)
                                  try {
                                    i.form.removeChild(i.iframe);
                                  } catch (t) {
                                    i.onError(
                                      "jsonp polling iframe removal error",
                                      t
                                    );
                                  }
                                try {
                                  var t =
                                    '<iframe src="javascript:0" name="' +
                                    i.iframeId +
                                    '">';
                                  n = document.createElement(t);
                                } catch (t) {
                                  ((n = document.createElement("iframe")).name =
                                    i.iframeId),
                                    (n.src = "javascript:0");
                                }
                                (n.id = i.iframeId),
                                  i.form.appendChild(n),
                                  (i.iframe = n);
                              };
                              l(),
                                (t = t.replace(f, "\\\n")),
                                (this.area.value = t.replace(p, "\\n"));
                              try {
                                this.form.submit();
                              } catch (t) {}
                              this.iframe.attachEvent
                                ? (this.iframe.onreadystatechange =
                                    function () {
                                      "complete" === i.iframe.readyState && a();
                                    })
                                : (this.iframe.onload = a);
                            },
                          },
                        ]) && r(e.prototype, n),
                        g
                      );
                    })(h);
                  t.exports = m;
                },
              "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
                function (t, e, n) {
                  function i(t) {
                    return (i =
                      "function" == typeof Symbol &&
                      "symbol" == typeof Symbol.iterator
                        ? function (t) {
                            return typeof t;
                          }
                        : function (t) {
                            return t &&
                              "function" == typeof Symbol &&
                              t.constructor === Symbol &&
                              t !== Symbol.prototype
                              ? "symbol"
                              : typeof t;
                          })(t);
                  }
                  function r() {
                    return (r =
                      Object.assign ||
                      function (t) {
                        for (var e = 1; e < arguments.length; e++) {
                          var n = arguments[e];
                          for (var i in n)
                            Object.prototype.hasOwnProperty.call(n, i) &&
                              (t[i] = n[i]);
                        }
                        return t;
                      }).apply(this, arguments);
                  }
                  function o(t, e) {
                    if (!(t instanceof e))
                      throw new TypeError("Cannot call a class as a function");
                  }
                  function s(t, e) {
                    for (var n = 0; n < e.length; n++) {
                      var i = e[n];
                      (i.enumerable = i.enumerable || !1),
                        (i.configurable = !0),
                        "value" in i && (i.writable = !0),
                        Object.defineProperty(t, i.key, i);
                    }
                  }
                  function a(t, e, n) {
                    return e && s(t.prototype, e), n && s(t, n), t;
                  }
                  function l(t, e) {
                    if ("function" != typeof e && null !== e)
                      throw new TypeError(
                        "Super expression must either be null or a function"
                      );
                    (t.prototype = Object.create(e && e.prototype, {
                      constructor: { value: t, writable: !0, configurable: !0 },
                    })),
                      e && c(t, e);
                  }
                  function c(t, e) {
                    return (c =
                      Object.setPrototypeOf ||
                      function (t, e) {
                        return (t.__proto__ = e), t;
                      })(t, e);
                  }
                  function u(t) {
                    var e = (function () {
                      if ("undefined" == typeof Reflect || !Reflect.construct)
                        return !1;
                      if (Reflect.construct.sham) return !1;
                      if ("function" == typeof Proxy) return !0;
                      try {
                        return (
                          Boolean.prototype.valueOf.call(
                            Reflect.construct(Boolean, [], function () {})
                          ),
                          !0
                        );
                      } catch (t) {
                        return !1;
                      }
                    })();
                    return function () {
                      var n,
                        i = d(t);
                      if (e) {
                        var r = d(this).constructor;
                        n = Reflect.construct(i, arguments, r);
                      } else n = i.apply(this, arguments);
                      return h(this, n);
                    };
                  }
                  function h(t, e) {
                    return !e || ("object" !== i(e) && "function" != typeof e)
                      ? (function (t) {
                          if (void 0 === t)
                            throw new ReferenceError(
                              "this hasn't been initialised - super() hasn't been called"
                            );
                          return t;
                        })(t)
                      : e;
                  }
                  function d(t) {
                    return (d = Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function (t) {
                          return t.__proto__ || Object.getPrototypeOf(t);
                        })(t);
                  }
                  var p = n(
                      "./node_modules/engine.io-client/lib/xmlhttprequest.js"
                    ),
                    f = n(
                      "./node_modules/engine.io-client/lib/transports/polling.js"
                    ),
                    m = n("./node_modules/component-emitter/index.js"),
                    g = n("./node_modules/engine.io-client/lib/util.js").pick,
                    v = n(
                      "./node_modules/engine.io-client/lib/globalThis.browser.js"
                    ),
                    y = n("./node_modules/debug/src/browser.js")(
                      "engine.io-client:polling-xhr"
                    );
                  function x() {}
                  var b = null != new p({ xdomain: !1 }).responseType,
                    w = (function (t) {
                      l(n, t);
                      var e = u(n);
                      function n(t) {
                        var i;
                        if (
                          (o(this, n),
                          (i = e.call(this, t)),
                          "undefined" != typeof location)
                        ) {
                          var r = "https:" === location.protocol,
                            s = location.port;
                          s || (s = r ? 443 : 80),
                            (i.xd =
                              ("undefined" != typeof location &&
                                t.hostname !== location.hostname) ||
                              s !== t.port),
                            (i.xs = t.secure !== r);
                        }
                        var a = t && t.forceBase64;
                        return (i.supportsBinary = b && !a), i;
                      }
                      return (
                        a(n, [
                          {
                            key: "request",
                            value: function () {
                              var t =
                                arguments.length > 0 && void 0 !== arguments[0]
                                  ? arguments[0]
                                  : {};
                              return (
                                r(t, { xd: this.xd, xs: this.xs }, this.opts),
                                new _(this.uri(), t)
                              );
                            },
                          },
                          {
                            key: "doWrite",
                            value: function (t, e) {
                              var n = this,
                                i = this.request({ method: "POST", data: t });
                              i.on("success", e),
                                i.on("error", function (t) {
                                  n.onError("xhr post error", t);
                                });
                            },
                          },
                          {
                            key: "doPoll",
                            value: function () {
                              var t = this;
                              y("xhr poll");
                              var e = this.request();
                              e.on("data", this.onData.bind(this)),
                                e.on("error", function (e) {
                                  t.onError("xhr poll error", e);
                                }),
                                (this.pollXhr = e);
                            },
                          },
                        ]),
                        n
                      );
                    })(f),
                    _ = (function (t) {
                      l(n, t);
                      var e = u(n);
                      function n(t, i) {
                        var r;
                        return (
                          o(this, n),
                          ((r = e.call(this)).opts = i),
                          (r.method = i.method || "GET"),
                          (r.uri = t),
                          (r.async = !1 !== i.async),
                          (r.data = void 0 !== i.data ? i.data : null),
                          r.create(),
                          r
                        );
                      }
                      return (
                        a(n, [
                          {
                            key: "create",
                            value: function () {
                              var t = this,
                                e = g(
                                  this.opts,
                                  "agent",
                                  "enablesXDR",
                                  "pfx",
                                  "key",
                                  "passphrase",
                                  "cert",
                                  "ca",
                                  "ciphers",
                                  "rejectUnauthorized",
                                  "autoUnref"
                                );
                              (e.xdomain = !!this.opts.xd),
                                (e.xscheme = !!this.opts.xs);
                              var i = (this.xhr = new p(e));
                              try {
                                y("xhr open %s: %s", this.method, this.uri),
                                  i.open(this.method, this.uri, this.async);
                                try {
                                  if (this.opts.extraHeaders)
                                    for (var r in (i.setDisableHeaderCheck &&
                                      i.setDisableHeaderCheck(!0),
                                    this.opts.extraHeaders))
                                      this.opts.extraHeaders.hasOwnProperty(
                                        r
                                      ) &&
                                        i.setRequestHeader(
                                          r,
                                          this.opts.extraHeaders[r]
                                        );
                                } catch (t) {}
                                if ("POST" === this.method)
                                  try {
                                    i.setRequestHeader(
                                      "Content-type",
                                      "text/plain;charset=UTF-8"
                                    );
                                  } catch (t) {}
                                try {
                                  i.setRequestHeader("Accept", "*/*");
                                } catch (t) {}
                                "withCredentials" in i &&
                                  (i.withCredentials =
                                    this.opts.withCredentials),
                                  this.opts.requestTimeout &&
                                    (i.timeout = this.opts.requestTimeout),
                                  this.hasXDR()
                                    ? ((i.onload = function () {
                                        t.onLoad();
                                      }),
                                      (i.onerror = function () {
                                        t.onError(i.responseText);
                                      }))
                                    : (i.onreadystatechange = function () {
                                        4 === i.readyState &&
                                          (200 === i.status || 1223 === i.status
                                            ? t.onLoad()
                                            : setTimeout(function () {
                                                t.onError(
                                                  "number" == typeof i.status
                                                    ? i.status
                                                    : 0
                                                );
                                              }, 0));
                                      }),
                                  y("xhr data %s", this.data),
                                  i.send(this.data);
                              } catch (e) {
                                return void setTimeout(function () {
                                  t.onError(e);
                                }, 0);
                              }
                              "undefined" != typeof document &&
                                ((this.index = n.requestsCount++),
                                (n.requests[this.index] = this));
                            },
                          },
                          {
                            key: "onSuccess",
                            value: function () {
                              this.emit("success"), this.cleanup();
                            },
                          },
                          {
                            key: "onData",
                            value: function (t) {
                              this.emit("data", t), this.onSuccess();
                            },
                          },
                          {
                            key: "onError",
                            value: function (t) {
                              this.emit("error", t), this.cleanup(!0);
                            },
                          },
                          {
                            key: "cleanup",
                            value: function (t) {
                              if (void 0 !== this.xhr && null !== this.xhr) {
                                if (
                                  (this.hasXDR()
                                    ? (this.xhr.onload = this.xhr.onerror = x)
                                    : (this.xhr.onreadystatechange = x),
                                  t)
                                )
                                  try {
                                    this.xhr.abort();
                                  } catch (t) {}
                                "undefined" != typeof document &&
                                  delete n.requests[this.index],
                                  (this.xhr = null);
                              }
                            },
                          },
                          {
                            key: "onLoad",
                            value: function () {
                              var t = this.xhr.responseText;
                              null !== t && this.onData(t);
                            },
                          },
                          {
                            key: "hasXDR",
                            value: function () {
                              return (
                                "undefined" != typeof XDomainRequest &&
                                !this.xs &&
                                this.enablesXDR
                              );
                            },
                          },
                          {
                            key: "abort",
                            value: function () {
                              this.cleanup();
                            },
                          },
                        ]),
                        n
                      );
                    })(m);
                  function M() {
                    for (var t in _.requests)
                      _.requests.hasOwnProperty(t) && _.requests[t].abort();
                  }
                  (_.requestsCount = 0),
                    (_.requests = {}),
                    "undefined" != typeof document &&
                      ("function" == typeof attachEvent
                        ? attachEvent("onunload", M)
                        : "function" == typeof addEventListener &&
                          addEventListener(
                            "onpagehide" in v ? "pagehide" : "unload",
                            M,
                            !1
                          )),
                    (t.exports = w),
                    (t.exports.Request = _);
                },
              "./node_modules/engine.io-client/lib/transports/polling.js":
                function (t, e, n) {
                  function i(t) {
                    return (i =
                      "function" == typeof Symbol &&
                      "symbol" == typeof Symbol.iterator
                        ? function (t) {
                            return typeof t;
                          }
                        : function (t) {
                            return t &&
                              "function" == typeof Symbol &&
                              t.constructor === Symbol &&
                              t !== Symbol.prototype
                              ? "symbol"
                              : typeof t;
                          })(t);
                  }
                  function r(t, e) {
                    if (!(t instanceof e))
                      throw new TypeError("Cannot call a class as a function");
                  }
                  function o(t, e) {
                    for (var n = 0; n < e.length; n++) {
                      var i = e[n];
                      (i.enumerable = i.enumerable || !1),
                        (i.configurable = !0),
                        "value" in i && (i.writable = !0),
                        Object.defineProperty(t, i.key, i);
                    }
                  }
                  function s(t, e) {
                    return (s =
                      Object.setPrototypeOf ||
                      function (t, e) {
                        return (t.__proto__ = e), t;
                      })(t, e);
                  }
                  function a(t, e) {
                    return !e || ("object" !== i(e) && "function" != typeof e)
                      ? (function (t) {
                          if (void 0 === t)
                            throw new ReferenceError(
                              "this hasn't been initialised - super() hasn't been called"
                            );
                          return t;
                        })(t)
                      : e;
                  }
                  function l(t) {
                    return (l = Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function (t) {
                          return t.__proto__ || Object.getPrototypeOf(t);
                        })(t);
                  }
                  var c = n("./node_modules/engine.io-client/lib/transport.js"),
                    u = n("./node_modules/parseqs/index.js"),
                    h = n("./node_modules/engine.io-parser/lib/index.js"),
                    d = n("./node_modules/yeast/index.js"),
                    p = n("./node_modules/debug/src/browser.js")(
                      "engine.io-client:polling"
                    ),
                    f = (function (t) {
                      !(function (t, e) {
                        if ("function" != typeof e && null !== e)
                          throw new TypeError(
                            "Super expression must either be null or a function"
                          );
                        (t.prototype = Object.create(e && e.prototype, {
                          constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0,
                          },
                        })),
                          e && s(t, e);
                      })(m, t);
                      var e,
                        n,
                        i,
                        c,
                        f =
                          ((i = m),
                          (c = (function () {
                            if (
                              "undefined" == typeof Reflect ||
                              !Reflect.construct
                            )
                              return !1;
                            if (Reflect.construct.sham) return !1;
                            if ("function" == typeof Proxy) return !0;
                            try {
                              return (
                                Boolean.prototype.valueOf.call(
                                  Reflect.construct(Boolean, [], function () {})
                                ),
                                !0
                              );
                            } catch (t) {
                              return !1;
                            }
                          })()),
                          function () {
                            var t,
                              e = l(i);
                            if (c) {
                              var n = l(this).constructor;
                              t = Reflect.construct(e, arguments, n);
                            } else t = e.apply(this, arguments);
                            return a(this, t);
                          });
                      function m() {
                        return r(this, m), f.apply(this, arguments);
                      }
                      return (
                        (e = m),
                        (n = [
                          {
                            key: "name",
                            get: function () {
                              return "polling";
                            },
                          },
                          {
                            key: "doOpen",
                            value: function () {
                              this.poll();
                            },
                          },
                          {
                            key: "pause",
                            value: function (t) {
                              var e = this;
                              this.readyState = "pausing";
                              var n = function () {
                                p("paused"), (e.readyState = "paused"), t();
                              };
                              if (this.polling || !this.writable) {
                                var i = 0;
                                this.polling &&
                                  (p(
                                    "we are currently polling - waiting to pause"
                                  ),
                                  i++,
                                  this.once("pollComplete", function () {
                                    p("pre-pause polling complete"), --i || n();
                                  })),
                                  this.writable ||
                                    (p(
                                      "we are currently writing - waiting to pause"
                                    ),
                                    i++,
                                    this.once("drain", function () {
                                      p("pre-pause writing complete"),
                                        --i || n();
                                    }));
                              } else n();
                            },
                          },
                          {
                            key: "poll",
                            value: function () {
                              p("polling"),
                                (this.polling = !0),
                                this.doPoll(),
                                this.emit("poll");
                            },
                          },
                          {
                            key: "onData",
                            value: function (t) {
                              var e = this;
                              p("polling got data %s", t),
                                h
                                  .decodePayload(t, this.socket.binaryType)
                                  .forEach(function (t) {
                                    if (
                                      ("opening" === e.readyState &&
                                        "open" === t.type &&
                                        e.onOpen(),
                                      "close" === t.type)
                                    )
                                      return e.onClose(), !1;
                                    e.onPacket(t);
                                  }),
                                "closed" !== this.readyState &&
                                  ((this.polling = !1),
                                  this.emit("pollComplete"),
                                  "open" === this.readyState
                                    ? this.poll()
                                    : p(
                                        'ignoring poll - transport state "%s"',
                                        this.readyState
                                      ));
                            },
                          },
                          {
                            key: "doClose",
                            value: function () {
                              var t = this,
                                e = function () {
                                  p("writing close packet"),
                                    t.write([{ type: "close" }]);
                                };
                              "open" === this.readyState
                                ? (p("transport open - closing"), e())
                                : (p("transport not open - deferring close"),
                                  this.once("open", e));
                            },
                          },
                          {
                            key: "write",
                            value: function (t) {
                              var e = this;
                              (this.writable = !1),
                                h.encodePayload(t, function (t) {
                                  e.doWrite(t, function () {
                                    (e.writable = !0), e.emit("drain");
                                  });
                                });
                            },
                          },
                          {
                            key: "uri",
                            value: function () {
                              var t = this.query || {},
                                e = this.opts.secure ? "https" : "http",
                                n = "";
                              return (
                                !1 !== this.opts.timestampRequests &&
                                  (t[this.opts.timestampParam] = d()),
                                this.supportsBinary || t.sid || (t.b64 = 1),
                                (t = u.encode(t)),
                                this.opts.port &&
                                  (("https" === e &&
                                    443 !== Number(this.opts.port)) ||
                                    ("http" === e &&
                                      80 !== Number(this.opts.port))) &&
                                  (n = ":" + this.opts.port),
                                t.length && (t = "?" + t),
                                e +
                                  "://" +
                                  (-1 !== this.opts.hostname.indexOf(":")
                                    ? "[" + this.opts.hostname + "]"
                                    : this.opts.hostname) +
                                  n +
                                  this.opts.path +
                                  t
                              );
                            },
                          },
                        ]) && o(e.prototype, n),
                        m
                      );
                    })(c);
                  t.exports = f;
                },
              "./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js":
                function (t, e, n) {
                  var i = n(
                      "./node_modules/engine.io-client/lib/globalThis.browser.js"
                    ),
                    r =
                      "function" == typeof Promise &&
                      "function" == typeof Promise.resolve
                        ? function (t) {
                            return Promise.resolve().then(t);
                          }
                        : function (t) {
                            return setTimeout(t, 0);
                          };
                  t.exports = {
                    WebSocket: i.WebSocket || i.MozWebSocket,
                    usingBrowserWebSocket: !0,
                    defaultBinaryType: "arraybuffer",
                    nextTick: r,
                  };
                },
              "./node_modules/engine.io-client/lib/transports/websocket.js":
                function (t, e, n) {
                  function i(t) {
                    return (i =
                      "function" == typeof Symbol &&
                      "symbol" == typeof Symbol.iterator
                        ? function (t) {
                            return typeof t;
                          }
                        : function (t) {
                            return t &&
                              "function" == typeof Symbol &&
                              t.constructor === Symbol &&
                              t !== Symbol.prototype
                              ? "symbol"
                              : typeof t;
                          })(t);
                  }
                  function r(t, e) {
                    for (var n = 0; n < e.length; n++) {
                      var i = e[n];
                      (i.enumerable = i.enumerable || !1),
                        (i.configurable = !0),
                        "value" in i && (i.writable = !0),
                        Object.defineProperty(t, i.key, i);
                    }
                  }
                  function o(t, e) {
                    return (o =
                      Object.setPrototypeOf ||
                      function (t, e) {
                        return (t.__proto__ = e), t;
                      })(t, e);
                  }
                  function s(t, e) {
                    return !e || ("object" !== i(e) && "function" != typeof e)
                      ? (function (t) {
                          if (void 0 === t)
                            throw new ReferenceError(
                              "this hasn't been initialised - super() hasn't been called"
                            );
                          return t;
                        })(t)
                      : e;
                  }
                  function a(t) {
                    return (a = Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function (t) {
                          return t.__proto__ || Object.getPrototypeOf(t);
                        })(t);
                  }
                  var l = n("./node_modules/engine.io-client/lib/transport.js"),
                    c = n("./node_modules/engine.io-parser/lib/index.js"),
                    u = n("./node_modules/parseqs/index.js"),
                    h = n("./node_modules/yeast/index.js"),
                    d = n("./node_modules/engine.io-client/lib/util.js").pick,
                    p = n(
                      "./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js"
                    ),
                    f = p.WebSocket,
                    m = p.usingBrowserWebSocket,
                    g = p.defaultBinaryType,
                    v = p.nextTick,
                    y = n("./node_modules/debug/src/browser.js")(
                      "engine.io-client:websocket"
                    ),
                    x =
                      "undefined" != typeof navigator &&
                      "string" == typeof navigator.product &&
                      "reactnative" === navigator.product.toLowerCase(),
                    b = (function (t) {
                      !(function (t, e) {
                        if ("function" != typeof e && null !== e)
                          throw new TypeError(
                            "Super expression must either be null or a function"
                          );
                        (t.prototype = Object.create(e && e.prototype, {
                          constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0,
                          },
                        })),
                          e && o(t, e);
                      })(w, t);
                      var e,
                        n,
                        i,
                        p,
                        b =
                          ((i = w),
                          (p = (function () {
                            if (
                              "undefined" == typeof Reflect ||
                              !Reflect.construct
                            )
                              return !1;
                            if (Reflect.construct.sham) return !1;
                            if ("function" == typeof Proxy) return !0;
                            try {
                              return (
                                Boolean.prototype.valueOf.call(
                                  Reflect.construct(Boolean, [], function () {})
                                ),
                                !0
                              );
                            } catch (t) {
                              return !1;
                            }
                          })()),
                          function () {
                            var t,
                              e = a(i);
                            if (p) {
                              var n = a(this).constructor;
                              t = Reflect.construct(e, arguments, n);
                            } else t = e.apply(this, arguments);
                            return s(this, t);
                          });
                      function w(t) {
                        var e;
                        return (
                          (function (t, e) {
                            if (!(t instanceof e))
                              throw new TypeError(
                                "Cannot call a class as a function"
                              );
                          })(this, w),
                          ((e = b.call(this, t)).supportsBinary =
                            !t.forceBase64),
                          e
                        );
                      }
                      return (
                        (e = w),
                        (n = [
                          {
                            key: "name",
                            get: function () {
                              return "websocket";
                            },
                          },
                          {
                            key: "doOpen",
                            value: function () {
                              if (this.check()) {
                                var t = this.uri(),
                                  e = this.opts.protocols,
                                  n = x
                                    ? {}
                                    : d(
                                        this.opts,
                                        "agent",
                                        "perMessageDeflate",
                                        "pfx",
                                        "key",
                                        "passphrase",
                                        "cert",
                                        "ca",
                                        "ciphers",
                                        "rejectUnauthorized",
                                        "localAddress",
                                        "protocolVersion",
                                        "origin",
                                        "maxPayload",
                                        "family",
                                        "checkServerIdentity"
                                      );
                                this.opts.extraHeaders &&
                                  (n.headers = this.opts.extraHeaders);
                                try {
                                  this.ws =
                                    m && !x
                                      ? e
                                        ? new f(t, e)
                                        : new f(t)
                                      : new f(t, e, n);
                                } catch (t) {
                                  return this.emit("error", t);
                                }
                                (this.ws.binaryType =
                                  this.socket.binaryType || g),
                                  this.addEventListeners();
                              }
                            },
                          },
                          {
                            key: "addEventListeners",
                            value: function () {
                              var t = this;
                              (this.ws.onopen = function () {
                                t.opts.autoUnref && t.ws._socket.unref(),
                                  t.onOpen();
                              }),
                                (this.ws.onclose = this.onClose.bind(this)),
                                (this.ws.onmessage = function (e) {
                                  return t.onData(e.data);
                                }),
                                (this.ws.onerror = function (e) {
                                  return t.onError("websocket error", e);
                                });
                            },
                          },
                          {
                            key: "write",
                            value: function (t) {
                              var e = this;
                              this.writable = !1;
                              for (
                                var n = function (n) {
                                    var i = t[n],
                                      r = n === t.length - 1;
                                    c.encodePacket(
                                      i,
                                      e.supportsBinary,
                                      function (t) {
                                        var n = {};
                                        m ||
                                          (i.options &&
                                            (n.compress = i.options.compress),
                                          e.opts.perMessageDeflate &&
                                            ("string" == typeof t
                                              ? Buffer.byteLength(t)
                                              : t.length) <
                                              e.opts.perMessageDeflate
                                                .threshold &&
                                            (n.compress = !1));
                                        try {
                                          m ? e.ws.send(t) : e.ws.send(t, n);
                                        } catch (t) {
                                          y(
                                            "websocket closed before onclose event"
                                          );
                                        }
                                        r &&
                                          v(function () {
                                            (e.writable = !0), e.emit("drain");
                                          });
                                      }
                                    );
                                  },
                                  i = 0;
                                i < t.length;
                                i++
                              )
                                n(i);
                            },
                          },
                          {
                            key: "onClose",
                            value: function () {
                              l.prototype.onClose.call(this);
                            },
                          },
                          {
                            key: "doClose",
                            value: function () {
                              void 0 !== this.ws &&
                                (this.ws.close(), (this.ws = null));
                            },
                          },
                          {
                            key: "uri",
                            value: function () {
                              var t = this.query || {},
                                e = this.opts.secure ? "wss" : "ws",
                                n = "";
                              return (
                                this.opts.port &&
                                  (("wss" === e &&
                                    443 !== Number(this.opts.port)) ||
                                    ("ws" === e &&
                                      80 !== Number(this.opts.port))) &&
                                  (n = ":" + this.opts.port),
                                this.opts.timestampRequests &&
                                  (t[this.opts.timestampParam] = h()),
                                this.supportsBinary || (t.b64 = 1),
                                (t = u.encode(t)).length && (t = "?" + t),
                                e +
                                  "://" +
                                  (-1 !== this.opts.hostname.indexOf(":")
                                    ? "[" + this.opts.hostname + "]"
                                    : this.opts.hostname) +
                                  n +
                                  this.opts.path +
                                  t
                              );
                            },
                          },
                          {
                            key: "check",
                            value: function () {
                              return !(
                                !f ||
                                ("__initialize" in f &&
                                  this.name === w.prototype.name)
                              );
                            },
                          },
                        ]) && r(e.prototype, n),
                        w
                      );
                    })(l);
                  t.exports = b;
                },
              "./node_modules/engine.io-client/lib/util.js": function (t, e) {
                t.exports.pick = function (t) {
                  for (
                    var e = arguments.length,
                      n = new Array(e > 1 ? e - 1 : 0),
                      i = 1;
                    i < e;
                    i++
                  )
                    n[i - 1] = arguments[i];
                  return n.reduce(function (e, n) {
                    return t.hasOwnProperty(n) && (e[n] = t[n]), e;
                  }, {});
                };
              },
              "./node_modules/engine.io-client/lib/xmlhttprequest.js":
                function (t, e, n) {
                  var i = n("./node_modules/has-cors/index.js"),
                    r = n(
                      "./node_modules/engine.io-client/lib/globalThis.browser.js"
                    );
                  t.exports = function (t) {
                    var e = t.xdomain,
                      n = t.xscheme,
                      o = t.enablesXDR;
                    try {
                      if ("undefined" != typeof XMLHttpRequest && (!e || i))
                        return new XMLHttpRequest();
                    } catch (t) {}
                    try {
                      if ("undefined" != typeof XDomainRequest && !n && o)
                        return new XDomainRequest();
                    } catch (t) {}
                    if (!e)
                      try {
                        return new r[["Active"].concat("Object").join("X")](
                          "Microsoft.XMLHTTP"
                        );
                      } catch (t) {}
                  };
                },
              "./node_modules/engine.io-parser/lib/commons.js": function (
                t,
                e
              ) {
                var n = Object.create(null);
                (n.open = "0"),
                  (n.close = "1"),
                  (n.ping = "2"),
                  (n.pong = "3"),
                  (n.message = "4"),
                  (n.upgrade = "5"),
                  (n.noop = "6");
                var i = Object.create(null);
                Object.keys(n).forEach(function (t) {
                  i[n[t]] = t;
                }),
                  (t.exports = {
                    PACKET_TYPES: n,
                    PACKET_TYPES_REVERSE: i,
                    ERROR_PACKET: { type: "error", data: "parser error" },
                  });
              },
              "./node_modules/engine.io-parser/lib/decodePacket.browser.js":
                function (t, e, n) {
                  var i,
                    r = n("./node_modules/engine.io-parser/lib/commons.js"),
                    o = r.PACKET_TYPES_REVERSE,
                    s = r.ERROR_PACKET;
                  "function" == typeof ArrayBuffer &&
                    (i = n(
                      "./node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js"
                    ));
                  var a = function (t, e) {
                      if (i) {
                        var n = i.decode(t);
                        return l(n, e);
                      }
                      return { base64: !0, data: t };
                    },
                    l = function (t, e) {
                      switch (e) {
                        case "blob":
                          return t instanceof ArrayBuffer ? new Blob([t]) : t;
                        case "arraybuffer":
                        default:
                          return t;
                      }
                    };
                  t.exports = function (t, e) {
                    if ("string" != typeof t)
                      return { type: "message", data: l(t, e) };
                    var n = t.charAt(0);
                    return "b" === n
                      ? { type: "message", data: a(t.substring(1), e) }
                      : o[n]
                      ? t.length > 1
                        ? { type: o[n], data: t.substring(1) }
                        : { type: o[n] }
                      : s;
                  };
                },
              "./node_modules/engine.io-parser/lib/encodePacket.browser.js":
                function (t, e, n) {
                  var i = n(
                      "./node_modules/engine.io-parser/lib/commons.js"
                    ).PACKET_TYPES,
                    r =
                      "function" == typeof Blob ||
                      ("undefined" != typeof Blob &&
                        "[object BlobConstructor]" ===
                          Object.prototype.toString.call(Blob)),
                    o = "function" == typeof ArrayBuffer,
                    s = function (t, e) {
                      var n = new FileReader();
                      return (
                        (n.onload = function () {
                          var t = n.result.split(",")[1];
                          e("b" + t);
                        }),
                        n.readAsDataURL(t)
                      );
                    };
                  t.exports = function (t, e, n) {
                    var a,
                      l = t.type,
                      c = t.data;
                    return r && c instanceof Blob
                      ? e
                        ? n(c)
                        : s(c, n)
                      : o &&
                        (c instanceof ArrayBuffer ||
                          ((a = c),
                          "function" == typeof ArrayBuffer.isView
                            ? ArrayBuffer.isView(a)
                            : a && a.buffer instanceof ArrayBuffer))
                      ? e
                        ? n(c instanceof ArrayBuffer ? c : c.buffer)
                        : s(new Blob([c]), n)
                      : n(i[l] + (c || ""));
                  };
                },
              "./node_modules/engine.io-parser/lib/index.js": function (
                t,
                e,
                n
              ) {
                var i = n(
                    "./node_modules/engine.io-parser/lib/encodePacket.browser.js"
                  ),
                  r = n(
                    "./node_modules/engine.io-parser/lib/decodePacket.browser.js"
                  ),
                  o = String.fromCharCode(30);
                t.exports = {
                  protocol: 4,
                  encodePacket: i,
                  encodePayload: function (t, e) {
                    var n = t.length,
                      r = new Array(n),
                      s = 0;
                    t.forEach(function (t, a) {
                      i(t, !1, function (t) {
                        (r[a] = t), ++s === n && e(r.join(o));
                      });
                    });
                  },
                  decodePacket: r,
                  decodePayload: function (t, e) {
                    for (var n = t.split(o), i = [], s = 0; s < n.length; s++) {
                      var a = r(n[s], e);
                      if ((i.push(a), "error" === a.type)) break;
                    }
                    return i;
                  },
                };
              },
              "./node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
                function (t, e) {
                  !(function (t) {
                    "use strict";
                    (e.encode = function (e) {
                      var n,
                        i = new Uint8Array(e),
                        r = i.length,
                        o = "";
                      for (n = 0; n < r; n += 3)
                        (o += t[i[n] >> 2]),
                          (o += t[((3 & i[n]) << 4) | (i[n + 1] >> 4)]),
                          (o += t[((15 & i[n + 1]) << 2) | (i[n + 2] >> 6)]),
                          (o += t[63 & i[n + 2]]);
                      return (
                        r % 3 == 2
                          ? (o = o.substring(0, o.length - 1) + "=")
                          : r % 3 == 1 &&
                            (o = o.substring(0, o.length - 2) + "=="),
                        o
                      );
                    }),
                      (e.decode = function (e) {
                        var n,
                          i,
                          r,
                          o,
                          s,
                          a = 0.75 * e.length,
                          l = e.length,
                          c = 0;
                        "=" === e[e.length - 1] &&
                          (a--, "=" === e[e.length - 2] && a--);
                        var u = new ArrayBuffer(a),
                          h = new Uint8Array(u);
                        for (n = 0; n < l; n += 4)
                          (i = t.indexOf(e[n])),
                            (r = t.indexOf(e[n + 1])),
                            (o = t.indexOf(e[n + 2])),
                            (s = t.indexOf(e[n + 3])),
                            (h[c++] = (i << 2) | (r >> 4)),
                            (h[c++] = ((15 & r) << 4) | (o >> 2)),
                            (h[c++] = ((3 & o) << 6) | (63 & s));
                        return u;
                      });
                  })(
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                  );
                },
              "./node_modules/has-cors/index.js": function (t, e) {
                try {
                  t.exports =
                    "undefined" != typeof XMLHttpRequest &&
                    "withCredentials" in new XMLHttpRequest();
                } catch (e) {
                  t.exports = !1;
                }
              },
              "./node_modules/ms/index.js": function (t, e) {
                function n(t) {
                  return (n =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                var i = 1e3,
                  r = 60 * i,
                  o = 60 * r,
                  s = 24 * o;
                function a(t, e, n, i) {
                  var r = e >= 1.5 * n;
                  return Math.round(t / n) + " " + i + (r ? "s" : "");
                }
                t.exports = function (t, e) {
                  e = e || {};
                  var l,
                    c,
                    u = n(t);
                  if ("string" === u && t.length > 0)
                    return (function (t) {
                      if (!((t = String(t)).length > 100)) {
                        var e =
                          /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                            t
                          );
                        if (e) {
                          var n = parseFloat(e[1]);
                          switch ((e[2] || "ms").toLowerCase()) {
                            case "years":
                            case "year":
                            case "yrs":
                            case "yr":
                            case "y":
                              return 315576e5 * n;
                            case "weeks":
                            case "week":
                            case "w":
                              return 6048e5 * n;
                            case "days":
                            case "day":
                            case "d":
                              return n * s;
                            case "hours":
                            case "hour":
                            case "hrs":
                            case "hr":
                            case "h":
                              return n * o;
                            case "minutes":
                            case "minute":
                            case "mins":
                            case "min":
                            case "m":
                              return n * r;
                            case "seconds":
                            case "second":
                            case "secs":
                            case "sec":
                            case "s":
                              return n * i;
                            case "milliseconds":
                            case "millisecond":
                            case "msecs":
                            case "msec":
                            case "ms":
                              return n;
                            default:
                              return;
                          }
                        }
                      }
                    })(t);
                  if ("number" === u && isFinite(t))
                    return e.long
                      ? ((l = t),
                        (c = Math.abs(l)) >= s
                          ? a(l, c, s, "day")
                          : c >= o
                          ? a(l, c, o, "hour")
                          : c >= r
                          ? a(l, c, r, "minute")
                          : c >= i
                          ? a(l, c, i, "second")
                          : l + " ms")
                      : (function (t) {
                          var e = Math.abs(t);
                          return e >= s
                            ? Math.round(t / s) + "d"
                            : e >= o
                            ? Math.round(t / o) + "h"
                            : e >= r
                            ? Math.round(t / r) + "m"
                            : e >= i
                            ? Math.round(t / i) + "s"
                            : t + "ms";
                        })(t);
                  throw new Error(
                    "val is not a non-empty string or a valid number. val=" +
                      JSON.stringify(t)
                  );
                };
              },
              "./node_modules/parseqs/index.js": function (t, e) {
                (e.encode = function (t) {
                  var e = "";
                  for (var n in t)
                    t.hasOwnProperty(n) &&
                      (e.length && (e += "&"),
                      (e +=
                        encodeURIComponent(n) +
                        "=" +
                        encodeURIComponent(t[n])));
                  return e;
                }),
                  (e.decode = function (t) {
                    for (
                      var e = {}, n = t.split("&"), i = 0, r = n.length;
                      i < r;
                      i++
                    ) {
                      var o = n[i].split("=");
                      e[decodeURIComponent(o[0])] = decodeURIComponent(o[1]);
                    }
                    return e;
                  });
              },
              "./node_modules/parseuri/index.js": function (t, e) {
                var n =
                    /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
                  i = [
                    "source",
                    "protocol",
                    "authority",
                    "userInfo",
                    "user",
                    "password",
                    "host",
                    "port",
                    "relative",
                    "path",
                    "directory",
                    "file",
                    "query",
                    "anchor",
                  ];
                t.exports = function (t) {
                  var e,
                    r,
                    o,
                    s = t,
                    a = t.indexOf("["),
                    l = t.indexOf("]");
                  -1 != a &&
                    -1 != l &&
                    (t =
                      t.substring(0, a) +
                      t.substring(a, l).replace(/:/g, ";") +
                      t.substring(l, t.length));
                  for (var c, u, h = n.exec(t || ""), d = {}, p = 14; p--; )
                    d[i[p]] = h[p] || "";
                  return (
                    -1 != a &&
                      -1 != l &&
                      ((d.source = s),
                      (d.host = d.host
                        .substring(1, d.host.length - 1)
                        .replace(/;/g, ":")),
                      (d.authority = d.authority
                        .replace("[", "")
                        .replace("]", "")
                        .replace(/;/g, ":")),
                      (d.ipv6uri = !0)),
                    (d.pathNames =
                      ((r = /\/{2,9}/g),
                      (o = (e = d.path).replace(r, "/").split("/")),
                      ("/" != e.substr(0, 1) && 0 !== e.length) ||
                        o.splice(0, 1),
                      "/" == e.substr(e.length - 1, 1) &&
                        o.splice(o.length - 1, 1),
                      o)),
                    (d.queryKey =
                      ((c = d.query),
                      (u = {}),
                      c.replace(
                        /(?:^|&)([^&=]*)=?([^&]*)/g,
                        function (t, e, n) {
                          e && (u[e] = n);
                        }
                      ),
                      u)),
                    d
                  );
                };
              },
              "./node_modules/socket.io-parser/dist/binary.js": function (
                t,
                e,
                n
              ) {
                "use strict";
                function i(t) {
                  return (i =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                Object.defineProperty(e, "__esModule", { value: !0 }),
                  (e.reconstructPacket = e.deconstructPacket = void 0);
                var r = n("./node_modules/socket.io-parser/dist/is-binary.js");
                function o(t, e) {
                  if (!t) return t;
                  if (r.isBinary(t)) {
                    var n = { _placeholder: !0, num: e.length };
                    return e.push(t), n;
                  }
                  if (Array.isArray(t)) {
                    for (var s = new Array(t.length), a = 0; a < t.length; a++)
                      s[a] = o(t[a], e);
                    return s;
                  }
                  if ("object" === i(t) && !(t instanceof Date)) {
                    var l = {};
                    for (var c in t) t.hasOwnProperty(c) && (l[c] = o(t[c], e));
                    return l;
                  }
                  return t;
                }
                function s(t, e) {
                  if (!t) return t;
                  if (t && t._placeholder) return e[t.num];
                  if (Array.isArray(t))
                    for (var n = 0; n < t.length; n++) t[n] = s(t[n], e);
                  else if ("object" === i(t))
                    for (var r in t) t.hasOwnProperty(r) && (t[r] = s(t[r], e));
                  return t;
                }
                (e.deconstructPacket = function (t) {
                  var e = [],
                    n = t.data,
                    i = t;
                  return (
                    (i.data = o(n, e)),
                    (i.attachments = e.length),
                    { packet: i, buffers: e }
                  );
                }),
                  (e.reconstructPacket = function (t, e) {
                    return (t.data = s(t.data, e)), (t.attachments = void 0), t;
                  });
              },
              "./node_modules/socket.io-parser/dist/index.js": function (
                t,
                e,
                n
              ) {
                "use strict";
                function i(t) {
                  return (i =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                function r(t, e, n) {
                  return (r =
                    "undefined" != typeof Reflect && Reflect.get
                      ? Reflect.get
                      : function (t, e, n) {
                          var i = (function (t, e) {
                            for (
                              ;
                              !Object.prototype.hasOwnProperty.call(t, e) &&
                              null !== (t = a(t));

                            );
                            return t;
                          })(t, e);
                          if (i) {
                            var r = Object.getOwnPropertyDescriptor(i, e);
                            return r.get ? r.get.call(n) : r.value;
                          }
                        })(t, e, n || t);
                }
                function o(t, e) {
                  return (o =
                    Object.setPrototypeOf ||
                    function (t, e) {
                      return (t.__proto__ = e), t;
                    })(t, e);
                }
                function s(t, e) {
                  return !e || ("object" !== i(e) && "function" != typeof e)
                    ? (function (t) {
                        if (void 0 === t)
                          throw new ReferenceError(
                            "this hasn't been initialised - super() hasn't been called"
                          );
                        return t;
                      })(t)
                    : e;
                }
                function a(t) {
                  return (a = Object.setPrototypeOf
                    ? Object.getPrototypeOf
                    : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t);
                      })(t);
                }
                function l(t, e) {
                  if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function");
                }
                function c(t, e) {
                  for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    (i.enumerable = i.enumerable || !1),
                      (i.configurable = !0),
                      "value" in i && (i.writable = !0),
                      Object.defineProperty(t, i.key, i);
                  }
                }
                function u(t, e, n) {
                  return e && c(t.prototype, e), n && c(t, n), t;
                }
                Object.defineProperty(e, "__esModule", { value: !0 }),
                  (e.Decoder = e.Encoder = e.PacketType = e.protocol = void 0);
                var h,
                  d = n("./node_modules/component-emitter/index.js"),
                  p = n("./node_modules/socket.io-parser/dist/binary.js"),
                  f = n("./node_modules/socket.io-parser/dist/is-binary.js"),
                  m = n("./node_modules/debug/src/browser.js")(
                    "socket.io-parser"
                  );
                (e.protocol = 5),
                  (function (t) {
                    (t[(t.CONNECT = 0)] = "CONNECT"),
                      (t[(t.DISCONNECT = 1)] = "DISCONNECT"),
                      (t[(t.EVENT = 2)] = "EVENT"),
                      (t[(t.ACK = 3)] = "ACK"),
                      (t[(t.CONNECT_ERROR = 4)] = "CONNECT_ERROR"),
                      (t[(t.BINARY_EVENT = 5)] = "BINARY_EVENT"),
                      (t[(t.BINARY_ACK = 6)] = "BINARY_ACK");
                  })((h = e.PacketType || (e.PacketType = {})));
                var g = (function () {
                  function t() {
                    l(this, t);
                  }
                  return (
                    u(t, [
                      {
                        key: "encode",
                        value: function (t) {
                          return (
                            m("encoding packet %j", t),
                            (t.type !== h.EVENT && t.type !== h.ACK) ||
                            !f.hasBinary(t)
                              ? [this.encodeAsString(t)]
                              : ((t.type =
                                  t.type === h.EVENT
                                    ? h.BINARY_EVENT
                                    : h.BINARY_ACK),
                                this.encodeAsBinary(t))
                          );
                        },
                      },
                      {
                        key: "encodeAsString",
                        value: function (t) {
                          var e = "" + t.type;
                          return (
                            (t.type !== h.BINARY_EVENT &&
                              t.type !== h.BINARY_ACK) ||
                              (e += t.attachments + "-"),
                            t.nsp && "/" !== t.nsp && (e += t.nsp + ","),
                            null != t.id && (e += t.id),
                            null != t.data && (e += JSON.stringify(t.data)),
                            m("encoded %j as %s", t, e),
                            e
                          );
                        },
                      },
                      {
                        key: "encodeAsBinary",
                        value: function (t) {
                          var e = p.deconstructPacket(t),
                            n = this.encodeAsString(e.packet),
                            i = e.buffers;
                          return i.unshift(n), i;
                        },
                      },
                    ]),
                    t
                  );
                })();
                e.Encoder = g;
                var v = (function (t) {
                  !(function (t, e) {
                    if ("function" != typeof e && null !== e)
                      throw new TypeError(
                        "Super expression must either be null or a function"
                      );
                    (t.prototype = Object.create(e && e.prototype, {
                      constructor: { value: t, writable: !0, configurable: !0 },
                    })),
                      e && o(t, e);
                  })(d, t);
                  var e,
                    n,
                    c =
                      ((e = d),
                      (n = (function () {
                        if ("undefined" == typeof Reflect || !Reflect.construct)
                          return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                          return (
                            Boolean.prototype.valueOf.call(
                              Reflect.construct(Boolean, [], function () {})
                            ),
                            !0
                          );
                        } catch (t) {
                          return !1;
                        }
                      })()),
                      function () {
                        var t,
                          i = a(e);
                        if (n) {
                          var r = a(this).constructor;
                          t = Reflect.construct(i, arguments, r);
                        } else t = i.apply(this, arguments);
                        return s(this, t);
                      });
                  function d() {
                    return l(this, d), c.call(this);
                  }
                  return (
                    u(
                      d,
                      [
                        {
                          key: "add",
                          value: function (t) {
                            var e;
                            if ("string" == typeof t)
                              (e = this.decodeString(t)).type ===
                                h.BINARY_EVENT || e.type === h.BINARY_ACK
                                ? ((this.reconstructor = new y(e)),
                                  0 === e.attachments &&
                                    r(a(d.prototype), "emit", this).call(
                                      this,
                                      "decoded",
                                      e
                                    ))
                                : r(a(d.prototype), "emit", this).call(
                                    this,
                                    "decoded",
                                    e
                                  );
                            else {
                              if (!f.isBinary(t) && !t.base64)
                                throw new Error("Unknown type: " + t);
                              if (!this.reconstructor)
                                throw new Error(
                                  "got binary data when not reconstructing a packet"
                                );
                              (e = this.reconstructor.takeBinaryData(t)) &&
                                ((this.reconstructor = null),
                                r(a(d.prototype), "emit", this).call(
                                  this,
                                  "decoded",
                                  e
                                ));
                            }
                          },
                        },
                        {
                          key: "decodeString",
                          value: function (t) {
                            var e = 0,
                              n = { type: Number(t.charAt(0)) };
                            if (void 0 === h[n.type])
                              throw new Error("unknown packet type " + n.type);
                            if (
                              n.type === h.BINARY_EVENT ||
                              n.type === h.BINARY_ACK
                            ) {
                              for (
                                var i = e + 1;
                                "-" !== t.charAt(++e) && e != t.length;

                              );
                              var r = t.substring(i, e);
                              if (r != Number(r) || "-" !== t.charAt(e))
                                throw new Error("Illegal attachments");
                              n.attachments = Number(r);
                            }
                            if ("/" === t.charAt(e + 1)) {
                              for (
                                var o = e + 1;
                                ++e && "," !== t.charAt(e) && e !== t.length;

                              );
                              n.nsp = t.substring(o, e);
                            } else n.nsp = "/";
                            var s = t.charAt(e + 1);
                            if ("" !== s && Number(s) == s) {
                              for (var a = e + 1; ++e; ) {
                                var l = t.charAt(e);
                                if (null == l || Number(l) != l) {
                                  --e;
                                  break;
                                }
                                if (e === t.length) break;
                              }
                              n.id = Number(t.substring(a, e + 1));
                            }
                            if (t.charAt(++e)) {
                              var c = (function (t) {
                                try {
                                  return JSON.parse(t);
                                } catch (t) {
                                  return !1;
                                }
                              })(t.substr(e));
                              if (!d.isPayloadValid(n.type, c))
                                throw new Error("invalid payload");
                              n.data = c;
                            }
                            return m("decoded %s as %j", t, n), n;
                          },
                        },
                        {
                          key: "destroy",
                          value: function () {
                            this.reconstructor &&
                              this.reconstructor.finishedReconstruction();
                          },
                        },
                      ],
                      [
                        {
                          key: "isPayloadValid",
                          value: function (t, e) {
                            switch (t) {
                              case h.CONNECT:
                                return "object" === i(e);
                              case h.DISCONNECT:
                                return void 0 === e;
                              case h.CONNECT_ERROR:
                                return (
                                  "string" == typeof e || "object" === i(e)
                                );
                              case h.EVENT:
                              case h.BINARY_EVENT:
                                return Array.isArray(e) && e.length > 0;
                              case h.ACK:
                              case h.BINARY_ACK:
                                return Array.isArray(e);
                            }
                          },
                        },
                      ]
                    ),
                    d
                  );
                })(d);
                e.Decoder = v;
                var y = (function () {
                  function t(e) {
                    l(this, t),
                      (this.packet = e),
                      (this.buffers = []),
                      (this.reconPack = e);
                  }
                  return (
                    u(t, [
                      {
                        key: "takeBinaryData",
                        value: function (t) {
                          if (
                            (this.buffers.push(t),
                            this.buffers.length === this.reconPack.attachments)
                          ) {
                            var e = p.reconstructPacket(
                              this.reconPack,
                              this.buffers
                            );
                            return this.finishedReconstruction(), e;
                          }
                          return null;
                        },
                      },
                      {
                        key: "finishedReconstruction",
                        value: function () {
                          (this.reconPack = null), (this.buffers = []);
                        },
                      },
                    ]),
                    t
                  );
                })();
              },
              "./node_modules/socket.io-parser/dist/is-binary.js": function (
                t,
                e,
                n
              ) {
                "use strict";
                function i(t) {
                  return (i =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (t) {
                          return typeof t;
                        }
                      : function (t) {
                          return t &&
                            "function" == typeof Symbol &&
                            t.constructor === Symbol &&
                            t !== Symbol.prototype
                            ? "symbol"
                            : typeof t;
                        })(t);
                }
                Object.defineProperty(e, "__esModule", { value: !0 }),
                  (e.hasBinary = e.isBinary = void 0);
                var r = "function" == typeof ArrayBuffer,
                  o = Object.prototype.toString,
                  s =
                    "function" == typeof Blob ||
                    ("undefined" != typeof Blob &&
                      "[object BlobConstructor]" === o.call(Blob)),
                  a =
                    "function" == typeof File ||
                    ("undefined" != typeof File &&
                      "[object FileConstructor]" === o.call(File));
                function l(t) {
                  return (
                    (r &&
                      (t instanceof ArrayBuffer ||
                        (function (t) {
                          return "function" == typeof ArrayBuffer.isView
                            ? ArrayBuffer.isView(t)
                            : t.buffer instanceof ArrayBuffer;
                        })(t))) ||
                    (s && t instanceof Blob) ||
                    (a && t instanceof File)
                  );
                }
                (e.isBinary = l),
                  (e.hasBinary = function t(e, n) {
                    if (!e || "object" !== i(e)) return !1;
                    if (Array.isArray(e)) {
                      for (var r = 0, o = e.length; r < o; r++)
                        if (t(e[r])) return !0;
                      return !1;
                    }
                    if (l(e)) return !0;
                    if (
                      e.toJSON &&
                      "function" == typeof e.toJSON &&
                      1 === arguments.length
                    )
                      return t(e.toJSON(), !0);
                    for (var s in e)
                      if (Object.prototype.hasOwnProperty.call(e, s) && t(e[s]))
                        return !0;
                    return !1;
                  });
              },
              "./node_modules/yeast/index.js": function (t, e, n) {
                "use strict";
                var i,
                  r =
                    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(
                      ""
                    ),
                  o = {},
                  s = 0,
                  a = 0;
                function l(t) {
                  var e = "";
                  do {
                    (e = r[t % 64] + e), (t = Math.floor(t / 64));
                  } while (t > 0);
                  return e;
                }
                function c() {
                  var t = l(+new Date());
                  return t !== i ? ((s = 0), (i = t)) : t + "." + l(s++);
                }
                for (; a < 64; a++) o[r[a]] = a;
                (c.encode = l),
                  (c.decode = function (t) {
                    var e = 0;
                    for (a = 0; a < t.length; a++) e = 64 * e + o[t.charAt(a)];
                    return e;
                  }),
                  (t.exports = c);
              },
            });
          }),
          (t.exports = e());
      },
    },
    e = {};
  function n(i) {
    var r = e[i];
    if (void 0 !== r) return r.exports;
    var o = (e[i] = { exports: {} });
    return t[i].call(o.exports, o, o.exports, n), o.exports;
  }
  (n.d = (t, e) => {
    for (var i in e)
      n.o(e, i) &&
        !n.o(t, i) &&
        Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
  }),
    (n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
    (n.r = (t) => {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (() => {
      "use strict";
      var t = {};
      n.r(t),
        n.d(t, {
          ACESFilmicToneMapping: () => et,
          AddEquation: () => S,
          AddOperation: () => J,
          AdditiveAnimationBlendMode: () => We,
          AdditiveBlending: () => b,
          AlphaFormat: () => Ot,
          AlwaysDepth: () => U,
          AlwaysStencilFunc: () => Mn,
          AmbientLight: () => id,
          AmbientLightProbe: () => Ed,
          AnimationClip: () => Eh,
          AnimationLoader: () => Ih,
          AnimationMixer: () => np,
          AnimationObjectGroup: () => tp,
          AnimationUtils: () => dh,
          ArcCurve: () => Yc,
          ArrayCamera: () => xl,
          ArrowHelper: () => qp,
          Audio: () => Dd,
          AudioAnalyser: () => Vd,
          AudioContext: () => _d,
          AudioListener: () => Od,
          AudioLoader: () => Md,
          AxesHelper: () => Xp,
          AxisHelper: () => _f,
          BackSide: () => f,
          BasicDepthPacking: () => rn,
          BasicShadowMap: () => c,
          BinaryTextureLoader: () => Af,
          Bone: () => rc,
          BooleanKeyframeTrack: () => yh,
          BoundingBoxHelper: () => Mf,
          Box2: () => dp,
          Box3: () => ci,
          Box3Helper: () => Up,
          BoxBufferGeometry: () => wo,
          BoxGeometry: () => wo,
          BoxHelper: () => Hp,
          BufferAttribute: () => Nr,
          BufferGeometry: () => $r,
          BufferGeometryLoader: () => hd,
          ByteType: () => St,
          Cache: () => Ah,
          Camera: () => To,
          CameraHelper: () => kp,
          CanvasRenderer: () => Lf,
          CanvasTexture: () => Bc,
          CatmullRomCurve3: () => tu,
          CineonToneMapping: () => tt,
          CircleBufferGeometry: () => Dc,
          CircleGeometry: () => Dc,
          ClampToEdgeWrapping: () => ht,
          Clock: () => Ld,
          Color: () => Cr,
          ColorKeyframeTrack: () => xh,
          CompressedTexture: () => Ic,
          CompressedTextureLoader: () => Bh,
          ConeBufferGeometry: () => Fc,
          ConeGeometry: () => Fc,
          CubeCamera: () => Lo,
          CubeReflectionMapping: () => rt,
          CubeRefractionMapping: () => ot,
          CubeTexture: () => Ro,
          CubeTextureLoader: () => Dh,
          CubeUVReflectionMapping: () => lt,
          CubeUVRefractionMapping: () => ct,
          CubicBezierCurve: () => ru,
          CubicBezierCurve3: () => ou,
          CubicInterpolant: () => fh,
          CullFaceBack: () => s,
          CullFaceFront: () => a,
          CullFaceFrontBack: () => l,
          CullFaceNone: () => o,
          Curve: () => qc,
          CurvePath: () => zh,
          CustomBlending: () => M,
          CustomToneMapping: () => nt,
          CylinderBufferGeometry: () => kc,
          CylinderGeometry: () => kc,
          Cylindrical: () => up,
          DataTexture: () => oc,
          DataTexture2DArray: () => Ps,
          DataTexture3D: () => Ns,
          DataTextureLoader: () => kh,
          DataUtils: () => Jp,
          DecrementStencilOp: () => dn,
          DecrementWrapStencilOp: () => fn,
          DefaultLoadingManager: () => Lh,
          DepthFormat: () => Ut,
          DepthStencilFormat: () => Vt,
          DepthTexture: () => Oc,
          DirectionalLight: () => nd,
          DirectionalLightHelper: () => Bp,
          DiscreteInterpolant: () => gh,
          DodecahedronBufferGeometry: () => Hc,
          DodecahedronGeometry: () => Hc,
          DoubleSide: () => m,
          DstAlphaFactor: () => O,
          DstColorFactor: () => k,
          DynamicBufferAttribute: () => df,
          DynamicCopyUsage: () => Pn,
          DynamicDrawUsage: () => En,
          DynamicReadUsage: () => Cn,
          EdgesGeometry: () => Wc,
          EdgesHelper: () => Sf,
          EllipseCurve: () => Xc,
          EqualDepth: () => j,
          EqualStencilFunc: () => yn,
          EquirectangularReflectionMapping: () => st,
          EquirectangularRefractionMapping: () => at,
          Euler: () => Xi,
          EventDispatcher: () => On,
          ExtrudeBufferGeometry: () => zu,
          ExtrudeGeometry: () => zu,
          FaceColors: () => tf,
          FileLoader: () => Nh,
          FlatShading: () => g,
          Float16BufferAttribute: () => Hr,
          Float32Attribute: () => bf,
          Float32BufferAttribute: () => Ur,
          Float64Attribute: () => wf,
          Float64BufferAttribute: () => Vr,
          FloatType: () => Lt,
          Fog: () => Cl,
          FogExp2: () => Al,
          Font: () => yd,
          FontLoader: () => bd,
          FrontSide: () => p,
          Frustum: () => Fo,
          GLBufferAttribute: () => op,
          GLSL1: () => In,
          GLSL3: () => Bn,
          GammaEncoding: () => Ke,
          GreaterDepth: () => q,
          GreaterEqualDepth: () => W,
          GreaterEqualStencilFunc: () => _n,
          GreaterStencilFunc: () => bn,
          GridHelper: () => Lp,
          Group: () => bl,
          HalfFloatType: () => Rt,
          HemisphereLight: () => Gh,
          HemisphereLightHelper: () => Cp,
          HemisphereLightProbe: () => Sd,
          IcosahedronBufferGeometry: () => Uu,
          IcosahedronGeometry: () => Uu,
          ImageBitmapLoader: () => gd,
          ImageLoader: () => Oh,
          ImageUtils: () => Kn,
          ImmediateRenderObject: () => gp,
          IncrementStencilOp: () => hn,
          IncrementWrapStencilOp: () => pn,
          InstancedBufferAttribute: () => ud,
          InstancedBufferGeometry: () => cd,
          InstancedInterleavedBuffer: () => rp,
          InstancedMesh: () => pc,
          Int16Attribute: () => gf,
          Int16BufferAttribute: () => Dr,
          Int32Attribute: () => yf,
          Int32BufferAttribute: () => Fr,
          Int8Attribute: () => pf,
          Int8BufferAttribute: () => Ir,
          IntType: () => At,
          InterleavedBuffer: () => Rl,
          InterleavedBufferAttribute: () => Nl,
          Interpolant: () => ph,
          InterpolateDiscrete: () => Fe,
          InterpolateLinear: () => ze,
          InterpolateSmooth: () => He,
          InvertStencilOp: () => mn,
          JSONLoader: () => Rf,
          KeepStencilOp: () => cn,
          KeyframeTrack: () => vh,
          LOD: () => Kl,
          LatheBufferGeometry: () => Vu,
          LatheGeometry: () => Vu,
          Layers: () => Yi,
          LensFlare: () => Nf,
          LessDepth: () => V,
          LessEqualDepth: () => G,
          LessEqualStencilFunc: () => xn,
          LessStencilFunc: () => vn,
          Light: () => Vh,
          LightProbe: () => sd,
          Line: () => bc,
          Line3: () => mp,
          LineBasicMaterial: () => fc,
          LineCurve: () => su,
          LineCurve3: () => au,
          LineDashedMaterial: () => uh,
          LineLoop: () => Sc,
          LinePieces: () => Qp,
          LineSegments: () => Mc,
          LineStrip: () => Kp,
          LinearEncoding: () => Ze,
          LinearFilter: () => yt,
          LinearInterpolant: () => mh,
          LinearMipMapLinearFilter: () => _t,
          LinearMipMapNearestFilter: () => bt,
          LinearMipmapLinearFilter: () => wt,
          LinearMipmapNearestFilter: () => xt,
          LinearToneMapping: () => Q,
          Loader: () => Rh,
          LoaderUtils: () => ld,
          LoadingManager: () => Ch,
          LogLuvEncoding: () => $e,
          LoopOnce: () => Oe,
          LoopPingPong: () => ke,
          LoopRepeat: () => De,
          LuminanceAlphaFormat: () => zt,
          LuminanceFormat: () => Ft,
          MOUSE: () => i,
          Material: () => wr,
          MaterialLoader: () => ad,
          Math: () => Xn,
          MathUtils: () => Xn,
          Matrix3: () => Zn,
          Matrix4: () => ki,
          MaxEquation: () => C,
          Mesh: () => xo,
          MeshBasicMaterial: () => Lr,
          MeshDepthMaterial: () => pl,
          MeshDistanceMaterial: () => fl,
          MeshFaceMaterial: () => nf,
          MeshLambertMaterial: () => lh,
          MeshMatcapMaterial: () => ch,
          MeshNormalMaterial: () => ah,
          MeshPhongMaterial: () => oh,
          MeshPhysicalMaterial: () => rh,
          MeshStandardMaterial: () => ih,
          MeshToonMaterial: () => sh,
          MinEquation: () => A,
          MirroredRepeatWrapping: () => dt,
          MixOperation: () => Z,
          MultiMaterial: () => rf,
          MultiplyBlending: () => _,
          MultiplyOperation: () => Y,
          NearestFilter: () => pt,
          NearestMipMapLinearFilter: () => vt,
          NearestMipMapNearestFilter: () => mt,
          NearestMipmapLinearFilter: () => gt,
          NearestMipmapNearestFilter: () => ft,
          NeverDepth: () => H,
          NeverStencilFunc: () => gn,
          NoBlending: () => y,
          NoColors: () => $p,
          NoToneMapping: () => K,
          NormalAnimationBlendMode: () => je,
          NormalBlending: () => x,
          NotEqualDepth: () => X,
          NotEqualStencilFunc: () => wn,
          NumberKeyframeTrack: () => bh,
          Object3D: () => lr,
          ObjectLoader: () => dd,
          ObjectSpaceNormalMap: () => an,
          OctahedronBufferGeometry: () => Gu,
          OctahedronGeometry: () => Gu,
          OneFactor: () => R,
          OneMinusDstAlphaFactor: () => D,
          OneMinusDstColorFactor: () => F,
          OneMinusSrcAlphaFactor: () => B,
          OneMinusSrcColorFactor: () => N,
          OrthographicCamera: () => Ko,
          PCFShadowMap: () => u,
          PCFSoftShadowMap: () => h,
          PMREMGenerator: () => ms,
          ParametricBufferGeometry: () => ju,
          ParametricGeometry: () => ju,
          Particle: () => sf,
          ParticleBasicMaterial: () => cf,
          ParticleSystem: () => af,
          ParticleSystemMaterial: () => uf,
          Path: () => Hh,
          PerspectiveCamera: () => Ao,
          Plane: () => Oo,
          PlaneBufferGeometry: () => Uo,
          PlaneGeometry: () => Uo,
          PlaneHelper: () => Vp,
          PointCloud: () => of,
          PointCloudMaterial: () => lf,
          PointLight: () => td,
          PointLightHelper: () => Sp,
          Points: () => Rc,
          PointsMaterial: () => Ec,
          PolarGridHelper: () => Rp,
          PolyhedronBufferGeometry: () => zc,
          PolyhedronGeometry: () => zc,
          PositionalAudio: () => Ud,
          PropertyBinding: () => $d,
          PropertyMixer: () => Gd,
          QuadraticBezierCurve: () => lu,
          QuadraticBezierCurve3: () => cu,
          Quaternion: () => oi,
          QuaternionKeyframeTrack: () => _h,
          QuaternionLinearInterpolant: () => wh,
          REVISION: () => e,
          RGBADepthPacking: () => on,
          RGBAFormat: () => kt,
          RGBAIntegerFormat: () => Yt,
          RGBA_ASTC_10x10_Format: () => ve,
          RGBA_ASTC_10x5_Format: () => fe,
          RGBA_ASTC_10x6_Format: () => me,
          RGBA_ASTC_10x8_Format: () => ge,
          RGBA_ASTC_12x10_Format: () => ye,
          RGBA_ASTC_12x12_Format: () => xe,
          RGBA_ASTC_4x4_Format: () => se,
          RGBA_ASTC_5x4_Format: () => ae,
          RGBA_ASTC_5x5_Format: () => le,
          RGBA_ASTC_6x5_Format: () => ce,
          RGBA_ASTC_6x6_Format: () => ue,
          RGBA_ASTC_8x5_Format: () => he,
          RGBA_ASTC_8x6_Format: () => de,
          RGBA_ASTC_8x8_Format: () => pe,
          RGBA_BPTC_Format: () => be,
          RGBA_ETC2_EAC_Format: () => oe,
          RGBA_PVRTC_2BPPV1_Format: () => ne,
          RGBA_PVRTC_4BPPV1_Format: () => ee,
          RGBA_S3TC_DXT1_Format: () => Jt,
          RGBA_S3TC_DXT3_Format: () => Kt,
          RGBA_S3TC_DXT5_Format: () => Qt,
          RGBDEncoding: () => nn,
          RGBEEncoding: () => Qe,
          RGBEFormat: () => Ht,
          RGBFormat: () => Dt,
          RGBIntegerFormat: () => Xt,
          RGBM16Encoding: () => en,
          RGBM7Encoding: () => tn,
          RGB_ETC1_Format: () => ie,
          RGB_ETC2_Format: () => re,
          RGB_PVRTC_2BPPV1_Format: () => te,
          RGB_PVRTC_4BPPV1_Format: () => $t,
          RGB_S3TC_DXT1_Format: () => Zt,
          RGFormat: () => Wt,
          RGIntegerFormat: () => qt,
          RawShaderMaterial: () => Qo,
          Ray: () => Di,
          Raycaster: () => sp,
          RectAreaLight: () => rd,
          RedFormat: () => Gt,
          RedIntegerFormat: () => jt,
          ReinhardToneMapping: () => $,
          RepeatWrapping: () => ut,
          ReplaceStencilOp: () => un,
          ReverseSubtractEquation: () => T,
          RingBufferGeometry: () => Wu,
          RingGeometry: () => Wu,
          SRGB8_ALPHA8_ASTC_10x10_Format: () => Ne,
          SRGB8_ALPHA8_ASTC_10x5_Format: () => Le,
          SRGB8_ALPHA8_ASTC_10x6_Format: () => Re,
          SRGB8_ALPHA8_ASTC_10x8_Format: () => Pe,
          SRGB8_ALPHA8_ASTC_12x10_Format: () => Ie,
          SRGB8_ALPHA8_ASTC_12x12_Format: () => Be,
          SRGB8_ALPHA8_ASTC_4x4_Format: () => we,
          SRGB8_ALPHA8_ASTC_5x4_Format: () => _e,
          SRGB8_ALPHA8_ASTC_5x5_Format: () => Me,
          SRGB8_ALPHA8_ASTC_6x5_Format: () => Se,
          SRGB8_ALPHA8_ASTC_6x6_Format: () => Ee,
          SRGB8_ALPHA8_ASTC_8x5_Format: () => Te,
          SRGB8_ALPHA8_ASTC_8x6_Format: () => Ae,
          SRGB8_ALPHA8_ASTC_8x8_Format: () => Ce,
          Scene: () => Ll,
          SceneUtils: () => Pf,
          ShaderChunk: () => Vo,
          ShaderLib: () => jo,
          ShaderMaterial: () => Eo,
          ShadowMaterial: () => nh,
          Shape: () => Uh,
          ShapeBufferGeometry: () => qu,
          ShapeGeometry: () => qu,
          ShapePath: () => vd,
          ShapeUtils: () => Du,
          ShortType: () => Et,
          Skeleton: () => lc,
          SkeletonHelper: () => _p,
          SkinnedMesh: () => ic,
          SmoothShading: () => v,
          Sphere: () => Ci,
          SphereBufferGeometry: () => Xu,
          SphereGeometry: () => Xu,
          Spherical: () => cp,
          SphericalHarmonics3: () => od,
          SplineCurve: () => uu,
          SpotLight: () => Zh,
          SpotLightHelper: () => yp,
          Sprite: () => Xl,
          SpriteMaterial: () => Il,
          SrcAlphaFactor: () => I,
          SrcAlphaSaturateFactor: () => z,
          SrcColorFactor: () => P,
          StaticCopyUsage: () => Rn,
          StaticDrawUsage: () => Sn,
          StaticReadUsage: () => An,
          StereoCamera: () => Cd,
          StreamCopyUsage: () => Nn,
          StreamDrawUsage: () => Tn,
          StreamReadUsage: () => Ln,
          StringKeyframeTrack: () => Mh,
          SubtractEquation: () => E,
          SubtractiveBlending: () => w,
          TOUCH: () => r,
          TangentSpaceNormalMap: () => sn,
          TetrahedronBufferGeometry: () => Yu,
          TetrahedronGeometry: () => Yu,
          TextBufferGeometry: () => Zu,
          TextGeometry: () => Zu,
          Texture: () => $n,
          TextureLoader: () => Fh,
          TorusBufferGeometry: () => Ju,
          TorusGeometry: () => Ju,
          TorusKnotBufferGeometry: () => Ku,
          TorusKnotGeometry: () => Ku,
          Triangle: () => xr,
          TriangleFanDrawMode: () => Ye,
          TriangleStripDrawMode: () => Xe,
          TrianglesDrawMode: () => qe,
          TubeBufferGeometry: () => Qu,
          TubeGeometry: () => Qu,
          UVMapping: () => it,
          Uint16Attribute: () => vf,
          Uint16BufferAttribute: () => kr,
          Uint32Attribute: () => xf,
          Uint32BufferAttribute: () => zr,
          Uint8Attribute: () => ff,
          Uint8BufferAttribute: () => Br,
          Uint8ClampedAttribute: () => mf,
          Uint8ClampedBufferAttribute: () => Or,
          Uniform: () => ip,
          UniformsLib: () => Go,
          UniformsUtils: () => So,
          UnsignedByteType: () => Mt,
          UnsignedInt248Type: () => Bt,
          UnsignedIntType: () => Ct,
          UnsignedShort4444Type: () => Pt,
          UnsignedShort5551Type: () => Nt,
          UnsignedShort565Type: () => It,
          UnsignedShortType: () => Tt,
          VSMShadowMap: () => d,
          Vector2: () => Yn,
          Vector3: () => si,
          Vector4: () => ei,
          VectorKeyframeTrack: () => Sh,
          Vertex: () => hf,
          VertexColors: () => ef,
          VideoTexture: () => Nc,
          WebGL1Renderer: () => Tl,
          WebGLCubeRenderTarget: () => Po,
          WebGLMultipleRenderTargets: () => ii,
          WebGLMultisampleRenderTarget: () => ri,
          WebGLRenderTarget: () => ni,
          WebGLRenderTargetCube: () => Cf,
          WebGLRenderer: () => El,
          WebGLUtils: () => yl,
          WireframeGeometry: () => $u,
          WireframeHelper: () => Ef,
          WrapAroundEnding: () => Ge,
          XHRLoader: () => Tf,
          ZeroCurvatureEnding: () => Ue,
          ZeroFactor: () => L,
          ZeroSlopeEnding: () => Ve,
          ZeroStencilOp: () => ln,
          sRGBEncoding: () => Je,
        });
      const e = "131";
      console.log(`THREE.js rev${e}`);
      const i = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
        r = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        o = 0,
        s = 1,
        a = 2,
        l = 3,
        c = 0,
        u = 1,
        h = 2,
        d = 3,
        p = 0,
        f = 1,
        m = 2,
        g = 1,
        v = 2,
        y = 0,
        x = 1,
        b = 2,
        w = 3,
        _ = 4,
        M = 5,
        S = 100,
        E = 101,
        T = 102,
        A = 103,
        C = 104,
        L = 200,
        R = 201,
        P = 202,
        N = 203,
        I = 204,
        B = 205,
        O = 206,
        D = 207,
        k = 208,
        F = 209,
        z = 210,
        H = 0,
        U = 1,
        V = 2,
        G = 3,
        j = 4,
        W = 5,
        q = 6,
        X = 7,
        Y = 0,
        Z = 1,
        J = 2,
        K = 0,
        Q = 1,
        $ = 2,
        tt = 3,
        et = 4,
        nt = 5,
        it = 300,
        rt = 301,
        ot = 302,
        st = 303,
        at = 304,
        lt = 306,
        ct = 307,
        ut = 1e3,
        ht = 1001,
        dt = 1002,
        pt = 1003,
        ft = 1004,
        mt = 1004,
        gt = 1005,
        vt = 1005,
        yt = 1006,
        xt = 1007,
        bt = 1007,
        wt = 1008,
        _t = 1008,
        Mt = 1009,
        St = 1010,
        Et = 1011,
        Tt = 1012,
        At = 1013,
        Ct = 1014,
        Lt = 1015,
        Rt = 1016,
        Pt = 1017,
        Nt = 1018,
        It = 1019,
        Bt = 1020,
        Ot = 1021,
        Dt = 1022,
        kt = 1023,
        Ft = 1024,
        zt = 1025,
        Ht = kt,
        Ut = 1026,
        Vt = 1027,
        Gt = 1028,
        jt = 1029,
        Wt = 1030,
        qt = 1031,
        Xt = 1032,
        Yt = 1033,
        Zt = 33776,
        Jt = 33777,
        Kt = 33778,
        Qt = 33779,
        $t = 35840,
        te = 35841,
        ee = 35842,
        ne = 35843,
        ie = 36196,
        re = 37492,
        oe = 37496,
        se = 37808,
        ae = 37809,
        le = 37810,
        ce = 37811,
        ue = 37812,
        he = 37813,
        de = 37814,
        pe = 37815,
        fe = 37816,
        me = 37817,
        ge = 37818,
        ve = 37819,
        ye = 37820,
        xe = 37821,
        be = 36492,
        we = 37840,
        _e = 37841,
        Me = 37842,
        Se = 37843,
        Ee = 37844,
        Te = 37845,
        Ae = 37846,
        Ce = 37847,
        Le = 37848,
        Re = 37849,
        Pe = 37850,
        Ne = 37851,
        Ie = 37852,
        Be = 37853,
        Oe = 2200,
        De = 2201,
        ke = 2202,
        Fe = 2300,
        ze = 2301,
        He = 2302,
        Ue = 2400,
        Ve = 2401,
        Ge = 2402,
        je = 2500,
        We = 2501,
        qe = 0,
        Xe = 1,
        Ye = 2,
        Ze = 3e3,
        Je = 3001,
        Ke = 3007,
        Qe = 3002,
        $e = 3003,
        tn = 3004,
        en = 3005,
        nn = 3006,
        rn = 3200,
        on = 3201,
        sn = 0,
        an = 1,
        ln = 0,
        cn = 7680,
        un = 7681,
        hn = 7682,
        dn = 7683,
        pn = 34055,
        fn = 34056,
        mn = 5386,
        gn = 512,
        vn = 513,
        yn = 514,
        xn = 515,
        bn = 516,
        wn = 517,
        _n = 518,
        Mn = 519,
        Sn = 35044,
        En = 35048,
        Tn = 35040,
        An = 35045,
        Cn = 35049,
        Ln = 35041,
        Rn = 35046,
        Pn = 35050,
        Nn = 35042,
        In = "100",
        Bn = "300 es";
      class On {
        addEventListener(t, e) {
          void 0 === this._listeners && (this._listeners = {});
          const n = this._listeners;
          void 0 === n[t] && (n[t] = []),
            -1 === n[t].indexOf(e) && n[t].push(e);
        }
        hasEventListener(t, e) {
          if (void 0 === this._listeners) return !1;
          const n = this._listeners;
          return void 0 !== n[t] && -1 !== n[t].indexOf(e);
        }
        removeEventListener(t, e) {
          if (void 0 === this._listeners) return;
          const n = this._listeners[t];
          if (void 0 !== n) {
            const t = n.indexOf(e);
            -1 !== t && n.splice(t, 1);
          }
        }
        dispatchEvent(t) {
          if (void 0 === this._listeners) return;
          const e = this._listeners[t.type];
          if (void 0 !== e) {
            t.target = this;
            const n = e.slice(0);
            for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
            t.target = null;
          }
        }
      }
      const Dn = [];
      for (let t = 0; t < 256; t++)
        Dn[t] = (t < 16 ? "0" : "") + t.toString(16);
      let kn = 1234567;
      const Fn = Math.PI / 180,
        zn = 180 / Math.PI;
      function Hn() {
        const t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          Dn[255 & t] +
          Dn[(t >> 8) & 255] +
          Dn[(t >> 16) & 255] +
          Dn[(t >> 24) & 255] +
          "-" +
          Dn[255 & e] +
          Dn[(e >> 8) & 255] +
          "-" +
          Dn[((e >> 16) & 15) | 64] +
          Dn[(e >> 24) & 255] +
          "-" +
          Dn[(63 & n) | 128] +
          Dn[(n >> 8) & 255] +
          "-" +
          Dn[(n >> 16) & 255] +
          Dn[(n >> 24) & 255] +
          Dn[255 & i] +
          Dn[(i >> 8) & 255] +
          Dn[(i >> 16) & 255] +
          Dn[(i >> 24) & 255]
        ).toUpperCase();
      }
      function Un(t, e, n) {
        return Math.max(e, Math.min(n, t));
      }
      function Vn(t, e) {
        return ((t % e) + e) % e;
      }
      function Gn(t, e, n) {
        return (1 - n) * t + n * e;
      }
      function jn(t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      }
      function Wn(t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      }
      function qn(t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      }
      var Xn = Object.freeze({
        __proto__: null,
        DEG2RAD: Fn,
        RAD2DEG: zn,
        generateUUID: Hn,
        clamp: Un,
        euclideanModulo: Vn,
        mapLinear: function (t, e, n, i, r) {
          return i + ((t - e) * (r - i)) / (n - e);
        },
        inverseLerp: function (t, e, n) {
          return t !== e ? (n - t) / (e - t) : 0;
        },
        lerp: Gn,
        damp: function (t, e, n, i) {
          return Gn(t, e, 1 - Math.exp(-n * i));
        },
        pingpong: function (t, e = 1) {
          return e - Math.abs(Vn(t, 2 * e) - e);
        },
        smoothstep: function (t, e, n) {
          return t <= e
            ? 0
            : t >= n
            ? 1
            : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
        },
        smootherstep: function (t, e, n) {
          return t <= e
            ? 0
            : t >= n
            ? 1
            : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
        },
        randInt: function (t, e) {
          return t + Math.floor(Math.random() * (e - t + 1));
        },
        randFloat: function (t, e) {
          return t + Math.random() * (e - t);
        },
        randFloatSpread: function (t) {
          return t * (0.5 - Math.random());
        },
        seededRandom: function (t) {
          return (
            void 0 !== t && (kn = t % 2147483647),
            (kn = (16807 * kn) % 2147483647),
            (kn - 1) / 2147483646
          );
        },
        degToRad: function (t) {
          return t * Fn;
        },
        radToDeg: function (t) {
          return t * zn;
        },
        isPowerOfTwo: jn,
        ceilPowerOfTwo: Wn,
        floorPowerOfTwo: qn,
        setQuaternionFromProperEuler: function (t, e, n, i, r) {
          const o = Math.cos,
            s = Math.sin,
            a = o(n / 2),
            l = s(n / 2),
            c = o((e + i) / 2),
            u = s((e + i) / 2),
            h = o((e - i) / 2),
            d = s((e - i) / 2),
            p = o((i - e) / 2),
            f = s((i - e) / 2);
          switch (r) {
            case "XYX":
              t.set(a * u, l * h, l * d, a * c);
              break;
            case "YZY":
              t.set(l * d, a * u, l * h, a * c);
              break;
            case "ZXZ":
              t.set(l * h, l * d, a * u, a * c);
              break;
            case "XZX":
              t.set(a * u, l * f, l * p, a * c);
              break;
            case "YXY":
              t.set(l * p, a * u, l * f, a * c);
              break;
            case "ZYZ":
              t.set(l * f, l * p, a * u, a * c);
              break;
            default:
              console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                  r
              );
          }
        },
      });
      class Yn {
        constructor(t = 0, e = 0) {
          (this.x = t), (this.y = e);
        }
        get width() {
          return this.x;
        }
        set width(t) {
          this.x = t;
        }
        get height() {
          return this.y;
        }
        set height(t) {
          this.y = t;
        }
        set(t, e) {
          return (this.x = t), (this.y = e), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), this;
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), this);
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), this;
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), this);
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), this;
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), this;
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            i = t.elements;
          return (
            (this.x = i[0] * e + i[3] * n + i[6]),
            (this.y = i[1] * e + i[4] * n + i[7]),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y;
          return e * e + n * n;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            this
          );
        }
        equals(t) {
          return t.x === this.x && t.y === this.y;
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), this;
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), t;
        }
        fromBufferAttribute(t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            this
          );
        }
        rotateAround(t, e) {
          const n = Math.cos(e),
            i = Math.sin(e),
            r = this.x - t.x,
            o = this.y - t.y;
          return (
            (this.x = r * n - o * i + t.x), (this.y = r * i + o * n + t.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
      }
      Yn.prototype.isVector2 = !0;
      class Zn {
        constructor() {
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(t, e, n, i, r, o, s, a, l) {
          const c = this.elements;
          return (
            (c[0] = t),
            (c[1] = i),
            (c[2] = s),
            (c[3] = e),
            (c[4] = r),
            (c[5] = a),
            (c[6] = n),
            (c[7] = o),
            (c[8] = l),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
          const e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            this
          );
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(t) {
          const e = t.elements;
          return (
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
          );
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            i = e.elements,
            r = this.elements,
            o = n[0],
            s = n[3],
            a = n[6],
            l = n[1],
            c = n[4],
            u = n[7],
            h = n[2],
            d = n[5],
            p = n[8],
            f = i[0],
            m = i[3],
            g = i[6],
            v = i[1],
            y = i[4],
            x = i[7],
            b = i[2],
            w = i[5],
            _ = i[8];
          return (
            (r[0] = o * f + s * v + a * b),
            (r[3] = o * m + s * y + a * w),
            (r[6] = o * g + s * x + a * _),
            (r[1] = l * f + c * v + u * b),
            (r[4] = l * m + c * y + u * w),
            (r[7] = l * g + c * x + u * _),
            (r[2] = h * f + d * v + p * b),
            (r[5] = h * m + d * y + p * w),
            (r[8] = h * g + d * x + p * _),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            o = t[4],
            s = t[5],
            a = t[6],
            l = t[7],
            c = t[8];
          return (
            e * o * c -
            e * s * l -
            n * r * c +
            n * s * a +
            i * r * l -
            i * o * a
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            o = t[4],
            s = t[5],
            a = t[6],
            l = t[7],
            c = t[8],
            u = c * o - s * l,
            h = s * a - c * r,
            d = l * r - o * a,
            p = e * u + n * h + i * d;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f = 1 / p;
          return (
            (t[0] = u * f),
            (t[1] = (i * l - c * n) * f),
            (t[2] = (s * n - i * o) * f),
            (t[3] = h * f),
            (t[4] = (c * e - i * a) * f),
            (t[5] = (i * r - s * e) * f),
            (t[6] = d * f),
            (t[7] = (n * a - l * e) * f),
            (t[8] = (o * e - n * r) * f),
            this
          );
        }
        transpose() {
          let t;
          const e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          );
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
          const e = this.elements;
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          );
        }
        setUvTransform(t, e, n, i, r, o, s) {
          const a = Math.cos(r),
            l = Math.sin(r);
          return (
            this.set(
              n * a,
              n * l,
              -n * (a * o + l * s) + o + t,
              -i * l,
              i * a,
              -i * (-l * o + a * s) + s + e,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(t, e) {
          const n = this.elements;
          return (
            (n[0] *= t),
            (n[3] *= t),
            (n[6] *= t),
            (n[1] *= e),
            (n[4] *= e),
            (n[7] *= e),
            this
          );
        }
        rotate(t) {
          const e = Math.cos(t),
            n = Math.sin(t),
            i = this.elements,
            r = i[0],
            o = i[3],
            s = i[6],
            a = i[1],
            l = i[4],
            c = i[7];
          return (
            (i[0] = e * r + n * a),
            (i[3] = e * o + n * l),
            (i[6] = e * s + n * c),
            (i[1] = -n * r + e * a),
            (i[4] = -n * o + e * l),
            (i[7] = -n * s + e * c),
            this
          );
        }
        translate(t, e) {
          const n = this.elements;
          return (
            (n[0] += t * n[2]),
            (n[3] += t * n[5]),
            (n[6] += t * n[8]),
            (n[1] += e * n[2]),
            (n[4] += e * n[5]),
            (n[7] += e * n[8]),
            this
          );
        }
        equals(t) {
          const e = this.elements,
            n = t.elements;
          for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            t
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      let Jn;
      Zn.prototype.isMatrix3 = !0;
      class Kn {
        static getDataURL(t) {
          if (/^data:/i.test(t.src)) return t.src;
          if ("undefined" == typeof HTMLCanvasElement) return t.src;
          let e;
          if (t instanceof HTMLCanvasElement) e = t;
          else {
            void 0 === Jn &&
              (Jn = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              )),
              (Jn.width = t.width),
              (Jn.height = t.height);
            const n = Jn.getContext("2d");
            t instanceof ImageData
              ? n.putImageData(t, 0, 0)
              : n.drawImage(t, 0, 0, t.width, t.height),
              (e = Jn);
          }
          return e.width > 2048 || e.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                t
              ),
              e.toDataURL("image/jpeg", 0.6))
            : e.toDataURL("image/png");
        }
      }
      let Qn = 0;
      class $n extends On {
        constructor(
          t = $n.DEFAULT_IMAGE,
          e = $n.DEFAULT_MAPPING,
          n = ht,
          i = ht,
          r = yt,
          o = wt,
          s = kt,
          a = Mt,
          l = 1,
          c = Ze
        ) {
          super(),
            Object.defineProperty(this, "id", { value: Qn++ }),
            (this.uuid = Hn()),
            (this.name = ""),
            (this.image = t),
            (this.mipmaps = []),
            (this.mapping = e),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = o),
            (this.anisotropy = l),
            (this.format = s),
            (this.internalFormat = null),
            (this.type = a),
            (this.offset = new Yn(0, 0)),
            (this.repeat = new Yn(1, 1)),
            (this.center = new Yn(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Zn()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = c),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1);
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            this
          );
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          if (void 0 !== this.image) {
            const i = this.image;
            if (
              (void 0 === i.uuid && (i.uuid = Hn()),
              !e && void 0 === t.images[i.uuid])
            ) {
              let e;
              if (Array.isArray(i)) {
                e = [];
                for (let t = 0, n = i.length; t < n; t++)
                  i[t].isDataTexture
                    ? e.push(ti(i[t].image))
                    : e.push(ti(i[t]));
              } else e = ti(i);
              t.images[i.uuid] = { uuid: i.uuid, url: e };
            }
            n.image = i.uuid;
          }
          return e || (t.textures[this.uuid] = n), n;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(t) {
          if (this.mapping !== it) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case ut:
                t.x = t.x - Math.floor(t.x);
                break;
              case ht:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case dt:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case ut:
                t.y = t.y - Math.floor(t.y);
                break;
              case ht:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case dt:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
            }
          return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
      }
      function ti(t) {
        return ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ? Kn.getDataURL(t)
          : t.data
          ? {
              data: Array.prototype.slice.call(t.data),
              width: t.width,
              height: t.height,
              type: t.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      ($n.DEFAULT_IMAGE = void 0),
        ($n.DEFAULT_MAPPING = it),
        ($n.prototype.isTexture = !0);
      class ei {
        constructor(t = 0, e = 0, n = 0, i = 1) {
          (this.x = t), (this.y = e), (this.z = n), (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(t) {
          this.z = t;
        }
        get height() {
          return this.w;
        }
        set height(t) {
          this.w = t;
        }
        set(t, e, n, i) {
          return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setW(t) {
          return (this.w = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          );
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x),
              (this.y += t.y),
              (this.z += t.z),
              (this.w += t.w),
              this);
        }
        addScalar(t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x),
              (this.y -= t.y),
              (this.z -= t.z),
              (this.w -= t.w),
              this);
        }
        subScalar(t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        }
        multiply(t) {
          return (
            (this.x *= t.x),
            (this.y *= t.y),
            (this.z *= t.z),
            (this.w *= t.w),
            this
          );
        }
        multiplyScalar(t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            o = t.elements;
          return (
            (this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r),
            (this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r),
            (this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r),
            (this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r),
            this
          );
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w);
          const e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, n, i, r;
          const o = 0.01,
            s = 0.1,
            a = t.elements,
            l = a[0],
            c = a[4],
            u = a[8],
            h = a[1],
            d = a[5],
            p = a[9],
            f = a[2],
            m = a[6],
            g = a[10];
          if (
            Math.abs(c - h) < o &&
            Math.abs(u - f) < o &&
            Math.abs(p - m) < o
          ) {
            if (
              Math.abs(c + h) < s &&
              Math.abs(u + f) < s &&
              Math.abs(p + m) < s &&
              Math.abs(l + d + g - 3) < s
            )
              return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const t = (l + 1) / 2,
              a = (d + 1) / 2,
              v = (g + 1) / 2,
              y = (c + h) / 4,
              x = (u + f) / 4,
              b = (p + m) / 4;
            return (
              t > a && t > v
                ? t < o
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(t)), (i = y / n), (r = x / n))
                : a > v
                ? a < o
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(a)), (n = y / i), (r = b / i))
                : v < o
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(v)), (n = x / r), (i = b / r)),
              this.set(n, i, r, e),
              this
            );
          }
          let v = Math.sqrt(
            (m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)
          );
          return (
            Math.abs(v) < 0.001 && (v = 1),
            (this.x = (m - p) / v),
            (this.y = (u - f) / v),
            (this.z = (h - c) / v),
            (this.w = Math.acos((l + d + g - 1) / 2)),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            (this.w = t.w + (e.w - t.w) * n),
            this
          );
        }
        equals(t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        }
        fromBufferAttribute(t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
      }
      ei.prototype.isVector4 = !0;
      class ni extends On {
        constructor(t, e, n = {}) {
          super(),
            (this.width = t),
            (this.height = e),
            (this.depth = 1),
            (this.scissor = new ei(0, 0, t, e)),
            (this.scissorTest = !1),
            (this.viewport = new ei(0, 0, t, e)),
            (this.texture = new $n(
              void 0,
              n.mapping,
              n.wrapS,
              n.wrapT,
              n.magFilter,
              n.minFilter,
              n.format,
              n.type,
              n.anisotropy,
              n.encoding
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.image = { width: t, height: e, depth: 1 }),
            (this.texture.generateMipmaps =
              void 0 !== n.generateMipmaps && n.generateMipmaps),
            (this.texture.minFilter =
              void 0 !== n.minFilter ? n.minFilter : yt),
            (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
            (this.stencilBuffer =
              void 0 !== n.stencilBuffer && n.stencilBuffer),
            (this.depthTexture =
              void 0 !== n.depthTexture ? n.depthTexture : null);
        }
        setTexture(t) {
          (t.image = {
            width: this.width,
            height: this.height,
            depth: this.depth,
          }),
            (this.texture = t);
        }
        setSize(t, e, n = 1) {
          (this.width === t && this.height === e && this.depth === n) ||
            ((this.width = t),
            (this.height = e),
            (this.depth = n),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.texture.image = { ...this.texture.image }),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      ni.prototype.isWebGLRenderTarget = !0;
      class ii extends ni {
        constructor(t, e, n) {
          super(t, e);
          const i = this.texture;
          this.texture = [];
          for (let t = 0; t < n; t++) this.texture[t] = i.clone();
        }
        setSize(t, e, n = 1) {
          if (this.width !== t || this.height !== e || this.depth !== n) {
            (this.width = t), (this.height = e), (this.depth = n);
            for (let i = 0, r = this.texture.length; i < r; i++)
              (this.texture[i].image.width = t),
                (this.texture[i].image.height = e),
                (this.texture[i].image.depth = n);
            this.dispose();
          }
          return (
            this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
          );
        }
        copy(t) {
          this.dispose(),
            (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            (this.texture.length = 0);
          for (let e = 0, n = t.texture.length; e < n; e++)
            this.texture[e] = t.texture[e].clone();
          return this;
        }
      }
      ii.prototype.isWebGLMultipleRenderTargets = !0;
      class ri extends ni {
        constructor(t, e, n) {
          super(t, e, n), (this.samples = 4);
        }
        copy(t) {
          return super.copy.call(this, t), (this.samples = t.samples), this;
        }
      }
      ri.prototype.isWebGLMultisampleRenderTarget = !0;
      class oi {
        constructor(t = 0, e = 0, n = 0, i = 1) {
          (this._x = t), (this._y = e), (this._z = n), (this._w = i);
        }
        static slerp(t, e, n, i) {
          return (
            console.warn(
              "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(t, e, i)
          );
        }
        static slerpFlat(t, e, n, i, r, o, s) {
          let a = n[i + 0],
            l = n[i + 1],
            c = n[i + 2],
            u = n[i + 3];
          const h = r[o + 0],
            d = r[o + 1],
            p = r[o + 2],
            f = r[o + 3];
          if (0 === s)
            return (
              (t[e + 0] = a),
              (t[e + 1] = l),
              (t[e + 2] = c),
              void (t[e + 3] = u)
            );
          if (1 === s)
            return (
              (t[e + 0] = h),
              (t[e + 1] = d),
              (t[e + 2] = p),
              void (t[e + 3] = f)
            );
          if (u !== f || a !== h || l !== d || c !== p) {
            let t = 1 - s;
            const e = a * h + l * d + c * p + u * f,
              n = e >= 0 ? 1 : -1,
              i = 1 - e * e;
            if (i > Number.EPSILON) {
              const r = Math.sqrt(i),
                o = Math.atan2(r, e * n);
              (t = Math.sin(t * o) / r), (s = Math.sin(s * o) / r);
            }
            const r = s * n;
            if (
              ((a = a * t + h * r),
              (l = l * t + d * r),
              (c = c * t + p * r),
              (u = u * t + f * r),
              t === 1 - s)
            ) {
              const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
              (a *= t), (l *= t), (c *= t), (u *= t);
            }
          }
          (t[e] = a), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = u);
        }
        static multiplyQuaternionsFlat(t, e, n, i, r, o) {
          const s = n[i],
            a = n[i + 1],
            l = n[i + 2],
            c = n[i + 3],
            u = r[o],
            h = r[o + 1],
            d = r[o + 2],
            p = r[o + 3];
          return (
            (t[e] = s * p + c * u + a * d - l * h),
            (t[e + 1] = a * p + c * h + l * u - s * d),
            (t[e + 2] = l * p + c * d + s * h - a * u),
            (t[e + 3] = c * p - s * u - a * h - l * d),
            t
          );
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t) {
          (this._w = t), this._onChangeCallback();
        }
        set(t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(t, e) {
          if (!t || !t.isEuler)
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          const n = t._x,
            i = t._y,
            r = t._z,
            o = t._order,
            s = Math.cos,
            a = Math.sin,
            l = s(n / 2),
            c = s(i / 2),
            u = s(r / 2),
            h = a(n / 2),
            d = a(i / 2),
            p = a(r / 2);
          switch (o) {
            case "XYZ":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "YXZ":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            case "ZXY":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "ZYX":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            case "YZX":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "XZY":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  o
              );
          }
          return !1 !== e && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, e) {
          const n = e / 2,
            i = Math.sin(n);
          return (
            (this._x = t.x * i),
            (this._y = t.y * i),
            (this._z = t.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t) {
          const e = t.elements,
            n = e[0],
            i = e[4],
            r = e[8],
            o = e[1],
            s = e[5],
            a = e[9],
            l = e[2],
            c = e[6],
            u = e[10],
            h = n + s + u;
          if (h > 0) {
            const t = 0.5 / Math.sqrt(h + 1);
            (this._w = 0.25 / t),
              (this._x = (c - a) * t),
              (this._y = (r - l) * t),
              (this._z = (o - i) * t);
          } else if (n > s && n > u) {
            const t = 2 * Math.sqrt(1 + n - s - u);
            (this._w = (c - a) / t),
              (this._x = 0.25 * t),
              (this._y = (i + o) / t),
              (this._z = (r + l) / t);
          } else if (s > u) {
            const t = 2 * Math.sqrt(1 + s - n - u);
            (this._w = (r - l) / t),
              (this._x = (i + o) / t),
              (this._y = 0.25 * t),
              (this._z = (a + c) / t);
          } else {
            const t = 2 * Math.sqrt(1 + u - n - s);
            (this._w = (o - i) / t),
              (this._x = (r + l) / t),
              (this._y = (a + c) / t),
              (this._z = 0.25 * t);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, e) {
          let n = t.dot(e) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y),
                    (this._y = t.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -t.z),
                    (this._z = t.y),
                    (this._w = n)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(Un(this.dot(t), -1, 1)));
        }
        rotateTowards(t, e) {
          const n = this.angleTo(t);
          if (0 === n) return this;
          const i = Math.min(1, e / n);
          return this.slerp(t, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let t = this.length();
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(t, e))
            : this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, e) {
          const n = t._x,
            i = t._y,
            r = t._z,
            o = t._w,
            s = e._x,
            a = e._y,
            l = e._z,
            c = e._w;
          return (
            (this._x = n * c + o * s + i * l - r * a),
            (this._y = i * c + o * a + r * s - n * l),
            (this._z = r * c + o * l + n * a - i * s),
            (this._w = o * c - n * s - i * a - r * l),
            this._onChangeCallback(),
            this
          );
        }
        slerp(t, e) {
          if (0 === e) return this;
          if (1 === e) return this.copy(t);
          const n = this._x,
            i = this._y,
            r = this._z,
            o = this._w;
          let s = o * t._w + n * t._x + i * t._y + r * t._z;
          if (
            (s < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (s = -s))
              : this.copy(t),
            s >= 1)
          )
            return (
              (this._w = o), (this._x = n), (this._y = i), (this._z = r), this
            );
          const a = 1 - s * s;
          if (a <= Number.EPSILON) {
            const t = 1 - e;
            return (
              (this._w = t * o + e * this._w),
              (this._x = t * n + e * this._x),
              (this._y = t * i + e * this._y),
              (this._z = t * r + e * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const l = Math.sqrt(a),
            c = Math.atan2(l, s),
            u = Math.sin((1 - e) * c) / l,
            h = Math.sin(e * c) / l;
          return (
            (this._w = o * u + this._w * h),
            (this._x = n * u + this._x * h),
            (this._y = i * u + this._y * h),
            (this._z = r * u + this._z * h),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(t, e, n) {
          this.copy(t).slerp(e, n);
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        }
        fromBufferAttribute(t, e) {
          return (
            (this._x = t.getX(e)),
            (this._y = t.getY(e)),
            (this._z = t.getZ(e)),
            (this._w = t.getW(e)),
            this
          );
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
      }
      oi.prototype.isQuaternion = !0;
      class si {
        constructor(t = 0, e = 0, n = 0) {
          (this.x = t), (this.y = e), (this.z = n);
        }
        set(t, e, n) {
          return (
            void 0 === n && (n = this.z),
            (this.x = t),
            (this.y = e),
            (this.z = n),
            this
          );
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), (this.z += t), this;
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
          );
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), this;
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            this
          );
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(t, e))
            : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), this;
        }
        multiplyVectors(t, e) {
          return (
            (this.x = t.x * e.x),
            (this.y = t.y * e.y),
            (this.z = t.z * e.z),
            this
          );
        }
        applyEuler(t) {
          return (
            (t && t.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
            this.applyQuaternion(li.setFromEuler(t))
          );
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(li.setFromAxisAngle(t, e));
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[3] * n + r[6] * i),
            (this.y = r[1] * e + r[4] * n + r[7] * i),
            (this.z = r[2] * e + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements,
            o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o),
            (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o),
            (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o),
            this
          );
        }
        applyQuaternion(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.x,
            o = t.y,
            s = t.z,
            a = t.w,
            l = a * e + o * i - s * n,
            c = a * n + s * e - r * i,
            u = a * i + r * n - o * e,
            h = -r * e - o * n - s * i;
          return (
            (this.x = l * a + h * -r + c * -s - u * -o),
            (this.y = c * a + h * -o + u * -r - l * -s),
            (this.z = u * a + h * -s + l * -o - c * -r),
            this
          );
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
            t.projectionMatrix
          );
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
            t.matrixWorld
          );
        }
        transformDirection(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[4] * n + r[8] * i),
            (this.y = r[1] * e + r[5] * n + r[9] * i),
            (this.z = r[2] * e + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            this
          );
        }
        cross(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(t, e))
            : this.crossVectors(this, t);
        }
        crossVectors(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            o = e.x,
            s = e.y,
            a = e.z;
          return (
            (this.x = i * a - r * s),
            (this.y = r * o - n * a),
            (this.z = n * s - i * o),
            this
          );
        }
        projectOnVector(t) {
          const e = t.lengthSq();
          if (0 === e) return this.set(0, 0, 0);
          const n = t.dot(this) / e;
          return this.copy(t).multiplyScalar(n);
        }
        projectOnPlane(t) {
          return ai.copy(this).projectOnVector(t), this.sub(ai);
        }
        reflect(t) {
          return this.sub(ai.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (0 === e) return Math.PI / 2;
          const n = this.dot(t) / e;
          return Math.acos(Un(n, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y,
            i = this.z - t.z;
          return e * e + n * n + i * i;
        }
        manhattanDistanceTo(t) {
          return (
            Math.abs(this.x - t.x) +
            Math.abs(this.y - t.y) +
            Math.abs(this.z - t.z)
          );
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, e, n) {
          const i = Math.sin(e) * t;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(e) * t),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, e, n) {
          return (
            (this.x = t * Math.sin(e)),
            (this.y = n),
            (this.z = t * Math.cos(e)),
            this
          );
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
        }
        setFromMatrixScale(t) {
          const e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            i = this.setFromMatrixColumn(t, 2).length();
          return (this.x = e), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, 4 * e);
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, 3 * e);
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
        }
        fromBufferAttribute(t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
      }
      si.prototype.isVector3 = !0;
      const ai = new si(),
        li = new oi();
      class ci {
        constructor(
          t = new si(1 / 0, 1 / 0, 1 / 0),
          e = new si(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromArray(t) {
          let e = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            s = -1 / 0;
          for (let a = 0, l = t.length; a < l; a += 3) {
            const l = t[a],
              c = t[a + 1],
              u = t[a + 2];
            l < e && (e = l),
              c < n && (n = c),
              u < i && (i = u),
              l > r && (r = l),
              c > o && (o = c),
              u > s && (s = u);
          }
          return this.min.set(e, n, i), this.max.set(r, o, s), this;
        }
        setFromBufferAttribute(t) {
          let e = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            o = -1 / 0,
            s = -1 / 0;
          for (let a = 0, l = t.count; a < l; a++) {
            const l = t.getX(a),
              c = t.getY(a),
              u = t.getZ(a);
            l < e && (e = l),
              c < n && (n = c),
              u < i && (i = u),
              l > r && (r = l),
              c > o && (o = c),
              u > s && (s = u);
          }
          return this.min.set(e, n, i), this.max.set(r, o, s), this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const n = hi.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
        }
        setFromObject(t) {
          return this.makeEmpty(), this.expandByObject(t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t) {
          t.updateWorldMatrix(!1, !1);
          const e = t.geometry;
          void 0 !== e &&
            (null === e.boundingBox && e.computeBoundingBox(),
            di.copy(e.boundingBox),
            di.applyMatrix4(t.matrixWorld),
            this.union(di));
          const n = t.children;
          for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
          return this;
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y ||
            t.z < this.min.z ||
            t.z > this.max.z
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y &&
            this.min.z <= t.min.z &&
            t.max.z <= this.max.z
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y ||
            t.max.z < this.min.z ||
            t.min.z > this.max.z
          );
        }
        intersectsSphere(t) {
          return (
            this.clampPoint(t.center, hi),
            hi.distanceToSquared(t.center) <= t.radius * t.radius
          );
        }
        intersectsPlane(t) {
          let e, n;
          return (
            t.normal.x > 0
              ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
              : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
            t.normal.y > 0
              ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
              : ((e += t.normal.y * this.max.y),
                (n += t.normal.y * this.min.y)),
            t.normal.z > 0
              ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
              : ((e += t.normal.z * this.max.z),
                (n += t.normal.z * this.min.z)),
            e <= -t.constant && n >= -t.constant
          );
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return !1;
          this.getCenter(xi),
            bi.subVectors(this.max, xi),
            pi.subVectors(t.a, xi),
            fi.subVectors(t.b, xi),
            mi.subVectors(t.c, xi),
            gi.subVectors(fi, pi),
            vi.subVectors(mi, fi),
            yi.subVectors(pi, mi);
          let e = [
            0,
            -gi.z,
            gi.y,
            0,
            -vi.z,
            vi.y,
            0,
            -yi.z,
            yi.y,
            gi.z,
            0,
            -gi.x,
            vi.z,
            0,
            -vi.x,
            yi.z,
            0,
            -yi.x,
            -gi.y,
            gi.x,
            0,
            -vi.y,
            vi.x,
            0,
            -yi.y,
            yi.x,
            0,
          ];
          return (
            !!Mi(e, pi, fi, mi, bi) &&
            ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!Mi(e, pi, fi, mi, bi) &&
              (wi.crossVectors(gi, vi),
              (e = [wi.x, wi.y, wi.z]),
              Mi(e, pi, fi, mi, bi)))
          );
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return hi.copy(t).clamp(this.min, this.max).sub(t).length();
        }
        getBoundingSphere(t) {
          return (
            this.getCenter(t.center),
            (t.radius = 0.5 * this.getSize(hi).length()),
            t
          );
        }
        intersect(t) {
          return (
            this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
          return (
            this.isEmpty() ||
              (ui[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
              ui[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
              ui[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
              ui[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
              ui[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
              ui[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
              ui[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
              ui[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
              this.setFromPoints(ui)),
            this
          );
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      ci.prototype.isBox3 = !0;
      const ui = [
          new si(),
          new si(),
          new si(),
          new si(),
          new si(),
          new si(),
          new si(),
          new si(),
        ],
        hi = new si(),
        di = new ci(),
        pi = new si(),
        fi = new si(),
        mi = new si(),
        gi = new si(),
        vi = new si(),
        yi = new si(),
        xi = new si(),
        bi = new si(),
        wi = new si(),
        _i = new si();
      function Mi(t, e, n, i, r) {
        for (let o = 0, s = t.length - 3; o <= s; o += 3) {
          _i.fromArray(t, o);
          const s =
              r.x * Math.abs(_i.x) +
              r.y * Math.abs(_i.y) +
              r.z * Math.abs(_i.z),
            a = e.dot(_i),
            l = n.dot(_i),
            c = i.dot(_i);
          if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > s) return !1;
        }
        return !0;
      }
      const Si = new ci(),
        Ei = new si(),
        Ti = new si(),
        Ai = new si();
      class Ci {
        constructor(t = new si(), e = -1) {
          (this.center = t), (this.radius = e);
        }
        set(t, e) {
          return this.center.copy(t), (this.radius = e), this;
        }
        setFromPoints(t, e) {
          const n = this.center;
          void 0 !== e ? n.copy(e) : Si.setFromPoints(t).getCenter(n);
          let i = 0;
          for (let e = 0, r = t.length; e < r; e++)
            i = Math.max(i, n.distanceToSquared(t[e]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(t) {
          return this.center.copy(t.center), (this.radius = t.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
          const e = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= e * e;
        }
        intersectsBox(t) {
          return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, e) {
          const n = this.center.distanceToSquared(t);
          return (
            e.copy(t),
            n > this.radius * this.radius &&
              (e.sub(this.center).normalize(),
              e.multiplyScalar(this.radius).add(this.center)),
            e
          );
        }
        getBoundingBox(t) {
          return this.isEmpty()
            ? (t.makeEmpty(), t)
            : (t.set(this.center, this.center),
              t.expandByScalar(this.radius),
              t);
        }
        applyMatrix4(t) {
          return (
            this.center.applyMatrix4(t),
            (this.radius = this.radius * t.getMaxScaleOnAxis()),
            this
          );
        }
        translate(t) {
          return this.center.add(t), this;
        }
        expandByPoint(t) {
          Ai.subVectors(t, this.center);
          const e = Ai.lengthSq();
          if (e > this.radius * this.radius) {
            const t = Math.sqrt(e),
              n = 0.5 * (t - this.radius);
            this.center.add(Ai.multiplyScalar(n / t)), (this.radius += n);
          }
          return this;
        }
        union(t) {
          return (
            Ti.subVectors(t.center, this.center)
              .normalize()
              .multiplyScalar(t.radius),
            this.expandByPoint(Ei.copy(t.center).add(Ti)),
            this.expandByPoint(Ei.copy(t.center).sub(Ti)),
            this
          );
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Li = new si(),
        Ri = new si(),
        Pi = new si(),
        Ni = new si(),
        Ii = new si(),
        Bi = new si(),
        Oi = new si();
      class Di {
        constructor(t = new si(), e = new si(0, 0, -1)) {
          (this.origin = t), (this.direction = e);
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        }
        copy(t) {
          return (
            this.origin.copy(t.origin), this.direction.copy(t.direction), this
          );
        }
        at(t, e) {
          return e.copy(this.direction).multiplyScalar(t).add(this.origin);
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, Li)), this;
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin);
          const n = e.dot(this.direction);
          return n < 0
            ? e.copy(this.origin)
            : e.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          const e = Li.subVectors(t, this.origin).dot(this.direction);
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (Li.copy(this.direction).multiplyScalar(e).add(this.origin),
              Li.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, n, i) {
          Ri.copy(t).add(e).multiplyScalar(0.5),
            Pi.copy(e).sub(t).normalize(),
            Ni.copy(this.origin).sub(Ri);
          const r = 0.5 * t.distanceTo(e),
            o = -this.direction.dot(Pi),
            s = Ni.dot(this.direction),
            a = -Ni.dot(Pi),
            l = Ni.lengthSq(),
            c = Math.abs(1 - o * o);
          let u, h, d, p;
          if (c > 0)
            if (((u = o * a - s), (h = o * s - a), (p = r * c), u >= 0))
              if (h >= -p)
                if (h <= p) {
                  const t = 1 / c;
                  (u *= t),
                    (h *= t),
                    (d = u * (u + o * h + 2 * s) + h * (o * u + h + 2 * a) + l);
                } else
                  (h = r),
                    (u = Math.max(0, -(o * h + s))),
                    (d = -u * u + h * (h + 2 * a) + l);
              else
                (h = -r),
                  (u = Math.max(0, -(o * h + s))),
                  (d = -u * u + h * (h + 2 * a) + l);
            else
              h <= -p
                ? ((u = Math.max(0, -(-o * r + s))),
                  (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)),
                  (d = -u * u + h * (h + 2 * a) + l))
                : h <= p
                ? ((u = 0),
                  (h = Math.min(Math.max(-r, -a), r)),
                  (d = h * (h + 2 * a) + l))
                : ((u = Math.max(0, -(o * r + s))),
                  (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)),
                  (d = -u * u + h * (h + 2 * a) + l));
          else
            (h = o > 0 ? -r : r),
              (u = Math.max(0, -(o * h + s))),
              (d = -u * u + h * (h + 2 * a) + l);
          return (
            n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
            i && i.copy(Pi).multiplyScalar(h).add(Ri),
            d
          );
        }
        intersectSphere(t, e) {
          Li.subVectors(t.center, this.origin);
          const n = Li.dot(this.direction),
            i = Li.dot(Li) - n * n,
            r = t.radius * t.radius;
          if (i > r) return null;
          const o = Math.sqrt(r - i),
            s = n - o,
            a = n + o;
          return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction);
          if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
          const n = -(this.origin.dot(t.normal) + t.constant) / e;
          return n >= 0 ? n : null;
        }
        intersectPlane(t, e) {
          const n = this.distanceToPlane(t);
          return null === n ? null : this.at(n, e);
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin);
          return 0 === e || t.normal.dot(this.direction) * e < 0;
        }
        intersectBox(t, e) {
          let n, i, r, o, s, a;
          const l = 1 / this.direction.x,
            c = 1 / this.direction.y,
            u = 1 / this.direction.z,
            h = this.origin;
          return (
            l >= 0
              ? ((n = (t.min.x - h.x) * l), (i = (t.max.x - h.x) * l))
              : ((n = (t.max.x - h.x) * l), (i = (t.min.x - h.x) * l)),
            c >= 0
              ? ((r = (t.min.y - h.y) * c), (o = (t.max.y - h.y) * c))
              : ((r = (t.max.y - h.y) * c), (o = (t.min.y - h.y) * c)),
            n > o || r > i
              ? null
              : ((r > n || n != n) && (n = r),
                (o < i || i != i) && (i = o),
                u >= 0
                  ? ((s = (t.min.z - h.z) * u), (a = (t.max.z - h.z) * u))
                  : ((s = (t.max.z - h.z) * u), (a = (t.min.z - h.z) * u)),
                n > a || s > i
                  ? null
                  : ((s > n || n != n) && (n = s),
                    (a < i || i != i) && (i = a),
                    i < 0 ? null : this.at(n >= 0 ? n : i, e)))
          );
        }
        intersectsBox(t) {
          return null !== this.intersectBox(t, Li);
        }
        intersectTriangle(t, e, n, i, r) {
          Ii.subVectors(e, t), Bi.subVectors(n, t), Oi.crossVectors(Ii, Bi);
          let o,
            s = this.direction.dot(Oi);
          if (s > 0) {
            if (i) return null;
            o = 1;
          } else {
            if (!(s < 0)) return null;
            (o = -1), (s = -s);
          }
          Ni.subVectors(this.origin, t);
          const a = o * this.direction.dot(Bi.crossVectors(Ni, Bi));
          if (a < 0) return null;
          const l = o * this.direction.dot(Ii.cross(Ni));
          if (l < 0) return null;
          if (a + l > s) return null;
          const c = -o * Ni.dot(Oi);
          return c < 0 ? null : this.at(c / s, r);
        }
        applyMatrix4(t) {
          return (
            this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
          );
        }
        equals(t) {
          return (
            t.origin.equals(this.origin) && t.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class ki {
        constructor() {
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
        }
        set(t, e, n, i, r, o, s, a, l, c, u, h, d, p, f, m) {
          const g = this.elements;
          return (
            (g[0] = t),
            (g[4] = e),
            (g[8] = n),
            (g[12] = i),
            (g[1] = r),
            (g[5] = o),
            (g[9] = s),
            (g[13] = a),
            (g[2] = l),
            (g[6] = c),
            (g[10] = u),
            (g[14] = h),
            (g[3] = d),
            (g[7] = p),
            (g[11] = f),
            (g[15] = m),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ki().fromArray(this.elements);
        }
        copy(t) {
          const e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            (e[9] = n[9]),
            (e[10] = n[10]),
            (e[11] = n[11]),
            (e[12] = n[12]),
            (e[13] = n[13]),
            (e[14] = n[14]),
            (e[15] = n[15]),
            this
          );
        }
        copyPosition(t) {
          const e = this.elements,
            n = t.elements;
          return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
        }
        setFromMatrix3(t) {
          const e = t.elements;
          return (
            this.set(
              e[0],
              e[3],
              e[6],
              0,
              e[1],
              e[4],
              e[7],
              0,
              e[2],
              e[5],
              e[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(t, e, n) {
          return (
            this.set(
              t.x,
              e.x,
              n.x,
              0,
              t.y,
              e.y,
              n.y,
              0,
              t.z,
              e.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(t) {
          const e = this.elements,
            n = t.elements,
            i = 1 / Fi.setFromMatrixColumn(t, 0).length(),
            r = 1 / Fi.setFromMatrixColumn(t, 1).length(),
            o = 1 / Fi.setFromMatrixColumn(t, 2).length();
          return (
            (e[0] = n[0] * i),
            (e[1] = n[1] * i),
            (e[2] = n[2] * i),
            (e[3] = 0),
            (e[4] = n[4] * r),
            (e[5] = n[5] * r),
            (e[6] = n[6] * r),
            (e[7] = 0),
            (e[8] = n[8] * o),
            (e[9] = n[9] * o),
            (e[10] = n[10] * o),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromEuler(t) {
          (t && t.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          const e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z,
            o = Math.cos(n),
            s = Math.sin(n),
            a = Math.cos(i),
            l = Math.sin(i),
            c = Math.cos(r),
            u = Math.sin(r);
          if ("XYZ" === t.order) {
            const t = o * c,
              n = o * u,
              i = s * c,
              r = s * u;
            (e[0] = a * c),
              (e[4] = -a * u),
              (e[8] = l),
              (e[1] = n + i * l),
              (e[5] = t - r * l),
              (e[9] = -s * a),
              (e[2] = r - t * l),
              (e[6] = i + n * l),
              (e[10] = o * a);
          } else if ("YXZ" === t.order) {
            const t = a * c,
              n = a * u,
              i = l * c,
              r = l * u;
            (e[0] = t + r * s),
              (e[4] = i * s - n),
              (e[8] = o * l),
              (e[1] = o * u),
              (e[5] = o * c),
              (e[9] = -s),
              (e[2] = n * s - i),
              (e[6] = r + t * s),
              (e[10] = o * a);
          } else if ("ZXY" === t.order) {
            const t = a * c,
              n = a * u,
              i = l * c,
              r = l * u;
            (e[0] = t - r * s),
              (e[4] = -o * u),
              (e[8] = i + n * s),
              (e[1] = n + i * s),
              (e[5] = o * c),
              (e[9] = r - t * s),
              (e[2] = -o * l),
              (e[6] = s),
              (e[10] = o * a);
          } else if ("ZYX" === t.order) {
            const t = o * c,
              n = o * u,
              i = s * c,
              r = s * u;
            (e[0] = a * c),
              (e[4] = i * l - n),
              (e[8] = t * l + r),
              (e[1] = a * u),
              (e[5] = r * l + t),
              (e[9] = n * l - i),
              (e[2] = -l),
              (e[6] = s * a),
              (e[10] = o * a);
          } else if ("YZX" === t.order) {
            const t = o * a,
              n = o * l,
              i = s * a,
              r = s * l;
            (e[0] = a * c),
              (e[4] = r - t * u),
              (e[8] = i * u + n),
              (e[1] = u),
              (e[5] = o * c),
              (e[9] = -s * c),
              (e[2] = -l * c),
              (e[6] = n * u + i),
              (e[10] = t - r * u);
          } else if ("XZY" === t.order) {
            const t = o * a,
              n = o * l,
              i = s * a,
              r = s * l;
            (e[0] = a * c),
              (e[4] = -u),
              (e[8] = l * c),
              (e[1] = t * u + r),
              (e[5] = o * c),
              (e[9] = n * u - i),
              (e[2] = i * u - n),
              (e[6] = s * c),
              (e[10] = r * u + t);
          }
          return (
            (e[3] = 0),
            (e[7] = 0),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(t) {
          return this.compose(Hi, t, Ui);
        }
        lookAt(t, e, n) {
          const i = this.elements;
          return (
            ji.subVectors(t, e),
            0 === ji.lengthSq() && (ji.z = 1),
            ji.normalize(),
            Vi.crossVectors(n, ji),
            0 === Vi.lengthSq() &&
              (1 === Math.abs(n.z) ? (ji.x += 1e-4) : (ji.z += 1e-4),
              ji.normalize(),
              Vi.crossVectors(n, ji)),
            Vi.normalize(),
            Gi.crossVectors(ji, Vi),
            (i[0] = Vi.x),
            (i[4] = Gi.x),
            (i[8] = ji.x),
            (i[1] = Vi.y),
            (i[5] = Gi.y),
            (i[9] = ji.y),
            (i[2] = Vi.z),
            (i[6] = Gi.z),
            (i[10] = ji.z),
            this
          );
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(t, e))
            : this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            i = e.elements,
            r = this.elements,
            o = n[0],
            s = n[4],
            a = n[8],
            l = n[12],
            c = n[1],
            u = n[5],
            h = n[9],
            d = n[13],
            p = n[2],
            f = n[6],
            m = n[10],
            g = n[14],
            v = n[3],
            y = n[7],
            x = n[11],
            b = n[15],
            w = i[0],
            _ = i[4],
            M = i[8],
            S = i[12],
            E = i[1],
            T = i[5],
            A = i[9],
            C = i[13],
            L = i[2],
            R = i[6],
            P = i[10],
            N = i[14],
            I = i[3],
            B = i[7],
            O = i[11],
            D = i[15];
          return (
            (r[0] = o * w + s * E + a * L + l * I),
            (r[4] = o * _ + s * T + a * R + l * B),
            (r[8] = o * M + s * A + a * P + l * O),
            (r[12] = o * S + s * C + a * N + l * D),
            (r[1] = c * w + u * E + h * L + d * I),
            (r[5] = c * _ + u * T + h * R + d * B),
            (r[9] = c * M + u * A + h * P + d * O),
            (r[13] = c * S + u * C + h * N + d * D),
            (r[2] = p * w + f * E + m * L + g * I),
            (r[6] = p * _ + f * T + m * R + g * B),
            (r[10] = p * M + f * A + m * P + g * O),
            (r[14] = p * S + f * C + m * N + g * D),
            (r[3] = v * w + y * E + x * L + b * I),
            (r[7] = v * _ + y * T + x * R + b * B),
            (r[11] = v * M + y * A + x * P + b * O),
            (r[15] = v * S + y * C + x * N + b * D),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[4] *= t),
            (e[8] *= t),
            (e[12] *= t),
            (e[1] *= t),
            (e[5] *= t),
            (e[9] *= t),
            (e[13] *= t),
            (e[2] *= t),
            (e[6] *= t),
            (e[10] *= t),
            (e[14] *= t),
            (e[3] *= t),
            (e[7] *= t),
            (e[11] *= t),
            (e[15] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[4],
            i = t[8],
            r = t[12],
            o = t[1],
            s = t[5],
            a = t[9],
            l = t[13],
            c = t[2],
            u = t[6],
            h = t[10],
            d = t[14];
          return (
            t[3] *
              (+r * a * u -
                i * l * u -
                r * s * h +
                n * l * h +
                i * s * d -
                n * a * d) +
            t[7] *
              (+e * a * d -
                e * l * h +
                r * o * h -
                i * o * d +
                i * l * c -
                r * a * c) +
            t[11] *
              (+e * l * u -
                e * s * d -
                r * o * u +
                n * o * d +
                r * s * c -
                n * l * c) +
            t[15] *
              (-i * s * c -
                e * a * u +
                e * s * h +
                i * o * u -
                n * o * h +
                n * a * c)
          );
        }
        transpose() {
          const t = this.elements;
          let e;
          return (
            (e = t[1]),
            (t[1] = t[4]),
            (t[4] = e),
            (e = t[2]),
            (t[2] = t[8]),
            (t[8] = e),
            (e = t[6]),
            (t[6] = t[9]),
            (t[9] = e),
            (e = t[3]),
            (t[3] = t[12]),
            (t[12] = e),
            (e = t[7]),
            (t[7] = t[13]),
            (t[13] = e),
            (e = t[11]),
            (t[11] = t[14]),
            (t[14] = e),
            this
          );
        }
        setPosition(t, e, n) {
          const i = this.elements;
          return (
            t.isVector3
              ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
              : ((i[12] = t), (i[13] = e), (i[14] = n)),
            this
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            o = t[4],
            s = t[5],
            a = t[6],
            l = t[7],
            c = t[8],
            u = t[9],
            h = t[10],
            d = t[11],
            p = t[12],
            f = t[13],
            m = t[14],
            g = t[15],
            v =
              u * m * l -
              f * h * l +
              f * a * d -
              s * m * d -
              u * a * g +
              s * h * g,
            y =
              p * h * l -
              c * m * l -
              p * a * d +
              o * m * d +
              c * a * g -
              o * h * g,
            x =
              c * f * l -
              p * u * l +
              p * s * d -
              o * f * d -
              c * s * g +
              o * u * g,
            b =
              p * u * a -
              c * f * a -
              p * s * h +
              o * f * h +
              c * s * m -
              o * u * m,
            w = e * v + n * y + i * x + r * b;
          if (0 === w)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const _ = 1 / w;
          return (
            (t[0] = v * _),
            (t[1] =
              (f * h * r -
                u * m * r -
                f * i * d +
                n * m * d +
                u * i * g -
                n * h * g) *
              _),
            (t[2] =
              (s * m * r -
                f * a * r +
                f * i * l -
                n * m * l -
                s * i * g +
                n * a * g) *
              _),
            (t[3] =
              (u * a * r -
                s * h * r -
                u * i * l +
                n * h * l +
                s * i * d -
                n * a * d) *
              _),
            (t[4] = y * _),
            (t[5] =
              (c * m * r -
                p * h * r +
                p * i * d -
                e * m * d -
                c * i * g +
                e * h * g) *
              _),
            (t[6] =
              (p * a * r -
                o * m * r -
                p * i * l +
                e * m * l +
                o * i * g -
                e * a * g) *
              _),
            (t[7] =
              (o * h * r -
                c * a * r +
                c * i * l -
                e * h * l -
                o * i * d +
                e * a * d) *
              _),
            (t[8] = x * _),
            (t[9] =
              (p * u * r -
                c * f * r -
                p * n * d +
                e * f * d +
                c * n * g -
                e * u * g) *
              _),
            (t[10] =
              (o * f * r -
                p * s * r +
                p * n * l -
                e * f * l -
                o * n * g +
                e * s * g) *
              _),
            (t[11] =
              (c * s * r -
                o * u * r -
                c * n * l +
                e * u * l +
                o * n * d -
                e * s * d) *
              _),
            (t[12] = b * _),
            (t[13] =
              (c * f * i -
                p * u * i +
                p * n * h -
                e * f * h -
                c * n * m +
                e * u * m) *
              _),
            (t[14] =
              (p * s * i -
                o * f * i -
                p * n * a +
                e * f * a +
                o * n * m -
                e * s * m) *
              _),
            (t[15] =
              (o * u * i -
                c * s * i +
                c * n * a -
                e * u * a -
                o * n * h +
                e * s * h) *
              _),
            this
          );
        }
        scale(t) {
          const e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z;
          return (
            (e[0] *= n),
            (e[4] *= i),
            (e[8] *= r),
            (e[1] *= n),
            (e[5] *= i),
            (e[9] *= r),
            (e[2] *= n),
            (e[6] *= i),
            (e[10] *= r),
            (e[3] *= n),
            (e[7] *= i),
            (e[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(e, n, i));
        }
        makeTranslation(t, e, n) {
          return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
        }
        makeRotationX(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(t, e) {
          const n = Math.cos(e),
            i = Math.sin(e),
            r = 1 - n,
            o = t.x,
            s = t.y,
            a = t.z,
            l = r * o,
            c = r * s;
          return (
            this.set(
              l * o + n,
              l * s - i * a,
              l * a + i * s,
              0,
              l * s + i * a,
              c * s + n,
              c * a - i * o,
              0,
              l * a - i * s,
              c * a + i * o,
              r * a * a + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(t, e, n) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, e, n, i, r, o) {
          return this.set(1, n, r, 0, t, 1, o, 0, e, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, e, n) {
          const i = this.elements,
            r = e._x,
            o = e._y,
            s = e._z,
            a = e._w,
            l = r + r,
            c = o + o,
            u = s + s,
            h = r * l,
            d = r * c,
            p = r * u,
            f = o * c,
            m = o * u,
            g = s * u,
            v = a * l,
            y = a * c,
            x = a * u,
            b = n.x,
            w = n.y,
            _ = n.z;
          return (
            (i[0] = (1 - (f + g)) * b),
            (i[1] = (d + x) * b),
            (i[2] = (p - y) * b),
            (i[3] = 0),
            (i[4] = (d - x) * w),
            (i[5] = (1 - (h + g)) * w),
            (i[6] = (m + v) * w),
            (i[7] = 0),
            (i[8] = (p + y) * _),
            (i[9] = (m - v) * _),
            (i[10] = (1 - (h + f)) * _),
            (i[11] = 0),
            (i[12] = t.x),
            (i[13] = t.y),
            (i[14] = t.z),
            (i[15] = 1),
            this
          );
        }
        decompose(t, e, n) {
          const i = this.elements;
          let r = Fi.set(i[0], i[1], i[2]).length();
          const o = Fi.set(i[4], i[5], i[6]).length(),
            s = Fi.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (t.x = i[12]),
            (t.y = i[13]),
            (t.z = i[14]),
            zi.copy(this);
          const a = 1 / r,
            l = 1 / o,
            c = 1 / s;
          return (
            (zi.elements[0] *= a),
            (zi.elements[1] *= a),
            (zi.elements[2] *= a),
            (zi.elements[4] *= l),
            (zi.elements[5] *= l),
            (zi.elements[6] *= l),
            (zi.elements[8] *= c),
            (zi.elements[9] *= c),
            (zi.elements[10] *= c),
            e.setFromRotationMatrix(zi),
            (n.x = r),
            (n.y = o),
            (n.z = s),
            this
          );
        }
        makePerspective(t, e, n, i, r, o) {
          void 0 === o &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          const s = this.elements,
            a = (2 * r) / (e - t),
            l = (2 * r) / (n - i),
            c = (e + t) / (e - t),
            u = (n + i) / (n - i),
            h = -(o + r) / (o - r),
            d = (-2 * o * r) / (o - r);
          return (
            (s[0] = a),
            (s[4] = 0),
            (s[8] = c),
            (s[12] = 0),
            (s[1] = 0),
            (s[5] = l),
            (s[9] = u),
            (s[13] = 0),
            (s[2] = 0),
            (s[6] = 0),
            (s[10] = h),
            (s[14] = d),
            (s[3] = 0),
            (s[7] = 0),
            (s[11] = -1),
            (s[15] = 0),
            this
          );
        }
        makeOrthographic(t, e, n, i, r, o) {
          const s = this.elements,
            a = 1 / (e - t),
            l = 1 / (n - i),
            c = 1 / (o - r),
            u = (e + t) * a,
            h = (n + i) * l,
            d = (o + r) * c;
          return (
            (s[0] = 2 * a),
            (s[4] = 0),
            (s[8] = 0),
            (s[12] = -u),
            (s[1] = 0),
            (s[5] = 2 * l),
            (s[9] = 0),
            (s[13] = -h),
            (s[2] = 0),
            (s[6] = 0),
            (s[10] = -2 * c),
            (s[14] = -d),
            (s[3] = 0),
            (s[7] = 0),
            (s[11] = 0),
            (s[15] = 1),
            this
          );
        }
        equals(t) {
          const e = this.elements,
            n = t.elements;
          for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            (t[e + 9] = n[9]),
            (t[e + 10] = n[10]),
            (t[e + 11] = n[11]),
            (t[e + 12] = n[12]),
            (t[e + 13] = n[13]),
            (t[e + 14] = n[14]),
            (t[e + 15] = n[15]),
            t
          );
        }
      }
      ki.prototype.isMatrix4 = !0;
      const Fi = new si(),
        zi = new ki(),
        Hi = new si(0, 0, 0),
        Ui = new si(1, 1, 1),
        Vi = new si(),
        Gi = new si(),
        ji = new si(),
        Wi = new ki(),
        qi = new oi();
      class Xi {
        constructor(t = 0, e = 0, n = 0, i = Xi.DefaultOrder) {
          (this._x = t), (this._y = e), (this._z = n), (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t) {
          (this._order = t), this._onChangeCallback();
        }
        set(t, e, n, i = this._order) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t, e = this._order, n = !0) {
          const i = t.elements,
            r = i[0],
            o = i[4],
            s = i[8],
            a = i[1],
            l = i[5],
            c = i[9],
            u = i[2],
            h = i[6],
            d = i[10];
          switch (e) {
            case "XYZ":
              (this._y = Math.asin(Un(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(-c, d)),
                    (this._z = Math.atan2(-o, r)))
                  : ((this._x = Math.atan2(h, l)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-Un(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._y = Math.atan2(s, d)), (this._z = Math.atan2(a, l)))
                  : ((this._y = Math.atan2(-u, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(Un(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-o, l)))
                  : ((this._y = 0), (this._z = Math.atan2(a, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-Un(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(a, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-o, l)));
              break;
            case "YZX":
              (this._z = Math.asin(Un(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-c, l)),
                    (this._y = Math.atan2(-u, r)))
                  : ((this._x = 0), (this._y = Math.atan2(s, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-Un(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(s, r)))
                  : ((this._x = Math.atan2(-c, d)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  e
              );
          }
          return (this._order = e), !0 === n && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, e, n) {
          return (
            Wi.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(Wi, e, n)
          );
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e);
        }
        reorder(t) {
          return qi.setFromEuler(this), this.setFromQuaternion(qi, t);
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        }
        fromArray(t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        }
        toVector3(t) {
          return t
            ? t.set(this._x, this._y, this._z)
            : new si(this._x, this._y, this._z);
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
      }
      (Xi.prototype.isEuler = !0),
        (Xi.DefaultOrder = "XYZ"),
        (Xi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
      class Yi {
        constructor() {
          this.mask = 1;
        }
        set(t) {
          this.mask = (1 << t) | 0;
        }
        enable(t) {
          this.mask |= (1 << t) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t) {
          this.mask ^= (1 << t) | 0;
        }
        disable(t) {
          this.mask &= ~((1 << t) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t) {
          return 0 != (this.mask & t.mask);
        }
      }
      let Zi = 0;
      const Ji = new si(),
        Ki = new oi(),
        Qi = new ki(),
        $i = new si(),
        tr = new si(),
        er = new si(),
        nr = new oi(),
        ir = new si(1, 0, 0),
        rr = new si(0, 1, 0),
        or = new si(0, 0, 1),
        sr = { type: "added" },
        ar = { type: "removed" };
      class lr extends On {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: Zi++ }),
            (this.uuid = Hn()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = lr.DefaultUp.clone());
          const t = new si(),
            e = new Xi(),
            n = new oi(),
            i = new si(1, 1, 1);
          e._onChange(function () {
            n.setFromEuler(e, !1);
          }),
            n._onChange(function () {
              e.setFromQuaternion(n, void 0, !1);
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: t },
              rotation: { configurable: !0, enumerable: !0, value: e },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new ki() },
              normalMatrix: { value: new Zn() },
            }),
            (this.matrix = new ki()),
            (this.matrixWorld = new ki()),
            (this.matrixAutoUpdate = lr.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Yi()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, !0);
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t);
        }
        rotateOnAxis(t, e) {
          return Ki.setFromAxisAngle(t, e), this.quaternion.multiply(Ki), this;
        }
        rotateOnWorldAxis(t, e) {
          return (
            Ki.setFromAxisAngle(t, e), this.quaternion.premultiply(Ki), this
          );
        }
        rotateX(t) {
          return this.rotateOnAxis(ir, t);
        }
        rotateY(t) {
          return this.rotateOnAxis(rr, t);
        }
        rotateZ(t) {
          return this.rotateOnAxis(or, t);
        }
        translateOnAxis(t, e) {
          return (
            Ji.copy(t).applyQuaternion(this.quaternion),
            this.position.add(Ji.multiplyScalar(e)),
            this
          );
        }
        translateX(t) {
          return this.translateOnAxis(ir, t);
        }
        translateY(t) {
          return this.translateOnAxis(rr, t);
        }
        translateZ(t) {
          return this.translateOnAxis(or, t);
        }
        localToWorld(t) {
          return t.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(t) {
          return t.applyMatrix4(Qi.copy(this.matrixWorld).invert());
        }
        lookAt(t, e, n) {
          t.isVector3 ? $i.copy(t) : $i.set(t, e, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            tr.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? Qi.lookAt(tr, $i, this.up)
              : Qi.lookAt($i, tr, this.up),
            this.quaternion.setFromRotationMatrix(Qi),
            i &&
              (Qi.extractRotation(i.matrixWorld),
              Ki.setFromRotationMatrix(Qi),
              this.quaternion.premultiply(Ki.invert()));
        }
        add(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(sr))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t
                  ),
              this);
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
              this.remove(arguments[t]);
            return this;
          }
          const e = this.children.indexOf(t);
          return (
            -1 !== e &&
              ((t.parent = null),
              this.children.splice(e, 1),
              t.dispatchEvent(ar)),
            this
          );
        }
        removeFromParent() {
          const t = this.parent;
          return null !== t && t.remove(this), this;
        }
        clear() {
          for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t];
            (e.parent = null), e.dispatchEvent(ar);
          }
          return (this.children.length = 0), this;
        }
        attach(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            Qi.copy(this.matrixWorld).invert(),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              Qi.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(Qi),
            this.add(t),
            t.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(t) {
          return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
          return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n].getObjectByProperty(t, e);
            if (void 0 !== i) return i;
          }
        }
        getWorldPosition(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(tr, t, er),
            t
          );
        }
        getWorldScale(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(tr, nr, t),
            t
          );
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1);
          const e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {}
        traverse(t) {
          t(this);
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
        }
        traverseVisible(t) {
          if (!1 === this.visible) return;
          t(this);
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
        }
        traverseAncestors(t) {
          const e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
        }
        updateWorldMatrix(t, e) {
          const n = this.parent;
          if (
            (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            !0 === e)
          ) {
            const t = this.children;
            for (let e = 0, n = t.length; e < n; e++)
              t[e].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t,
            n = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          function r(e, n) {
            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor &&
                (i.instanceColor = this.instanceColor.toJSON())),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(t).uuid)),
              this.environment &&
                this.environment.isTexture &&
                (i.environment = this.environment.toJSON(t).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(t.geometries, this.geometry);
            const e = this.geometry.parameters;
            if (void 0 !== e && void 0 !== e.shapes) {
              const n = e.shapes;
              if (Array.isArray(n))
                for (let e = 0, i = n.length; e < i; e++) {
                  const i = n[e];
                  r(t.shapes, i);
                }
              else r(t.shapes, n);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton &&
                (r(t.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              const e = [];
              for (let n = 0, i = this.material.length; n < i; n++)
                e.push(r(t.materials, this.material[n]));
              i.material = e;
            } else i.material = r(t.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let e = 0; e < this.children.length; e++)
              i.children.push(this.children[e].toJSON(t).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let e = 0; e < this.animations.length; e++) {
              const n = this.animations[e];
              i.animations.push(r(t.animations, n));
            }
          }
          if (e) {
            const e = o(t.geometries),
              i = o(t.materials),
              r = o(t.textures),
              s = o(t.images),
              a = o(t.shapes),
              l = o(t.skeletons),
              c = o(t.animations);
            e.length > 0 && (n.geometries = e),
              i.length > 0 && (n.materials = i),
              r.length > 0 && (n.textures = r),
              s.length > 0 && (n.images = s),
              a.length > 0 && (n.shapes = a),
              l.length > 0 && (n.skeletons = l),
              c.length > 0 && (n.animations = c);
          }
          return (n.object = i), n;
          function o(t) {
            const e = [];
            for (const n in t) {
              const i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t);
        }
        copy(t, e = !0) {
          if (
            ((this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            (this.rotation.order = t.rotation.order),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (let e = 0; e < t.children.length; e++) {
              const n = t.children[e];
              this.add(n.clone());
            }
          return this;
        }
      }
      (lr.DefaultUp = new si(0, 1, 0)),
        (lr.DefaultMatrixAutoUpdate = !0),
        (lr.prototype.isObject3D = !0);
      const cr = new si(),
        ur = new si(),
        hr = new si(),
        dr = new si(),
        pr = new si(),
        fr = new si(),
        mr = new si(),
        gr = new si(),
        vr = new si(),
        yr = new si();
      class xr {
        constructor(t = new si(), e = new si(), n = new si()) {
          (this.a = t), (this.b = e), (this.c = n);
        }
        static getNormal(t, e, n, i) {
          i.subVectors(n, e), cr.subVectors(t, e), i.cross(cr);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(t, e, n, i, r) {
          cr.subVectors(i, e), ur.subVectors(n, e), hr.subVectors(t, e);
          const o = cr.dot(cr),
            s = cr.dot(ur),
            a = cr.dot(hr),
            l = ur.dot(ur),
            c = ur.dot(hr),
            u = o * l - s * s;
          if (0 === u) return r.set(-2, -1, -1);
          const h = 1 / u,
            d = (l * a - s * c) * h,
            p = (o * c - s * a) * h;
          return r.set(1 - d - p, p, d);
        }
        static containsPoint(t, e, n, i) {
          return (
            this.getBarycoord(t, e, n, i, dr),
            dr.x >= 0 && dr.y >= 0 && dr.x + dr.y <= 1
          );
        }
        static getUV(t, e, n, i, r, o, s, a) {
          return (
            this.getBarycoord(t, e, n, i, dr),
            a.set(0, 0),
            a.addScaledVector(r, dr.x),
            a.addScaledVector(o, dr.y),
            a.addScaledVector(s, dr.z),
            a
          );
        }
        static isFrontFacing(t, e, n, i) {
          return (
            cr.subVectors(n, e), ur.subVectors(t, e), cr.cross(ur).dot(i) < 0
          );
        }
        set(t, e, n) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
        }
        setFromPointsAndIndices(t, e, n, i) {
          return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
          return (
            cr.subVectors(this.c, this.b),
            ur.subVectors(this.a, this.b),
            0.5 * cr.cross(ur).length()
          );
        }
        getMidpoint(t) {
          return t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(t) {
          return xr.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, e) {
          return xr.getBarycoord(t, this.a, this.b, this.c, e);
        }
        getUV(t, e, n, i, r) {
          return xr.getUV(t, this.a, this.b, this.c, e, n, i, r);
        }
        containsPoint(t) {
          return xr.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
          return xr.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, e) {
          const n = this.a,
            i = this.b,
            r = this.c;
          let o, s;
          pr.subVectors(i, n), fr.subVectors(r, n), gr.subVectors(t, n);
          const a = pr.dot(gr),
            l = fr.dot(gr);
          if (a <= 0 && l <= 0) return e.copy(n);
          vr.subVectors(t, i);
          const c = pr.dot(vr),
            u = fr.dot(vr);
          if (c >= 0 && u <= c) return e.copy(i);
          const h = a * u - c * l;
          if (h <= 0 && a >= 0 && c <= 0)
            return (o = a / (a - c)), e.copy(n).addScaledVector(pr, o);
          yr.subVectors(t, r);
          const d = pr.dot(yr),
            p = fr.dot(yr);
          if (p >= 0 && d <= p) return e.copy(r);
          const f = d * l - a * p;
          if (f <= 0 && l >= 0 && p <= 0)
            return (s = l / (l - p)), e.copy(n).addScaledVector(fr, s);
          const m = c * p - d * u;
          if (m <= 0 && u - c >= 0 && d - p >= 0)
            return (
              mr.subVectors(r, i),
              (s = (u - c) / (u - c + (d - p))),
              e.copy(i).addScaledVector(mr, s)
            );
          const g = 1 / (m + f + h);
          return (
            (o = f * g),
            (s = h * g),
            e.copy(n).addScaledVector(pr, o).addScaledVector(fr, s)
          );
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      }
      let br = 0;
      class wr extends On {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: br++ }),
            (this.uuid = Hn()),
            (this.name = ""),
            (this.type = "Material"),
            (this.fog = !0),
            (this.blending = x),
            (this.side = p),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = I),
            (this.blendDst = B),
            (this.blendEquation = S),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = G),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = Mn),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = cn),
            (this.stencilZFail = cn),
            (this.stencilZPass = cn),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaTest = 0),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0);
        }
        onBuild() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t) {
          if (void 0 !== t)
            for (const e in t) {
              const n = t[e];
              if (void 0 === n) {
                console.warn(
                  "THREE.Material: '" + e + "' parameter is undefined."
                );
                continue;
              }
              if ("shading" === e) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = n === g);
                continue;
              }
              const i = this[e];
              void 0 !== i
                ? i && i.isColor
                  ? i.set(n)
                  : i && i.isVector3 && n && n.isVector3
                  ? i.copy(n)
                  : (this[e] = n)
                : console.warn(
                    "THREE." +
                      this.type +
                      ": '" +
                      e +
                      "' is not a property of this material."
                  );
            }
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t;
          e && (t = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function i(t) {
            const e = [];
            for (const n in t) {
              const i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (n.specularIntensity = this.specularIntensity),
            this.specularTint &&
              this.specularTint.isColor &&
              (n.specularTint = this.specularTint.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(t).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(t).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(t).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(t).uuid),
            this.specularTintMap &&
              this.specularTintMap.isTexture &&
              (n.specularTintMap = this.specularTintMap.toJSON(t).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(t).uuid),
              void 0 !== this.combine && (n.combine = this.combine)),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (n.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.transmission &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
            void 0 !== this.thickness && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
            void 0 !== this.attenuationDistance &&
              (n.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationTint &&
              (n.attenuationTint = this.attenuationTint.getHex()),
            void 0 !== this.size && (n.size = this.size),
            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== x && (n.blending = this.blending),
            this.side !== p && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation &&
              0 !== this.rotation &&
              (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth &&
              1 !== this.linewidth &&
              (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage &&
              (n.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            e)
          ) {
            const e = i(t.textures),
              r = i(t.images);
            e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.name = t.name),
            (this.fog = t.fog),
            (this.blending = t.blending),
            (this.side = t.side),
            (this.vertexColors = t.vertexColors),
            (this.opacity = t.opacity),
            (this.transparent = t.transparent),
            (this.blendSrc = t.blendSrc),
            (this.blendDst = t.blendDst),
            (this.blendEquation = t.blendEquation),
            (this.blendSrcAlpha = t.blendSrcAlpha),
            (this.blendDstAlpha = t.blendDstAlpha),
            (this.blendEquationAlpha = t.blendEquationAlpha),
            (this.depthFunc = t.depthFunc),
            (this.depthTest = t.depthTest),
            (this.depthWrite = t.depthWrite),
            (this.stencilWriteMask = t.stencilWriteMask),
            (this.stencilFunc = t.stencilFunc),
            (this.stencilRef = t.stencilRef),
            (this.stencilFuncMask = t.stencilFuncMask),
            (this.stencilFail = t.stencilFail),
            (this.stencilZFail = t.stencilZFail),
            (this.stencilZPass = t.stencilZPass),
            (this.stencilWrite = t.stencilWrite);
          const e = t.clippingPlanes;
          let n = null;
          if (null !== e) {
            const t = e.length;
            n = new Array(t);
            for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = t.clipIntersection),
            (this.clipShadows = t.clipShadows),
            (this.shadowSide = t.shadowSide),
            (this.colorWrite = t.colorWrite),
            (this.precision = t.precision),
            (this.polygonOffset = t.polygonOffset),
            (this.polygonOffsetFactor = t.polygonOffsetFactor),
            (this.polygonOffsetUnits = t.polygonOffsetUnits),
            (this.dithering = t.dithering),
            (this.alphaTest = t.alphaTest),
            (this.alphaToCoverage = t.alphaToCoverage),
            (this.premultipliedAlpha = t.premultipliedAlpha),
            (this.visible = t.visible),
            (this.toneMapped = t.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
      }
      wr.prototype.isMaterial = !0;
      const _r = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        Mr = { h: 0, s: 0, l: 0 },
        Sr = { h: 0, s: 0, l: 0 };
      function Er(t, e, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? t + 6 * (e - t) * n
            : n < 0.5
            ? e
            : n < 2 / 3
            ? t + 6 * (e - t) * (2 / 3 - n)
            : t
        );
      }
      function Tr(t) {
        return t < 0.04045
          ? 0.0773993808 * t
          : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
      }
      function Ar(t) {
        return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
      }
      class Cr {
        constructor(t, e, n) {
          return void 0 === e && void 0 === n
            ? this.set(t)
            : this.setRGB(t, e, n);
        }
        set(t) {
          return (
            t && t.isColor
              ? this.copy(t)
              : "number" == typeof t
              ? this.setHex(t)
              : "string" == typeof t && this.setStyle(t),
            this
          );
        }
        setScalar(t) {
          return (this.r = t), (this.g = t), (this.b = t), this;
        }
        setHex(t) {
          return (
            (t = Math.floor(t)),
            (this.r = ((t >> 16) & 255) / 255),
            (this.g = ((t >> 8) & 255) / 255),
            (this.b = (255 & t) / 255),
            this
          );
        }
        setRGB(t, e, n) {
          return (this.r = t), (this.g = e), (this.b = n), this;
        }
        setHSL(t, e, n) {
          if (((t = Vn(t, 1)), (e = Un(e, 0, 1)), (n = Un(n, 0, 1)), 0 === e))
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
              r = 2 * n - i;
            (this.r = Er(r, i, t + 1 / 3)),
              (this.g = Er(r, i, t)),
              (this.b = Er(r, i, t - 1 / 3));
          }
          return this;
        }
        setStyle(t) {
          function e(e) {
            void 0 !== e &&
              parseFloat(e) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + t + " will be ignored."
              );
          }
          let n;
          if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
            let t;
            const i = n[1],
              r = n[2];
            switch (i) {
              case "rgb":
              case "rgba":
                if (
                  (t =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                    e(t[4]),
                    this
                  );
                if (
                  (t =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                    e(t[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (t =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      r
                    ))
                ) {
                  const n = parseFloat(t[1]) / 360,
                    i = parseInt(t[2], 10) / 100,
                    r = parseInt(t[3], 10) / 100;
                  return e(t[4]), this.setHSL(n, i, r);
                }
            }
          } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
            const t = n[1],
              e = t.length;
            if (3 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                this
              );
            if (6 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                this
              );
          }
          return t && t.length > 0 ? this.setColorName(t) : this;
        }
        setColorName(t) {
          const e = _r[t.toLowerCase()];
          return (
            void 0 !== e
              ? this.setHex(e)
              : console.warn("THREE.Color: Unknown color " + t),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
          return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
        }
        copyGammaToLinear(t, e = 2) {
          return (
            (this.r = Math.pow(t.r, e)),
            (this.g = Math.pow(t.g, e)),
            (this.b = Math.pow(t.b, e)),
            this
          );
        }
        copyLinearToGamma(t, e = 2) {
          const n = e > 0 ? 1 / e : 1;
          return (
            (this.r = Math.pow(t.r, n)),
            (this.g = Math.pow(t.g, n)),
            (this.b = Math.pow(t.b, n)),
            this
          );
        }
        convertGammaToLinear(t) {
          return this.copyGammaToLinear(this, t), this;
        }
        convertLinearToGamma(t) {
          return this.copyLinearToGamma(this, t), this;
        }
        copySRGBToLinear(t) {
          return (
            (this.r = Tr(t.r)), (this.g = Tr(t.g)), (this.b = Tr(t.b)), this
          );
        }
        copyLinearToSRGB(t) {
          return (
            (this.r = Ar(t.r)), (this.g = Ar(t.g)), (this.b = Ar(t.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return (
            ((255 * this.r) << 16) ^
            ((255 * this.g) << 8) ^
            ((255 * this.b) << 0)
          );
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(t) {
          const e = this.r,
            n = this.g,
            i = this.b,
            r = Math.max(e, n, i),
            o = Math.min(e, n, i);
          let s, a;
          const l = (o + r) / 2;
          if (o === r) (s = 0), (a = 0);
          else {
            const t = r - o;
            switch (((a = l <= 0.5 ? t / (r + o) : t / (2 - r - o)), r)) {
              case e:
                s = (n - i) / t + (n < i ? 6 : 0);
                break;
              case n:
                s = (i - e) / t + 2;
                break;
              case i:
                s = (e - n) / t + 4;
            }
            s /= 6;
          }
          return (t.h = s), (t.s = a), (t.l = l), t;
        }
        getStyle() {
          return (
            "rgb(" +
            ((255 * this.r) | 0) +
            "," +
            ((255 * this.g) | 0) +
            "," +
            ((255 * this.b) | 0) +
            ")"
          );
        }
        offsetHSL(t, e, n) {
          return (
            this.getHSL(Mr),
            (Mr.h += t),
            (Mr.s += e),
            (Mr.l += n),
            this.setHSL(Mr.h, Mr.s, Mr.l),
            this
          );
        }
        add(t) {
          return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
        }
        addColors(t, e) {
          return (
            (this.r = t.r + e.r),
            (this.g = t.g + e.g),
            (this.b = t.b + e.b),
            this
          );
        }
        addScalar(t) {
          return (this.r += t), (this.g += t), (this.b += t), this;
        }
        sub(t) {
          return (
            (this.r = Math.max(0, this.r - t.r)),
            (this.g = Math.max(0, this.g - t.g)),
            (this.b = Math.max(0, this.b - t.b)),
            this
          );
        }
        multiply(t) {
          return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
        }
        multiplyScalar(t) {
          return (this.r *= t), (this.g *= t), (this.b *= t), this;
        }
        lerp(t, e) {
          return (
            (this.r += (t.r - this.r) * e),
            (this.g += (t.g - this.g) * e),
            (this.b += (t.b - this.b) * e),
            this
          );
        }
        lerpColors(t, e, n) {
          return (
            (this.r = t.r + (e.r - t.r) * n),
            (this.g = t.g + (e.g - t.g) * n),
            (this.b = t.b + (e.b - t.b) * n),
            this
          );
        }
        lerpHSL(t, e) {
          this.getHSL(Mr), t.getHSL(Sr);
          const n = Gn(Mr.h, Sr.h, e),
            i = Gn(Mr.s, Sr.s, e),
            r = Gn(Mr.l, Sr.l, e);
          return this.setHSL(n, i, r), this;
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, e = 0) {
          return (
            (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
        }
        fromBufferAttribute(t, e) {
          return (
            (this.r = t.getX(e)),
            (this.g = t.getY(e)),
            (this.b = t.getZ(e)),
            !0 === t.normalized &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
      }
      (Cr.NAMES = _r),
        (Cr.prototype.isColor = !0),
        (Cr.prototype.r = 1),
        (Cr.prototype.g = 1),
        (Cr.prototype.b = 1);
      class Lr extends wr {
        constructor(t) {
          super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new Cr(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Y),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          );
        }
      }
      Lr.prototype.isMeshBasicMaterial = !0;
      const Rr = new si(),
        Pr = new Yn();
      class Nr {
        constructor(t, e, n) {
          if (Array.isArray(t))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.name = ""),
            (this.array = t),
            (this.itemSize = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.normalized = !0 === n),
            (this.usage = Sn),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            this
          );
        }
        copyAt(t, e, n) {
          (t *= this.itemSize), (n *= e.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        }
        copyArray(t) {
          return this.array.set(t), this;
        }
        copyColorsArray(t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (r = new Cr())),
              (e[n++] = r.r),
              (e[n++] = r.g),
              (e[n++] = r.b);
          }
          return this;
        }
        copyVector2sArray(t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                i
              ),
              (r = new Yn())),
              (e[n++] = r.x),
              (e[n++] = r.y);
          }
          return this;
        }
        copyVector3sArray(t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (r = new si())),
              (e[n++] = r.x),
              (e[n++] = r.y),
              (e[n++] = r.z);
          }
          return this;
        }
        copyVector4sArray(t) {
          const e = this.array;
          let n = 0;
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i];
            void 0 === r &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (r = new ei())),
              (e[n++] = r.x),
              (e[n++] = r.y),
              (e[n++] = r.z),
              (e[n++] = r.w);
          }
          return this;
        }
        applyMatrix3(t) {
          if (2 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              Pr.fromBufferAttribute(this, e),
                Pr.applyMatrix3(t),
                this.setXY(e, Pr.x, Pr.y);
          else if (3 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              Rr.fromBufferAttribute(this, e),
                Rr.applyMatrix3(t),
                this.setXYZ(e, Rr.x, Rr.y, Rr.z);
          return this;
        }
        applyMatrix4(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Rr.x = this.getX(e)),
              (Rr.y = this.getY(e)),
              (Rr.z = this.getZ(e)),
              Rr.applyMatrix4(t),
              this.setXYZ(e, Rr.x, Rr.y, Rr.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Rr.x = this.getX(e)),
              (Rr.y = this.getY(e)),
              (Rr.z = this.getZ(e)),
              Rr.applyNormalMatrix(t),
              this.setXYZ(e, Rr.x, Rr.y, Rr.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Rr.x = this.getX(e)),
              (Rr.y = this.getY(e)),
              (Rr.z = this.getZ(e)),
              Rr.transformDirection(t),
              this.setXYZ(e, Rr.x, Rr.y, Rr.z);
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        getX(t) {
          return this.array[t * this.itemSize];
        }
        setX(t, e) {
          return (this.array[t * this.itemSize] = e), this;
        }
        getY(t) {
          return this.array[t * this.itemSize + 1];
        }
        setY(t, e) {
          return (this.array[t * this.itemSize + 1] = e), this;
        }
        getZ(t) {
          return this.array[t * this.itemSize + 2];
        }
        setZ(t, e) {
          return (this.array[t * this.itemSize + 2] = e), this;
        }
        getW(t) {
          return this.array[t * this.itemSize + 3];
        }
        setW(t, e) {
          return (this.array[t * this.itemSize + 3] = e), this;
        }
        setXY(t, e, n) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            this
          );
        }
        setXYZ(t, e, n, i) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            this
          );
        }
        setXYZW(t, e, n, i, r) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            (this.array[t + 3] = r),
            this
          );
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (t.name = this.name),
            this.usage !== Sn && (t.usage = this.usage),
            (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
              (t.updateRange = this.updateRange),
            t
          );
        }
      }
      Nr.prototype.isBufferAttribute = !0;
      class Ir extends Nr {
        constructor(t, e, n) {
          super(new Int8Array(t), e, n);
        }
      }
      class Br extends Nr {
        constructor(t, e, n) {
          super(new Uint8Array(t), e, n);
        }
      }
      class Or extends Nr {
        constructor(t, e, n) {
          super(new Uint8ClampedArray(t), e, n);
        }
      }
      class Dr extends Nr {
        constructor(t, e, n) {
          super(new Int16Array(t), e, n);
        }
      }
      class kr extends Nr {
        constructor(t, e, n) {
          super(new Uint16Array(t), e, n);
        }
      }
      class Fr extends Nr {
        constructor(t, e, n) {
          super(new Int32Array(t), e, n);
        }
      }
      class zr extends Nr {
        constructor(t, e, n) {
          super(new Uint32Array(t), e, n);
        }
      }
      class Hr extends Nr {
        constructor(t, e, n) {
          super(new Uint16Array(t), e, n);
        }
      }
      Hr.prototype.isFloat16BufferAttribute = !0;
      class Ur extends Nr {
        constructor(t, e, n) {
          super(new Float32Array(t), e, n);
        }
      }
      class Vr extends Nr {
        constructor(t, e, n) {
          super(new Float64Array(t), e, n);
        }
      }
      function Gr(t) {
        if (0 === t.length) return -1 / 0;
        let e = t[0];
        for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
        return e;
      }
      const jr = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      };
      function Wr(t, e) {
        return new jr[t](e);
      }
      let qr = 0;
      const Xr = new ki(),
        Yr = new lr(),
        Zr = new si(),
        Jr = new ci(),
        Kr = new ci(),
        Qr = new si();
      class $r extends On {
        constructor() {
          super(),
            Object.defineProperty(this, "id", { value: qr++ }),
            (this.uuid = Hn()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(t) {
          return (
            Array.isArray(t)
              ? (this.index = new (Gr(t) > 65535 ? zr : kr)(t, 1))
              : (this.index = t),
            this
          );
        }
        getAttribute(t) {
          return this.attributes[t];
        }
        setAttribute(t, e) {
          return (this.attributes[t] = e), this;
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this;
        }
        hasAttribute(t) {
          return void 0 !== this.attributes[t];
        }
        addGroup(t, e, n = 0) {
          this.groups.push({ start: t, count: e, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t, e) {
          (this.drawRange.start = t), (this.drawRange.count = e);
        }
        applyMatrix4(t) {
          const e = this.attributes.position;
          void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
          const n = this.attributes.normal;
          if (void 0 !== n) {
            const e = new Zn().getNormalMatrix(t);
            n.applyNormalMatrix(e), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(t) {
          return Xr.makeRotationFromQuaternion(t), this.applyMatrix4(Xr), this;
        }
        rotateX(t) {
          return Xr.makeRotationX(t), this.applyMatrix4(Xr), this;
        }
        rotateY(t) {
          return Xr.makeRotationY(t), this.applyMatrix4(Xr), this;
        }
        rotateZ(t) {
          return Xr.makeRotationZ(t), this.applyMatrix4(Xr), this;
        }
        translate(t, e, n) {
          return Xr.makeTranslation(t, e, n), this.applyMatrix4(Xr), this;
        }
        scale(t, e, n) {
          return Xr.makeScale(t, e, n), this.applyMatrix4(Xr), this;
        }
        lookAt(t) {
          return (
            Yr.lookAt(t), Yr.updateMatrix(), this.applyMatrix4(Yr.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Zr).negate(),
            this.translate(Zr.x, Zr.y, Zr.z),
            this
          );
        }
        setFromPoints(t) {
          const e = [];
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            e.push(i.x, i.y, i.z || 0);
          }
          return this.setAttribute("position", new Ur(e, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new ci());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingBox.set(
                new si(-1 / 0, -1 / 0, -1 / 0),
                new si(1 / 0, 1 / 0, 1 / 0)
              )
            );
          if (void 0 !== t) {
            if ((this.boundingBox.setFromBufferAttribute(t), e))
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                Jr.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (Qr.addVectors(this.boundingBox.min, Jr.min),
                      this.boundingBox.expandByPoint(Qr),
                      Qr.addVectors(this.boundingBox.max, Jr.max),
                      this.boundingBox.expandByPoint(Qr))
                    : (this.boundingBox.expandByPoint(Jr.min),
                      this.boundingBox.expandByPoint(Jr.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Ci());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingSphere.set(new si(), 1 / 0)
            );
          if (t) {
            const n = this.boundingSphere.center;
            if ((Jr.setFromBufferAttribute(t), e))
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                Kr.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (Qr.addVectors(Jr.min, Kr.min),
                      Jr.expandByPoint(Qr),
                      Qr.addVectors(Jr.max, Kr.max),
                      Jr.expandByPoint(Qr))
                    : (Jr.expandByPoint(Kr.min), Jr.expandByPoint(Kr.max));
              }
            Jr.getCenter(n);
            let i = 0;
            for (let e = 0, r = t.count; e < r; e++)
              Qr.fromBufferAttribute(t, e),
                (i = Math.max(i, n.distanceToSquared(Qr)));
            if (e)
              for (let r = 0, o = e.length; r < o; r++) {
                const o = e[r],
                  s = this.morphTargetsRelative;
                for (let e = 0, r = o.count; e < r; e++)
                  Qr.fromBufferAttribute(o, e),
                    s && (Zr.fromBufferAttribute(t, e), Qr.add(Zr)),
                    (i = Math.max(i, n.distanceToSquared(Qr)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeFaceNormals() {}
        computeTangents() {
          const t = this.index,
            e = this.attributes;
          if (
            null === t ||
            void 0 === e.position ||
            void 0 === e.normal ||
            void 0 === e.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
          const n = t.array,
            i = e.position.array,
            r = e.normal.array,
            o = e.uv.array,
            s = i.length / 3;
          void 0 === e.tangent &&
            this.setAttribute("tangent", new Nr(new Float32Array(4 * s), 4));
          const a = e.tangent.array,
            l = [],
            c = [];
          for (let t = 0; t < s; t++) (l[t] = new si()), (c[t] = new si());
          const u = new si(),
            h = new si(),
            d = new si(),
            p = new Yn(),
            f = new Yn(),
            m = new Yn(),
            g = new si(),
            v = new si();
          function y(t, e, n) {
            u.fromArray(i, 3 * t),
              h.fromArray(i, 3 * e),
              d.fromArray(i, 3 * n),
              p.fromArray(o, 2 * t),
              f.fromArray(o, 2 * e),
              m.fromArray(o, 2 * n),
              h.sub(u),
              d.sub(u),
              f.sub(p),
              m.sub(p);
            const r = 1 / (f.x * m.y - m.x * f.y);
            isFinite(r) &&
              (g
                .copy(h)
                .multiplyScalar(m.y)
                .addScaledVector(d, -f.y)
                .multiplyScalar(r),
              v
                .copy(d)
                .multiplyScalar(f.x)
                .addScaledVector(h, -m.x)
                .multiplyScalar(r),
              l[t].add(g),
              l[e].add(g),
              l[n].add(g),
              c[t].add(v),
              c[e].add(v),
              c[n].add(v));
          }
          let x = this.groups;
          0 === x.length && (x = [{ start: 0, count: n.length }]);
          for (let t = 0, e = x.length; t < e; ++t) {
            const e = x[t],
              i = e.start;
            for (let t = i, r = i + e.count; t < r; t += 3)
              y(n[t + 0], n[t + 1], n[t + 2]);
          }
          const b = new si(),
            w = new si(),
            _ = new si(),
            M = new si();
          function S(t) {
            _.fromArray(r, 3 * t), M.copy(_);
            const e = l[t];
            b.copy(e),
              b.sub(_.multiplyScalar(_.dot(e))).normalize(),
              w.crossVectors(M, e);
            const n = w.dot(c[t]) < 0 ? -1 : 1;
            (a[4 * t] = b.x),
              (a[4 * t + 1] = b.y),
              (a[4 * t + 2] = b.z),
              (a[4 * t + 3] = n);
          }
          for (let t = 0, e = x.length; t < e; ++t) {
            const e = x[t],
              i = e.start;
            for (let t = i, r = i + e.count; t < r; t += 3)
              S(n[t + 0]), S(n[t + 1]), S(n[t + 2]);
          }
        }
        computeVertexNormals() {
          const t = this.index,
            e = this.getAttribute("position");
          if (void 0 !== e) {
            let n = this.getAttribute("normal");
            if (void 0 === n)
              (n = new Nr(new Float32Array(3 * e.count), 3)),
                this.setAttribute("normal", n);
            else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
            const i = new si(),
              r = new si(),
              o = new si(),
              s = new si(),
              a = new si(),
              l = new si(),
              c = new si(),
              u = new si();
            if (t)
              for (let h = 0, d = t.count; h < d; h += 3) {
                const d = t.getX(h + 0),
                  p = t.getX(h + 1),
                  f = t.getX(h + 2);
                i.fromBufferAttribute(e, d),
                  r.fromBufferAttribute(e, p),
                  o.fromBufferAttribute(e, f),
                  c.subVectors(o, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  s.fromBufferAttribute(n, d),
                  a.fromBufferAttribute(n, p),
                  l.fromBufferAttribute(n, f),
                  s.add(c),
                  a.add(c),
                  l.add(c),
                  n.setXYZ(d, s.x, s.y, s.z),
                  n.setXYZ(p, a.x, a.y, a.z),
                  n.setXYZ(f, l.x, l.y, l.z);
              }
            else
              for (let t = 0, s = e.count; t < s; t += 3)
                i.fromBufferAttribute(e, t + 0),
                  r.fromBufferAttribute(e, t + 1),
                  o.fromBufferAttribute(e, t + 2),
                  c.subVectors(o, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  n.setXYZ(t + 0, c.x, c.y, c.z),
                  n.setXYZ(t + 1, c.x, c.y, c.z),
                  n.setXYZ(t + 2, c.x, c.y, c.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        merge(t, e) {
          if (!t || !t.isBufferGeometry)
            return void console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              t
            );
          void 0 === e &&
            ((e = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          const n = this.attributes;
          for (const i in n) {
            if (void 0 === t.attributes[i]) continue;
            const r = n[i].array,
              o = t.attributes[i],
              s = o.array,
              a = o.itemSize * e,
              l = Math.min(s.length, r.length - a);
            for (let t = 0, e = a; t < l; t++, e++) r[e] = s[t];
          }
          return this;
        }
        normalizeNormals() {
          const t = this.attributes.normal;
          for (let e = 0, n = t.count; e < n; e++)
            Qr.fromBufferAttribute(t, e),
              Qr.normalize(),
              t.setXYZ(e, Qr.x, Qr.y, Qr.z);
        }
        toNonIndexed() {
          function t(t, e) {
            const n = t.array,
              i = t.itemSize,
              r = t.normalized,
              o = new n.constructor(e.length * i);
            let s = 0,
              a = 0;
            for (let r = 0, l = e.length; r < l; r++) {
              s = t.isInterleavedBufferAttribute
                ? e[r] * t.data.stride + t.offset
                : e[r] * i;
              for (let t = 0; t < i; t++) o[a++] = n[s++];
            }
            return new Nr(o, i, r);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const e = new $r(),
            n = this.index.array,
            i = this.attributes;
          for (const r in i) {
            const o = t(i[r], n);
            e.setAttribute(r, o);
          }
          const r = this.morphAttributes;
          for (const i in r) {
            const o = [],
              s = r[i];
            for (let e = 0, i = s.length; e < i; e++) {
              const i = t(s[e], n);
              o.push(i);
            }
            e.morphAttributes[i] = o;
          }
          e.morphTargetsRelative = this.morphTargetsRelative;
          const o = this.groups;
          for (let t = 0, n = o.length; t < n; t++) {
            const n = o[t];
            e.addGroup(n.start, n.count, n.materialIndex);
          }
          return e;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            "" !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (t.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const e = this.parameters;
            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
            return t;
          }
          t.data = { attributes: {} };
          const e = this.index;
          null !== e &&
            (t.data.index = {
              type: e.array.constructor.name,
              array: Array.prototype.slice.call(e.array),
            });
          const n = this.attributes;
          for (const e in n) {
            const i = n[e];
            t.data.attributes[e] = i.toJSON(t.data);
          }
          const i = {};
          let r = !1;
          for (const e in this.morphAttributes) {
            const n = this.morphAttributes[e],
              o = [];
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              o.push(i.toJSON(t.data));
            }
            o.length > 0 && ((i[e] = o), (r = !0));
          }
          r &&
            ((t.data.morphAttributes = i),
            (t.data.morphTargetsRelative = this.morphTargetsRelative));
          const o = this.groups;
          o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
          const s = this.boundingSphere;
          return (
            null !== s &&
              (t.data.boundingSphere = {
                center: s.center.toArray(),
                radius: s.radius,
              }),
            t
          );
        }
        clone() {
          return new $r().copy(this);
        }
        copy(t) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const e = {};
          this.name = t.name;
          const n = t.index;
          null !== n && this.setIndex(n.clone(e));
          const i = t.attributes;
          for (const t in i) {
            const n = i[t];
            this.setAttribute(t, n.clone(e));
          }
          const r = t.morphAttributes;
          for (const t in r) {
            const n = [],
              i = r[t];
            for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
            this.morphAttributes[t] = n;
          }
          this.morphTargetsRelative = t.morphTargetsRelative;
          const o = t.groups;
          for (let t = 0, e = o.length; t < e; t++) {
            const e = o[t];
            this.addGroup(e.start, e.count, e.materialIndex);
          }
          const s = t.boundingBox;
          null !== s && (this.boundingBox = s.clone());
          const a = t.boundingSphere;
          return (
            null !== a && (this.boundingSphere = a.clone()),
            (this.drawRange.start = t.drawRange.start),
            (this.drawRange.count = t.drawRange.count),
            (this.userData = t.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      $r.prototype.isBufferGeometry = !0;
      const to = new ki(),
        eo = new Di(),
        no = new Ci(),
        ro = new si(),
        oo = new si(),
        so = new si(),
        ao = new si(),
        lo = new si(),
        co = new si(),
        uo = new si(),
        ho = new si(),
        po = new si(),
        fo = new Yn(),
        mo = new Yn(),
        go = new Yn(),
        vo = new si(),
        yo = new si();
      class xo extends lr {
        constructor(t = new $r(), e = new Lr()) {
          super(),
            (this.type = "Mesh"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t) {
          return (
            super.copy(t),
            void 0 !== t.morphTargetInfluences &&
              (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                t.morphTargetDictionary
              )),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        updateMorphTargets() {
          const t = this.geometry;
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              n = Object.keys(e);
            if (n.length > 0) {
              const t = e[n[0]];
              if (void 0 !== t) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = e);
                }
              }
            }
          } else {
            const e = t.morphTargets;
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (void 0 === i) return;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            no.copy(n.boundingSphere),
            no.applyMatrix4(r),
            !1 === t.ray.intersectsSphere(no))
          )
            return;
          if (
            (to.copy(r).invert(),
            eo.copy(t.ray).applyMatrix4(to),
            null !== n.boundingBox && !1 === eo.intersectsBox(n.boundingBox))
          )
            return;
          let o;
          if (n.isBufferGeometry) {
            const r = n.index,
              s = n.attributes.position,
              a = n.morphAttributes.position,
              l = n.morphTargetsRelative,
              c = n.attributes.uv,
              u = n.attributes.uv2,
              h = n.groups,
              d = n.drawRange;
            if (null !== r)
              if (Array.isArray(i))
                for (let n = 0, p = h.length; n < p; n++) {
                  const p = h[n],
                    f = i[p.materialIndex];
                  for (
                    let n = Math.max(p.start, d.start),
                      i = Math.min(p.start + p.count, d.start + d.count);
                    n < i;
                    n += 3
                  ) {
                    const i = r.getX(n),
                      h = r.getX(n + 1),
                      d = r.getX(n + 2);
                    (o = bo(this, f, t, eo, s, a, l, c, u, i, h, d)),
                      o &&
                        ((o.faceIndex = Math.floor(n / 3)),
                        (o.face.materialIndex = p.materialIndex),
                        e.push(o));
                  }
                }
              else
                for (
                  let n = Math.max(0, d.start),
                    h = Math.min(r.count, d.start + d.count);
                  n < h;
                  n += 3
                ) {
                  const h = r.getX(n),
                    d = r.getX(n + 1),
                    p = r.getX(n + 2);
                  (o = bo(this, i, t, eo, s, a, l, c, u, h, d, p)),
                    o && ((o.faceIndex = Math.floor(n / 3)), e.push(o));
                }
            else if (void 0 !== s)
              if (Array.isArray(i))
                for (let n = 0, r = h.length; n < r; n++) {
                  const r = h[n],
                    p = i[r.materialIndex];
                  for (
                    let n = Math.max(r.start, d.start),
                      i = Math.min(r.start + r.count, d.start + d.count);
                    n < i;
                    n += 3
                  )
                    (o = bo(this, p, t, eo, s, a, l, c, u, n, n + 1, n + 2)),
                      o &&
                        ((o.faceIndex = Math.floor(n / 3)),
                        (o.face.materialIndex = r.materialIndex),
                        e.push(o));
                }
              else
                for (
                  let n = Math.max(0, d.start),
                    r = Math.min(s.count, d.start + d.count);
                  n < r;
                  n += 3
                )
                  (o = bo(this, i, t, eo, s, a, l, c, u, n, n + 1, n + 2)),
                    o && ((o.faceIndex = Math.floor(n / 3)), e.push(o));
          } else
            n.isGeometry &&
              console.error(
                "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
      }
      function bo(t, e, n, i, r, o, s, a, l, c, u, h) {
        ro.fromBufferAttribute(r, c),
          oo.fromBufferAttribute(r, u),
          so.fromBufferAttribute(r, h);
        const d = t.morphTargetInfluences;
        if (o && d) {
          uo.set(0, 0, 0), ho.set(0, 0, 0), po.set(0, 0, 0);
          for (let t = 0, e = o.length; t < e; t++) {
            const e = d[t],
              n = o[t];
            0 !== e &&
              (ao.fromBufferAttribute(n, c),
              lo.fromBufferAttribute(n, u),
              co.fromBufferAttribute(n, h),
              s
                ? (uo.addScaledVector(ao, e),
                  ho.addScaledVector(lo, e),
                  po.addScaledVector(co, e))
                : (uo.addScaledVector(ao.sub(ro), e),
                  ho.addScaledVector(lo.sub(oo), e),
                  po.addScaledVector(co.sub(so), e)));
          }
          ro.add(uo), oo.add(ho), so.add(po);
        }
        t.isSkinnedMesh &&
          (t.boneTransform(c, ro),
          t.boneTransform(u, oo),
          t.boneTransform(h, so));
        const p = (function (t, e, n, i, r, o, s, a) {
          let l;
          if (
            ((l =
              e.side === f
                ? i.intersectTriangle(s, o, r, !0, a)
                : i.intersectTriangle(r, o, s, e.side !== m, a)),
            null === l)
          )
            return null;
          yo.copy(a), yo.applyMatrix4(t.matrixWorld);
          const c = n.ray.origin.distanceTo(yo);
          return c < n.near || c > n.far
            ? null
            : { distance: c, point: yo.clone(), object: t };
        })(t, e, n, i, ro, oo, so, vo);
        if (p) {
          a &&
            (fo.fromBufferAttribute(a, c),
            mo.fromBufferAttribute(a, u),
            go.fromBufferAttribute(a, h),
            (p.uv = xr.getUV(vo, ro, oo, so, fo, mo, go, new Yn()))),
            l &&
              (fo.fromBufferAttribute(l, c),
              mo.fromBufferAttribute(l, u),
              go.fromBufferAttribute(l, h),
              (p.uv2 = xr.getUV(vo, ro, oo, so, fo, mo, go, new Yn())));
          const t = { a: c, b: u, c: h, normal: new si(), materialIndex: 0 };
          xr.getNormal(ro, oo, so, t.normal), (p.face = t);
        }
        return p;
      }
      xo.prototype.isMesh = !0;
      class wo extends $r {
        constructor(t = 1, e = 1, n = 1, i = 1, r = 1, o = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: o,
            });
          const s = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
          const a = [],
            l = [],
            c = [],
            u = [];
          let h = 0,
            d = 0;
          function p(t, e, n, i, r, o, p, f, m, g, v) {
            const y = o / m,
              x = p / g,
              b = o / 2,
              w = p / 2,
              _ = f / 2,
              M = m + 1,
              S = g + 1;
            let E = 0,
              T = 0;
            const A = new si();
            for (let o = 0; o < S; o++) {
              const s = o * x - w;
              for (let a = 0; a < M; a++) {
                const h = a * y - b;
                (A[t] = h * i),
                  (A[e] = s * r),
                  (A[n] = _),
                  l.push(A.x, A.y, A.z),
                  (A[t] = 0),
                  (A[e] = 0),
                  (A[n] = f > 0 ? 1 : -1),
                  c.push(A.x, A.y, A.z),
                  u.push(a / m),
                  u.push(1 - o / g),
                  (E += 1);
              }
            }
            for (let t = 0; t < g; t++)
              for (let e = 0; e < m; e++) {
                const n = h + e + M * t,
                  i = h + e + M * (t + 1),
                  r = h + (e + 1) + M * (t + 1),
                  o = h + (e + 1) + M * t;
                a.push(n, i, o), a.push(i, r, o), (T += 6);
              }
            s.addGroup(d, T, v), (d += T), (h += E);
          }
          p("z", "y", "x", -1, -1, n, e, t, o, r, 0),
            p("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
            p("x", "z", "y", 1, 1, t, n, e, i, o, 2),
            p("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
            p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
            p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
            this.setIndex(a),
            this.setAttribute("position", new Ur(l, 3)),
            this.setAttribute("normal", new Ur(c, 3)),
            this.setAttribute("uv", new Ur(u, 2));
        }
        static fromJSON(t) {
          return new wo(
            t.width,
            t.height,
            t.depth,
            t.widthSegments,
            t.heightSegments,
            t.depthSegments
          );
        }
      }
      function _o(t) {
        const e = {};
        for (const n in t) {
          e[n] = {};
          for (const i in t[n]) {
            const r = t[n][i];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? (e[n][i] = r.clone())
              : Array.isArray(r)
              ? (e[n][i] = r.slice())
              : (e[n][i] = r);
          }
        }
        return e;
      }
      function Mo(t) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
          const i = _o(t[n]);
          for (const t in i) e[t] = i[t];
        }
        return e;
      }
      const So = { clone: _o, merge: Mo };
      class Eo extends wr {
        constructor(t) {
          super(),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader =
              "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
            (this.fragmentShader =
              "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== t &&
              (void 0 !== t.attributes &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
              this.setValues(t));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.fragmentShader = t.fragmentShader),
            (this.vertexShader = t.vertexShader),
            (this.uniforms = _o(t.uniforms)),
            (this.defines = Object.assign({}, t.defines)),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.lights = t.lights),
            (this.clipping = t.clipping),
            (this.extensions = Object.assign({}, t.extensions)),
            (this.glslVersion = t.glslVersion),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          (e.glslVersion = this.glslVersion), (e.uniforms = {});
          for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture
              ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
              : i && i.isColor
              ? (e.uniforms[n] = { type: "c", value: i.getHex() })
              : i && i.isVector2
              ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
              : i && i.isVector3
              ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
              : i && i.isVector4
              ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
              : i && i.isMatrix3
              ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
              : i && i.isMatrix4
              ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
              : (e.uniforms[n] = { value: i });
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            (e.vertexShader = this.vertexShader),
            (e.fragmentShader = this.fragmentShader);
          const n = {};
          for (const t in this.extensions)
            !0 === this.extensions[t] && (n[t] = !0);
          return Object.keys(n).length > 0 && (e.extensions = n), e;
        }
      }
      Eo.prototype.isShaderMaterial = !0;
      class To extends lr {
        constructor() {
          super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new ki()),
            (this.projectionMatrix = new ki()),
            (this.projectionMatrixInverse = new ki());
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
          );
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1);
          const e = this.matrixWorld.elements;
          return t.set(-e[8], -e[9], -e[10]).normalize();
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      To.prototype.isCamera = !0;
      class Ao extends To {
        constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
          super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        }
        setFocalLength(t) {
          const e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = 2 * zn * Math.atan(e)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t = Math.tan(0.5 * Fn * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        }
        getEffectiveFOV() {
          return 2 * zn * Math.atan(Math.tan(0.5 * Fn * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(t, e, n, i, r, o) {
          (this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = this.near;
          let e = (t * Math.tan(0.5 * Fn * this.fov)) / this.zoom,
            n = 2 * e,
            i = this.aspect * n,
            r = -0.5 * i;
          const o = this.view;
          if (null !== this.view && this.view.enabled) {
            const t = o.fullWidth,
              s = o.fullHeight;
            (r += (o.offsetX * i) / t),
              (e -= (o.offsetY * n) / s),
              (i *= o.width / t),
              (n *= o.height / s);
          }
          const s = this.filmOffset;
          0 !== s && (r += (t * s) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              e,
              e - n,
              t,
              this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        }
      }
      Ao.prototype.isPerspectiveCamera = !0;
      const Co = 90;
      class Lo extends lr {
        constructor(t, e, n) {
          if (
            (super(),
            (this.type = "CubeCamera"),
            !0 !== n.isWebGLCubeRenderTarget)
          )
            return void console.error(
              "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
            );
          this.renderTarget = n;
          const i = new Ao(Co, 1, t, e);
          (i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new si(1, 0, 0)),
            this.add(i);
          const r = new Ao(Co, 1, t, e);
          (r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new si(-1, 0, 0)),
            this.add(r);
          const o = new Ao(Co, 1, t, e);
          (o.layers = this.layers),
            o.up.set(0, 0, 1),
            o.lookAt(new si(0, 1, 0)),
            this.add(o);
          const s = new Ao(Co, 1, t, e);
          (s.layers = this.layers),
            s.up.set(0, 0, -1),
            s.lookAt(new si(0, -1, 0)),
            this.add(s);
          const a = new Ao(Co, 1, t, e);
          (a.layers = this.layers),
            a.up.set(0, -1, 0),
            a.lookAt(new si(0, 0, 1)),
            this.add(a);
          const l = new Ao(Co, 1, t, e);
          (l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new si(0, 0, -1)),
            this.add(l);
        }
        update(t, e) {
          null === this.parent && this.updateMatrixWorld();
          const n = this.renderTarget,
            [i, r, o, s, a, l] = this.children,
            c = t.xr.enabled,
            u = t.getRenderTarget();
          t.xr.enabled = !1;
          const h = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            t.setRenderTarget(n, 0),
            t.render(e, i),
            t.setRenderTarget(n, 1),
            t.render(e, r),
            t.setRenderTarget(n, 2),
            t.render(e, o),
            t.setRenderTarget(n, 3),
            t.render(e, s),
            t.setRenderTarget(n, 4),
            t.render(e, a),
            (n.texture.generateMipmaps = h),
            t.setRenderTarget(n, 5),
            t.render(e, l),
            t.setRenderTarget(u),
            (t.xr.enabled = c);
        }
      }
      class Ro extends $n {
        constructor(t, e, n, i, r, o, s, a, l, c) {
          super(
            (t = void 0 !== t ? t : []),
            (e = void 0 !== e ? e : rt),
            n,
            i,
            r,
            o,
            (s = void 0 !== s ? s : Dt),
            a,
            l,
            c
          ),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(t) {
          this.image = t;
        }
      }
      Ro.prototype.isCubeTexture = !0;
      class Po extends ni {
        constructor(t, e, n) {
          Number.isInteger(e) &&
            (console.warn(
              "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
            ),
            (e = n)),
            super(t, t, e),
            (e = e || {}),
            (this.texture = new Ro(
              void 0,
              e.mapping,
              e.wrapS,
              e.wrapT,
              e.magFilter,
              e.minFilter,
              e.format,
              e.type,
              e.anisotropy,
              e.encoding
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== e.generateMipmaps && e.generateMipmaps),
            (this.texture.minFilter =
              void 0 !== e.minFilter ? e.minFilter : yt),
            (this.texture._needsFlipEnvMap = !1);
        }
        fromEquirectangularTexture(t, e) {
          (this.texture.type = e.type),
            (this.texture.format = kt),
            (this.texture.encoding = e.encoding),
            (this.texture.generateMipmaps = e.generateMipmaps),
            (this.texture.minFilter = e.minFilter),
            (this.texture.magFilter = e.magFilter);
          const n = { tEquirect: { value: null } },
            i =
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            r =
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            o = new wo(5, 5, 5),
            s = new Eo({
              name: "CubemapFromEquirect",
              uniforms: _o(n),
              vertexShader: i,
              fragmentShader: r,
              side: f,
              blending: y,
            });
          s.uniforms.tEquirect.value = e;
          const a = new xo(o, s),
            l = e.minFilter;
          return (
            e.minFilter === wt && (e.minFilter = yt),
            new Lo(1, 10, this).update(t, a),
            (e.minFilter = l),
            a.geometry.dispose(),
            a.material.dispose(),
            this
          );
        }
        clear(t, e, n, i) {
          const r = t.getRenderTarget();
          for (let r = 0; r < 6; r++)
            t.setRenderTarget(this, r), t.clear(e, n, i);
          t.setRenderTarget(r);
        }
      }
      Po.prototype.isWebGLCubeRenderTarget = !0;
      const No = new si(),
        Io = new si(),
        Bo = new Zn();
      class Oo {
        constructor(t = new si(1, 0, 0), e = 0) {
          (this.normal = t), (this.constant = e);
        }
        set(t, e) {
          return this.normal.copy(t), (this.constant = e), this;
        }
        setComponents(t, e, n, i) {
          return this.normal.set(t, e, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return (
            this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(t, e, n) {
          const i = No.subVectors(n, e).cross(Io.subVectors(t, e)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, t), this;
        }
        copy(t) {
          return this.normal.copy(t.normal), (this.constant = t.constant), this;
        }
        normalize() {
          const t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), (this.constant *= t), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, e) {
          return e
            .copy(this.normal)
            .multiplyScalar(-this.distanceToPoint(t))
            .add(t);
        }
        intersectLine(t, e) {
          const n = t.delta(No),
            i = this.normal.dot(n);
          if (0 === i)
            return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
          const r = -(t.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1
            ? null
            : e.copy(n).multiplyScalar(r).add(t.start);
        }
        intersectsLine(t) {
          const e = this.distanceToPoint(t.start),
            n = this.distanceToPoint(t.end);
          return (e < 0 && n > 0) || (n < 0 && e > 0);
        }
        intersectsBox(t) {
          return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, e) {
          const n = e || Bo.getNormalMatrix(t),
            i = this.coplanarPoint(No).applyMatrix4(t),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(t) {
          return (this.constant -= t.dot(this.normal)), this;
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Oo.prototype.isPlane = !0;
      const Do = new Ci(),
        ko = new si();
      class Fo {
        constructor(
          t = new Oo(),
          e = new Oo(),
          n = new Oo(),
          i = new Oo(),
          r = new Oo(),
          o = new Oo()
        ) {
          this.planes = [t, e, n, i, r, o];
        }
        set(t, e, n, i, r, o) {
          const s = this.planes;
          return (
            s[0].copy(t),
            s[1].copy(e),
            s[2].copy(n),
            s[3].copy(i),
            s[4].copy(r),
            s[5].copy(o),
            this
          );
        }
        copy(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
          return this;
        }
        setFromProjectionMatrix(t) {
          const e = this.planes,
            n = t.elements,
            i = n[0],
            r = n[1],
            o = n[2],
            s = n[3],
            a = n[4],
            l = n[5],
            c = n[6],
            u = n[7],
            h = n[8],
            d = n[9],
            p = n[10],
            f = n[11],
            m = n[12],
            g = n[13],
            v = n[14],
            y = n[15];
          return (
            e[0].setComponents(s - i, u - a, f - h, y - m).normalize(),
            e[1].setComponents(s + i, u + a, f + h, y + m).normalize(),
            e[2].setComponents(s + r, u + l, f + d, y + g).normalize(),
            e[3].setComponents(s - r, u - l, f - d, y - g).normalize(),
            e[4].setComponents(s - o, u - c, f - p, y - v).normalize(),
            e[5].setComponents(s + o, u + c, f + p, y + v).normalize(),
            this
          );
        }
        intersectsObject(t) {
          const e = t.geometry;
          return (
            null === e.boundingSphere && e.computeBoundingSphere(),
            Do.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Do)
          );
        }
        intersectsSprite(t) {
          return (
            Do.center.set(0, 0, 0),
            (Do.radius = 0.7071067811865476),
            Do.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Do)
          );
        }
        intersectsSphere(t) {
          const e = this.planes,
            n = t.center,
            i = -t.radius;
          for (let t = 0; t < 6; t++)
            if (e[t].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = e[n];
            if (
              ((ko.x = i.normal.x > 0 ? t.max.x : t.min.x),
              (ko.y = i.normal.y > 0 ? t.max.y : t.min.y),
              (ko.z = i.normal.z > 0 ? t.max.z : t.min.z),
              i.distanceToPoint(ko) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++)
            if (e[n].distanceToPoint(t) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function zo() {
        let t = null,
          e = !1,
          n = null,
          i = null;
        function r(e, o) {
          n(e, o), (i = t.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== e &&
              null !== n &&
              ((i = t.requestAnimationFrame(r)), (e = !0));
          },
          stop: function () {
            t.cancelAnimationFrame(i), (e = !1);
          },
          setAnimationLoop: function (t) {
            n = t;
          },
          setContext: function (e) {
            t = e;
          },
        };
      }
      function Ho(t, e) {
        const n = e.isWebGL2,
          i = new WeakMap();
        return {
          get: function (t) {
            return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
          },
          remove: function (e) {
            e.isInterleavedBufferAttribute && (e = e.data);
            const n = i.get(e);
            n && (t.deleteBuffer(n.buffer), i.delete(e));
          },
          update: function (e, r) {
            if (e.isGLBufferAttribute) {
              const t = i.get(e);
              return void (
                (!t || t.version < e.version) &&
                i.set(e, {
                  buffer: e.buffer,
                  type: e.type,
                  bytesPerElement: e.elementSize,
                  version: e.version,
                })
              );
            }
            e.isInterleavedBufferAttribute && (e = e.data);
            const o = i.get(e);
            void 0 === o
              ? i.set(
                  e,
                  (function (e, i) {
                    const r = e.array,
                      o = e.usage,
                      s = t.createBuffer();
                    t.bindBuffer(i, s),
                      t.bufferData(i, r, o),
                      e.onUploadCallback();
                    let a = 5126;
                    return (
                      r instanceof Float32Array
                        ? (a = 5126)
                        : r instanceof Float64Array
                        ? console.warn(
                            "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                          )
                        : r instanceof Uint16Array
                        ? e.isFloat16BufferAttribute
                          ? n
                            ? (a = 5131)
                            : console.warn(
                                "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                              )
                          : (a = 5123)
                        : r instanceof Int16Array
                        ? (a = 5122)
                        : r instanceof Uint32Array
                        ? (a = 5125)
                        : r instanceof Int32Array
                        ? (a = 5124)
                        : r instanceof Int8Array
                        ? (a = 5120)
                        : (r instanceof Uint8Array ||
                            r instanceof Uint8ClampedArray) &&
                          (a = 5121),
                      {
                        buffer: s,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version,
                      }
                    );
                  })(e, r)
                )
              : o.version < e.version &&
                ((function (e, i, r) {
                  const o = i.array,
                    s = i.updateRange;
                  t.bindBuffer(r, e),
                    -1 === s.count
                      ? t.bufferSubData(r, 0, o)
                      : (n
                          ? t.bufferSubData(
                              r,
                              s.offset * o.BYTES_PER_ELEMENT,
                              o,
                              s.offset,
                              s.count
                            )
                          : t.bufferSubData(
                              r,
                              s.offset * o.BYTES_PER_ELEMENT,
                              o.subarray(s.offset, s.offset + s.count)
                            ),
                        (s.count = -1));
                })(o.buffer, e, r),
                (o.version = e.version));
          },
        };
      }
      class Uo extends $r {
        constructor(t = 1, e = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              widthSegments: n,
              heightSegments: i,
            });
          const r = t / 2,
            o = e / 2,
            s = Math.floor(n),
            a = Math.floor(i),
            l = s + 1,
            c = a + 1,
            u = t / s,
            h = e / a,
            d = [],
            p = [],
            f = [],
            m = [];
          for (let t = 0; t < c; t++) {
            const e = t * h - o;
            for (let n = 0; n < l; n++) {
              const i = n * u - r;
              p.push(i, -e, 0),
                f.push(0, 0, 1),
                m.push(n / s),
                m.push(1 - t / a);
            }
          }
          for (let t = 0; t < a; t++)
            for (let e = 0; e < s; e++) {
              const n = e + l * t,
                i = e + l * (t + 1),
                r = e + 1 + l * (t + 1),
                o = e + 1 + l * t;
              d.push(n, i, o), d.push(i, r, o);
            }
          this.setIndex(d),
            this.setAttribute("position", new Ur(p, 3)),
            this.setAttribute("normal", new Ur(f, 3)),
            this.setAttribute("uv", new Ur(m, 2));
        }
        static fromJSON(t) {
          return new Uo(t.width, t.height, t.widthSegments, t.heightSegments);
        }
      }
      const Vo = {
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          encodings_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment:
            "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
          lightmap_fragment:
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_vertex:
            "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
          normal_fragment_begin:
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps:
            "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment:
            "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif",
          transmission_pars_fragment:
            "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif",
          uv_pars_fragment:
            "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
          uv_pars_vertex:
            "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
          uv_vertex:
            "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
          uv2_pars_fragment:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
          uv2_pars_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
          uv2_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_frag:
            "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          cube_frag:
            "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          depth_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}",
          normal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
          normal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        },
        Go = {
          common: {
            diffuse: { value: new Cr(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new Zn() },
            uv2Transform: { value: new Zn() },
            alphaMap: { value: null },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new Yn(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Cr(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Cr(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new Zn() },
          },
          sprite: {
            diffuse: { value: new Cr(16777215) },
            opacity: { value: 1 },
            center: { value: new Yn(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new Zn() },
          },
        },
        jo = {
          basic: {
            uniforms: Mo([
              Go.common,
              Go.specularmap,
              Go.envmap,
              Go.aomap,
              Go.lightmap,
              Go.fog,
            ]),
            vertexShader: Vo.meshbasic_vert,
            fragmentShader: Vo.meshbasic_frag,
          },
          lambert: {
            uniforms: Mo([
              Go.common,
              Go.specularmap,
              Go.envmap,
              Go.aomap,
              Go.lightmap,
              Go.emissivemap,
              Go.fog,
              Go.lights,
              { emissive: { value: new Cr(0) } },
            ]),
            vertexShader: Vo.meshlambert_vert,
            fragmentShader: Vo.meshlambert_frag,
          },
          phong: {
            uniforms: Mo([
              Go.common,
              Go.specularmap,
              Go.envmap,
              Go.aomap,
              Go.lightmap,
              Go.emissivemap,
              Go.bumpmap,
              Go.normalmap,
              Go.displacementmap,
              Go.fog,
              Go.lights,
              {
                emissive: { value: new Cr(0) },
                specular: { value: new Cr(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Vo.meshphong_vert,
            fragmentShader: Vo.meshphong_frag,
          },
          standard: {
            uniforms: Mo([
              Go.common,
              Go.envmap,
              Go.aomap,
              Go.lightmap,
              Go.emissivemap,
              Go.bumpmap,
              Go.normalmap,
              Go.displacementmap,
              Go.roughnessmap,
              Go.metalnessmap,
              Go.fog,
              Go.lights,
              {
                emissive: { value: new Cr(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Vo.meshphysical_vert,
            fragmentShader: Vo.meshphysical_frag,
          },
          toon: {
            uniforms: Mo([
              Go.common,
              Go.aomap,
              Go.lightmap,
              Go.emissivemap,
              Go.bumpmap,
              Go.normalmap,
              Go.displacementmap,
              Go.gradientmap,
              Go.fog,
              Go.lights,
              { emissive: { value: new Cr(0) } },
            ]),
            vertexShader: Vo.meshtoon_vert,
            fragmentShader: Vo.meshtoon_frag,
          },
          matcap: {
            uniforms: Mo([
              Go.common,
              Go.bumpmap,
              Go.normalmap,
              Go.displacementmap,
              Go.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Vo.meshmatcap_vert,
            fragmentShader: Vo.meshmatcap_frag,
          },
          points: {
            uniforms: Mo([Go.points, Go.fog]),
            vertexShader: Vo.points_vert,
            fragmentShader: Vo.points_frag,
          },
          dashed: {
            uniforms: Mo([
              Go.common,
              Go.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Vo.linedashed_vert,
            fragmentShader: Vo.linedashed_frag,
          },
          depth: {
            uniforms: Mo([Go.common, Go.displacementmap]),
            vertexShader: Vo.depth_vert,
            fragmentShader: Vo.depth_frag,
          },
          normal: {
            uniforms: Mo([
              Go.common,
              Go.bumpmap,
              Go.normalmap,
              Go.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Vo.normal_vert,
            fragmentShader: Vo.normal_frag,
          },
          sprite: {
            uniforms: Mo([Go.sprite, Go.fog]),
            vertexShader: Vo.sprite_vert,
            fragmentShader: Vo.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new Zn() },
              t2D: { value: null },
            },
            vertexShader: Vo.background_vert,
            fragmentShader: Vo.background_frag,
          },
          cube: {
            uniforms: Mo([Go.envmap, { opacity: { value: 1 } }]),
            vertexShader: Vo.cube_vert,
            fragmentShader: Vo.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Vo.equirect_vert,
            fragmentShader: Vo.equirect_frag,
          },
          distanceRGBA: {
            uniforms: Mo([
              Go.common,
              Go.displacementmap,
              {
                referencePosition: { value: new si() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Vo.distanceRGBA_vert,
            fragmentShader: Vo.distanceRGBA_frag,
          },
          shadow: {
            uniforms: Mo([
              Go.lights,
              Go.fog,
              { color: { value: new Cr(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Vo.shadow_vert,
            fragmentShader: Vo.shadow_frag,
          },
        };
      function Wo(t, e, n, i, r) {
        const o = new Cr(0);
        let s,
          a,
          l = 0,
          c = null,
          u = 0,
          h = null;
        function d(t, e) {
          n.buffers.color.setClear(t.r, t.g, t.b, e, r);
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (t, e = 1) {
            o.set(t), (l = e), d(o, l);
          },
          getClearAlpha: function () {
            return l;
          },
          setClearAlpha: function (t) {
            (l = t), d(o, l);
          },
          render: function (n, r) {
            let m = !1,
              g = !0 === r.isScene ? r.background : null;
            g && g.isTexture && (g = e.get(g));
            const v = t.xr,
              y = v.getSession && v.getSession();
            y && "additive" === y.environmentBlendMode && (g = null),
              null === g ? d(o, l) : g && g.isColor && (d(g, 1), (m = !0)),
              (t.autoClear || m) &&
                t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
              g && (g.isCubeTexture || g.mapping === lt)
                ? (void 0 === a &&
                    ((a = new xo(
                      new wo(1, 1, 1),
                      new Eo({
                        name: "BackgroundCubeMaterial",
                        uniforms: _o(jo.cube.uniforms),
                        vertexShader: jo.cube.vertexShader,
                        fragmentShader: jo.cube.fragmentShader,
                        side: f,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    a.geometry.deleteAttribute("normal"),
                    a.geometry.deleteAttribute("uv"),
                    (a.onBeforeRender = function (t, e, n) {
                      this.matrixWorld.copyPosition(n.matrixWorld);
                    }),
                    Object.defineProperty(a.material, "envMap", {
                      get: function () {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    i.update(a)),
                  (a.material.uniforms.envMap.value = g),
                  (a.material.uniforms.flipEnvMap.value =
                    g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1),
                  (c === g && u === g.version && h === t.toneMapping) ||
                    ((a.material.needsUpdate = !0),
                    (c = g),
                    (u = g.version),
                    (h = t.toneMapping)),
                  n.unshift(a, a.geometry, a.material, 0, 0, null))
                : g &&
                  g.isTexture &&
                  (void 0 === s &&
                    ((s = new xo(
                      new Uo(2, 2),
                      new Eo({
                        name: "BackgroundMaterial",
                        uniforms: _o(jo.background.uniforms),
                        vertexShader: jo.background.vertexShader,
                        fragmentShader: jo.background.fragmentShader,
                        side: p,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    s.geometry.deleteAttribute("normal"),
                    Object.defineProperty(s.material, "map", {
                      get: function () {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    i.update(s)),
                  (s.material.uniforms.t2D.value = g),
                  !0 === g.matrixAutoUpdate && g.updateMatrix(),
                  s.material.uniforms.uvTransform.value.copy(g.matrix),
                  (c === g && u === g.version && h === t.toneMapping) ||
                    ((s.material.needsUpdate = !0),
                    (c = g),
                    (u = g.version),
                    (h = t.toneMapping)),
                  n.unshift(s, s.geometry, s.material, 0, 0, null));
          },
        };
      }
      function qo(t, e, n, i) {
        const r = t.getParameter(34921),
          o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          s = i.isWebGL2 || null !== o,
          a = {},
          l = d(null);
        let c = l;
        function u(e) {
          return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e);
        }
        function h(e) {
          return i.isWebGL2
            ? t.deleteVertexArray(e)
            : o.deleteVertexArrayOES(e);
        }
        function d(t) {
          const e = [],
            n = [],
            i = [];
          for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: e,
            enabledAttributes: n,
            attributeDivisors: i,
            object: t,
            attributes: {},
            index: null,
          };
        }
        function p() {
          const t = c.newAttributes;
          for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
        }
        function f(t) {
          m(t, 0);
        }
        function m(n, r) {
          const o = c.newAttributes,
            s = c.enabledAttributes,
            a = c.attributeDivisors;
          (o[n] = 1),
            0 === s[n] && (t.enableVertexAttribArray(n), (s[n] = 1)),
            a[n] !== r &&
              ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](n, r),
              (a[n] = r));
        }
        function g() {
          const e = c.newAttributes,
            n = c.enabledAttributes;
          for (let i = 0, r = n.length; i < r; i++)
            n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
        }
        function v(e, n, r, o, s, a) {
          !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
            ? t.vertexAttribPointer(e, n, r, o, s, a)
            : t.vertexAttribIPointer(e, n, r, s, a);
        }
        function y() {
          x(), c !== l && ((c = l), u(c.object));
        }
        function x() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: function (r, l, h, y, x) {
            let b = !1;
            if (s) {
              const e = (function (e, n, r) {
                const s = !0 === r.wireframe;
                let l = a[e.id];
                void 0 === l && ((l = {}), (a[e.id] = l));
                let c = l[n.id];
                void 0 === c && ((c = {}), (l[n.id] = c));
                let u = c[s];
                return (
                  void 0 === u &&
                    ((u = d(
                      i.isWebGL2
                        ? t.createVertexArray()
                        : o.createVertexArrayOES()
                    )),
                    (c[s] = u)),
                  u
                );
              })(y, h, l);
              c !== e && ((c = e), u(c.object)),
                (b = (function (t, e) {
                  const n = c.attributes,
                    i = t.attributes;
                  let r = 0;
                  for (const t in i) {
                    const e = n[t],
                      o = i[t];
                    if (void 0 === e) return !0;
                    if (e.attribute !== o) return !0;
                    if (e.data !== o.data) return !0;
                    r++;
                  }
                  return c.attributesNum !== r || c.index !== e;
                })(y, x)),
                b &&
                  (function (t, e) {
                    const n = {},
                      i = t.attributes;
                    let r = 0;
                    for (const t in i) {
                      const e = i[t],
                        o = {};
                      (o.attribute = e),
                        e.data && (o.data = e.data),
                        (n[t] = o),
                        r++;
                    }
                    (c.attributes = n), (c.attributesNum = r), (c.index = e);
                  })(y, x);
            } else {
              const t = !0 === l.wireframe;
              (c.geometry === y.id &&
                c.program === h.id &&
                c.wireframe === t) ||
                ((c.geometry = y.id),
                (c.program = h.id),
                (c.wireframe = t),
                (b = !0));
            }
            !0 === r.isInstancedMesh && (b = !0),
              null !== x && n.update(x, 34963),
              b &&
                ((function (r, o, s, a) {
                  if (
                    !1 === i.isWebGL2 &&
                    (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                    null === e.get("ANGLE_instanced_arrays")
                  )
                    return;
                  p();
                  const l = a.attributes,
                    c = s.getAttributes(),
                    u = o.defaultAttributeValues;
                  for (const e in c) {
                    const i = c[e];
                    if (i >= 0) {
                      const o = l[e];
                      if (void 0 !== o) {
                        const e = o.normalized,
                          r = o.itemSize,
                          s = n.get(o);
                        if (void 0 === s) continue;
                        const l = s.buffer,
                          c = s.type,
                          u = s.bytesPerElement;
                        if (o.isInterleavedBufferAttribute) {
                          const n = o.data,
                            s = n.stride,
                            h = o.offset;
                          n && n.isInstancedInterleavedBuffer
                            ? (m(i, n.meshPerAttribute),
                              void 0 === a._maxInstanceCount &&
                                (a._maxInstanceCount =
                                  n.meshPerAttribute * n.count))
                            : f(i),
                            t.bindBuffer(34962, l),
                            v(i, r, c, e, s * u, h * u);
                        } else
                          o.isInstancedBufferAttribute
                            ? (m(i, o.meshPerAttribute),
                              void 0 === a._maxInstanceCount &&
                                (a._maxInstanceCount =
                                  o.meshPerAttribute * o.count))
                            : f(i),
                            t.bindBuffer(34962, l),
                            v(i, r, c, e, 0, 0);
                      } else if ("instanceMatrix" === e) {
                        const e = n.get(r.instanceMatrix);
                        if (void 0 === e) continue;
                        const o = e.buffer,
                          s = e.type;
                        m(i + 0, 1),
                          m(i + 1, 1),
                          m(i + 2, 1),
                          m(i + 3, 1),
                          t.bindBuffer(34962, o),
                          t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0),
                          t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16),
                          t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32),
                          t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48);
                      } else if ("instanceColor" === e) {
                        const e = n.get(r.instanceColor);
                        if (void 0 === e) continue;
                        const o = e.buffer,
                          s = e.type;
                        m(i, 1),
                          t.bindBuffer(34962, o),
                          t.vertexAttribPointer(i, 3, s, !1, 12, 0);
                      } else if (void 0 !== u) {
                        const n = u[e];
                        if (void 0 !== n)
                          switch (n.length) {
                            case 2:
                              t.vertexAttrib2fv(i, n);
                              break;
                            case 3:
                              t.vertexAttrib3fv(i, n);
                              break;
                            case 4:
                              t.vertexAttrib4fv(i, n);
                              break;
                            default:
                              t.vertexAttrib1fv(i, n);
                          }
                      }
                    }
                  }
                  g();
                })(r, l, h, y),
                null !== x && t.bindBuffer(34963, n.get(x).buffer));
          },
          reset: y,
          resetDefaultState: x,
          dispose: function () {
            y();
            for (const t in a) {
              const e = a[t];
              for (const t in e) {
                const n = e[t];
                for (const t in n) h(n[t].object), delete n[t];
                delete e[t];
              }
              delete a[t];
            }
          },
          releaseStatesOfGeometry: function (t) {
            if (void 0 === a[t.id]) return;
            const e = a[t.id];
            for (const t in e) {
              const n = e[t];
              for (const t in n) h(n[t].object), delete n[t];
              delete e[t];
            }
            delete a[t.id];
          },
          releaseStatesOfProgram: function (t) {
            for (const e in a) {
              const n = a[e];
              if (void 0 === n[t.id]) continue;
              const i = n[t.id];
              for (const t in i) h(i[t].object), delete i[t];
              delete n[t.id];
            }
          },
          initAttributes: p,
          enableAttribute: f,
          disableUnusedAttributes: g,
        };
      }
      function Xo(t, e, n, i) {
        const r = i.isWebGL2;
        let o;
        (this.setMode = function (t) {
          o = t;
        }),
          (this.render = function (e, i) {
            t.drawArrays(o, e, i), n.update(i, o, 1);
          }),
          (this.renderInstances = function (i, s, a) {
            if (0 === a) return;
            let l, c;
            if (r) (l = t), (c = "drawArraysInstanced");
            else if (
              ((l = e.get("ANGLE_instanced_arrays")),
              (c = "drawArraysInstancedANGLE"),
              null === l)
            )
              return void console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            l[c](o, i, s, a), n.update(s, o, a);
          });
      }
      function Yo(t, e, n) {
        let i;
        function r(e) {
          if ("highp" === e) {
            if (
              t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            e = "mediump";
          }
          return "mediump" === e &&
            t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            t.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        const o =
          ("undefined" != typeof WebGL2RenderingContext &&
            t instanceof WebGL2RenderingContext) ||
          ("undefined" != typeof WebGL2ComputeRenderingContext &&
            t instanceof WebGL2ComputeRenderingContext);
        let s = void 0 !== n.precision ? n.precision : "highp";
        const a = r(s);
        a !== s &&
          (console.warn(
            "THREE.WebGLRenderer:",
            s,
            "not supported, using",
            a,
            "instead."
          ),
          (s = a));
        const l = o || e.has("WEBGL_draw_buffers"),
          c = !0 === n.logarithmicDepthBuffer,
          u = t.getParameter(34930),
          h = t.getParameter(35660),
          d = t.getParameter(3379),
          p = t.getParameter(34076),
          f = t.getParameter(34921),
          m = t.getParameter(36347),
          g = t.getParameter(36348),
          v = t.getParameter(36349),
          y = h > 0,
          x = o || e.has("OES_texture_float");
        return {
          isWebGL2: o,
          drawBuffers: l,
          getMaxAnisotropy: function () {
            if (void 0 !== i) return i;
            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
              const n = e.get("EXT_texture_filter_anisotropic");
              i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else i = 0;
            return i;
          },
          getMaxPrecision: r,
          precision: s,
          logarithmicDepthBuffer: c,
          maxTextures: u,
          maxVertexTextures: h,
          maxTextureSize: d,
          maxCubemapSize: p,
          maxAttributes: f,
          maxVertexUniforms: m,
          maxVaryings: g,
          maxFragmentUniforms: v,
          vertexTextures: y,
          floatFragmentTextures: x,
          floatVertexTextures: y && x,
          maxSamples: o ? t.getParameter(36183) : 0,
        };
      }
      function Zo(t) {
        const e = this;
        let n = null,
          i = 0,
          r = !1,
          o = !1;
        const s = new Oo(),
          a = new Zn(),
          l = { value: null, needsUpdate: !1 };
        function c() {
          l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
            (e.numPlanes = i),
            (e.numIntersection = 0);
        }
        function u(t, n, i, r) {
          const o = null !== t ? t.length : 0;
          let c = null;
          if (0 !== o) {
            if (((c = l.value), !0 !== r || null === c)) {
              const e = i + 4 * o,
                r = n.matrixWorldInverse;
              a.getNormalMatrix(r),
                (null === c || c.length < e) && (c = new Float32Array(e));
              for (let e = 0, n = i; e !== o; ++e, n += 4)
                s.copy(t[e]).applyMatrix4(r, a),
                  s.normal.toArray(c, n),
                  (c[n + 3] = s.constant);
            }
            (l.value = c), (l.needsUpdate = !0);
          }
          return (e.numPlanes = o), (e.numIntersection = 0), c;
        }
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (t, e, o) {
            const s = 0 !== t.length || e || 0 !== i || r;
            return (r = e), (n = u(t, o, 0)), (i = t.length), s;
          }),
          (this.beginShadows = function () {
            (o = !0), u(null);
          }),
          (this.endShadows = function () {
            (o = !1), c();
          }),
          (this.setState = function (e, s, a) {
            const h = e.clippingPlanes,
              d = e.clipIntersection,
              p = e.clipShadows,
              f = t.get(e);
            if (!r || null === h || 0 === h.length || (o && !p))
              o ? u(null) : c();
            else {
              const t = o ? 0 : i,
                e = 4 * t;
              let r = f.clippingState || null;
              (l.value = r), (r = u(h, s, e, a));
              for (let t = 0; t !== e; ++t) r[t] = n[t];
              (f.clippingState = r),
                (this.numIntersection = d ? this.numPlanes : 0),
                (this.numPlanes += t);
            }
          });
      }
      function Jo(t) {
        let e = new WeakMap();
        function n(t, e) {
          return e === st ? (t.mapping = rt) : e === at && (t.mapping = ot), t;
        }
        function i(t) {
          const n = t.target;
          n.removeEventListener("dispose", i);
          const r = e.get(n);
          void 0 !== r && (e.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
              const o = r.mapping;
              if (o === st || o === at) {
                if (e.has(r)) return n(e.get(r).texture, r.mapping);
                {
                  const o = r.image;
                  if (o && o.height > 0) {
                    const s = t.getRenderTarget(),
                      a = new Po(o.height / 2);
                    return (
                      a.fromEquirectangularTexture(t, r),
                      e.set(r, a),
                      t.setRenderTarget(s),
                      r.addEventListener("dispose", i),
                      n(a.texture, r.mapping)
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      jo.physical = {
        uniforms: Mo([
          jo.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new Yn(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: new Cr(0) },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new Yn() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationTint: { value: new Cr(0) },
            specularIntensity: { value: 0 },
            specularIntensityMap: { value: null },
            specularTint: { value: new Cr(1, 1, 1) },
            specularTintMap: { value: null },
          },
        ]),
        vertexShader: Vo.meshphysical_vert,
        fragmentShader: Vo.meshphysical_frag,
      };
      class Ko extends To {
        constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
          super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = t),
            (this.right = e),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = o),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          );
        }
        setViewOffset(t, e, n, i, r, o) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - t,
            o = n + t,
            s = i + e,
            a = i - e;
          if (null !== this.view && this.view.enabled) {
            const t =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += t * this.view.offsetX),
              (o = r + t * this.view.width),
              (s -= e * this.view.offsetY),
              (a = s - e * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            o,
            s,
            a,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        }
      }
      Ko.prototype.isOrthographicCamera = !0;
      class Qo extends Eo {
        constructor(t) {
          super(t), (this.type = "RawShaderMaterial");
        }
      }
      Qo.prototype.isRawShaderMaterial = !0;
      const $o = Math.pow(2, 8),
        ts = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        es = 5 + ts.length,
        ns = { [Ze]: 0, [Je]: 1, [Qe]: 2, [tn]: 3, [en]: 4, [nn]: 5, [Ke]: 6 },
        is = new Lr({ side: f, depthWrite: !1, depthTest: !1 }),
        rs = new xo(new wo(), is),
        os = new Ko(),
        { _lodPlanes: ss, _sizeLods: as, _sigmas: ls } = vs(),
        cs = new Cr();
      let us = null;
      const hs = (1 + Math.sqrt(5)) / 2,
        ds = 1 / hs,
        ps = [
          new si(1, 1, 1),
          new si(-1, 1, 1),
          new si(1, 1, -1),
          new si(-1, 1, -1),
          new si(0, hs, ds),
          new si(0, hs, -ds),
          new si(ds, 0, hs),
          new si(-ds, 0, hs),
          new si(hs, ds, 0),
          new si(-hs, ds, 0),
        ];
      function fs(t) {
        const e = Math.max(t.r, t.g, t.b),
          n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
        return t.multiplyScalar(Math.pow(2, -n)), (n + 128) / 255;
      }
      class ms {
        constructor(t) {
          (this._renderer = t),
            (this._pingPongRenderTarget = null),
            (this._blurMaterial = (function (t) {
              const e = new Float32Array(20),
                n = new si(0, 1, 0);
              return new Qo({
                name: "SphericalGaussianBlur",
                defines: { n: 20 },
                uniforms: {
                  envMap: { value: null },
                  samples: { value: 1 },
                  weights: { value: e },
                  latitudinal: { value: !1 },
                  dTheta: { value: 0 },
                  mipInt: { value: 0 },
                  poleAxis: { value: n },
                  inputEncoding: { value: ns[Ze] },
                  outputEncoding: { value: ns[Ze] },
                },
                vertexShader:
                  "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader:
                  "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                blending: y,
                depthTest: !1,
                depthWrite: !1,
              });
            })()),
            (this._equirectShader = null),
            (this._cubemapShader = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(t, e = 0, n = 0.1, i = 100) {
          us = this._renderer.getRenderTarget();
          const r = this._allocateTargets();
          return (
            this._sceneToCubeUV(t, n, i, r),
            e > 0 && this._blur(r, 0, 0, e),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(t) {
          return this._fromTexture(t);
        }
        fromCubemap(t) {
          return this._fromTexture(t);
        }
        compileCubemapShader() {
          null === this._cubemapShader &&
            ((this._cubemapShader = ws()),
            this._compileMaterial(this._cubemapShader));
        }
        compileEquirectangularShader() {
          null === this._equirectShader &&
            ((this._equirectShader = bs()),
            this._compileMaterial(this._equirectShader));
        }
        dispose() {
          this._blurMaterial.dispose(),
            null !== this._cubemapShader && this._cubemapShader.dispose(),
            null !== this._equirectShader && this._equirectShader.dispose();
          for (let t = 0; t < ss.length; t++) ss[t].dispose();
        }
        _cleanup(t) {
          this._pingPongRenderTarget.dispose(),
            this._renderer.setRenderTarget(us),
            (t.scissorTest = !1),
            xs(t, 0, 0, t.width, t.height);
        }
        _fromTexture(t) {
          us = this._renderer.getRenderTarget();
          const e = this._allocateTargets(t);
          return (
            this._textureToCubeUV(t, e),
            this._applyPMREM(e),
            this._cleanup(e),
            e
          );
        }
        _allocateTargets(t) {
          const e = {
              magFilter: pt,
              minFilter: pt,
              generateMipmaps: !1,
              type: Mt,
              format: Ht,
              encoding: gs(t) ? t.encoding : Qe,
              depthBuffer: !1,
            },
            n = ys(e);
          return (n.depthBuffer = !t), (this._pingPongRenderTarget = ys(e)), n;
        }
        _compileMaterial(t) {
          const e = new xo(ss[0], t);
          this._renderer.compile(e, os);
        }
        _sceneToCubeUV(t, e, n, i) {
          const r = new Ao(90, 1, e, n),
            o = [1, -1, 1, 1, 1, 1],
            s = [1, 1, 1, -1, -1, -1],
            a = this._renderer,
            l = a.autoClear,
            c = a.outputEncoding,
            u = a.toneMapping;
          a.getClearColor(cs),
            (a.toneMapping = K),
            (a.outputEncoding = Ze),
            (a.autoClear = !1);
          let h = !1;
          const d = t.background;
          if (d) {
            if (d.isColor) {
              is.color.copy(d).convertSRGBToLinear(), (t.background = null);
              const e = fs(is.color);
              (is.opacity = e), (h = !0);
            }
          } else {
            is.color.copy(cs).convertSRGBToLinear();
            const t = fs(is.color);
            (is.opacity = t), (h = !0);
          }
          for (let e = 0; e < 6; e++) {
            const n = e % 3;
            0 == n
              ? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0))
              : 1 == n
              ? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0))
              : (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])),
              xs(i, n * $o, e > 2 ? $o : 0, $o, $o),
              a.setRenderTarget(i),
              h && a.render(rs, r),
              a.render(t, r);
          }
          (a.toneMapping = u), (a.outputEncoding = c), (a.autoClear = l);
        }
        _textureToCubeUV(t, e) {
          const n = this._renderer;
          t.isCubeTexture
            ? null == this._cubemapShader && (this._cubemapShader = ws())
            : null == this._equirectShader && (this._equirectShader = bs());
          const i = t.isCubeTexture
              ? this._cubemapShader
              : this._equirectShader,
            r = new xo(ss[0], i),
            o = i.uniforms;
          (o.envMap.value = t),
            t.isCubeTexture ||
              o.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
            (o.inputEncoding.value = ns[t.encoding]),
            (o.outputEncoding.value = ns[e.texture.encoding]),
            xs(e, 0, 0, 3 * $o, 2 * $o),
            n.setRenderTarget(e),
            n.render(r, os);
        }
        _applyPMREM(t) {
          const e = this._renderer,
            n = e.autoClear;
          e.autoClear = !1;
          for (let e = 1; e < es; e++) {
            const n = Math.sqrt(ls[e] * ls[e] - ls[e - 1] * ls[e - 1]),
              i = ps[(e - 1) % ps.length];
            this._blur(t, e - 1, e, n, i);
          }
          e.autoClear = n;
        }
        _blur(t, e, n, i, r) {
          const o = this._pingPongRenderTarget;
          this._halfBlur(t, o, e, n, i, "latitudinal", r),
            this._halfBlur(o, t, n, n, i, "longitudinal", r);
        }
        _halfBlur(t, e, n, i, r, o, s) {
          const a = this._renderer,
            l = this._blurMaterial;
          "latitudinal" !== o &&
            "longitudinal" !== o &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const c = new xo(ss[i], l),
            u = l.uniforms,
            h = as[n] - 1,
            d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
            p = r / d,
            f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
          f > 20 &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
            );
          const m = [];
          let g = 0;
          for (let t = 0; t < 20; ++t) {
            const e = t / p,
              n = Math.exp((-e * e) / 2);
            m.push(n), 0 == t ? (g += n) : t < f && (g += 2 * n);
          }
          for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
          (u.envMap.value = t.texture),
            (u.samples.value = f),
            (u.weights.value = m),
            (u.latitudinal.value = "latitudinal" === o),
            s && (u.poleAxis.value = s),
            (u.dTheta.value = d),
            (u.mipInt.value = 8 - n),
            (u.inputEncoding.value = ns[t.texture.encoding]),
            (u.outputEncoding.value = ns[t.texture.encoding]);
          const v = as[i];
          xs(
            e,
            3 * Math.max(0, $o - 2 * v),
            (0 === i ? 0 : 2 * $o) + 2 * v * (i > 4 ? i - 8 + 4 : 0),
            3 * v,
            2 * v
          ),
            a.setRenderTarget(e),
            a.render(c, os);
        }
      }
      function gs(t) {
        return (
          void 0 !== t &&
          t.type === Mt &&
          (t.encoding === Ze || t.encoding === Je || t.encoding === Ke)
        );
      }
      function vs() {
        const t = [],
          e = [],
          n = [];
        let i = 8;
        for (let r = 0; r < es; r++) {
          const o = Math.pow(2, i);
          e.push(o);
          let s = 1 / o;
          r > 4 ? (s = ts[r - 8 + 4 - 1]) : 0 == r && (s = 0), n.push(s);
          const a = 1 / (o - 1),
            l = -a / 2,
            c = 1 + a / 2,
            u = [l, l, c, l, c, c, l, l, c, c, l, c],
            h = 6,
            d = 6,
            p = 3,
            f = 2,
            m = 1,
            g = new Float32Array(p * d * h),
            v = new Float32Array(f * d * h),
            y = new Float32Array(m * d * h);
          for (let t = 0; t < h; t++) {
            const e = ((t % 3) * 2) / 3 - 1,
              n = t > 2 ? 0 : -1,
              i = [
                e,
                n,
                0,
                e + 2 / 3,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n + 1,
                0,
              ];
            g.set(i, p * d * t), v.set(u, f * d * t);
            const r = [t, t, t, t, t, t];
            y.set(r, m * d * t);
          }
          const x = new $r();
          x.setAttribute("position", new Nr(g, p)),
            x.setAttribute("uv", new Nr(v, f)),
            x.setAttribute("faceIndex", new Nr(y, m)),
            t.push(x),
            i > 4 && i--;
        }
        return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
      }
      function ys(t) {
        const e = new ni(3 * $o, 3 * $o, t);
        return (
          (e.texture.mapping = lt),
          (e.texture.name = "PMREM.cubeUv"),
          (e.scissorTest = !0),
          e
        );
      }
      function xs(t, e, n, i, r) {
        t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
      }
      function bs() {
        const t = new Yn(1, 1);
        return new Qo({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: { value: null },
            texelSize: { value: t },
            inputEncoding: { value: ns[Ze] },
            outputEncoding: { value: ns[Ze] },
          },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
          blending: y,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function ws() {
        return new Qo({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: { value: null },
            inputEncoding: { value: ns[Ze] },
            outputEncoding: { value: ns[Ze] },
          },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
          blending: y,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function _s(t) {
        let e = new WeakMap(),
          n = null;
        function i(t) {
          const n = t.target;
          n.removeEventListener("dispose", i);
          const r = e.get(n);
          void 0 !== r && (r.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
              const o = r.mapping,
                s = o === st || o === at,
                a = o === rt || o === ot;
              if (s || a) {
                if (e.has(r)) return e.get(r).texture;
                {
                  const o = r.image;
                  if (
                    (s && o && o.height > 0) ||
                    (a &&
                      o &&
                      (function (t) {
                        let e = 0;
                        for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                        return 6 === e;
                      })(o))
                  ) {
                    const o = t.getRenderTarget();
                    null === n && (n = new ms(t));
                    const a = s ? n.fromEquirectangular(r) : n.fromCubemap(r);
                    return (
                      e.set(r, a),
                      t.setRenderTarget(o),
                      r.addEventListener("dispose", i),
                      a.texture
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
          },
        };
      }
      function Ms(t) {
        const e = {};
        function n(n) {
          if (void 0 !== e[n]) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                t.getExtension("WEBGL_depth_texture") ||
                t.getExtension("MOZ_WEBGL_depth_texture") ||
                t.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                t.getExtension("EXT_texture_filter_anisotropic") ||
                t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                t.getExtension("WEBGL_compressed_texture_s3tc") ||
                t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = t.getExtension(n);
          }
          return (e[n] = i), i;
        }
        return {
          has: function (t) {
            return null !== n(t);
          },
          init: function (t) {
            t.isWebGL2
              ? n("EXT_color_buffer_float")
              : (n("WEBGL_depth_texture"),
                n("OES_texture_float"),
                n("OES_texture_half_float"),
                n("OES_texture_half_float_linear"),
                n("OES_standard_derivatives"),
                n("OES_element_index_uint"),
                n("OES_vertex_array_object"),
                n("ANGLE_instanced_arrays")),
              n("OES_texture_float_linear"),
              n("EXT_color_buffer_half_float");
          },
          get: function (t) {
            const e = n(t);
            return (
              null === e &&
                console.warn(
                  "THREE.WebGLRenderer: " + t + " extension not supported."
                ),
              e
            );
          },
        };
      }
      function Ss(t, e, n, i) {
        const r = {},
          o = new WeakMap();
        function s(t) {
          const a = t.target;
          null !== a.index && e.remove(a.index);
          for (const t in a.attributes) e.remove(a.attributes[t]);
          a.removeEventListener("dispose", s), delete r[a.id];
          const l = o.get(a);
          l && (e.remove(l), o.delete(a)),
            i.releaseStatesOfGeometry(a),
            !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
            n.memory.geometries--;
        }
        function a(t) {
          const n = [],
            i = t.index,
            r = t.attributes.position;
          let s = 0;
          if (null !== i) {
            const t = i.array;
            s = i.version;
            for (let e = 0, i = t.length; e < i; e += 3) {
              const i = t[e + 0],
                r = t[e + 1],
                o = t[e + 2];
              n.push(i, r, r, o, o, i);
            }
          } else {
            const t = r.array;
            s = r.version;
            for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
              const t = e + 0,
                i = e + 1,
                r = e + 2;
              n.push(t, i, i, r, r, t);
            }
          }
          const a = new (Gr(n) > 65535 ? zr : kr)(n, 1);
          a.version = s;
          const l = o.get(t);
          l && e.remove(l), o.set(t, a);
        }
        return {
          get: function (t, e) {
            return (
              !0 === r[e.id] ||
                (e.addEventListener("dispose", s),
                (r[e.id] = !0),
                n.memory.geometries++),
              e
            );
          },
          update: function (t) {
            const n = t.attributes;
            for (const t in n) e.update(n[t], 34962);
            const i = t.morphAttributes;
            for (const t in i) {
              const n = i[t];
              for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);
            }
          },
          getWireframeAttribute: function (t) {
            const e = o.get(t);
            if (e) {
              const n = t.index;
              null !== n && e.version < n.version && a(t);
            } else a(t);
            return o.get(t);
          },
        };
      }
      function Es(t, e, n, i) {
        const r = i.isWebGL2;
        let o, s, a;
        (this.setMode = function (t) {
          o = t;
        }),
          (this.setIndex = function (t) {
            (s = t.type), (a = t.bytesPerElement);
          }),
          (this.render = function (e, i) {
            t.drawElements(o, i, s, e * a), n.update(i, o, 1);
          }),
          (this.renderInstances = function (i, l, c) {
            if (0 === c) return;
            let u, h;
            if (r) (u = t), (h = "drawElementsInstanced");
            else if (
              ((u = e.get("ANGLE_instanced_arrays")),
              (h = "drawElementsInstancedANGLE"),
              null === u)
            )
              return void console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            u[h](o, l, s, i * a, c), n.update(l, o, c);
          });
      }
      function Ts(t) {
        const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: e,
          programs: null,
          autoReset: !0,
          reset: function () {
            e.frame++,
              (e.calls = 0),
              (e.triangles = 0),
              (e.points = 0),
              (e.lines = 0);
          },
          update: function (t, n, i) {
            switch ((e.calls++, n)) {
              case 4:
                e.triangles += i * (t / 3);
                break;
              case 1:
                e.lines += i * (t / 2);
                break;
              case 3:
                e.lines += i * (t - 1);
                break;
              case 2:
                e.lines += i * t;
                break;
              case 0:
                e.points += i * t;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", n);
            }
          },
        };
      }
      function As(t, e) {
        return t[0] - e[0];
      }
      function Cs(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1]);
      }
      function Ls(t) {
        const e = {},
          n = new Float32Array(8),
          i = [];
        for (let t = 0; t < 8; t++) i[t] = [t, 0];
        return {
          update: function (r, o, s, a) {
            const l = r.morphTargetInfluences,
              c = void 0 === l ? 0 : l.length;
            let u = e[o.id];
            if (void 0 === u || u.length !== c) {
              u = [];
              for (let t = 0; t < c; t++) u[t] = [t, 0];
              e[o.id] = u;
            }
            for (let t = 0; t < c; t++) {
              const e = u[t];
              (e[0] = t), (e[1] = l[t]);
            }
            u.sort(Cs);
            for (let t = 0; t < 8; t++)
              t < c && u[t][1]
                ? ((i[t][0] = u[t][0]), (i[t][1] = u[t][1]))
                : ((i[t][0] = Number.MAX_SAFE_INTEGER), (i[t][1] = 0));
            i.sort(As);
            const h = o.morphAttributes.position,
              d = o.morphAttributes.normal;
            let p = 0;
            for (let t = 0; t < 8; t++) {
              const e = i[t],
                r = e[0],
                s = e[1];
              r !== Number.MAX_SAFE_INTEGER && s
                ? (h &&
                    o.getAttribute("morphTarget" + t) !== h[r] &&
                    o.setAttribute("morphTarget" + t, h[r]),
                  d &&
                    o.getAttribute("morphNormal" + t) !== d[r] &&
                    o.setAttribute("morphNormal" + t, d[r]),
                  (n[t] = s),
                  (p += s))
                : (h &&
                    !0 === o.hasAttribute("morphTarget" + t) &&
                    o.deleteAttribute("morphTarget" + t),
                  d &&
                    !0 === o.hasAttribute("morphNormal" + t) &&
                    o.deleteAttribute("morphNormal" + t),
                  (n[t] = 0));
            }
            const f = o.morphTargetsRelative ? 1 : 1 - p;
            a.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
              a.getUniforms().setValue(t, "morphTargetInfluences", n);
          },
        };
      }
      function Rs(t, e, n, i) {
        let r = new WeakMap();
        function o(t) {
          const e = t.target;
          e.removeEventListener("dispose", o),
            n.remove(e.instanceMatrix),
            null !== e.instanceColor && n.remove(e.instanceColor);
        }
        return {
          update: function (t) {
            const s = i.render.frame,
              a = t.geometry,
              l = e.get(t, a);
            return (
              r.get(l) !== s && (e.update(l), r.set(l, s)),
              t.isInstancedMesh &&
                (!1 === t.hasEventListener("dispose", o) &&
                  t.addEventListener("dispose", o),
                n.update(t.instanceMatrix, 34962),
                null !== t.instanceColor && n.update(t.instanceColor, 34962)),
              l
            );
          },
          dispose: function () {
            r = new WeakMap();
          },
        };
      }
      class Ps extends $n {
        constructor(t = null, e = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: t, width: e, height: n, depth: i }),
            (this.magFilter = pt),
            (this.minFilter = pt),
            (this.wrapR = ht),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      Ps.prototype.isDataTexture2DArray = !0;
      class Ns extends $n {
        constructor(t = null, e = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: t, width: e, height: n, depth: i }),
            (this.magFilter = pt),
            (this.minFilter = pt),
            (this.wrapR = ht),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      Ns.prototype.isDataTexture3D = !0;
      const Is = new $n(),
        Bs = new Ps(),
        Os = new Ns(),
        Ds = new Ro(),
        ks = [],
        Fs = [],
        zs = new Float32Array(16),
        Hs = new Float32Array(9),
        Us = new Float32Array(4);
      function Vs(t, e, n) {
        const i = t[0];
        if (i <= 0 || i > 0) return t;
        const r = e * n;
        let o = ks[r];
        if (
          (void 0 === o && ((o = new Float32Array(r)), (ks[r] = o)), 0 !== e)
        ) {
          i.toArray(o, 0);
          for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(o, r);
        }
        return o;
      }
      function Gs(t, e) {
        if (t.length !== e.length) return !1;
        for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
        return !0;
      }
      function js(t, e) {
        for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
      }
      function Ws(t, e) {
        let n = Fs[e];
        void 0 === n && ((n = new Int32Array(e)), (Fs[e] = n));
        for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
        return n;
      }
      function qs(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
      }
      function Xs(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y) ||
            (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
        else {
          if (Gs(n, e)) return;
          t.uniform2fv(this.addr, e), js(n, e);
        }
      }
      function Ys(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
            (t.uniform3f(this.addr, e.x, e.y, e.z),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z));
        else if (void 0 !== e.r)
          (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
            (t.uniform3f(this.addr, e.r, e.g, e.b),
            (n[0] = e.r),
            (n[1] = e.g),
            (n[2] = e.b));
        else {
          if (Gs(n, e)) return;
          t.uniform3fv(this.addr, e), js(n, e);
        }
      }
      function Zs(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
            (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z),
            (n[3] = e.w));
        else {
          if (Gs(n, e)) return;
          t.uniform4fv(this.addr, e), js(n, e);
        }
      }
      function Js(t, e) {
        const n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (Gs(n, e)) return;
          t.uniformMatrix2fv(this.addr, !1, e), js(n, e);
        } else {
          if (Gs(n, i)) return;
          Us.set(i), t.uniformMatrix2fv(this.addr, !1, Us), js(n, i);
        }
      }
      function Ks(t, e) {
        const n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (Gs(n, e)) return;
          t.uniformMatrix3fv(this.addr, !1, e), js(n, e);
        } else {
          if (Gs(n, i)) return;
          Hs.set(i), t.uniformMatrix3fv(this.addr, !1, Hs), js(n, i);
        }
      }
      function Qs(t, e) {
        const n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (Gs(n, e)) return;
          t.uniformMatrix4fv(this.addr, !1, e), js(n, e);
        } else {
          if (Gs(n, i)) return;
          zs.set(i), t.uniformMatrix4fv(this.addr, !1, zs), js(n, i);
        }
      }
      function $s(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
      }
      function ta(t, e) {
        const n = this.cache;
        Gs(n, e) || (t.uniform2iv(this.addr, e), js(n, e));
      }
      function ea(t, e) {
        const n = this.cache;
        Gs(n, e) || (t.uniform3iv(this.addr, e), js(n, e));
      }
      function na(t, e) {
        const n = this.cache;
        Gs(n, e) || (t.uniform4iv(this.addr, e), js(n, e));
      }
      function ia(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
      }
      function ra(t, e) {
        const n = this.cache;
        Gs(n, e) || (t.uniform2uiv(this.addr, e), js(n, e));
      }
      function oa(t, e) {
        const n = this.cache;
        Gs(n, e) || (t.uniform3uiv(this.addr, e), js(n, e));
      }
      function sa(t, e) {
        const n = this.cache;
        Gs(n, e) || (t.uniform4uiv(this.addr, e), js(n, e));
      }
      function aa(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.safeSetTexture2D(e || Is, r);
      }
      function la(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture3D(e || Os, r);
      }
      function ca(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.safeSetTextureCube(e || Ds, r);
      }
      function ua(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2DArray(e || Bs, r);
      }
      function ha(t, e) {
        t.uniform1fv(this.addr, e);
      }
      function da(t, e) {
        const n = Vs(e, this.size, 2);
        t.uniform2fv(this.addr, n);
      }
      function pa(t, e) {
        const n = Vs(e, this.size, 3);
        t.uniform3fv(this.addr, n);
      }
      function fa(t, e) {
        const n = Vs(e, this.size, 4);
        t.uniform4fv(this.addr, n);
      }
      function ma(t, e) {
        const n = Vs(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n);
      }
      function ga(t, e) {
        const n = Vs(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n);
      }
      function va(t, e) {
        const n = Vs(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n);
      }
      function ya(t, e) {
        t.uniform1iv(this.addr, e);
      }
      function xa(t, e) {
        t.uniform2iv(this.addr, e);
      }
      function ba(t, e) {
        t.uniform3iv(this.addr, e);
      }
      function wa(t, e) {
        t.uniform4iv(this.addr, e);
      }
      function _a(t, e) {
        t.uniform1uiv(this.addr, e);
      }
      function Ma(t, e) {
        t.uniform2uiv(this.addr, e);
      }
      function Sa(t, e) {
        t.uniform3uiv(this.addr, e);
      }
      function Ea(t, e) {
        t.uniform4uiv(this.addr, e);
      }
      function Ta(t, e, n) {
        const i = e.length,
          r = Ws(n, i);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || Is, r[t]);
      }
      function Aa(t, e, n) {
        const i = e.length,
          r = Ws(n, i);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Ds, r[t]);
      }
      function Ca(t, e, n) {
        (this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return qs;
              case 35664:
                return Xs;
              case 35665:
                return Ys;
              case 35666:
                return Zs;
              case 35674:
                return Js;
              case 35675:
                return Ks;
              case 35676:
                return Qs;
              case 5124:
              case 35670:
                return $s;
              case 35667:
              case 35671:
                return ta;
              case 35668:
              case 35672:
                return ea;
              case 35669:
              case 35673:
                return na;
              case 5125:
                return ia;
              case 36294:
                return ra;
              case 36295:
                return oa;
              case 36296:
                return sa;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return aa;
              case 35679:
              case 36299:
              case 36307:
                return la;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return ca;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return ua;
            }
          })(e.type));
      }
      function La(t, e, n) {
        (this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return ha;
              case 35664:
                return da;
              case 35665:
                return pa;
              case 35666:
                return fa;
              case 35674:
                return ma;
              case 35675:
                return ga;
              case 35676:
                return va;
              case 5124:
              case 35670:
                return ya;
              case 35667:
              case 35671:
                return xa;
              case 35668:
              case 35672:
                return ba;
              case 35669:
              case 35673:
                return wa;
              case 5125:
                return _a;
              case 36294:
                return Ma;
              case 36295:
                return Sa;
              case 36296:
                return Ea;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Ta;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return Aa;
            }
          })(e.type));
      }
      function Ra(t) {
        (this.id = t), (this.seq = []), (this.map = {});
      }
      (La.prototype.updateCache = function (t) {
        const e = this.cache;
        t instanceof Float32Array &&
          e.length !== t.length &&
          (this.cache = new Float32Array(t.length)),
          js(e, t);
      }),
        (Ra.prototype.setValue = function (t, e, n) {
          const i = this.seq;
          for (let r = 0, o = i.length; r !== o; ++r) {
            const o = i[r];
            o.setValue(t, e[o.id], n);
          }
        });
      const Pa = /(\w+)(\])?(\[|\.)?/g;
      function Na(t, e) {
        t.seq.push(e), (t.map[e.id] = e);
      }
      function Ia(t, e, n) {
        const i = t.name,
          r = i.length;
        for (Pa.lastIndex = 0; ; ) {
          const o = Pa.exec(i),
            s = Pa.lastIndex;
          let a = o[1];
          const l = "]" === o[2],
            c = o[3];
          if ((l && (a |= 0), void 0 === c || ("[" === c && s + 2 === r))) {
            Na(n, void 0 === c ? new Ca(a, t, e) : new La(a, t, e));
            break;
          }
          {
            let t = n.map[a];
            void 0 === t && ((t = new Ra(a)), Na(n, t)), (n = t);
          }
        }
      }
      function Ba(t, e) {
        (this.seq = []), (this.map = {});
        const n = t.getProgramParameter(e, 35718);
        for (let i = 0; i < n; ++i) {
          const n = t.getActiveUniform(e, i);
          Ia(n, t.getUniformLocation(e, n.name), this);
        }
      }
      function Oa(t, e, n) {
        const i = t.createShader(e);
        return t.shaderSource(i, n), t.compileShader(i), i;
      }
      (Ba.prototype.setValue = function (t, e, n, i) {
        const r = this.map[e];
        void 0 !== r && r.setValue(t, n, i);
      }),
        (Ba.prototype.setOptional = function (t, e, n) {
          const i = e[n];
          void 0 !== i && this.setValue(t, n, i);
        }),
        (Ba.upload = function (t, e, n, i) {
          for (let r = 0, o = e.length; r !== o; ++r) {
            const o = e[r],
              s = n[o.id];
            !1 !== s.needsUpdate && o.setValue(t, s.value, i);
          }
        }),
        (Ba.seqWithValue = function (t, e) {
          const n = [];
          for (let i = 0, r = t.length; i !== r; ++i) {
            const r = t[i];
            r.id in e && n.push(r);
          }
          return n;
        });
      let Da = 0;
      function ka(t) {
        switch (t) {
          case Ze:
            return ["Linear", "( value )"];
          case Je:
            return ["sRGB", "( value )"];
          case Qe:
            return ["RGBE", "( value )"];
          case tn:
            return ["RGBM", "( value, 7.0 )"];
          case en:
            return ["RGBM", "( value, 16.0 )"];
          case nn:
            return ["RGBD", "( value, 256.0 )"];
          case Ke:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case $e:
            return ["LogLuv", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
              ["Linear", "( value )"]
            );
        }
      }
      function Fa(t, e, n) {
        const i = t.getShaderParameter(e, 35713),
          r = t.getShaderInfoLog(e).trim();
        return i && "" === r
          ? ""
          : "THREE.WebGLShader: gl.getShaderInfoLog() " +
              n +
              "\n" +
              r +
              (function (t) {
                const e = t.split("\n");
                for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                return e.join("\n");
              })(t.getShaderSource(e));
      }
      function za(t, e) {
        const n = ka(e);
        return (
          "vec4 " +
          t +
          "( vec4 value ) { return " +
          n[0] +
          "ToLinear" +
          n[1] +
          "; }"
        );
      }
      function Ha(t, e) {
        const n = ka(e);
        return (
          "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        );
      }
      function Ua(t, e) {
        let n;
        switch (e) {
          case Q:
            n = "Linear";
            break;
          case $:
            n = "Reinhard";
            break;
          case tt:
            n = "OptimizedCineon";
            break;
          case et:
            n = "ACESFilmic";
            break;
          case nt:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (n = "Linear");
        }
        return (
          "vec3 " +
          t +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      function Va(t) {
        return "" !== t;
      }
      function Ga(t, e) {
        return t
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function ja(t, e) {
        return t
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const Wa = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function qa(t) {
        return t.replace(Wa, Xa);
      }
      function Xa(t, e) {
        const n = Vo[e];
        if (void 0 === n)
          throw new Error("Can not resolve #include <" + e + ">");
        return qa(n);
      }
      const Ya =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        Za =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Ja(t) {
        return t.replace(Za, Qa).replace(Ya, Ka);
      }
      function Ka(t, e, n, i) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          Qa(0, e, n, i)
        );
      }
      function Qa(t, e, n, i) {
        let r = "";
        for (let t = parseInt(e); t < parseInt(n); t++)
          r += i
            .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, t);
        return r;
      }
      function $a(t) {
        let e =
          "precision " +
          t.precision +
          " float;\nprecision " +
          t.precision +
          " int;";
        return (
          "highp" === t.precision
            ? (e += "\n#define HIGH_PRECISION")
            : "mediump" === t.precision
            ? (e += "\n#define MEDIUM_PRECISION")
            : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
          e
        );
      }
      function tl(t, e, n, i) {
        const r = t.getContext(),
          o = n.defines;
        let s = n.vertexShader,
          a = n.fragmentShader;
        const l = (function (t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return (
              t.shadowMapType === u
                ? (e = "SHADOWMAP_TYPE_PCF")
                : t.shadowMapType === h
                ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                : t.shadowMapType === d && (e = "SHADOWMAP_TYPE_VSM"),
              e
            );
          })(n),
          c = (function (t) {
            let e = "ENVMAP_TYPE_CUBE";
            if (t.envMap)
              switch (t.envMapMode) {
                case rt:
                case ot:
                  e = "ENVMAP_TYPE_CUBE";
                  break;
                case lt:
                case ct:
                  e = "ENVMAP_TYPE_CUBE_UV";
              }
            return e;
          })(n),
          p = (function (t) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (t.envMap)
              switch (t.envMapMode) {
                case ot:
                case ct:
                  e = "ENVMAP_MODE_REFRACTION";
              }
            return e;
          })(n),
          f = (function (t) {
            let e = "ENVMAP_BLENDING_NONE";
            if (t.envMap)
              switch (t.combine) {
                case Y:
                  e = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case Z:
                  e = "ENVMAP_BLENDING_MIX";
                  break;
                case J:
                  e = "ENVMAP_BLENDING_ADD";
              }
            return e;
          })(n),
          m = t.gammaFactor > 0 ? t.gammaFactor : 1,
          g = n.isWebGL2
            ? ""
            : (function (t) {
                return [
                  t.extensionDerivatives ||
                  t.envMapCubeUV ||
                  t.bumpMap ||
                  t.tangentSpaceNormalMap ||
                  t.clearcoatNormalMap ||
                  t.flatShading ||
                  "physical" === t.shaderID
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                  t.rendererExtensionFragDepth
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (t.extensionShaderTextureLOD ||
                    t.envMap ||
                    t.transmission > 0) &&
                  t.rendererExtensionShaderTextureLod
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(Va)
                  .join("\n");
              })(n),
          v = (function (t) {
            const e = [];
            for (const n in t) {
              const i = t[n];
              !1 !== i && e.push("#define " + n + " " + i);
            }
            return e.join("\n");
          })(o),
          y = r.createProgram();
        let x,
          b,
          w = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial
          ? ((x = [v].filter(Va).join("\n")),
            x.length > 0 && (x += "\n"),
            (b = [g, v].filter(Va).join("\n")),
            b.length > 0 && (b += "\n"))
          : ((x = [
              $a(n),
              "#define SHADER_NAME " + n.shaderName,
              v,
              n.instancing ? "#define USE_INSTANCING" : "",
              n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + m,
              "#define MAX_BONES " + n.maxBones,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + p : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.displacementMap && n.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.useVertexTexture ? "#define BONE_TEXTURE" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + l : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(Va)
              .join("\n")),
            (b = [
              g,
              $a(n),
              "#define SHADER_NAME " + n.shaderName,
              v,
              n.alphaTest
                ? "#define ALPHATEST " +
                  n.alphaTest +
                  (n.alphaTest % 1 ? "" : ".0")
                : "",
              "#define GAMMA_FACTOR " + m,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.matcap ? "#define USE_MATCAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + c : "",
              n.envMap ? "#define " + p : "",
              n.envMap ? "#define " + f : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.sheen ? "#define USE_SHEEN" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.gradientMap ? "#define USE_GRADIENTMAP" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + l : "",
              n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              n.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              (n.extensionShaderTextureLOD || n.envMap) &&
              n.rendererExtensionShaderTextureLod
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              n.toneMapping !== K ? "#define TONE_MAPPING" : "",
              n.toneMapping !== K ? Vo.tonemapping_pars_fragment : "",
              n.toneMapping !== K ? Ua("toneMapping", n.toneMapping) : "",
              n.dithering ? "#define DITHERING" : "",
              Vo.encodings_pars_fragment,
              n.map ? za("mapTexelToLinear", n.mapEncoding) : "",
              n.matcap ? za("matcapTexelToLinear", n.matcapEncoding) : "",
              n.envMap ? za("envMapTexelToLinear", n.envMapEncoding) : "",
              n.emissiveMap
                ? za("emissiveMapTexelToLinear", n.emissiveMapEncoding)
                : "",
              n.specularTintMap
                ? za("specularTintMapTexelToLinear", n.specularTintMapEncoding)
                : "",
              n.lightMap ? za("lightMapTexelToLinear", n.lightMapEncoding) : "",
              Ha("linearToOutputTexel", n.outputEncoding),
              n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
              "\n",
            ]
              .filter(Va)
              .join("\n"))),
          (s = qa(s)),
          (s = Ga(s, n)),
          (s = ja(s, n)),
          (a = qa(a)),
          (a = Ga(a, n)),
          (a = ja(a, n)),
          (s = Ja(s)),
          (a = Ja(a)),
          n.isWebGL2 &&
            !0 !== n.isRawShaderMaterial &&
            ((w = "#version 300 es\n"),
            (x =
              [
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              x),
            (b =
              [
                "#define varying in",
                n.glslVersion === Bn ? "" : "out highp vec4 pc_fragColor;",
                n.glslVersion === Bn ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              b));
        const _ = w + b + a,
          M = Oa(r, 35633, w + x + s),
          S = Oa(r, 35632, _);
        if (
          (r.attachShader(y, M),
          r.attachShader(y, S),
          void 0 !== n.index0AttributeName
            ? r.bindAttribLocation(y, 0, n.index0AttributeName)
            : !0 === n.morphTargets && r.bindAttribLocation(y, 0, "position"),
          r.linkProgram(y),
          t.debug.checkShaderErrors)
        ) {
          const t = r.getProgramInfoLog(y).trim(),
            e = r.getShaderInfoLog(M).trim(),
            n = r.getShaderInfoLog(S).trim();
          let i = !0,
            o = !0;
          if (!1 === r.getProgramParameter(y, 35714)) {
            i = !1;
            const e = Fa(r, M, "vertex"),
              n = Fa(r, S, "fragment");
            console.error(
              "THREE.WebGLProgram: shader error: ",
              r.getError(),
              "35715",
              r.getProgramParameter(y, 35715),
              "gl.getProgramInfoLog",
              t,
              e,
              n
            );
          } else
            "" !== t
              ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t)
              : ("" !== e && "" !== n) || (o = !1);
          o &&
            (this.diagnostics = {
              runnable: i,
              programLog: t,
              vertexShader: { log: e, prefix: x },
              fragmentShader: { log: n, prefix: b },
            });
        }
        let E, T;
        return (
          r.deleteShader(M),
          r.deleteShader(S),
          (this.getUniforms = function () {
            return void 0 === E && (E = new Ba(r, y)), E;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === T &&
                (T = (function (t, e) {
                  const n = {},
                    i = t.getProgramParameter(e, 35721);
                  for (let r = 0; r < i; r++) {
                    const i = t.getActiveAttrib(e, r).name;
                    n[i] = t.getAttribLocation(e, i);
                  }
                  return n;
                })(r, y)),
              T
            );
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              r.deleteProgram(y),
              (this.program = void 0);
          }),
          (this.name = n.shaderName),
          (this.id = Da++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = y),
          (this.vertexShader = M),
          (this.fragmentShader = S),
          this
        );
      }
      function el(t, e, n, i, r, o, s) {
        const a = [],
          l = r.isWebGL2,
          c = r.logarithmicDepthBuffer,
          u = r.floatVertexTextures,
          h = r.maxVertexUniforms,
          d = r.vertexTextures;
        let p = r.precision;
        const g = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          },
          v = [
            "precision",
            "isWebGL2",
            "supportsVertexTextures",
            "outputEncoding",
            "instancing",
            "instancingColor",
            "map",
            "mapEncoding",
            "matcap",
            "matcapEncoding",
            "envMap",
            "envMapMode",
            "envMapEncoding",
            "envMapCubeUV",
            "lightMap",
            "lightMapEncoding",
            "aoMap",
            "emissiveMap",
            "emissiveMapEncoding",
            "bumpMap",
            "normalMap",
            "objectSpaceNormalMap",
            "tangentSpaceNormalMap",
            "clearcoatMap",
            "clearcoatRoughnessMap",
            "clearcoatNormalMap",
            "displacementMap",
            "specularMap",
            "specularIntensityMap",
            "specularTintMap",
            "specularTintMapEncoding",
            "roughnessMap",
            "metalnessMap",
            "gradientMap",
            "alphaMap",
            "combine",
            "vertexColors",
            "vertexAlphas",
            "vertexTangents",
            "vertexUvs",
            "uvsVertexOnly",
            "fog",
            "useFog",
            "fogExp2",
            "flatShading",
            "sizeAttenuation",
            "logarithmicDepthBuffer",
            "skinning",
            "maxBones",
            "useVertexTexture",
            "morphTargets",
            "morphNormals",
            "premultipliedAlpha",
            "numDirLights",
            "numPointLights",
            "numSpotLights",
            "numHemiLights",
            "numRectAreaLights",
            "numDirLightShadows",
            "numPointLightShadows",
            "numSpotLightShadows",
            "shadowMapEnabled",
            "shadowMapType",
            "toneMapping",
            "physicallyCorrectLights",
            "alphaTest",
            "doubleSided",
            "flipSided",
            "numClippingPlanes",
            "numClipIntersection",
            "depthPacking",
            "dithering",
            "sheen",
            "transmission",
            "transmissionMap",
            "thicknessMap",
          ];
        function y(t) {
          let e;
          return (
            t && t.isTexture
              ? (e = t.encoding)
              : t && t.isWebGLRenderTarget
              ? (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                ),
                (e = t.texture.encoding))
              : (e = Ze),
            e
          );
        }
        return {
          getParameters: function (o, a, v, x, b) {
            const w = x.fog,
              _ = o.isMeshStandardMaterial ? x.environment : null,
              M = (o.isMeshStandardMaterial ? n : e).get(o.envMap || _),
              S = g[o.type],
              E = b.isSkinnedMesh
                ? (function (t) {
                    const e = t.skeleton.bones;
                    if (u) return 1024;
                    {
                      const t = h,
                        n = Math.floor((t - 20) / 4),
                        i = Math.min(n, e.length);
                      return i < e.length
                        ? (console.warn(
                            "THREE.WebGLRenderer: Skeleton has " +
                              e.length +
                              " bones. This GPU supports " +
                              i +
                              "."
                          ),
                          0)
                        : i;
                    }
                  })(b)
                : 0;
            let T, A;
            if (
              (null !== o.precision &&
                ((p = r.getMaxPrecision(o.precision)),
                p !== o.precision &&
                  console.warn(
                    "THREE.WebGLProgram.getParameters:",
                    o.precision,
                    "not supported, using",
                    p,
                    "instead."
                  )),
              S)
            ) {
              const t = jo[S];
              (T = t.vertexShader), (A = t.fragmentShader);
            } else (T = o.vertexShader), (A = o.fragmentShader);
            const C = t.getRenderTarget();
            return {
              isWebGL2: l,
              shaderID: S,
              shaderName: o.type,
              vertexShader: T,
              fragmentShader: A,
              defines: o.defines,
              isRawShaderMaterial: !0 === o.isRawShaderMaterial,
              glslVersion: o.glslVersion,
              precision: p,
              instancing: !0 === b.isInstancedMesh,
              instancingColor:
                !0 === b.isInstancedMesh && null !== b.instanceColor,
              supportsVertexTextures: d,
              outputEncoding: null !== C ? y(C.texture) : t.outputEncoding,
              map: !!o.map,
              mapEncoding: y(o.map),
              matcap: !!o.matcap,
              matcapEncoding: y(o.matcap),
              envMap: !!M,
              envMapMode: M && M.mapping,
              envMapEncoding: y(M),
              envMapCubeUV: !!M && (M.mapping === lt || M.mapping === ct),
              lightMap: !!o.lightMap,
              lightMapEncoding: y(o.lightMap),
              aoMap: !!o.aoMap,
              emissiveMap: !!o.emissiveMap,
              emissiveMapEncoding: y(o.emissiveMap),
              bumpMap: !!o.bumpMap,
              normalMap: !!o.normalMap,
              objectSpaceNormalMap: o.normalMapType === an,
              tangentSpaceNormalMap: o.normalMapType === sn,
              clearcoatMap: !!o.clearcoatMap,
              clearcoatRoughnessMap: !!o.clearcoatRoughnessMap,
              clearcoatNormalMap: !!o.clearcoatNormalMap,
              displacementMap: !!o.displacementMap,
              roughnessMap: !!o.roughnessMap,
              metalnessMap: !!o.metalnessMap,
              specularMap: !!o.specularMap,
              specularIntensityMap: !!o.specularIntensityMap,
              specularTintMap: !!o.specularTintMap,
              specularTintMapEncoding: y(o.specularTintMap),
              alphaMap: !!o.alphaMap,
              gradientMap: !!o.gradientMap,
              sheen: !!o.sheen,
              transmission: !!o.transmission,
              transmissionMap: !!o.transmissionMap,
              thicknessMap: !!o.thicknessMap,
              combine: o.combine,
              vertexTangents:
                o.normalMap && b.geometry && b.geometry.attributes.tangent,
              vertexColors: o.vertexColors,
              vertexAlphas:
                !0 === o.vertexColors &&
                b.geometry &&
                b.geometry.attributes.color &&
                4 === b.geometry.attributes.color.itemSize,
              vertexUvs: !!(
                o.map ||
                o.bumpMap ||
                o.normalMap ||
                o.specularMap ||
                o.alphaMap ||
                o.emissiveMap ||
                o.roughnessMap ||
                o.metalnessMap ||
                o.clearcoatMap ||
                o.clearcoatRoughnessMap ||
                o.clearcoatNormalMap ||
                o.displacementMap ||
                o.transmissionMap ||
                o.thicknessMap ||
                o.specularIntensityMap ||
                o.specularTintMap
              ),
              uvsVertexOnly: !(
                o.map ||
                o.bumpMap ||
                o.normalMap ||
                o.specularMap ||
                o.alphaMap ||
                o.emissiveMap ||
                o.roughnessMap ||
                o.metalnessMap ||
                o.clearcoatNormalMap ||
                o.transmission ||
                o.transmissionMap ||
                o.thicknessMap ||
                o.specularIntensityMap ||
                o.specularTintMap ||
                !o.displacementMap
              ),
              fog: !!w,
              useFog: o.fog,
              fogExp2: w && w.isFogExp2,
              flatShading: !!o.flatShading,
              sizeAttenuation: o.sizeAttenuation,
              logarithmicDepthBuffer: c,
              skinning: !0 === b.isSkinnedMesh && E > 0,
              maxBones: E,
              useVertexTexture: u,
              morphTargets:
                b.geometry && void 0 !== b.geometry.morphAttributes.position,
              morphNormals:
                b.geometry && void 0 !== b.geometry.morphAttributes.normal,
              numDirLights: a.directional.length,
              numPointLights: a.point.length,
              numSpotLights: a.spot.length,
              numRectAreaLights: a.rectArea.length,
              numHemiLights: a.hemi.length,
              numDirLightShadows: a.directionalShadowMap.length,
              numPointLightShadows: a.pointShadowMap.length,
              numSpotLightShadows: a.spotShadowMap.length,
              numClippingPlanes: s.numPlanes,
              numClipIntersection: s.numIntersection,
              dithering: o.dithering,
              shadowMapEnabled: t.shadowMap.enabled && v.length > 0,
              shadowMapType: t.shadowMap.type,
              toneMapping: o.toneMapped ? t.toneMapping : K,
              physicallyCorrectLights: t.physicallyCorrectLights,
              premultipliedAlpha: o.premultipliedAlpha,
              alphaTest: o.alphaTest,
              doubleSided: o.side === m,
              flipSided: o.side === f,
              depthPacking: void 0 !== o.depthPacking && o.depthPacking,
              index0AttributeName: o.index0AttributeName,
              extensionDerivatives: o.extensions && o.extensions.derivatives,
              extensionFragDepth: o.extensions && o.extensions.fragDepth,
              extensionDrawBuffers: o.extensions && o.extensions.drawBuffers,
              extensionShaderTextureLOD:
                o.extensions && o.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: l || i.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                l || i.has("EXT_shader_texture_lod"),
              customProgramCacheKey: o.customProgramCacheKey(),
            };
          },
          getProgramCacheKey: function (e) {
            const n = [];
            if (
              (e.shaderID
                ? n.push(e.shaderID)
                : (n.push(e.fragmentShader), n.push(e.vertexShader)),
              void 0 !== e.defines)
            )
              for (const t in e.defines) n.push(t), n.push(e.defines[t]);
            if (!1 === e.isRawShaderMaterial) {
              for (let t = 0; t < v.length; t++) n.push(e[v[t]]);
              n.push(t.outputEncoding), n.push(t.gammaFactor);
            }
            return n.push(e.customProgramCacheKey), n.join();
          },
          getUniforms: function (t) {
            const e = g[t.type];
            let n;
            if (e) {
              const t = jo[e];
              n = So.clone(t.uniforms);
            } else n = t.uniforms;
            return n;
          },
          acquireProgram: function (e, n) {
            let i;
            for (let t = 0, e = a.length; t < e; t++) {
              const e = a[t];
              if (e.cacheKey === n) {
                (i = e), ++i.usedTimes;
                break;
              }
            }
            return void 0 === i && ((i = new tl(t, n, e, o)), a.push(i)), i;
          },
          releaseProgram: function (t) {
            if (0 == --t.usedTimes) {
              const e = a.indexOf(t);
              (a[e] = a[a.length - 1]), a.pop(), t.destroy();
            }
          },
          programs: a,
        };
      }
      function nl() {
        let t = new WeakMap();
        return {
          get: function (e) {
            let n = t.get(e);
            return void 0 === n && ((n = {}), t.set(e, n)), n;
          },
          remove: function (e) {
            t.delete(e);
          },
          update: function (e, n, i) {
            t.get(e)[n] = i;
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      function il(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.program !== e.program
          ? t.program.id - e.program.id
          : t.material.id !== e.material.id
          ? t.material.id - e.material.id
          : t.z !== e.z
          ? t.z - e.z
          : t.id - e.id;
      }
      function rl(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.z !== e.z
          ? e.z - t.z
          : t.id - e.id;
      }
      function ol(t) {
        const e = [];
        let n = 0;
        const i = [],
          r = [],
          o = [],
          s = { id: -1 };
        function a(i, r, o, a, l, c) {
          let u = e[n];
          const h = t.get(o);
          return (
            void 0 === u
              ? ((u = {
                  id: i.id,
                  object: i,
                  geometry: r,
                  material: o,
                  program: h.program || s,
                  groupOrder: a,
                  renderOrder: i.renderOrder,
                  z: l,
                  group: c,
                }),
                (e[n] = u))
              : ((u.id = i.id),
                (u.object = i),
                (u.geometry = r),
                (u.material = o),
                (u.program = h.program || s),
                (u.groupOrder = a),
                (u.renderOrder = i.renderOrder),
                (u.z = l),
                (u.group = c)),
            n++,
            u
          );
        }
        return {
          opaque: i,
          transmissive: r,
          transparent: o,
          init: function () {
            (n = 0), (i.length = 0), (r.length = 0), (o.length = 0);
          },
          push: function (t, e, n, s, l, c) {
            const u = a(t, e, n, s, l, c);
            n.transmission > 0
              ? r.push(u)
              : !0 === n.transparent
              ? o.push(u)
              : i.push(u);
          },
          unshift: function (t, e, n, s, l, c) {
            const u = a(t, e, n, s, l, c);
            n.transmission > 0
              ? r.unshift(u)
              : !0 === n.transparent
              ? o.unshift(u)
              : i.unshift(u);
          },
          finish: function () {
            for (let t = n, i = e.length; t < i; t++) {
              const n = e[t];
              if (null === n.id) break;
              (n.id = null),
                (n.object = null),
                (n.geometry = null),
                (n.material = null),
                (n.program = null),
                (n.group = null);
            }
          },
          sort: function (t, e) {
            i.length > 1 && i.sort(t || il),
              r.length > 1 && r.sort(e || rl),
              o.length > 1 && o.sort(e || rl);
          },
        };
      }
      function sl(t) {
        let e = new WeakMap();
        return {
          get: function (n, i) {
            let r;
            return (
              !1 === e.has(n)
                ? ((r = new ol(t)), e.set(n, [r]))
                : i >= e.get(n).length
                ? ((r = new ol(t)), e.get(n).push(r))
                : (r = e.get(n)[i]),
              r
            );
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function al() {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
              case "DirectionalLight":
                n = { direction: new si(), color: new Cr() };
                break;
              case "SpotLight":
                n = {
                  position: new si(),
                  direction: new si(),
                  color: new Cr(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                n = {
                  position: new si(),
                  color: new Cr(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new si(),
                  skyColor: new Cr(),
                  groundColor: new Cr(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new Cr(),
                  position: new si(),
                  halfWidth: new si(),
                  halfHeight: new si(),
                };
            }
            return (t[e.id] = n), n;
          },
        };
      }
      let ll = 0;
      function cl(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
      }
      function ul(t, e) {
        const n = new al(),
          i = (function () {
            const t = {};
            return {
              get: function (e) {
                if (void 0 !== t[e.id]) return t[e.id];
                let n;
                switch (e.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Yn(),
                    };
                    break;
                  case "PointLight":
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Yn(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (t[e.id] = n), n;
              },
            };
          })(),
          r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          };
        for (let t = 0; t < 9; t++) r.probe.push(new si());
        const o = new si(),
          s = new ki(),
          a = new ki();
        return {
          setup: function (o) {
            let s = 0,
              a = 0,
              l = 0;
            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
            let c = 0,
              u = 0,
              h = 0,
              d = 0,
              p = 0,
              f = 0,
              m = 0,
              g = 0;
            o.sort(cl);
            for (let t = 0, e = o.length; t < e; t++) {
              const e = o[t],
                v = e.color,
                y = e.intensity,
                x = e.distance,
                b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
              if (e.isAmbientLight)
                (s += v.r * y), (a += v.g * y), (l += v.b * y);
              else if (e.isLightProbe)
                for (let t = 0; t < 9; t++)
                  r.probe[t].addScaledVector(e.sh.coefficients[t], y);
              else if (e.isDirectionalLight) {
                const t = n.get(e);
                if (
                  (t.color.copy(e.color).multiplyScalar(e.intensity),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    n = i.get(e);
                  (n.shadowBias = t.bias),
                    (n.shadowNormalBias = t.normalBias),
                    (n.shadowRadius = t.radius),
                    (n.shadowMapSize = t.mapSize),
                    (r.directionalShadow[c] = n),
                    (r.directionalShadowMap[c] = b),
                    (r.directionalShadowMatrix[c] = e.shadow.matrix),
                    f++;
                }
                (r.directional[c] = t), c++;
              } else if (e.isSpotLight) {
                const t = n.get(e);
                if (
                  (t.position.setFromMatrixPosition(e.matrixWorld),
                  t.color.copy(v).multiplyScalar(y),
                  (t.distance = x),
                  (t.coneCos = Math.cos(e.angle)),
                  (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                  (t.decay = e.decay),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    n = i.get(e);
                  (n.shadowBias = t.bias),
                    (n.shadowNormalBias = t.normalBias),
                    (n.shadowRadius = t.radius),
                    (n.shadowMapSize = t.mapSize),
                    (r.spotShadow[h] = n),
                    (r.spotShadowMap[h] = b),
                    (r.spotShadowMatrix[h] = e.shadow.matrix),
                    g++;
                }
                (r.spot[h] = t), h++;
              } else if (e.isRectAreaLight) {
                const t = n.get(e);
                t.color.copy(v).multiplyScalar(y),
                  t.halfWidth.set(0.5 * e.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * e.height, 0),
                  (r.rectArea[d] = t),
                  d++;
              } else if (e.isPointLight) {
                const t = n.get(e);
                if (
                  (t.color.copy(e.color).multiplyScalar(e.intensity),
                  (t.distance = e.distance),
                  (t.decay = e.decay),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    n = i.get(e);
                  (n.shadowBias = t.bias),
                    (n.shadowNormalBias = t.normalBias),
                    (n.shadowRadius = t.radius),
                    (n.shadowMapSize = t.mapSize),
                    (n.shadowCameraNear = t.camera.near),
                    (n.shadowCameraFar = t.camera.far),
                    (r.pointShadow[u] = n),
                    (r.pointShadowMap[u] = b),
                    (r.pointShadowMatrix[u] = e.shadow.matrix),
                    m++;
                }
                (r.point[u] = t), u++;
              } else if (e.isHemisphereLight) {
                const t = n.get(e);
                t.skyColor.copy(e.color).multiplyScalar(y),
                  t.groundColor.copy(e.groundColor).multiplyScalar(y),
                  (r.hemi[p] = t),
                  p++;
              }
            }
            d > 0 &&
              (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
                ? ((r.rectAreaLTC1 = Go.LTC_FLOAT_1),
                  (r.rectAreaLTC2 = Go.LTC_FLOAT_2))
                : !0 === t.has("OES_texture_half_float_linear")
                ? ((r.rectAreaLTC1 = Go.LTC_HALF_1),
                  (r.rectAreaLTC2 = Go.LTC_HALF_2))
                : console.error(
                    "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                  )),
              (r.ambient[0] = s),
              (r.ambient[1] = a),
              (r.ambient[2] = l);
            const v = r.hash;
            (v.directionalLength === c &&
              v.pointLength === u &&
              v.spotLength === h &&
              v.rectAreaLength === d &&
              v.hemiLength === p &&
              v.numDirectionalShadows === f &&
              v.numPointShadows === m &&
              v.numSpotShadows === g) ||
              ((r.directional.length = c),
              (r.spot.length = h),
              (r.rectArea.length = d),
              (r.point.length = u),
              (r.hemi.length = p),
              (r.directionalShadow.length = f),
              (r.directionalShadowMap.length = f),
              (r.pointShadow.length = m),
              (r.pointShadowMap.length = m),
              (r.spotShadow.length = g),
              (r.spotShadowMap.length = g),
              (r.directionalShadowMatrix.length = f),
              (r.pointShadowMatrix.length = m),
              (r.spotShadowMatrix.length = g),
              (v.directionalLength = c),
              (v.pointLength = u),
              (v.spotLength = h),
              (v.rectAreaLength = d),
              (v.hemiLength = p),
              (v.numDirectionalShadows = f),
              (v.numPointShadows = m),
              (v.numSpotShadows = g),
              (r.version = ll++));
          },
          setupView: function (t, e) {
            let n = 0,
              i = 0,
              l = 0,
              c = 0,
              u = 0;
            const h = e.matrixWorldInverse;
            for (let e = 0, d = t.length; e < d; e++) {
              const d = t[e];
              if (d.isDirectionalLight) {
                const t = r.directional[n];
                t.direction.setFromMatrixPosition(d.matrixWorld),
                  o.setFromMatrixPosition(d.target.matrixWorld),
                  t.direction.sub(o),
                  t.direction.transformDirection(h),
                  n++;
              } else if (d.isSpotLight) {
                const t = r.spot[l];
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(h),
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                  o.setFromMatrixPosition(d.target.matrixWorld),
                  t.direction.sub(o),
                  t.direction.transformDirection(h),
                  l++;
              } else if (d.isRectAreaLight) {
                const t = r.rectArea[c];
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(h),
                  a.identity(),
                  s.copy(d.matrixWorld),
                  s.premultiply(h),
                  a.extractRotation(s),
                  t.halfWidth.set(0.5 * d.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * d.height, 0),
                  t.halfWidth.applyMatrix4(a),
                  t.halfHeight.applyMatrix4(a),
                  c++;
              } else if (d.isPointLight) {
                const t = r.point[i];
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(h),
                  i++;
              } else if (d.isHemisphereLight) {
                const t = r.hemi[u];
                t.direction.setFromMatrixPosition(d.matrixWorld),
                  t.direction.transformDirection(h),
                  t.direction.normalize(),
                  u++;
              }
            }
          },
          state: r,
        };
      }
      function hl(t, e) {
        const n = new ul(t, e),
          i = [],
          r = [];
        return {
          init: function () {
            (i.length = 0), (r.length = 0);
          },
          state: { lightsArray: i, shadowsArray: r, lights: n },
          setupLights: function () {
            n.setup(i);
          },
          setupLightsView: function (t) {
            n.setupView(i, t);
          },
          pushLight: function (t) {
            i.push(t);
          },
          pushShadow: function (t) {
            r.push(t);
          },
        };
      }
      function dl(t, e) {
        let n = new WeakMap();
        return {
          get: function (i, r = 0) {
            let o;
            return (
              !1 === n.has(i)
                ? ((o = new hl(t, e)), n.set(i, [o]))
                : r >= n.get(i).length
                ? ((o = new hl(t, e)), n.get(i).push(o))
                : (o = n.get(i)[r]),
              o
            );
          },
          dispose: function () {
            n = new WeakMap();
          },
        };
      }
      class pl extends wr {
        constructor(t) {
          super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = rn),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.depthPacking = t.depthPacking),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            this
          );
        }
      }
      pl.prototype.isMeshDepthMaterial = !0;
      class fl extends wr {
        constructor(t) {
          super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new si()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.referencePosition.copy(t.referencePosition),
            (this.nearDistance = t.nearDistance),
            (this.farDistance = t.farDistance),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            this
          );
        }
      }
      function ml(t, e, n) {
        let i = new Fo();
        const r = new Yn(),
          o = new Yn(),
          s = new ei(),
          a = new pl({ depthPacking: on }),
          l = new fl(),
          c = {},
          h = n.maxTextureSize,
          g = { 0: f, 1: p, 2: m },
          v = new Eo({
            defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new Yn() },
              radius: { value: 4 },
            },
            vertexShader:
              "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader:
              "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          }),
          x = v.clone();
        x.defines.HORIZONTAL_PASS = 1;
        const b = new $r();
        b.setAttribute(
          "position",
          new Nr(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const w = new xo(b, v),
          _ = this;
        function M(n, i) {
          const r = e.update(w);
          (v.uniforms.shadow_pass.value = n.map.texture),
            (v.uniforms.resolution.value = n.mapSize),
            (v.uniforms.radius.value = n.radius),
            t.setRenderTarget(n.mapPass),
            t.clear(),
            t.renderBufferDirect(i, null, r, v, w, null),
            (x.uniforms.shadow_pass.value = n.mapPass.texture),
            (x.uniforms.resolution.value = n.mapSize),
            (x.uniforms.radius.value = n.radius),
            t.setRenderTarget(n.map),
            t.clear(),
            t.renderBufferDirect(i, null, r, x, w, null);
        }
        function S(e, n, i, r, o, s, u) {
          let h = null;
          const p =
            !0 === r.isPointLight
              ? e.customDistanceMaterial
              : e.customDepthMaterial;
          if (
            ((h = void 0 !== p ? p : !0 === r.isPointLight ? l : a),
            t.localClippingEnabled &&
              !0 === i.clipShadows &&
              0 !== i.clippingPlanes.length)
          ) {
            const t = h.uuid,
              e = i.uuid;
            let n = c[t];
            void 0 === n && ((n = {}), (c[t] = n));
            let r = n[e];
            void 0 === r && ((r = h.clone()), (n[e] = r)), (h = r);
          }
          return (
            (h.visible = i.visible),
            (h.wireframe = i.wireframe),
            (h.side =
              u === d
                ? null !== i.shadowSide
                  ? i.shadowSide
                  : i.side
                : null !== i.shadowSide
                ? i.shadowSide
                : g[i.side]),
            (h.clipShadows = i.clipShadows),
            (h.clippingPlanes = i.clippingPlanes),
            (h.clipIntersection = i.clipIntersection),
            (h.wireframeLinewidth = i.wireframeLinewidth),
            (h.linewidth = i.linewidth),
            !0 === r.isPointLight &&
              !0 === h.isMeshDistanceMaterial &&
              (h.referencePosition.setFromMatrixPosition(r.matrixWorld),
              (h.nearDistance = o),
              (h.farDistance = s)),
            h
          );
        }
        function E(n, r, o, s, a) {
          if (!1 === n.visible) return;
          if (
            n.layers.test(r.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && a === d)) &&
            (!n.frustumCulled || i.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              o.matrixWorldInverse,
              n.matrixWorld
            );
            const i = e.update(n),
              r = n.material;
            if (Array.isArray(r)) {
              const e = i.groups;
              for (let l = 0, c = e.length; l < c; l++) {
                const c = e[l],
                  u = r[c.materialIndex];
                if (u && u.visible) {
                  const e = S(n, 0, u, s, o.near, o.far, a);
                  t.renderBufferDirect(o, null, i, e, n, c);
                }
              }
            } else if (r.visible) {
              const e = S(n, 0, r, s, o.near, o.far, a);
              t.renderBufferDirect(o, null, i, e, n, null);
            }
          }
          const l = n.children;
          for (let t = 0, e = l.length; t < e; t++) E(l[t], r, o, s, a);
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = u),
          (this.render = function (e, n, a) {
            if (!1 === _.enabled) return;
            if (!1 === _.autoUpdate && !1 === _.needsUpdate) return;
            if (0 === e.length) return;
            const l = t.getRenderTarget(),
              c = t.getActiveCubeFace(),
              u = t.getActiveMipmapLevel(),
              p = t.state;
            p.setBlending(y),
              p.buffers.color.setClear(1, 1, 1, 1),
              p.buffers.depth.setTest(!0),
              p.setScissorTest(!1);
            for (let l = 0, c = e.length; l < c; l++) {
              const c = e[l],
                u = c.shadow;
              if (void 0 === u) {
                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                continue;
              }
              if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
              r.copy(u.mapSize);
              const f = u.getFrameExtents();
              if (
                (r.multiply(f),
                o.copy(u.mapSize),
                (r.x > h || r.y > h) &&
                  (r.x > h &&
                    ((o.x = Math.floor(h / f.x)),
                    (r.x = o.x * f.x),
                    (u.mapSize.x = o.x)),
                  r.y > h &&
                    ((o.y = Math.floor(h / f.y)),
                    (r.y = o.y * f.y),
                    (u.mapSize.y = o.y))),
                null === u.map && !u.isPointLightShadow && this.type === d)
              ) {
                const t = { minFilter: yt, magFilter: yt, format: kt };
                (u.map = new ni(r.x, r.y, t)),
                  (u.map.texture.name = c.name + ".shadowMap"),
                  (u.mapPass = new ni(r.x, r.y, t)),
                  u.camera.updateProjectionMatrix();
              }
              if (null === u.map) {
                const t = { minFilter: pt, magFilter: pt, format: kt };
                (u.map = new ni(r.x, r.y, t)),
                  (u.map.texture.name = c.name + ".shadowMap"),
                  u.camera.updateProjectionMatrix();
              }
              t.setRenderTarget(u.map), t.clear();
              const m = u.getViewportCount();
              for (let t = 0; t < m; t++) {
                const e = u.getViewport(t);
                s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
                  p.viewport(s),
                  u.updateMatrices(c, t),
                  (i = u.getFrustum()),
                  E(n, a, u.camera, c, this.type);
              }
              u.isPointLightShadow || this.type !== d || M(u, a),
                (u.needsUpdate = !1);
            }
            (_.needsUpdate = !1), t.setRenderTarget(l, c, u);
          });
      }
      function gl(t, e, n) {
        const i = n.isWebGL2,
          r = new (function () {
            let e = !1;
            const n = new ei();
            let i = null;
            const r = new ei(0, 0, 0, 0);
            return {
              setMask: function (n) {
                i === n || e || (t.colorMask(n, n, n, n), (i = n));
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e, i, o, s, a) {
                !0 === a && ((e *= s), (i *= s), (o *= s)),
                  n.set(e, i, o, s),
                  !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n));
              },
              reset: function () {
                (e = !1), (i = null), r.set(-1, 0, 0, 0);
              },
            };
          })(),
          l = new (function () {
            let e = !1,
              n = null,
              i = null,
              r = null;
            return {
              setTest: function (t) {
                t ? yt(2929) : xt(2929);
              },
              setMask: function (i) {
                n === i || e || (t.depthMask(i), (n = i));
              },
              setFunc: function (e) {
                if (i !== e) {
                  if (e)
                    switch (e) {
                      case H:
                        t.depthFunc(512);
                        break;
                      case U:
                        t.depthFunc(519);
                        break;
                      case V:
                        t.depthFunc(513);
                        break;
                      case G:
                        t.depthFunc(515);
                        break;
                      case j:
                        t.depthFunc(514);
                        break;
                      case W:
                        t.depthFunc(518);
                        break;
                      case q:
                        t.depthFunc(516);
                        break;
                      case X:
                        t.depthFunc(517);
                        break;
                      default:
                        t.depthFunc(515);
                    }
                  else t.depthFunc(515);
                  i = e;
                }
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e) {
                r !== e && (t.clearDepth(e), (r = e));
              },
              reset: function () {
                (e = !1), (n = null), (i = null), (r = null);
              },
            };
          })(),
          c = new (function () {
            let e = !1,
              n = null,
              i = null,
              r = null,
              o = null,
              s = null,
              a = null,
              l = null,
              c = null;
            return {
              setTest: function (t) {
                e || (t ? yt(2960) : xt(2960));
              },
              setMask: function (i) {
                n === i || e || (t.stencilMask(i), (n = i));
              },
              setFunc: function (e, n, s) {
                (i === e && r === n && o === s) ||
                  (t.stencilFunc(e, n, s), (i = e), (r = n), (o = s));
              },
              setOp: function (e, n, i) {
                (s === e && a === n && l === i) ||
                  (t.stencilOp(e, n, i), (s = e), (a = n), (l = i));
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e) {
                c !== e && (t.clearStencil(e), (c = e));
              },
              reset: function () {
                (e = !1),
                  (n = null),
                  (i = null),
                  (r = null),
                  (o = null),
                  (s = null),
                  (a = null),
                  (l = null),
                  (c = null);
              },
            };
          })();
        let u = {},
          h = null,
          d = {},
          p = null,
          g = !1,
          v = null,
          Y = null,
          Z = null,
          J = null,
          K = null,
          Q = null,
          $ = null,
          tt = !1,
          et = null,
          nt = null,
          it = null,
          rt = null,
          ot = null;
        const st = t.getParameter(35661);
        let at = !1,
          lt = 0;
        const ct = t.getParameter(7938);
        -1 !== ct.indexOf("WebGL")
          ? ((lt = parseFloat(/^WebGL (\d)/.exec(ct)[1])), (at = lt >= 1))
          : -1 !== ct.indexOf("OpenGL ES") &&
            ((lt = parseFloat(/^OpenGL ES (\d)/.exec(ct)[1])), (at = lt >= 2));
        let ut = null,
          ht = {};
        const dt = t.getParameter(3088),
          pt = t.getParameter(2978),
          ft = new ei().fromArray(dt),
          mt = new ei().fromArray(pt);
        function gt(e, n, i) {
          const r = new Uint8Array(4),
            o = t.createTexture();
          t.bindTexture(e, o),
            t.texParameteri(e, 10241, 9728),
            t.texParameteri(e, 10240, 9728);
          for (let e = 0; e < i; e++)
            t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
          return o;
        }
        const vt = {};
        function yt(e) {
          !0 !== u[e] && (t.enable(e), (u[e] = !0));
        }
        function xt(e) {
          !1 !== u[e] && (t.disable(e), (u[e] = !1));
        }
        (vt[3553] = gt(3553, 3553, 1)),
          (vt[34067] = gt(34067, 34069, 6)),
          r.setClear(0, 0, 0, 1),
          l.setClear(1),
          c.setClear(0),
          yt(2929),
          l.setFunc(G),
          Mt(!1),
          St(s),
          yt(2884),
          _t(y);
        const bt = { [S]: 32774, [E]: 32778, [T]: 32779 };
        if (i) (bt[A] = 32775), (bt[C] = 32776);
        else {
          const t = e.get("EXT_blend_minmax");
          null !== t && ((bt[A] = t.MIN_EXT), (bt[C] = t.MAX_EXT));
        }
        const wt = {
          [L]: 0,
          [R]: 1,
          [P]: 768,
          [I]: 770,
          [z]: 776,
          [k]: 774,
          [O]: 772,
          [N]: 769,
          [B]: 771,
          [F]: 775,
          [D]: 773,
        };
        function _t(e, n, i, r, o, s, a, l) {
          if (e !== y) {
            if ((!1 === g && (yt(3042), (g = !0)), e === M))
              (o = o || n),
                (s = s || i),
                (a = a || r),
                (n === Y && o === K) ||
                  (t.blendEquationSeparate(bt[n], bt[o]), (Y = n), (K = o)),
                (i === Z && r === J && s === Q && a === $) ||
                  (t.blendFuncSeparate(wt[i], wt[r], wt[s], wt[a]),
                  (Z = i),
                  (J = r),
                  (Q = s),
                  ($ = a)),
                (v = e),
                (tt = null);
            else if (e !== v || l !== tt) {
              if (
                ((Y === S && K === S) ||
                  (t.blendEquation(32774), (Y = S), (K = S)),
                l)
              )
                switch (e) {
                  case x:
                    t.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case b:
                    t.blendFunc(1, 1);
                    break;
                  case w:
                    t.blendFuncSeparate(0, 0, 769, 771);
                    break;
                  case _:
                    t.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                }
              else
                switch (e) {
                  case x:
                    t.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case b:
                    t.blendFunc(770, 1);
                    break;
                  case w:
                    t.blendFunc(0, 769);
                    break;
                  case _:
                    t.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                }
              (Z = null), (J = null), (Q = null), ($ = null), (v = e), (tt = l);
            }
          } else !0 === g && (xt(3042), (g = !1));
        }
        function Mt(e) {
          et !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (et = e));
        }
        function St(e) {
          e !== o
            ? (yt(2884),
              e !== nt &&
                (e === s
                  ? t.cullFace(1029)
                  : e === a
                  ? t.cullFace(1028)
                  : t.cullFace(1032)))
            : xt(2884),
            (nt = e);
        }
        function Et(e, n, i) {
          e
            ? (yt(32823),
              (rt === n && ot === i) ||
                (t.polygonOffset(n, i), (rt = n), (ot = i)))
            : xt(32823);
        }
        function Tt(e) {
          void 0 === e && (e = 33984 + st - 1),
            ut !== e && (t.activeTexture(e), (ut = e));
        }
        return {
          buffers: { color: r, depth: l, stencil: c },
          enable: yt,
          disable: xt,
          bindFramebuffer: function (e, n) {
            return (
              null === n && null !== h && (n = h),
              d[e] !== n &&
                (t.bindFramebuffer(e, n),
                (d[e] = n),
                i &&
                  (36009 === e && (d[36160] = n),
                  36160 === e && (d[36009] = n)),
                !0)
            );
          },
          bindXRFramebuffer: function (e) {
            e !== h && (t.bindFramebuffer(36160, e), (h = e));
          },
          useProgram: function (e) {
            return p !== e && (t.useProgram(e), (p = e), !0);
          },
          setBlending: _t,
          setMaterial: function (t, e) {
            t.side === m ? xt(2884) : yt(2884);
            let n = t.side === f;
            e && (n = !n),
              Mt(n),
              t.blending === x && !1 === t.transparent
                ? _t(y)
                : _t(
                    t.blending,
                    t.blendEquation,
                    t.blendSrc,
                    t.blendDst,
                    t.blendEquationAlpha,
                    t.blendSrcAlpha,
                    t.blendDstAlpha,
                    t.premultipliedAlpha
                  ),
              l.setFunc(t.depthFunc),
              l.setTest(t.depthTest),
              l.setMask(t.depthWrite),
              r.setMask(t.colorWrite);
            const i = t.stencilWrite;
            c.setTest(i),
              i &&
                (c.setMask(t.stencilWriteMask),
                c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
              Et(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
              !0 === t.alphaToCoverage ? yt(32926) : xt(32926);
          },
          setFlipSided: Mt,
          setCullFace: St,
          setLineWidth: function (e) {
            e !== it && (at && t.lineWidth(e), (it = e));
          },
          setPolygonOffset: Et,
          setScissorTest: function (t) {
            t ? yt(3089) : xt(3089);
          },
          activeTexture: Tt,
          bindTexture: function (e, n) {
            null === ut && Tt();
            let i = ht[ut];
            void 0 === i &&
              ((i = { type: void 0, texture: void 0 }), (ht[ut] = i)),
              (i.type === e && i.texture === n) ||
                (t.bindTexture(e, n || vt[e]), (i.type = e), (i.texture = n));
          },
          unbindTexture: function () {
            const e = ht[ut];
            void 0 !== e &&
              void 0 !== e.type &&
              (t.bindTexture(e.type, null),
              (e.type = void 0),
              (e.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              t.compressedTexImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage2D: function () {
            try {
              t.texImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage3D: function () {
            try {
              t.texImage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          scissor: function (e) {
            !1 === ft.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ft.copy(e));
          },
          viewport: function (e) {
            !1 === mt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), mt.copy(e));
          },
          reset: function () {
            t.disable(3042),
              t.disable(2884),
              t.disable(2929),
              t.disable(32823),
              t.disable(3089),
              t.disable(2960),
              t.disable(32926),
              t.blendEquation(32774),
              t.blendFunc(1, 0),
              t.blendFuncSeparate(1, 0, 1, 0),
              t.colorMask(!0, !0, !0, !0),
              t.clearColor(0, 0, 0, 0),
              t.depthMask(!0),
              t.depthFunc(513),
              t.clearDepth(1),
              t.stencilMask(4294967295),
              t.stencilFunc(519, 0, 4294967295),
              t.stencilOp(7680, 7680, 7680),
              t.clearStencil(0),
              t.cullFace(1029),
              t.frontFace(2305),
              t.polygonOffset(0, 0),
              t.activeTexture(33984),
              t.bindFramebuffer(36160, null),
              !0 === i &&
                (t.bindFramebuffer(36009, null),
                t.bindFramebuffer(36008, null)),
              t.useProgram(null),
              t.lineWidth(1),
              t.scissor(0, 0, t.canvas.width, t.canvas.height),
              t.viewport(0, 0, t.canvas.width, t.canvas.height),
              (u = {}),
              (ut = null),
              (ht = {}),
              (h = null),
              (d = {}),
              (p = null),
              (g = !1),
              (v = null),
              (Y = null),
              (Z = null),
              (J = null),
              (K = null),
              (Q = null),
              ($ = null),
              (tt = !1),
              (et = null),
              (nt = null),
              (it = null),
              (rt = null),
              (ot = null),
              ft.set(0, 0, t.canvas.width, t.canvas.height),
              mt.set(0, 0, t.canvas.width, t.canvas.height),
              r.reset(),
              l.reset(),
              c.reset();
          },
        };
      }
      function vl(t, e, n, i, r, o, s) {
        const a = r.isWebGL2,
          l = r.maxTextures,
          c = r.maxCubemapSize,
          u = r.maxTextureSize,
          h = r.maxSamples,
          d = new WeakMap();
        let p,
          f = !1;
        try {
          f =
            "undefined" != typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (t) {}
        function m(t, e) {
          return f
            ? new OffscreenCanvas(t, e)
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
        }
        function g(t, e, n, i) {
          let r = 1;
          if (
            ((t.width > i || t.height > i) &&
              (r = i / Math.max(t.width, t.height)),
            r < 1 || !0 === e)
          ) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                t instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                t instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const i = e ? qn : Math.floor,
                o = i(r * t.width),
                s = i(r * t.height);
              void 0 === p && (p = m(o, s));
              const a = n ? m(o, s) : p;
              return (
                (a.width = o),
                (a.height = s),
                a.getContext("2d").drawImage(t, 0, 0, o, s),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    t.width +
                    "x" +
                    t.height +
                    ") to (" +
                    o +
                    "x" +
                    s +
                    ")."
                ),
                a
              );
            }
            return (
              "data" in t &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    t.width +
                    "x" +
                    t.height +
                    ")."
                ),
              t
            );
          }
          return t;
        }
        function v(t) {
          return jn(t.width) && jn(t.height);
        }
        function y(t, e) {
          return (
            t.generateMipmaps && e && t.minFilter !== pt && t.minFilter !== yt
          );
        }
        function x(e, n, r, o, s = 1) {
          t.generateMipmap(e),
            (i.get(n).__maxMipLevel = Math.log2(Math.max(r, o, s)));
        }
        function b(n, i, r) {
          if (!1 === a) return i;
          if (null !== n) {
            if (void 0 !== t[n]) return t[n];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'"
            );
          }
          let o = i;
          return (
            6403 === i &&
              (5126 === r && (o = 33326),
              5131 === r && (o = 33325),
              5121 === r && (o = 33321)),
            6407 === i &&
              (5126 === r && (o = 34837),
              5131 === r && (o = 34843),
              5121 === r && (o = 32849)),
            6408 === i &&
              (5126 === r && (o = 34836),
              5131 === r && (o = 34842),
              5121 === r && (o = 32856)),
            (33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o) ||
              e.get("EXT_color_buffer_float"),
            o
          );
        }
        function w(t) {
          return t === pt || t === ft || t === gt ? 9728 : 9729;
        }
        function _(e) {
          const n = e.target;
          n.removeEventListener("dispose", _),
            (function (e) {
              const n = i.get(e);
              void 0 !== n.__webglInit &&
                (t.deleteTexture(n.__webglTexture), i.remove(e));
            })(n),
            n.isVideoTexture && d.delete(n),
            s.memory.textures--;
        }
        function M(e) {
          const n = e.target;
          n.removeEventListener("dispose", M),
            (function (e) {
              const n = e.texture,
                r = i.get(e),
                o = i.get(n);
              if (e) {
                if (
                  (void 0 !== o.__webglTexture &&
                    (t.deleteTexture(o.__webglTexture), s.memory.textures--),
                  e.depthTexture && e.depthTexture.dispose(),
                  e.isWebGLCubeRenderTarget)
                )
                  for (let e = 0; e < 6; e++)
                    t.deleteFramebuffer(r.__webglFramebuffer[e]),
                      r.__webglDepthbuffer &&
                        t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                else
                  t.deleteFramebuffer(r.__webglFramebuffer),
                    r.__webglDepthbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthbuffer),
                    r.__webglMultisampledFramebuffer &&
                      t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                    r.__webglDepthRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                if (e.isWebGLMultipleRenderTargets)
                  for (let e = 0, r = n.length; e < r; e++) {
                    const r = i.get(n[e]);
                    r.__webglTexture &&
                      (t.deleteTexture(r.__webglTexture), s.memory.textures--),
                      i.remove(n[e]);
                  }
                i.remove(n), i.remove(e);
              }
            })(n);
        }
        let S = 0;
        function E(t, e) {
          const r = i.get(t);
          if (
            (t.isVideoTexture &&
              (function (t) {
                const e = s.render.frame;
                d.get(t) !== e && (d.set(t, e), t.update());
              })(t),
            t.version > 0 && r.__version !== t.version)
          ) {
            const n = t.image;
            if (void 0 === n)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined"
              );
            else {
              if (!1 !== n.complete) return void P(r, t, e);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
        }
        function T(e, r) {
          const s = i.get(e);
          e.version > 0 && s.__version !== e.version
            ? (function (e, i, r) {
                if (6 !== i.image.length) return;
                R(e, i),
                  n.activeTexture(33984 + r),
                  n.bindTexture(34067, e.__webglTexture),
                  t.pixelStorei(37440, i.flipY),
                  t.pixelStorei(37441, i.premultiplyAlpha),
                  t.pixelStorei(3317, i.unpackAlignment),
                  t.pixelStorei(37443, 0);
                const s =
                    i &&
                    (i.isCompressedTexture || i.image[0].isCompressedTexture),
                  l = i.image[0] && i.image[0].isDataTexture,
                  u = [];
                for (let t = 0; t < 6; t++)
                  u[t] =
                    s || l
                      ? l
                        ? i.image[t].image
                        : i.image[t]
                      : g(i.image[t], !1, !0, c);
                const h = u[0],
                  d = v(h) || a,
                  p = o.convert(i.format),
                  f = o.convert(i.type),
                  m = b(i.internalFormat, p, f);
                let w;
                if ((L(34067, i, d), s)) {
                  for (let t = 0; t < 6; t++) {
                    w = u[t].mipmaps;
                    for (let e = 0; e < w.length; e++) {
                      const r = w[e];
                      i.format !== kt && i.format !== Dt
                        ? null !== p
                          ? n.compressedTexImage2D(
                              34069 + t,
                              e,
                              m,
                              r.width,
                              r.height,
                              0,
                              r.data
                            )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : n.texImage2D(
                            34069 + t,
                            e,
                            m,
                            r.width,
                            r.height,
                            0,
                            p,
                            f,
                            r.data
                          );
                    }
                  }
                  e.__maxMipLevel = w.length - 1;
                } else {
                  w = i.mipmaps;
                  for (let t = 0; t < 6; t++)
                    if (l) {
                      n.texImage2D(
                        34069 + t,
                        0,
                        m,
                        u[t].width,
                        u[t].height,
                        0,
                        p,
                        f,
                        u[t].data
                      );
                      for (let e = 0; e < w.length; e++) {
                        const i = w[e].image[t].image;
                        n.texImage2D(
                          34069 + t,
                          e + 1,
                          m,
                          i.width,
                          i.height,
                          0,
                          p,
                          f,
                          i.data
                        );
                      }
                    } else {
                      n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                      for (let e = 0; e < w.length; e++) {
                        const i = w[e];
                        n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t]);
                      }
                    }
                  e.__maxMipLevel = w.length;
                }
                y(i, d) && x(34067, i, h.width, h.height),
                  (e.__version = i.version),
                  i.onUpdate && i.onUpdate(i);
              })(s, e, r)
            : (n.activeTexture(33984 + r),
              n.bindTexture(34067, s.__webglTexture));
        }
        const A = { [ut]: 10497, [ht]: 33071, [dt]: 33648 },
          C = {
            [pt]: 9728,
            [ft]: 9984,
            [gt]: 9986,
            [yt]: 9729,
            [xt]: 9985,
            [wt]: 9987,
          };
        function L(n, o, s) {
          if (
            (s
              ? (t.texParameteri(n, 10242, A[o.wrapS]),
                t.texParameteri(n, 10243, A[o.wrapT]),
                (32879 !== n && 35866 !== n) ||
                  t.texParameteri(n, 32882, A[o.wrapR]),
                t.texParameteri(n, 10240, C[o.magFilter]),
                t.texParameteri(n, 10241, C[o.minFilter]))
              : (t.texParameteri(n, 10242, 33071),
                t.texParameteri(n, 10243, 33071),
                (32879 !== n && 35866 !== n) ||
                  t.texParameteri(n, 32882, 33071),
                (o.wrapS === ht && o.wrapT === ht) ||
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                t.texParameteri(n, 10240, w(o.magFilter)),
                t.texParameteri(n, 10241, w(o.minFilter)),
                o.minFilter !== pt &&
                  o.minFilter !== yt &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            !0 === e.has("EXT_texture_filter_anisotropic"))
          ) {
            const s = e.get("EXT_texture_filter_anisotropic");
            if (o.type === Lt && !1 === e.has("OES_texture_float_linear"))
              return;
            if (
              !1 === a &&
              o.type === Rt &&
              !1 === e.has("OES_texture_half_float_linear")
            )
              return;
            (o.anisotropy > 1 || i.get(o).__currentAnisotropy) &&
              (t.texParameterf(
                n,
                s.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(o.anisotropy, r.getMaxAnisotropy())
              ),
              (i.get(o).__currentAnisotropy = o.anisotropy));
          }
        }
        function R(e, n) {
          void 0 === e.__webglInit &&
            ((e.__webglInit = !0),
            n.addEventListener("dispose", _),
            (e.__webglTexture = t.createTexture()),
            s.memory.textures++);
        }
        function P(e, i, r) {
          let s = 3553;
          i.isDataTexture2DArray && (s = 35866),
            i.isDataTexture3D && (s = 32879),
            R(e, i),
            n.activeTexture(33984 + r),
            n.bindTexture(s, e.__webglTexture),
            t.pixelStorei(37440, i.flipY),
            t.pixelStorei(37441, i.premultiplyAlpha),
            t.pixelStorei(3317, i.unpackAlignment),
            t.pixelStorei(37443, 0);
          const l =
              (function (t) {
                return (
                  !a &&
                  (t.wrapS !== ht ||
                    t.wrapT !== ht ||
                    (t.minFilter !== pt && t.minFilter !== yt))
                );
              })(i) && !1 === v(i.image),
            c = g(i.image, l, !1, u),
            h = v(c) || a,
            d = o.convert(i.format);
          let p,
            f = o.convert(i.type),
            m = b(i.internalFormat, d, f);
          L(s, i, h);
          const w = i.mipmaps;
          if (i.isDepthTexture)
            (m = 6402),
              a
                ? (m =
                    i.type === Lt
                      ? 36012
                      : i.type === Ct
                      ? 33190
                      : i.type === Bt
                      ? 35056
                      : 33189)
                : i.type === Lt &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
              i.format === Ut &&
                6402 === m &&
                i.type !== Tt &&
                i.type !== Ct &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (i.type = Tt),
                (f = o.convert(i.type))),
              i.format === Vt &&
                6402 === m &&
                ((m = 34041),
                i.type !== Bt &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (i.type = Bt),
                  (f = o.convert(i.type)))),
              n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
          else if (i.isDataTexture)
            if (w.length > 0 && h) {
              for (let t = 0, e = w.length; t < e; t++)
                (p = w[t]),
                  n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
              (i.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
            } else
              n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data),
                (e.__maxMipLevel = 0);
          else if (i.isCompressedTexture) {
            for (let t = 0, e = w.length; t < e; t++)
              (p = w[t]),
                i.format !== kt && i.format !== Dt
                  ? null !== d
                    ? n.compressedTexImage2D(
                        3553,
                        t,
                        m,
                        p.width,
                        p.height,
                        0,
                        p.data
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : n.texImage2D(
                      3553,
                      t,
                      m,
                      p.width,
                      p.height,
                      0,
                      d,
                      f,
                      p.data
                    );
            e.__maxMipLevel = w.length - 1;
          } else if (i.isDataTexture2DArray)
            n.texImage3D(
              35866,
              0,
              m,
              c.width,
              c.height,
              c.depth,
              0,
              d,
              f,
              c.data
            ),
              (e.__maxMipLevel = 0);
          else if (i.isDataTexture3D)
            n.texImage3D(
              32879,
              0,
              m,
              c.width,
              c.height,
              c.depth,
              0,
              d,
              f,
              c.data
            ),
              (e.__maxMipLevel = 0);
          else if (w.length > 0 && h) {
            for (let t = 0, e = w.length; t < e; t++)
              (p = w[t]), n.texImage2D(3553, t, m, d, f, p);
            (i.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
          } else n.texImage2D(3553, 0, m, d, f, c), (e.__maxMipLevel = 0);
          y(i, h) && x(s, i, c.width, c.height),
            (e.__version = i.version),
            i.onUpdate && i.onUpdate(i);
        }
        function N(e, r, s, a, l) {
          const c = o.convert(s.format),
            u = o.convert(s.type),
            h = b(s.internalFormat, c, u);
          32879 === l || 35866 === l
            ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null)
            : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null),
            n.bindFramebuffer(36160, e),
            t.framebufferTexture2D(36160, a, l, i.get(s).__webglTexture, 0),
            n.bindFramebuffer(36160, null);
        }
        function I(e, n, i) {
          if (
            (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)
          ) {
            let r = 33189;
            if (i) {
              const e = n.depthTexture;
              e &&
                e.isDepthTexture &&
                (e.type === Lt ? (r = 36012) : e.type === Ct && (r = 33190));
              const i = B(n);
              t.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
            } else t.renderbufferStorage(36161, r, n.width, n.height);
            t.framebufferRenderbuffer(36160, 36096, 36161, e);
          } else if (n.depthBuffer && n.stencilBuffer) {
            if (i) {
              const e = B(n);
              t.renderbufferStorageMultisample(
                36161,
                e,
                35056,
                n.width,
                n.height
              );
            } else t.renderbufferStorage(36161, 34041, n.width, n.height);
            t.framebufferRenderbuffer(36160, 33306, 36161, e);
          } else {
            const e =
                !0 === n.isWebGLMultipleRenderTargets
                  ? n.texture[0]
                  : n.texture,
              r = o.convert(e.format),
              s = o.convert(e.type),
              a = b(e.internalFormat, r, s);
            if (i) {
              const e = B(n);
              t.renderbufferStorageMultisample(36161, e, a, n.width, n.height);
            } else t.renderbufferStorage(36161, a, n.width, n.height);
          }
          t.bindRenderbuffer(36161, null);
        }
        function B(t) {
          return a && t.isWebGLMultisampleRenderTarget
            ? Math.min(h, t.samples)
            : 0;
        }
        let O = !1,
          D = !1;
        (this.allocateTextureUnit = function () {
          const t = S;
          return (
            t >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  t +
                  " texture units while this GPU supports only " +
                  l
              ),
            (S += 1),
            t
          );
        }),
          (this.resetTextureUnits = function () {
            S = 0;
          }),
          (this.setTexture2D = E),
          (this.setTexture2DArray = function (t, e) {
            const r = i.get(t);
            t.version > 0 && r.__version !== t.version
              ? P(r, t, e)
              : (n.activeTexture(33984 + e),
                n.bindTexture(35866, r.__webglTexture));
          }),
          (this.setTexture3D = function (t, e) {
            const r = i.get(t);
            t.version > 0 && r.__version !== t.version
              ? P(r, t, e)
              : (n.activeTexture(33984 + e),
                n.bindTexture(32879, r.__webglTexture));
          }),
          (this.setTextureCube = T),
          (this.setupRenderTarget = function (e) {
            const l = e.texture,
              c = i.get(e),
              u = i.get(l);
            e.addEventListener("dispose", M),
              !0 !== e.isWebGLMultipleRenderTargets &&
                ((u.__webglTexture = t.createTexture()),
                (u.__version = l.version),
                s.memory.textures++);
            const h = !0 === e.isWebGLCubeRenderTarget,
              d = !0 === e.isWebGLMultipleRenderTargets,
              p = !0 === e.isWebGLMultisampleRenderTarget,
              f = l.isDataTexture3D || l.isDataTexture2DArray,
              m = v(e) || a;
            if (
              (!a ||
                l.format !== Dt ||
                (l.type !== Lt && l.type !== Rt) ||
                ((l.format = kt),
                console.warn(
                  "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
                )),
              h)
            ) {
              c.__webglFramebuffer = [];
              for (let e = 0; e < 6; e++)
                c.__webglFramebuffer[e] = t.createFramebuffer();
            } else if (((c.__webglFramebuffer = t.createFramebuffer()), d))
              if (r.drawBuffers) {
                const n = e.texture;
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = i.get(n[e]);
                  void 0 === r.__webglTexture &&
                    ((r.__webglTexture = t.createTexture()),
                    s.memory.textures++);
                }
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                );
            else if (p)
              if (a) {
                (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                  (c.__webglColorRenderbuffer = t.createRenderbuffer()),
                  t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                const i = o.convert(l.format),
                  r = o.convert(l.type),
                  s = b(l.internalFormat, i, r),
                  a = B(e);
                t.renderbufferStorageMultisample(
                  36161,
                  a,
                  s,
                  e.width,
                  e.height
                ),
                  n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                  t.framebufferRenderbuffer(
                    36160,
                    36064,
                    36161,
                    c.__webglColorRenderbuffer
                  ),
                  t.bindRenderbuffer(36161, null),
                  e.depthBuffer &&
                    ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                    I(c.__webglDepthRenderbuffer, e, !0)),
                  n.bindFramebuffer(36160, null);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
            if (h) {
              n.bindTexture(34067, u.__webglTexture), L(34067, l, m);
              for (let t = 0; t < 6; t++)
                N(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
              y(l, m) && x(34067, l, e.width, e.height),
                n.bindTexture(34067, null);
            } else if (d) {
              const t = e.texture;
              for (let r = 0, o = t.length; r < o; r++) {
                const o = t[r],
                  s = i.get(o);
                n.bindTexture(3553, s.__webglTexture),
                  L(3553, o, m),
                  N(c.__webglFramebuffer, e, o, 36064 + r, 3553),
                  y(o, m) && x(3553, o, e.width, e.height);
              }
              n.bindTexture(3553, null);
            } else {
              let t = 3553;
              f &&
                (a
                  ? (t = l.isDataTexture3D ? 32879 : 35866)
                  : console.warn(
                      "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                    )),
                n.bindTexture(t, u.__webglTexture),
                L(t, l, m),
                N(c.__webglFramebuffer, e, l, 36064, t),
                y(l, m) && x(t, l, e.width, e.height, e.depth),
                n.bindTexture(t, null);
            }
            e.depthBuffer &&
              (function (e) {
                const r = i.get(e),
                  o = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture) {
                  if (o)
                    throw new Error(
                      "target.depthTexture not supported in Cube render targets"
                    );
                  !(function (e, r) {
                    if (r && r.isWebGLCubeRenderTarget)
                      throw new Error(
                        "Depth Texture with cube render targets is not supported"
                      );
                    if (
                      (n.bindFramebuffer(36160, e),
                      !r.depthTexture || !r.depthTexture.isDepthTexture)
                    )
                      throw new Error(
                        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                      );
                    (i.get(r.depthTexture).__webglTexture &&
                      r.depthTexture.image.width === r.width &&
                      r.depthTexture.image.height === r.height) ||
                      ((r.depthTexture.image.width = r.width),
                      (r.depthTexture.image.height = r.height),
                      (r.depthTexture.needsUpdate = !0)),
                      E(r.depthTexture, 0);
                    const o = i.get(r.depthTexture).__webglTexture;
                    if (r.depthTexture.format === Ut)
                      t.framebufferTexture2D(36160, 36096, 3553, o, 0);
                    else {
                      if (r.depthTexture.format !== Vt)
                        throw new Error("Unknown depthTexture format");
                      t.framebufferTexture2D(36160, 33306, 3553, o, 0);
                    }
                  })(r.__webglFramebuffer, e);
                } else if (o) {
                  r.__webglDepthbuffer = [];
                  for (let i = 0; i < 6; i++)
                    n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                      (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                      I(r.__webglDepthbuffer[i], e, !1);
                } else
                  n.bindFramebuffer(36160, r.__webglFramebuffer),
                    (r.__webglDepthbuffer = t.createRenderbuffer()),
                    I(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(36160, null);
              })(e);
          }),
          (this.updateRenderTargetMipmap = function (t) {
            const e = v(t) || a,
              r =
                !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
            for (let o = 0, s = r.length; o < s; o++) {
              const s = r[o];
              if (y(s, e)) {
                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                  r = i.get(s).__webglTexture;
                n.bindTexture(e, r),
                  x(e, s, t.width, t.height),
                  n.bindTexture(e, null);
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (e) {
            if (e.isWebGLMultisampleRenderTarget)
              if (a) {
                const r = e.width,
                  o = e.height;
                let s = 16384;
                e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024);
                const a = i.get(e);
                n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer),
                  n.bindFramebuffer(36009, a.__webglFramebuffer),
                  t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728),
                  n.bindFramebuffer(36008, null),
                  n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer);
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
          }),
          (this.safeSetTexture2D = function (t, e) {
            t &&
              t.isWebGLRenderTarget &&
              (!1 === O &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                ),
                (O = !0)),
              (t = t.texture)),
              E(t, e);
          }),
          (this.safeSetTextureCube = function (t, e) {
            t &&
              t.isWebGLCubeRenderTarget &&
              (!1 === D &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                ),
                (D = !0)),
              (t = t.texture)),
              T(t, e);
          });
      }
      function yl(t, e, n) {
        const i = n.isWebGL2;
        return {
          convert: function (t) {
            let n;
            if (t === Mt) return 5121;
            if (t === Pt) return 32819;
            if (t === Nt) return 32820;
            if (t === It) return 33635;
            if (t === St) return 5120;
            if (t === Et) return 5122;
            if (t === Tt) return 5123;
            if (t === At) return 5124;
            if (t === Ct) return 5125;
            if (t === Lt) return 5126;
            if (t === Rt)
              return i
                ? 5131
                : ((n = e.get("OES_texture_half_float")),
                  null !== n ? n.HALF_FLOAT_OES : null);
            if (t === Ot) return 6406;
            if (t === Dt) return 6407;
            if (t === kt) return 6408;
            if (t === Ft) return 6409;
            if (t === zt) return 6410;
            if (t === Ut) return 6402;
            if (t === Vt) return 34041;
            if (t === Gt) return 6403;
            if (t === jt) return 36244;
            if (t === Wt) return 33319;
            if (t === qt) return 33320;
            if (t === Xt) return 36248;
            if (t === Yt) return 36249;
            if (t === Zt || t === Jt || t === Kt || t === Qt) {
              if (((n = e.get("WEBGL_compressed_texture_s3tc")), null === n))
                return null;
              if (t === Zt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (t === Jt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (t === Kt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (t === Qt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            if (t === $t || t === te || t === ee || t === ne) {
              if (((n = e.get("WEBGL_compressed_texture_pvrtc")), null === n))
                return null;
              if (t === $t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (t === te) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (t === ee) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (t === ne) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (t === ie)
              return (
                (n = e.get("WEBGL_compressed_texture_etc1")),
                null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
              );
            if (
              (t === re || t === oe) &&
              ((n = e.get("WEBGL_compressed_texture_etc")), null !== n)
            ) {
              if (t === re) return n.COMPRESSED_RGB8_ETC2;
              if (t === oe) return n.COMPRESSED_RGBA8_ETC2_EAC;
            }
            return t === se ||
              t === ae ||
              t === le ||
              t === ce ||
              t === ue ||
              t === he ||
              t === de ||
              t === pe ||
              t === fe ||
              t === me ||
              t === ge ||
              t === ve ||
              t === ye ||
              t === xe ||
              t === we ||
              t === _e ||
              t === Me ||
              t === Se ||
              t === Ee ||
              t === Te ||
              t === Ae ||
              t === Ce ||
              t === Le ||
              t === Re ||
              t === Pe ||
              t === Ne ||
              t === Ie ||
              t === Be
              ? ((n = e.get("WEBGL_compressed_texture_astc")),
                null !== n ? t : null)
              : t === be
              ? ((n = e.get("EXT_texture_compression_bptc")),
                null !== n ? t : null)
              : t === Bt
              ? i
                ? 34042
                : ((n = e.get("WEBGL_depth_texture")),
                  null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
              : void 0;
          },
        };
      }
      fl.prototype.isMeshDistanceMaterial = !0;
      class xl extends Ao {
        constructor(t = []) {
          super(), (this.cameras = t);
        }
      }
      xl.prototype.isArrayCamera = !0;
      class bl extends lr {
        constructor() {
          super(), (this.type = "Group");
        }
      }
      bl.prototype.isGroup = !0;
      const wl = { type: "move" };
      class _l {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new bl()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new bl()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new si()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new si())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new bl()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new si()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new si())),
            this._grip
          );
        }
        dispatchEvent(t) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            null !== this._hand && this._hand.dispatchEvent(t),
            this
          );
        }
        disconnect(t) {
          return (
            this.dispatchEvent({ type: "disconnected", data: t }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          );
        }
        update(t, e, n) {
          let i = null,
            r = null,
            o = null;
          const s = this._targetRay,
            a = this._grip,
            l = this._hand;
          if (t && "visible-blurred" !== e.session.visibilityState)
            if (
              (null !== s &&
                ((i = e.getPose(t.targetRaySpace, n)),
                null !== i &&
                  (s.matrix.fromArray(i.transform.matrix),
                  s.matrix.decompose(s.position, s.rotation, s.scale),
                  i.linearVelocity
                    ? ((s.hasLinearVelocity = !0),
                      s.linearVelocity.copy(i.linearVelocity))
                    : (s.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((s.hasAngularVelocity = !0),
                      s.angularVelocity.copy(i.angularVelocity))
                    : (s.hasAngularVelocity = !1),
                  this.dispatchEvent(wl))),
              l && t.hand)
            ) {
              o = !0;
              for (const i of t.hand.values()) {
                const t = e.getJointPose(i, n);
                if (void 0 === l.joints[i.jointName]) {
                  const t = new bl();
                  (t.matrixAutoUpdate = !1),
                    (t.visible = !1),
                    (l.joints[i.jointName] = t),
                    l.add(t);
                }
                const r = l.joints[i.jointName];
                null !== t &&
                  (r.matrix.fromArray(t.transform.matrix),
                  r.matrix.decompose(r.position, r.rotation, r.scale),
                  (r.jointRadius = t.radius)),
                  (r.visible = null !== t);
              }
              const i = l.joints["index-finger-tip"],
                r = l.joints["thumb-tip"],
                s = i.position.distanceTo(r.position),
                a = 0.02,
                c = 0.005;
              l.inputState.pinching && s > a + c
                ? ((l.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this,
                  }))
                : !l.inputState.pinching &&
                  s <= a - c &&
                  ((l.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this,
                  }));
            } else
              null !== a &&
                t.gripSpace &&
                ((r = e.getPose(t.gripSpace, n)),
                null !== r &&
                  (a.matrix.fromArray(r.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  r.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(r.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(r.angularVelocity))
                    : (a.hasAngularVelocity = !1)));
          return (
            null !== s && (s.visible = null !== i),
            null !== a && (a.visible = null !== r),
            null !== l && (l.visible = null !== o),
            this
          );
        }
      }
      class Ml extends On {
        constructor(t, e) {
          super();
          const n = this,
            i = t.state;
          let r = null,
            o = 1,
            s = null,
            a = "local-floor",
            l = null,
            c = null,
            u = null,
            h = null,
            d = null;
          const p = [],
            f = new Map(),
            m = new Ao();
          m.layers.enable(1), (m.viewport = new ei());
          const g = new Ao();
          g.layers.enable(2), (g.viewport = new ei());
          const v = [m, g],
            y = new xl();
          y.layers.enable(1), y.layers.enable(2);
          let x = null,
            b = null;
          function w(t) {
            const e = f.get(t.inputSource);
            e && e.dispatchEvent({ type: t.type, data: t.inputSource });
          }
          function _() {
            f.forEach(function (t, e) {
              t.disconnect(e);
            }),
              f.clear(),
              (x = null),
              (b = null),
              i.bindXRFramebuffer(null),
              t.setRenderTarget(t.getRenderTarget()),
              C.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          function M(t) {
            const e = r.inputSources;
            for (let t = 0; t < p.length; t++) f.set(e[t], p[t]);
            for (let e = 0; e < t.removed.length; e++) {
              const n = t.removed[e],
                i = f.get(n);
              i &&
                (i.dispatchEvent({ type: "disconnected", data: n }),
                f.delete(n));
            }
            for (let e = 0; e < t.added.length; e++) {
              const n = t.added[e],
                i = f.get(n);
              i && i.dispatchEvent({ type: "connected", data: n });
            }
          }
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (t) {
              let e = p[t];
              return (
                void 0 === e && ((e = new _l()), (p[t] = e)),
                e.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (t) {
              let e = p[t];
              return (
                void 0 === e && ((e = new _l()), (p[t] = e)), e.getGripSpace()
              );
            }),
            (this.getHand = function (t) {
              let e = p[t];
              return (
                void 0 === e && ((e = new _l()), (p[t] = e)), e.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (t) {
              (o = t),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                  );
            }),
            (this.setReferenceSpaceType = function (t) {
              (a = t),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return s;
            }),
            (this.getSession = function () {
              return r;
            }),
            (this.setSession = async function (t) {
              if (((r = t), null !== r)) {
                r.addEventListener("select", w),
                  r.addEventListener("selectstart", w),
                  r.addEventListener("selectend", w),
                  r.addEventListener("squeeze", w),
                  r.addEventListener("squeezestart", w),
                  r.addEventListener("squeezeend", w),
                  r.addEventListener("end", _),
                  r.addEventListener("inputsourceschange", M);
                const t = e.getContextAttributes();
                if (
                  (!0 !== t.xrCompatible && (await e.makeXRCompatible()),
                  void 0 === r.renderState.layers)
                ) {
                  const n = {
                    antialias: t.antialias,
                    alpha: t.alpha,
                    depth: t.depth,
                    stencil: t.stencil,
                    framebufferScaleFactor: o,
                  };
                  (d = new XRWebGLLayer(r, e, n)),
                    r.updateRenderState({ baseLayer: d });
                } else {
                  let n = 0;
                  if (t.antialias) {
                    const n = {
                      antialias: !0,
                      alpha: t.alpha,
                      depth: t.depth,
                      stencil: t.stencil,
                      framebufferScaleFactor: o,
                    };
                    (d = new XRWebGLLayer(r, e, n)),
                      r.updateRenderState({ layers: [d] });
                  } else {
                    t.depth && (n = t.stencil ? 34041 : 6402);
                    const i = {
                      colorFormat: t.alpha ? 6408 : 6407,
                      depthFormat: n,
                      scaleFactor: o,
                    };
                    (c = new XRWebGLBinding(r, e)),
                      (h = c.createProjectionLayer(i)),
                      (u = e.createFramebuffer()),
                      r.updateRenderState({ layers: [h] });
                  }
                }
                (s = await r.requestReferenceSpace(a)),
                  C.setContext(r),
                  C.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            });
          const S = new si(),
            E = new si();
          function T(t, e) {
            null === e
              ? t.matrixWorld.copy(t.matrix)
              : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
              t.matrixWorldInverse.copy(t.matrixWorld).invert();
          }
          (this.updateCamera = function (t) {
            if (null === r) return;
            (y.near = g.near = m.near = t.near),
              (y.far = g.far = m.far = t.far),
              (x === y.near && b === y.far) ||
                (r.updateRenderState({ depthNear: y.near, depthFar: y.far }),
                (x = y.near),
                (b = y.far));
            const e = t.parent,
              n = y.cameras;
            T(y, e);
            for (let t = 0; t < n.length; t++) T(n[t], e);
            y.matrixWorld.decompose(y.position, y.quaternion, y.scale),
              t.position.copy(y.position),
              t.quaternion.copy(y.quaternion),
              t.scale.copy(y.scale),
              t.matrix.copy(y.matrix),
              t.matrixWorld.copy(y.matrixWorld);
            const i = t.children;
            for (let t = 0, e = i.length; t < e; t++)
              i[t].updateMatrixWorld(!0);
            2 === n.length
              ? (function (t, e, n) {
                  S.setFromMatrixPosition(e.matrixWorld),
                    E.setFromMatrixPosition(n.matrixWorld);
                  const i = S.distanceTo(E),
                    r = e.projectionMatrix.elements,
                    o = n.projectionMatrix.elements,
                    s = r[14] / (r[10] - 1),
                    a = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    h = (o[8] + 1) / o[0],
                    d = s * u,
                    p = s * h,
                    f = i / (-u + h),
                    m = f * -u;
                  e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(m),
                    t.translateZ(f),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert();
                  const g = s + f,
                    v = a + f,
                    y = d - m,
                    x = p + (i - m),
                    b = ((l * a) / v) * g,
                    w = ((c * a) / v) * g;
                  t.projectionMatrix.makePerspective(y, x, b, w, g, v);
                })(y, m, g)
              : y.projectionMatrix.copy(m.projectionMatrix);
          }),
            (this.getCamera = function () {
              return y;
            }),
            (this.getFoveation = function () {
              return null !== h
                ? h.fixedFoveation
                : null !== d
                ? d.fixedFoveation
                : void 0;
            }),
            (this.setFoveation = function (t) {
              null !== h && (h.fixedFoveation = t),
                null !== d &&
                  void 0 !== d.fixedFoveation &&
                  (d.fixedFoveation = t);
            });
          let A = null;
          const C = new zo();
          C.setAnimationLoop(function (t, n) {
            if (((l = n.getViewerPose(s)), null !== l)) {
              const t = l.views;
              null !== d && i.bindXRFramebuffer(d.framebuffer);
              let n = !1;
              t.length !== y.cameras.length &&
                ((y.cameras.length = 0), (n = !0));
              for (let r = 0; r < t.length; r++) {
                const o = t[r];
                let s = null;
                if (null !== d) s = d.getViewport(o);
                else {
                  const t = c.getViewSubImage(h, o);
                  i.bindXRFramebuffer(u),
                    void 0 !== t.depthStencilTexture &&
                      e.framebufferTexture2D(
                        36160,
                        36096,
                        3553,
                        t.depthStencilTexture,
                        0
                      ),
                    e.framebufferTexture2D(
                      36160,
                      36064,
                      3553,
                      t.colorTexture,
                      0
                    ),
                    (s = t.viewport);
                }
                const a = v[r];
                a.matrix.fromArray(o.transform.matrix),
                  a.projectionMatrix.fromArray(o.projectionMatrix),
                  a.viewport.set(s.x, s.y, s.width, s.height),
                  0 === r && y.matrix.copy(a.matrix),
                  !0 === n && y.cameras.push(a);
              }
            }
            const o = r.inputSources;
            for (let t = 0; t < p.length; t++) {
              const e = p[t],
                i = o[t];
              e.update(i, n, s);
            }
            A && A(t, n);
          }),
            (this.setAnimationLoop = function (t) {
              A = t;
            }),
            (this.dispose = function () {});
        }
      }
      function Sl(t) {
        function e(e, n) {
          (e.opacity.value = n.opacity),
            n.color && e.diffuse.value.copy(n.color),
            n.emissive &&
              e.emissive.value
                .copy(n.emissive)
                .multiplyScalar(n.emissiveIntensity),
            n.map && (e.map.value = n.map),
            n.alphaMap && (e.alphaMap.value = n.alphaMap),
            n.specularMap && (e.specularMap.value = n.specularMap);
          const i = t.get(n).envMap;
          if (i) {
            (e.envMap.value = i),
              (e.flipEnvMap.value =
                i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
              (e.reflectivity.value = n.reflectivity),
              (e.refractionRatio.value = n.refractionRatio);
            const r = t.get(i).__maxMipLevel;
            void 0 !== r && (e.maxMipLevel.value = r);
          }
          let r, o;
          n.lightMap &&
            ((e.lightMap.value = n.lightMap),
            (e.lightMapIntensity.value = n.lightMapIntensity)),
            n.aoMap &&
              ((e.aoMap.value = n.aoMap),
              (e.aoMapIntensity.value = n.aoMapIntensity)),
            n.map
              ? (r = n.map)
              : n.specularMap
              ? (r = n.specularMap)
              : n.displacementMap
              ? (r = n.displacementMap)
              : n.normalMap
              ? (r = n.normalMap)
              : n.bumpMap
              ? (r = n.bumpMap)
              : n.roughnessMap
              ? (r = n.roughnessMap)
              : n.metalnessMap
              ? (r = n.metalnessMap)
              : n.alphaMap
              ? (r = n.alphaMap)
              : n.emissiveMap
              ? (r = n.emissiveMap)
              : n.clearcoatMap
              ? (r = n.clearcoatMap)
              : n.clearcoatNormalMap
              ? (r = n.clearcoatNormalMap)
              : n.clearcoatRoughnessMap
              ? (r = n.clearcoatRoughnessMap)
              : n.specularIntensityMap
              ? (r = n.specularIntensityMap)
              : n.specularTintMap && (r = n.specularTintMap),
            void 0 !== r &&
              (r.isWebGLRenderTarget && (r = r.texture),
              !0 === r.matrixAutoUpdate && r.updateMatrix(),
              e.uvTransform.value.copy(r.matrix)),
            n.aoMap ? (o = n.aoMap) : n.lightMap && (o = n.lightMap),
            void 0 !== o &&
              (o.isWebGLRenderTarget && (o = o.texture),
              !0 === o.matrixAutoUpdate && o.updateMatrix(),
              e.uv2Transform.value.copy(o.matrix));
        }
        function n(e, n) {
          (e.roughness.value = n.roughness),
            (e.metalness.value = n.metalness),
            n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
            n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
            n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
            n.bumpMap &&
              ((e.bumpMap.value = n.bumpMap),
              (e.bumpScale.value = n.bumpScale),
              n.side === f && (e.bumpScale.value *= -1)),
            n.normalMap &&
              ((e.normalMap.value = n.normalMap),
              e.normalScale.value.copy(n.normalScale),
              n.side === f && e.normalScale.value.negate()),
            n.displacementMap &&
              ((e.displacementMap.value = n.displacementMap),
              (e.displacementScale.value = n.displacementScale),
              (e.displacementBias.value = n.displacementBias)),
            t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
        }
        return {
          refreshFogUniforms: function (t, e) {
            t.fogColor.value.copy(e.color),
              e.isFog
                ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                : e.isFogExp2 && (t.fogDensity.value = e.density);
          },
          refreshMaterialUniforms: function (t, i, r, o, s) {
            i.isMeshBasicMaterial
              ? e(t, i)
              : i.isMeshLambertMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                })(t, i))
              : i.isMeshToonMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.gradientMap && (t.gradientMap.value = e.gradientMap),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      e.side === f && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      e.side === f && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                })(t, i))
              : i.isMeshPhongMaterial
              ? (e(t, i),
                (function (t, e) {
                  t.specular.value.copy(e.specular),
                    (t.shininess.value = Math.max(e.shininess, 1e-4)),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      e.side === f && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      e.side === f && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                })(t, i))
              : i.isMeshStandardMaterial
              ? (e(t, i),
                i.isMeshPhysicalMaterial
                  ? (function (t, e, i) {
                      n(t, e),
                        (t.reflectivity.value = e.reflectivity),
                        (t.clearcoat.value = e.clearcoat),
                        (t.clearcoatRoughness.value = e.clearcoatRoughness),
                        e.sheen && t.sheen.value.copy(e.sheen),
                        e.clearcoatMap &&
                          (t.clearcoatMap.value = e.clearcoatMap),
                        e.clearcoatRoughnessMap &&
                          (t.clearcoatRoughnessMap.value =
                            e.clearcoatRoughnessMap),
                        e.clearcoatNormalMap &&
                          (t.clearcoatNormalScale.value.copy(
                            e.clearcoatNormalScale
                          ),
                          (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                          e.side === f &&
                            t.clearcoatNormalScale.value.negate()),
                        (t.transmission.value = e.transmission),
                        e.transmissionMap &&
                          (t.transmissionMap.value = e.transmissionMap),
                        e.transmission > 0 &&
                          ((t.transmissionSamplerMap.value = i.texture),
                          t.transmissionSamplerSize.value.set(
                            i.width,
                            i.height
                          )),
                        (t.thickness.value = e.thickness),
                        e.thicknessMap &&
                          (t.thicknessMap.value = e.thicknessMap),
                        (t.attenuationDistance.value = e.attenuationDistance),
                        t.attenuationTint.value.copy(e.attenuationTint),
                        (t.specularIntensity.value = e.specularIntensity),
                        t.specularTint.value.copy(e.specularTint),
                        e.specularIntensityMap &&
                          (t.specularIntensityMap.value =
                            e.specularIntensityMap),
                        e.specularTintMap &&
                          (t.specularTintMap.value = e.specularTintMap);
                    })(t, i, s)
                  : n(t, i))
              : i.isMeshMatcapMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.matcap && (t.matcap.value = e.matcap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      e.side === f && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      e.side === f && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                })(t, i))
              : i.isMeshDepthMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(t, i))
              : i.isMeshDistanceMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias)),
                    t.referencePosition.value.copy(e.referencePosition),
                    (t.nearDistance.value = e.nearDistance),
                    (t.farDistance.value = e.farDistance);
                })(t, i))
              : i.isMeshNormalMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    e.side === f && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      e.side === f && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                })(t, i))
              : i.isLineBasicMaterial
              ? ((function (t, e) {
                  t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
                })(t, i),
                i.isLineDashedMaterial &&
                  (function (t, e) {
                    (t.dashSize.value = e.dashSize),
                      (t.totalSize.value = e.dashSize + e.gapSize),
                      (t.scale.value = e.scale);
                  })(t, i))
              : i.isPointsMaterial
              ? (function (t, e, n, i) {
                  let r;
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.size.value = e.size * n),
                    (t.scale.value = 0.5 * i),
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap),
                    void 0 !== r &&
                      (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                      t.uvTransform.value.copy(r.matrix));
                })(t, i, r, o)
              : i.isSpriteMaterial
              ? (function (t, e) {
                  let n;
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.rotation.value = e.rotation),
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
                    void 0 !== n &&
                      (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                      t.uvTransform.value.copy(n.matrix));
                })(t, i)
              : i.isShadowMaterial
              ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
              : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
          },
        };
      }
      function El(t = {}) {
        const e =
            void 0 !== t.canvas
              ? t.canvas
              : (function () {
                  const t = document.createElementNS(
                    "http://www.w3.org/1999/xhtml",
                    "canvas"
                  );
                  return (t.style.display = "block"), t;
                })(),
          n = void 0 !== t.context ? t.context : null,
          i = void 0 !== t.alpha && t.alpha,
          r = void 0 === t.depth || t.depth,
          o = void 0 === t.stencil || t.stencil,
          s = void 0 !== t.antialias && t.antialias,
          a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
          l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
          c = void 0 !== t.powerPreference ? t.powerPreference : "default",
          u =
            void 0 !== t.failIfMajorPerformanceCaveat &&
            t.failIfMajorPerformanceCaveat;
        let h = null,
          d = null;
        const g = [],
          v = [];
        (this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.outputEncoding = Ze),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = K),
          (this.toneMappingExposure = 1);
        const y = this;
        let x = !1,
          b = 0,
          w = 0,
          _ = null,
          M = -1,
          S = null;
        const E = new ei(),
          T = new ei();
        let A = null,
          C = e.width,
          L = e.height,
          R = 1,
          P = null,
          N = null;
        const I = new ei(0, 0, C, L),
          B = new ei(0, 0, C, L);
        let O = !1;
        const D = [],
          k = new Fo();
        let F = !1,
          z = !1,
          H = null;
        const U = new ki(),
          V = new si(),
          G = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function j() {
          return null === _ ? R : 1;
        }
        let W,
          q,
          X,
          Y,
          Z,
          J,
          Q,
          $,
          tt,
          et,
          nt,
          it,
          rt,
          ot,
          st,
          at,
          lt,
          ct,
          ut,
          dt,
          ft,
          mt,
          gt,
          vt = n;
        function yt(t, n) {
          for (let i = 0; i < t.length; i++) {
            const r = t[i],
              o = e.getContext(r, n);
            if (null !== o) return o;
          }
          return null;
        }
        try {
          const t = {
            alpha: i,
            depth: r,
            stencil: o,
            antialias: s,
            premultipliedAlpha: a,
            preserveDrawingBuffer: l,
            powerPreference: c,
            failIfMajorPerformanceCaveat: u,
          };
          if (
            (e.addEventListener("webglcontextlost", _t, !1),
            e.addEventListener("webglcontextrestored", St, !1),
            null === vt)
          ) {
            const e = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === y.isWebGL1Renderer && e.shift(),
              (vt = yt(e, t)),
              null === vt)
            )
              throw yt(e)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          void 0 === vt.getShaderPrecisionFormat &&
            (vt.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (t) {
          throw (console.error("THREE.WebGLRenderer: " + t.message), t);
        }
        function xt() {
          (W = new Ms(vt)),
            (q = new Yo(vt, W, t)),
            W.init(q),
            (mt = new yl(vt, W, q)),
            (X = new gl(vt, W, q)),
            (D[0] = 1029),
            (Y = new Ts(vt)),
            (Z = new nl()),
            (J = new vl(vt, W, X, Z, q, mt, Y)),
            (Q = new Jo(y)),
            ($ = new _s(y)),
            (tt = new Ho(vt, q)),
            (gt = new qo(vt, W, tt, q)),
            (et = new Ss(vt, tt, Y, gt)),
            (nt = new Rs(vt, et, tt, Y)),
            (ut = new Ls(vt)),
            (at = new Zo(Z)),
            (it = new el(y, Q, $, W, q, gt, at)),
            (rt = new Sl(Z)),
            (ot = new sl(Z)),
            (st = new dl(W, q)),
            (ct = new Wo(y, Q, X, nt, a)),
            (lt = new ml(y, nt, q)),
            (dt = new Xo(vt, W, Y, q)),
            (ft = new Es(vt, W, Y, q)),
            (Y.programs = it.programs),
            (y.capabilities = q),
            (y.extensions = W),
            (y.properties = Z),
            (y.renderLists = ot),
            (y.shadowMap = lt),
            (y.state = X),
            (y.info = Y);
        }
        xt();
        const bt = new Ml(y, vt);
        function _t(t) {
          t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (x = !0);
        }
        function St() {
          console.log("THREE.WebGLRenderer: Context Restored."), (x = !1);
          const t = Y.autoReset,
            e = lt.enabled,
            n = lt.autoUpdate,
            i = lt.needsUpdate,
            r = lt.type;
          xt(),
            (Y.autoReset = t),
            (lt.enabled = e),
            (lt.autoUpdate = n),
            (lt.needsUpdate = i),
            (lt.type = r);
        }
        function Et(t) {
          const e = t.target;
          e.removeEventListener("dispose", Et),
            (function (t) {
              (function (t) {
                const e = Z.get(t).programs;
                void 0 !== e &&
                  e.forEach(function (t) {
                    it.releaseProgram(t);
                  });
              })(t),
                Z.remove(t);
            })(e);
        }
        (this.xr = bt),
          (this.getContext = function () {
            return vt;
          }),
          (this.getContextAttributes = function () {
            return vt.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const t = W.get("WEBGL_lose_context");
            t && t.loseContext();
          }),
          (this.forceContextRestore = function () {
            const t = W.get("WEBGL_lose_context");
            t && t.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return R;
          }),
          (this.setPixelRatio = function (t) {
            void 0 !== t && ((R = t), this.setSize(C, L, !1));
          }),
          (this.getSize = function (t) {
            return t.set(C, L);
          }),
          (this.setSize = function (t, n, i) {
            bt.isPresenting
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((C = t),
                (L = n),
                (e.width = Math.floor(t * R)),
                (e.height = Math.floor(n * R)),
                !1 !== i &&
                  ((e.style.width = t + "px"), (e.style.height = n + "px")),
                this.setViewport(0, 0, t, n));
          }),
          (this.getDrawingBufferSize = function (t) {
            return t.set(C * R, L * R).floor();
          }),
          (this.setDrawingBufferSize = function (t, n, i) {
            (C = t),
              (L = n),
              (R = i),
              (e.width = Math.floor(t * i)),
              (e.height = Math.floor(n * i)),
              this.setViewport(0, 0, t, n);
          }),
          (this.getCurrentViewport = function (t) {
            return t.copy(E);
          }),
          (this.getViewport = function (t) {
            return t.copy(I);
          }),
          (this.setViewport = function (t, e, n, i) {
            t.isVector4 ? I.set(t.x, t.y, t.z, t.w) : I.set(t, e, n, i),
              X.viewport(E.copy(I).multiplyScalar(R).floor());
          }),
          (this.getScissor = function (t) {
            return t.copy(B);
          }),
          (this.setScissor = function (t, e, n, i) {
            t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, i),
              X.scissor(T.copy(B).multiplyScalar(R).floor());
          }),
          (this.getScissorTest = function () {
            return O;
          }),
          (this.setScissorTest = function (t) {
            X.setScissorTest((O = t));
          }),
          (this.setOpaqueSort = function (t) {
            P = t;
          }),
          (this.setTransparentSort = function (t) {
            N = t;
          }),
          (this.getClearColor = function (t) {
            return t.copy(ct.getClearColor());
          }),
          (this.setClearColor = function () {
            ct.setClearColor.apply(ct, arguments);
          }),
          (this.getClearAlpha = function () {
            return ct.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            ct.setClearAlpha.apply(ct, arguments);
          }),
          (this.clear = function (t, e, n) {
            let i = 0;
            (void 0 === t || t) && (i |= 16384),
              (void 0 === e || e) && (i |= 256),
              (void 0 === n || n) && (i |= 1024),
              vt.clear(i);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", _t, !1),
              e.removeEventListener("webglcontextrestored", St, !1),
              ot.dispose(),
              st.dispose(),
              Z.dispose(),
              Q.dispose(),
              $.dispose(),
              nt.dispose(),
              gt.dispose(),
              bt.dispose(),
              bt.removeEventListener("sessionstart", At),
              bt.removeEventListener("sessionend", Ct),
              H && (H.dispose(), (H = null)),
              Pt.stop();
          }),
          (this.renderBufferImmediate = function (t, e) {
            gt.initAttributes();
            const n = Z.get(t);
            t.hasPositions && !n.position && (n.position = vt.createBuffer()),
              t.hasNormals && !n.normal && (n.normal = vt.createBuffer()),
              t.hasUvs && !n.uv && (n.uv = vt.createBuffer()),
              t.hasColors && !n.color && (n.color = vt.createBuffer());
            const i = e.getAttributes();
            t.hasPositions &&
              (vt.bindBuffer(34962, n.position),
              vt.bufferData(34962, t.positionArray, 35048),
              gt.enableAttribute(i.position),
              vt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
              t.hasNormals &&
                (vt.bindBuffer(34962, n.normal),
                vt.bufferData(34962, t.normalArray, 35048),
                gt.enableAttribute(i.normal),
                vt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
              t.hasUvs &&
                (vt.bindBuffer(34962, n.uv),
                vt.bufferData(34962, t.uvArray, 35048),
                gt.enableAttribute(i.uv),
                vt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
              t.hasColors &&
                (vt.bindBuffer(34962, n.color),
                vt.bufferData(34962, t.colorArray, 35048),
                gt.enableAttribute(i.color),
                vt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
              gt.disableUnusedAttributes(),
              vt.drawArrays(4, 0, t.count),
              (t.count = 0);
          }),
          (this.renderBufferDirect = function (t, e, n, i, r, o) {
            null === e && (e = G);
            const s = r.isMesh && r.matrixWorld.determinant() < 0,
              a = Ft(t, e, i, r);
            X.setMaterial(i, s);
            let l = n.index;
            const c = n.attributes.position;
            if (null === l) {
              if (void 0 === c || 0 === c.count) return;
            } else if (0 === l.count) return;
            let u,
              h = 1;
            !0 === i.wireframe && ((l = et.getWireframeAttribute(n)), (h = 2)),
              (void 0 === n.morphAttributes.position &&
                void 0 === n.morphAttributes.normal) ||
                ut.update(r, n, i, a),
              gt.setup(r, i, a, n, l);
            let d = dt;
            null !== l && ((u = tt.get(l)), (d = ft), d.setIndex(u));
            const p = null !== l ? l.count : c.count,
              f = n.drawRange.start * h,
              m = n.drawRange.count * h,
              g = null !== o ? o.start * h : 0,
              v = null !== o ? o.count * h : 1 / 0,
              y = Math.max(f, g),
              x = Math.min(p, f + m, g + v) - 1,
              b = Math.max(0, x - y + 1);
            if (0 !== b) {
              if (r.isMesh)
                !0 === i.wireframe
                  ? (X.setLineWidth(i.wireframeLinewidth * j()), d.setMode(1))
                  : d.setMode(4);
              else if (r.isLine) {
                let t = i.linewidth;
                void 0 === t && (t = 1),
                  X.setLineWidth(t * j()),
                  r.isLineSegments
                    ? d.setMode(1)
                    : r.isLineLoop
                    ? d.setMode(2)
                    : d.setMode(3);
              } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
              if (r.isInstancedMesh) d.renderInstances(y, b, r.count);
              else if (n.isInstancedBufferGeometry) {
                const t = Math.min(n.instanceCount, n._maxInstanceCount);
                d.renderInstances(y, b, t);
              } else d.render(y, b);
            }
          }),
          (this.compile = function (t, e) {
            (d = st.get(t)),
              d.init(),
              v.push(d),
              t.traverseVisible(function (t) {
                t.isLight &&
                  t.layers.test(e.layers) &&
                  (d.pushLight(t), t.castShadow && d.pushShadow(t));
              }),
              d.setupLights(),
              t.traverse(function (e) {
                const n = e.material;
                if (n)
                  if (Array.isArray(n))
                    for (let i = 0; i < n.length; i++) Ot(n[i], t, e);
                  else Ot(n, t, e);
              }),
              v.pop(),
              (d = null);
          });
        let Tt = null;
        function At() {
          Pt.stop();
        }
        function Ct() {
          Pt.start();
        }
        const Pt = new zo();
        function Nt(t, e, n, i) {
          if (!1 === t.visible) return;
          if (t.layers.test(e.layers))
            if (t.isGroup) n = t.renderOrder;
            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
            else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
            else if (t.isSprite) {
              if (!t.frustumCulled || k.intersectsSprite(t)) {
                i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
                const e = nt.update(t),
                  r = t.material;
                r.visible && h.push(t, e, r, n, V.z, null);
              }
            } else if (t.isImmediateRenderObject)
              i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U),
                h.push(t, null, t.material, n, V.z, null);
            else if (
              (t.isMesh || t.isLine || t.isPoints) &&
              (t.isSkinnedMesh &&
                t.skeleton.frame !== Y.render.frame &&
                (t.skeleton.update(), (t.skeleton.frame = Y.render.frame)),
              !t.frustumCulled || k.intersectsObject(t))
            ) {
              i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
              const e = nt.update(t),
                r = t.material;
              if (Array.isArray(r)) {
                const i = e.groups;
                for (let o = 0, s = i.length; o < s; o++) {
                  const s = i[o],
                    a = r[s.materialIndex];
                  a && a.visible && h.push(t, e, a, n, V.z, s);
                }
              } else r.visible && h.push(t, e, r, n, V.z, null);
            }
          const r = t.children;
          for (let t = 0, o = r.length; t < o; t++) Nt(r[t], e, n, i);
        }
        function It(t, e, n) {
          const i = !0 === e.isScene ? e.overrideMaterial : null;
          if (n.isArrayCamera) {
            const r = n.cameras;
            for (let n = 0, o = r.length; n < o; n++) {
              const o = r[n];
              X.viewport(E.copy(o.viewport)), d.setupLightsView(o);
              for (let n = 0, r = t.length; n < r; n++) {
                const r = t[n],
                  s = r.object,
                  a = r.geometry,
                  l = null === i ? r.material : i,
                  c = r.group;
                s.layers.test(o.layers) && Bt(s, e, o, a, l, c);
              }
            }
          } else
            for (let r = 0, o = t.length; r < o; r++) {
              const o = t[r];
              Bt(
                o.object,
                e,
                n,
                o.geometry,
                null === i ? o.material : i,
                o.group
              );
            }
        }
        function Bt(t, e, n, i, r, o) {
          if (
            (t.onBeforeRender(y, e, n, i, r, o),
            t.modelViewMatrix.multiplyMatrices(
              n.matrixWorldInverse,
              t.matrixWorld
            ),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            t.isImmediateRenderObject)
          ) {
            const i = Ft(n, e, r, t);
            X.setMaterial(r),
              gt.reset(),
              (function (t, e) {
                t.render(function (t) {
                  y.renderBufferImmediate(t, e);
                });
              })(t, i);
          } else
            !0 === r.transparent && r.side === m
              ? ((r.side = f),
                (r.needsUpdate = !0),
                y.renderBufferDirect(n, e, i, r, t, o),
                (r.side = p),
                (r.needsUpdate = !0),
                y.renderBufferDirect(n, e, i, r, t, o),
                (r.side = m))
              : y.renderBufferDirect(n, e, i, r, t, o);
          t.onAfterRender(y, e, n, i, r, o);
        }
        function Ot(t, e, n) {
          !0 !== e.isScene && (e = G);
          const i = Z.get(t),
            r = d.state.lights,
            o = d.state.shadowsArray,
            s = r.state.version,
            a = it.getParameters(t, r.state, o, e, n),
            l = it.getProgramCacheKey(a);
          let c = i.programs;
          (i.environment = t.isMeshStandardMaterial ? e.environment : null),
            (i.fog = e.fog),
            (i.envMap = (t.isMeshStandardMaterial ? $ : Q).get(
              t.envMap || i.environment
            )),
            void 0 === c &&
              (t.addEventListener("dispose", Et),
              (c = new Map()),
              (i.programs = c));
          let u = c.get(l);
          if (void 0 !== u) {
            if (i.currentProgram === u && i.lightsStateVersion === s)
              return Dt(t, a), u;
          } else
            (a.uniforms = it.getUniforms(t)),
              t.onBuild(a, y),
              t.onBeforeCompile(a, y),
              (u = it.acquireProgram(a, l)),
              c.set(l, u),
              (i.uniforms = a.uniforms);
          const h = i.uniforms;
          ((t.isShaderMaterial || t.isRawShaderMaterial) &&
            !0 !== t.clipping) ||
            (h.clippingPlanes = at.uniform),
            Dt(t, a),
            (i.needsLights = (function (t) {
              return (
                t.isMeshLambertMaterial ||
                t.isMeshToonMaterial ||
                t.isMeshPhongMaterial ||
                t.isMeshStandardMaterial ||
                t.isShadowMaterial ||
                (t.isShaderMaterial && !0 === t.lights)
              );
            })(t)),
            (i.lightsStateVersion = s),
            i.needsLights &&
              ((h.ambientLightColor.value = r.state.ambient),
              (h.lightProbe.value = r.state.probe),
              (h.directionalLights.value = r.state.directional),
              (h.directionalLightShadows.value = r.state.directionalShadow),
              (h.spotLights.value = r.state.spot),
              (h.spotLightShadows.value = r.state.spotShadow),
              (h.rectAreaLights.value = r.state.rectArea),
              (h.ltc_1.value = r.state.rectAreaLTC1),
              (h.ltc_2.value = r.state.rectAreaLTC2),
              (h.pointLights.value = r.state.point),
              (h.pointLightShadows.value = r.state.pointShadow),
              (h.hemisphereLights.value = r.state.hemi),
              (h.directionalShadowMap.value = r.state.directionalShadowMap),
              (h.directionalShadowMatrix.value =
                r.state.directionalShadowMatrix),
              (h.spotShadowMap.value = r.state.spotShadowMap),
              (h.spotShadowMatrix.value = r.state.spotShadowMatrix),
              (h.pointShadowMap.value = r.state.pointShadowMap),
              (h.pointShadowMatrix.value = r.state.pointShadowMatrix));
          const p = u.getUniforms(),
            f = Ba.seqWithValue(p.seq, h);
          return (i.currentProgram = u), (i.uniformsList = f), u;
        }
        function Dt(t, e) {
          const n = Z.get(t);
          (n.outputEncoding = e.outputEncoding),
            (n.instancing = e.instancing),
            (n.skinning = e.skinning),
            (n.morphTargets = e.morphTargets),
            (n.morphNormals = e.morphNormals),
            (n.numClippingPlanes = e.numClippingPlanes),
            (n.numIntersection = e.numClipIntersection),
            (n.vertexAlphas = e.vertexAlphas),
            (n.vertexTangents = e.vertexTangents);
        }
        function Ft(t, e, n, i) {
          !0 !== e.isScene && (e = G), J.resetTextureUnits();
          const r = e.fog,
            o = n.isMeshStandardMaterial ? e.environment : null,
            s = null === _ ? y.outputEncoding : _.texture.encoding,
            a = (n.isMeshStandardMaterial ? $ : Q).get(n.envMap || o),
            l =
              !0 === n.vertexColors &&
              i.geometry &&
              i.geometry.attributes.color &&
              4 === i.geometry.attributes.color.itemSize,
            c = i.geometry && i.geometry.attributes.tangent,
            u = i.geometry && i.geometry.morphAttributes.position,
            h = i.geometry && i.geometry.morphAttributes.normal,
            p = Z.get(n),
            f = d.state.lights;
          if (!0 === F && (!0 === z || t !== S)) {
            const e = t === S && n.id === M;
            at.setState(n, t, e);
          }
          let m = !1;
          n.version === p.__version
            ? (p.needsLights && p.lightsStateVersion !== f.state.version) ||
              p.outputEncoding !== s ||
              (i.isInstancedMesh && !1 === p.instancing)
              ? (m = !0)
              : i.isInstancedMesh || !0 !== p.instancing
              ? i.isSkinnedMesh && !1 === p.skinning
                ? (m = !0)
                : i.isSkinnedMesh || !0 !== p.skinning
                ? p.envMap !== a || (n.fog && p.fog !== r)
                  ? (m = !0)
                  : void 0 === p.numClippingPlanes ||
                    (p.numClippingPlanes === at.numPlanes &&
                      p.numIntersection === at.numIntersection)
                  ? (p.vertexAlphas !== l ||
                      p.vertexTangents !== c ||
                      p.morphTargets !== u ||
                      p.morphNormals !== h) &&
                    (m = !0)
                  : (m = !0)
                : (m = !0)
              : (m = !0)
            : ((m = !0), (p.__version = n.version));
          let g = p.currentProgram;
          !0 === m && (g = Ot(n, e, i));
          let v = !1,
            x = !1,
            b = !1;
          const w = g.getUniforms(),
            E = p.uniforms;
          if (
            (X.useProgram(g.program) && ((v = !0), (x = !0), (b = !0)),
            n.id !== M && ((M = n.id), (x = !0)),
            v || S !== t)
          ) {
            if (
              (w.setValue(vt, "projectionMatrix", t.projectionMatrix),
              q.logarithmicDepthBuffer &&
                w.setValue(
                  vt,
                  "logDepthBufFC",
                  2 / (Math.log(t.far + 1) / Math.LN2)
                ),
              S !== t && ((S = t), (x = !0), (b = !0)),
              n.isShaderMaterial ||
                n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshStandardMaterial ||
                n.envMap)
            ) {
              const e = w.map.cameraPosition;
              void 0 !== e &&
                e.setValue(vt, V.setFromMatrixPosition(t.matrixWorld));
            }
            (n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshLambertMaterial ||
              n.isMeshBasicMaterial ||
              n.isMeshStandardMaterial ||
              n.isShaderMaterial) &&
              w.setValue(vt, "isOrthographic", !0 === t.isOrthographicCamera),
              (n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshLambertMaterial ||
                n.isMeshBasicMaterial ||
                n.isMeshStandardMaterial ||
                n.isShaderMaterial ||
                n.isShadowMaterial ||
                i.isSkinnedMesh) &&
                w.setValue(vt, "viewMatrix", t.matrixWorldInverse);
          }
          if (i.isSkinnedMesh) {
            w.setOptional(vt, i, "bindMatrix"),
              w.setOptional(vt, i, "bindMatrixInverse");
            const t = i.skeleton;
            t &&
              (q.floatVertexTextures
                ? (null === t.boneTexture && t.computeBoneTexture(),
                  w.setValue(vt, "boneTexture", t.boneTexture, J),
                  w.setValue(vt, "boneTextureSize", t.boneTextureSize))
                : w.setOptional(vt, t, "boneMatrices"));
          }
          var T, A;
          return (
            (x || p.receiveShadow !== i.receiveShadow) &&
              ((p.receiveShadow = i.receiveShadow),
              w.setValue(vt, "receiveShadow", i.receiveShadow)),
            x &&
              (w.setValue(vt, "toneMappingExposure", y.toneMappingExposure),
              p.needsLights &&
                ((A = b),
                ((T = E).ambientLightColor.needsUpdate = A),
                (T.lightProbe.needsUpdate = A),
                (T.directionalLights.needsUpdate = A),
                (T.directionalLightShadows.needsUpdate = A),
                (T.pointLights.needsUpdate = A),
                (T.pointLightShadows.needsUpdate = A),
                (T.spotLights.needsUpdate = A),
                (T.spotLightShadows.needsUpdate = A),
                (T.rectAreaLights.needsUpdate = A),
                (T.hemisphereLights.needsUpdate = A)),
              r && n.fog && rt.refreshFogUniforms(E, r),
              rt.refreshMaterialUniforms(E, n, R, L, H),
              Ba.upload(vt, p.uniformsList, E, J)),
            n.isShaderMaterial &&
              !0 === n.uniformsNeedUpdate &&
              (Ba.upload(vt, p.uniformsList, E, J),
              (n.uniformsNeedUpdate = !1)),
            n.isSpriteMaterial && w.setValue(vt, "center", i.center),
            w.setValue(vt, "modelViewMatrix", i.modelViewMatrix),
            w.setValue(vt, "normalMatrix", i.normalMatrix),
            w.setValue(vt, "modelMatrix", i.matrixWorld),
            g
          );
        }
        Pt.setAnimationLoop(function (t) {
          Tt && Tt(t);
        }),
          "undefined" != typeof window && Pt.setContext(window),
          (this.setAnimationLoop = function (t) {
            (Tt = t),
              bt.setAnimationLoop(t),
              null === t ? Pt.stop() : Pt.start();
          }),
          bt.addEventListener("sessionstart", At),
          bt.addEventListener("sessionend", Ct),
          (this.render = function (t, e) {
            if (void 0 !== e && !0 !== e.isCamera)
              return void console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
            if (!0 === x) return;
            !0 === t.autoUpdate && t.updateMatrixWorld(),
              null === e.parent && e.updateMatrixWorld(),
              !0 === bt.enabled &&
                !0 === bt.isPresenting &&
                (!0 === bt.cameraAutoUpdate && bt.updateCamera(e),
                (e = bt.getCamera())),
              !0 === t.isScene && t.onBeforeRender(y, t, e, _),
              (d = st.get(t, v.length)),
              d.init(),
              v.push(d),
              U.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              k.setFromProjectionMatrix(U),
              (z = this.localClippingEnabled),
              (F = at.init(this.clippingPlanes, z, e)),
              (h = ot.get(t, g.length)),
              h.init(),
              g.push(h),
              Nt(t, e, 0, y.sortObjects),
              h.finish(),
              !0 === y.sortObjects && h.sort(P, N),
              !0 === F && at.beginShadows();
            const n = d.state.shadowsArray;
            lt.render(n, t, e),
              d.setupLights(),
              d.setupLightsView(e),
              !0 === F && at.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              ct.render(h, t);
            const i = h.opaque,
              r = h.transmissive,
              o = h.transparent;
            i.length > 0 && It(i, t, e),
              r.length > 0 &&
                (function (t, e, n, i) {
                  if (null === H) {
                    const t = !0 === s && !0 === q.isWebGL2;
                    H = new (t ? ri : ni)(1024, 1024, {
                      generateMipmaps: !0,
                      type: null !== mt.convert(Rt) ? Rt : Mt,
                      minFilter: wt,
                      magFilter: pt,
                      wrapS: ht,
                      wrapT: ht,
                    });
                  }
                  const r = y.getRenderTarget();
                  y.setRenderTarget(H), y.clear();
                  const o = y.toneMapping;
                  (y.toneMapping = K),
                    It(t, n, i),
                    (y.toneMapping = o),
                    J.updateMultisampleRenderTarget(H),
                    J.updateRenderTargetMipmap(H),
                    y.setRenderTarget(r),
                    It(e, n, i);
                })(i, r, t, e),
              o.length > 0 && It(o, t, e),
              null !== _ &&
                (J.updateMultisampleRenderTarget(_),
                J.updateRenderTargetMipmap(_)),
              !0 === t.isScene && t.onAfterRender(y, t, e),
              X.buffers.depth.setTest(!0),
              X.buffers.depth.setMask(!0),
              X.buffers.color.setMask(!0),
              X.setPolygonOffset(!1),
              gt.resetDefaultState(),
              (M = -1),
              (S = null),
              v.pop(),
              (d = v.length > 0 ? v[v.length - 1] : null),
              g.pop(),
              (h = g.length > 0 ? g[g.length - 1] : null);
          }),
          (this.getActiveCubeFace = function () {
            return b;
          }),
          (this.getActiveMipmapLevel = function () {
            return w;
          }),
          (this.getRenderTarget = function () {
            return _;
          }),
          (this.setRenderTarget = function (t, e = 0, n = 0) {
            (_ = t),
              (b = e),
              (w = n),
              t &&
                void 0 === Z.get(t).__webglFramebuffer &&
                J.setupRenderTarget(t);
            let i = null,
              r = !1,
              o = !1;
            if (t) {
              const n = t.texture;
              (n.isDataTexture3D || n.isDataTexture2DArray) && (o = !0);
              const s = Z.get(t).__webglFramebuffer;
              t.isWebGLCubeRenderTarget
                ? ((i = s[e]), (r = !0))
                : (i = t.isWebGLMultisampleRenderTarget
                    ? Z.get(t).__webglMultisampledFramebuffer
                    : s),
                E.copy(t.viewport),
                T.copy(t.scissor),
                (A = t.scissorTest);
            } else
              E.copy(I).multiplyScalar(R).floor(),
                T.copy(B).multiplyScalar(R).floor(),
                (A = O);
            if (X.bindFramebuffer(36160, i) && q.drawBuffers) {
              let e = !1;
              if (t)
                if (t.isWebGLMultipleRenderTargets) {
                  const n = t.texture;
                  if (D.length !== n.length || 36064 !== D[0]) {
                    for (let t = 0, e = n.length; t < e; t++) D[t] = 36064 + t;
                    (D.length = n.length), (e = !0);
                  }
                } else
                  (1 === D.length && 36064 === D[0]) ||
                    ((D[0] = 36064), (D.length = 1), (e = !0));
              else
                (1 === D.length && 1029 === D[0]) ||
                  ((D[0] = 1029), (D.length = 1), (e = !0));
              e &&
                (q.isWebGL2
                  ? vt.drawBuffers(D)
                  : W.get("WEBGL_draw_buffers").drawBuffersWEBGL(D));
            }
            if ((X.viewport(E), X.scissor(T), X.setScissorTest(A), r)) {
              const i = Z.get(t.texture);
              vt.framebufferTexture2D(
                36160,
                36064,
                34069 + e,
                i.__webglTexture,
                n
              );
            } else if (o) {
              const i = Z.get(t.texture),
                r = e || 0;
              vt.framebufferTextureLayer(
                36160,
                36064,
                i.__webglTexture,
                n || 0,
                r
              );
            }
          }),
          (this.readRenderTargetPixels = function (t, e, n, i, r, o, s) {
            if (!t || !t.isWebGLRenderTarget)
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
            let a = Z.get(t).__webglFramebuffer;
            if ((t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a)) {
              X.bindFramebuffer(36160, a);
              try {
                const s = t.texture,
                  a = s.format,
                  l = s.type;
                if (a !== kt && mt.convert(a) !== vt.getParameter(35739))
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                const c =
                  l === Rt &&
                  (W.has("EXT_color_buffer_half_float") ||
                    (q.isWebGL2 && W.has("EXT_color_buffer_float")));
                if (
                  !(
                    l === Mt ||
                    mt.convert(l) === vt.getParameter(35738) ||
                    (l === Lt &&
                      (q.isWebGL2 ||
                        W.has("OES_texture_float") ||
                        W.has("WEBGL_color_buffer_float"))) ||
                    c
                  )
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                36053 === vt.checkFramebufferStatus(36160)
                  ? e >= 0 &&
                    e <= t.width - i &&
                    n >= 0 &&
                    n <= t.height - r &&
                    vt.readPixels(e, n, i, r, mt.convert(a), mt.convert(l), o)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                const t = null !== _ ? Z.get(_).__webglFramebuffer : null;
                X.bindFramebuffer(36160, t);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (t, e, n = 0) {
            const i = Math.pow(2, -n),
              r = Math.floor(e.image.width * i),
              o = Math.floor(e.image.height * i);
            let s = mt.convert(e.format);
            q.isWebGL2 &&
              (6407 === s && (s = 32849), 6408 === s && (s = 32856)),
              J.setTexture2D(e, 0),
              vt.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0),
              X.unbindTexture();
          }),
          (this.copyTextureToTexture = function (t, e, n, i = 0) {
            const r = e.image.width,
              o = e.image.height,
              s = mt.convert(n.format),
              a = mt.convert(n.type);
            J.setTexture2D(n, 0),
              vt.pixelStorei(37440, n.flipY),
              vt.pixelStorei(37441, n.premultiplyAlpha),
              vt.pixelStorei(3317, n.unpackAlignment),
              e.isDataTexture
                ? vt.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data)
                : e.isCompressedTexture
                ? vt.compressedTexSubImage2D(
                    3553,
                    i,
                    t.x,
                    t.y,
                    e.mipmaps[0].width,
                    e.mipmaps[0].height,
                    s,
                    e.mipmaps[0].data
                  )
                : vt.texSubImage2D(3553, i, t.x, t.y, s, a, e.image),
              0 === i && n.generateMipmaps && vt.generateMipmap(3553),
              X.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
            if (y.isWebGL1Renderer)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
            const o = t.max.x - t.min.x + 1,
              s = t.max.y - t.min.y + 1,
              a = t.max.z - t.min.z + 1,
              l = mt.convert(i.format),
              c = mt.convert(i.type);
            let u;
            if (i.isDataTexture3D) J.setTexture3D(i, 0), (u = 32879);
            else {
              if (!i.isDataTexture2DArray)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                );
              J.setTexture2DArray(i, 0), (u = 35866);
            }
            vt.pixelStorei(37440, i.flipY),
              vt.pixelStorei(37441, i.premultiplyAlpha),
              vt.pixelStorei(3317, i.unpackAlignment);
            const h = vt.getParameter(3314),
              d = vt.getParameter(32878),
              p = vt.getParameter(3316),
              f = vt.getParameter(3315),
              m = vt.getParameter(32877),
              g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
            vt.pixelStorei(3314, g.width),
              vt.pixelStorei(32878, g.height),
              vt.pixelStorei(3316, t.min.x),
              vt.pixelStorei(3315, t.min.y),
              vt.pixelStorei(32877, t.min.z),
              n.isDataTexture || n.isDataTexture3D
                ? vt.texSubImage3D(u, r, e.x, e.y, e.z, o, s, a, l, c, g.data)
                : n.isCompressedTexture
                ? (console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                  ),
                  vt.compressedTexSubImage3D(
                    u,
                    r,
                    e.x,
                    e.y,
                    e.z,
                    o,
                    s,
                    a,
                    l,
                    g.data
                  ))
                : vt.texSubImage3D(u, r, e.x, e.y, e.z, o, s, a, l, c, g),
              vt.pixelStorei(3314, h),
              vt.pixelStorei(32878, d),
              vt.pixelStorei(3316, p),
              vt.pixelStorei(3315, f),
              vt.pixelStorei(32877, m),
              0 === r && i.generateMipmaps && vt.generateMipmap(u),
              X.unbindTexture();
          }),
          (this.initTexture = function (t) {
            J.setTexture2D(t, 0), X.unbindTexture();
          }),
          (this.resetState = function () {
            (b = 0), (w = 0), (_ = null), X.reset(), gt.reset();
          }),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      class Tl extends El {}
      Tl.prototype.isWebGL1Renderer = !0;
      class Al {
        constructor(t, e = 25e-5) {
          (this.name = ""), (this.color = new Cr(t)), (this.density = e);
        }
        clone() {
          return new Al(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density,
          };
        }
      }
      Al.prototype.isFogExp2 = !0;
      class Cl {
        constructor(t, e = 1, n = 1e3) {
          (this.name = ""),
            (this.color = new Cr(t)),
            (this.near = e),
            (this.far = n);
        }
        clone() {
          return new Cl(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        }
      }
      Cl.prototype.isFog = !0;
      class Ll extends lr {
        constructor() {
          super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment &&
              (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.autoUpdate = t.autoUpdate),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
        }
      }
      Ll.prototype.isScene = !0;
      class Rl {
        constructor(t, e) {
          (this.array = t),
            (this.stride = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.usage = Sn),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = Hn());
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        copy(t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.usage = t.usage),
            this
          );
        }
        copyAt(t, e, n) {
          (t *= this.stride), (n *= e.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        clone(t) {
          void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = Hn()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const e = new this.array.constructor(
              t.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(e, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        toJSON(t) {
          return (
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = Hn()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      Rl.prototype.isInterleavedBuffer = !0;
      const Pl = new si();
      class Nl {
        constructor(t, e, n, i = !1) {
          (this.name = ""),
            (this.data = t),
            (this.itemSize = e),
            (this.offset = n),
            (this.normalized = !0 === i);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(t) {
          this.data.needsUpdate = t;
        }
        applyMatrix4(t) {
          for (let e = 0, n = this.data.count; e < n; e++)
            (Pl.x = this.getX(e)),
              (Pl.y = this.getY(e)),
              (Pl.z = this.getZ(e)),
              Pl.applyMatrix4(t),
              this.setXYZ(e, Pl.x, Pl.y, Pl.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Pl.x = this.getX(e)),
              (Pl.y = this.getY(e)),
              (Pl.z = this.getZ(e)),
              Pl.applyNormalMatrix(t),
              this.setXYZ(e, Pl.x, Pl.y, Pl.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Pl.x = this.getX(e)),
              (Pl.y = this.getY(e)),
              (Pl.z = this.getZ(e)),
              Pl.transformDirection(t),
              this.setXYZ(e, Pl.x, Pl.y, Pl.z);
          return this;
        }
        setX(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset] = e), this
          );
        }
        setY(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 1] = e), this
          );
        }
        setZ(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 2] = e), this
          );
        }
        setW(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 3] = e), this
          );
        }
        getX(t) {
          return this.data.array[t * this.data.stride + this.offset];
        }
        getY(t) {
          return this.data.array[t * this.data.stride + this.offset + 1];
        }
        getZ(t) {
          return this.data.array[t * this.data.stride + this.offset + 2];
        }
        getW(t) {
          return this.data.array[t * this.data.stride + this.offset + 3];
        }
        setXY(t, e, n) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            this
          );
        }
        setXYZ(t, e, n, i) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            this
          );
        }
        setXYZW(t, e, n, i, r) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            (this.data.array[t + 3] = r),
            this
          );
        }
        clone(t) {
          if (void 0 === t) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let e = 0; e < this.count; e++) {
              const n = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[n + e]);
            }
            return new Nr(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new Nl(
              t.interleavedBuffers[this.data.uuid],
              this.itemSize,
              this.offset,
              this.normalized
            )
          );
        }
        toJSON(t) {
          if (void 0 === t) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
            );
            const t = [];
            for (let e = 0; e < this.count; e++) {
              const n = e * this.data.stride + this.offset;
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[n + e]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          );
        }
      }
      Nl.prototype.isInterleavedBufferAttribute = !0;
      class Il extends wr {
        constructor(t) {
          super(),
            (this.type = "SpriteMaterial"),
            (this.color = new Cr(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.rotation = t.rotation),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          );
        }
      }
      let Bl;
      Il.prototype.isSpriteMaterial = !0;
      const Ol = new si(),
        Dl = new si(),
        kl = new si(),
        Fl = new Yn(),
        zl = new Yn(),
        Hl = new ki(),
        Ul = new si(),
        Vl = new si(),
        Gl = new si(),
        jl = new Yn(),
        Wl = new Yn(),
        ql = new Yn();
      class Xl extends lr {
        constructor(t) {
          if ((super(), (this.type = "Sprite"), void 0 === Bl)) {
            Bl = new $r();
            const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
              e = new Rl(t, 5);
            Bl.setIndex([0, 1, 2, 0, 2, 3]),
              Bl.setAttribute("position", new Nl(e, 3, 0, !1)),
              Bl.setAttribute("uv", new Nl(e, 2, 3, !1));
          }
          (this.geometry = Bl),
            (this.material = void 0 !== t ? t : new Il()),
            (this.center = new Yn(0.5, 0.5));
        }
        raycast(t, e) {
          null === t.camera &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
            ),
            Dl.setFromMatrixScale(this.matrixWorld),
            Hl.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              t.camera.matrixWorldInverse,
              this.matrixWorld
            ),
            kl.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera &&
              !1 === this.material.sizeAttenuation &&
              Dl.multiplyScalar(-kl.z);
          const n = this.material.rotation;
          let i, r;
          0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
          const o = this.center;
          Yl(Ul.set(-0.5, -0.5, 0), kl, o, Dl, i, r),
            Yl(Vl.set(0.5, -0.5, 0), kl, o, Dl, i, r),
            Yl(Gl.set(0.5, 0.5, 0), kl, o, Dl, i, r),
            jl.set(0, 0),
            Wl.set(1, 0),
            ql.set(1, 1);
          let s = t.ray.intersectTriangle(Ul, Vl, Gl, !1, Ol);
          if (
            null === s &&
            (Yl(Vl.set(-0.5, 0.5, 0), kl, o, Dl, i, r),
            Wl.set(0, 1),
            (s = t.ray.intersectTriangle(Ul, Gl, Vl, !1, Ol)),
            null === s)
          )
            return;
          const a = t.ray.origin.distanceTo(Ol);
          a < t.near ||
            a > t.far ||
            e.push({
              distance: a,
              point: Ol.clone(),
              uv: xr.getUV(Ol, Ul, Vl, Gl, jl, Wl, ql, new Yn()),
              face: null,
              object: this,
            });
        }
        copy(t) {
          return (
            super.copy(t),
            void 0 !== t.center && this.center.copy(t.center),
            (this.material = t.material),
            this
          );
        }
      }
      function Yl(t, e, n, i, r, o) {
        Fl.subVectors(t, n).addScalar(0.5).multiply(i),
          void 0 !== r
            ? ((zl.x = o * Fl.x - r * Fl.y), (zl.y = r * Fl.x + o * Fl.y))
            : zl.copy(Fl),
          t.copy(e),
          (t.x += zl.x),
          (t.y += zl.y),
          t.applyMatrix4(Hl);
      }
      Xl.prototype.isSprite = !0;
      const Zl = new si(),
        Jl = new si();
      class Kl extends lr {
        constructor() {
          super(),
            (this._currentLevel = 0),
            (this.type = "LOD"),
            Object.defineProperties(this, {
              levels: { enumerable: !0, value: [] },
              isLOD: { value: !0 },
            }),
            (this.autoUpdate = !0);
        }
        copy(t) {
          super.copy(t, !1);
          const e = t.levels;
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t];
            this.addLevel(n.object.clone(), n.distance);
          }
          return (this.autoUpdate = t.autoUpdate), this;
        }
        addLevel(t, e = 0) {
          e = Math.abs(e);
          const n = this.levels;
          let i;
          for (i = 0; i < n.length && !(e < n[i].distance); i++);
          return n.splice(i, 0, { distance: e, object: t }), this.add(t), this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(t) {
          const e = this.levels;
          if (e.length > 0) {
            let n, i;
            for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
            return e[n - 1].object;
          }
          return null;
        }
        raycast(t, e) {
          if (this.levels.length > 0) {
            Zl.setFromMatrixPosition(this.matrixWorld);
            const n = t.ray.origin.distanceTo(Zl);
            this.getObjectForDistance(n).raycast(t, e);
          }
        }
        update(t) {
          const e = this.levels;
          if (e.length > 1) {
            Zl.setFromMatrixPosition(t.matrixWorld),
              Jl.setFromMatrixPosition(this.matrixWorld);
            const n = Zl.distanceTo(Jl) / t.zoom;
            let i, r;
            for (
              e[0].object.visible = !0, i = 1, r = e.length;
              i < r && n >= e[i].distance;
              i++
            )
              (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
            for (this._currentLevel = i - 1; i < r; i++)
              e[i].object.visible = !1;
          }
        }
        toJSON(t) {
          const e = super.toJSON(t);
          !1 === this.autoUpdate && (e.object.autoUpdate = !1),
            (e.object.levels = []);
          const n = this.levels;
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            e.object.levels.push({
              object: i.object.uuid,
              distance: i.distance,
            });
          }
          return e;
        }
      }
      const Ql = new si(),
        $l = new ei(),
        tc = new ei(),
        ec = new si(),
        nc = new ki();
      class ic extends xo {
        constructor(t, e) {
          super(t, e),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new ki()),
            (this.bindMatrixInverse = new ki());
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bindMode = t.bindMode),
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            (this.skeleton = t.skeleton),
            this
          );
        }
        bind(t, e) {
          (this.skeleton = t),
            void 0 === e &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.copy(e).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const t = new ei(),
            e = this.geometry.attributes.skinWeight;
          for (let n = 0, i = e.count; n < i; n++) {
            (t.x = e.getX(n)),
              (t.y = e.getY(n)),
              (t.z = e.getZ(n)),
              (t.w = e.getW(n));
            const i = 1 / t.manhattanLength();
            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
              e.setXYZW(n, t.x, t.y, t.z, t.w);
          }
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            "attached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        boneTransform(t, e) {
          const n = this.skeleton,
            i = this.geometry;
          $l.fromBufferAttribute(i.attributes.skinIndex, t),
            tc.fromBufferAttribute(i.attributes.skinWeight, t),
            Ql.fromBufferAttribute(i.attributes.position, t).applyMatrix4(
              this.bindMatrix
            ),
            e.set(0, 0, 0);
          for (let t = 0; t < 4; t++) {
            const i = tc.getComponent(t);
            if (0 !== i) {
              const r = $l.getComponent(t);
              nc.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                e.addScaledVector(ec.copy(Ql).applyMatrix4(nc), i);
            }
          }
          return e.applyMatrix4(this.bindMatrixInverse);
        }
      }
      ic.prototype.isSkinnedMesh = !0;
      class rc extends lr {
        constructor() {
          super(), (this.type = "Bone");
        }
      }
      rc.prototype.isBone = !0;
      class oc extends $n {
        constructor(
          t = null,
          e = 1,
          n = 1,
          i,
          r,
          o,
          s,
          a,
          l = pt,
          c = pt,
          u,
          h
        ) {
          super(null, o, s, a, l, c, i, r, u, h),
            (this.image = { data: t, width: e, height: n }),
            (this.magFilter = l),
            (this.minFilter = c),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0);
        }
      }
      oc.prototype.isDataTexture = !0;
      const sc = new ki(),
        ac = new ki();
      class lc {
        constructor(t = [], e = []) {
          (this.uuid = Hn()),
            (this.bones = t.slice(0)),
            (this.boneInverses = e),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init();
        }
        init() {
          const t = this.bones,
            e = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(16 * t.length)),
            0 === e.length)
          )
            this.calculateInverses();
          else if (t.length !== e.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let t = 0, e = this.bones.length; t < e; t++)
              this.boneInverses.push(new ki());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = new ki();
            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
              this.boneInverses.push(e);
          }
        }
        pose() {
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t];
            e && e.matrixWorld.copy(this.boneInverses[t]).invert();
          }
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t];
            e &&
              (e.parent && e.parent.isBone
                ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                  e.matrix.multiply(e.matrixWorld))
                : e.matrix.copy(e.matrixWorld),
              e.matrix.decompose(e.position, e.quaternion, e.scale));
          }
        }
        update() {
          const t = this.bones,
            e = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let i = 0, r = t.length; i < r; i++) {
            const r = t[i] ? t[i].matrixWorld : ac;
            sc.multiplyMatrices(r, e[i]), sc.toArray(n, 16 * i);
          }
          null !== i && (i.needsUpdate = !0);
        }
        clone() {
          return new lc(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let t = Math.sqrt(4 * this.bones.length);
          (t = Wn(t)), (t = Math.max(t, 4));
          const e = new Float32Array(t * t * 4);
          e.set(this.boneMatrices);
          const n = new oc(e, t, t, kt, Lt);
          return (
            (this.boneMatrices = e),
            (this.boneTexture = n),
            (this.boneTextureSize = t),
            this
          );
        }
        getBoneByName(t) {
          for (let e = 0, n = this.bones.length; e < n; e++) {
            const n = this.bones[e];
            if (n.name === t) return n;
          }
        }
        dispose() {
          null !== this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(t, e) {
          this.uuid = t.uuid;
          for (let n = 0, i = t.bones.length; n < i; n++) {
            const i = t.bones[n];
            let r = e[i];
            void 0 === r &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", i),
              (r = new rc())),
              this.bones.push(r),
              this.boneInverses.push(new ki().fromArray(t.boneInverses[n]));
          }
          return this.init(), this;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          t.uuid = this.uuid;
          const e = this.bones,
            n = this.boneInverses;
          for (let i = 0, r = e.length; i < r; i++) {
            const r = e[i];
            t.bones.push(r.uuid);
            const o = n[i];
            t.boneInverses.push(o.toArray());
          }
          return t;
        }
      }
      const cc = new ki(),
        uc = new ki(),
        hc = [],
        dc = new xo();
      class pc extends xo {
        constructor(t, e, n) {
          super(t, e),
            (this.instanceMatrix = new Nr(new Float32Array(16 * n), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1);
        }
        copy(t) {
          return (
            super.copy(t),
            this.instanceMatrix.copy(t.instanceMatrix),
            null !== t.instanceColor &&
              (this.instanceColor = t.instanceColor.clone()),
            (this.count = t.count),
            this
          );
        }
        getColorAt(t, e) {
          e.fromArray(this.instanceColor.array, 3 * t);
        }
        getMatrixAt(t, e) {
          e.fromArray(this.instanceMatrix.array, 16 * t);
        }
        raycast(t, e) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((dc.geometry = this.geometry),
            (dc.material = this.material),
            void 0 !== dc.material)
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, cc),
                uc.multiplyMatrices(n, cc),
                (dc.matrixWorld = uc),
                dc.raycast(t, hc);
              for (let t = 0, n = hc.length; t < n; t++) {
                const n = hc[t];
                (n.instanceId = r), (n.object = this), e.push(n);
              }
              hc.length = 0;
            }
        }
        setColorAt(t, e) {
          null === this.instanceColor &&
            (this.instanceColor = new Nr(
              new Float32Array(3 * this.instanceMatrix.count),
              3
            )),
            e.toArray(this.instanceColor.array, 3 * t);
        }
        setMatrixAt(t, e) {
          e.toArray(this.instanceMatrix.array, 16 * t);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      pc.prototype.isInstancedMesh = !0;
      class fc extends wr {
        constructor(t) {
          super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new Cr(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.linewidth = t.linewidth),
            (this.linecap = t.linecap),
            (this.linejoin = t.linejoin),
            this
          );
        }
      }
      fc.prototype.isLineBasicMaterial = !0;
      const mc = new si(),
        gc = new si(),
        vc = new ki(),
        yc = new Di(),
        xc = new Ci();
      class bc extends lr {
        constructor(t = new $r(), e = new fc()) {
          super(),
            (this.type = "Line"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.isBufferGeometry)
            if (null === t.index) {
              const e = t.attributes.position,
                n = [0];
              for (let t = 1, i = e.count; t < i; t++)
                mc.fromBufferAttribute(e, t - 1),
                  gc.fromBufferAttribute(e, t),
                  (n[t] = n[t - 1]),
                  (n[t] += mc.distanceTo(gc));
              t.setAttribute("lineDistance", new Ur(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            t.isGeometry &&
              console.error(
                "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = t.params.Line.threshold,
            o = n.drawRange;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            xc.copy(n.boundingSphere),
            xc.applyMatrix4(i),
            (xc.radius += r),
            !1 === t.ray.intersectsSphere(xc))
          )
            return;
          vc.copy(i).invert(), yc.copy(t.ray).applyMatrix4(vc);
          const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = s * s,
            l = new si(),
            c = new si(),
            u = new si(),
            h = new si(),
            d = this.isLineSegments ? 2 : 1;
          if (n.isBufferGeometry) {
            const i = n.index,
              r = n.attributes.position;
            if (null !== i)
              for (
                let n = Math.max(0, o.start),
                  s = Math.min(i.count, o.start + o.count) - 1;
                n < s;
                n += d
              ) {
                const o = i.getX(n),
                  s = i.getX(n + 1);
                if (
                  (l.fromBufferAttribute(r, o),
                  c.fromBufferAttribute(r, s),
                  yc.distanceSqToSegment(l, c, h, u) > a)
                )
                  continue;
                h.applyMatrix4(this.matrixWorld);
                const d = t.ray.origin.distanceTo(h);
                d < t.near ||
                  d > t.far ||
                  e.push({
                    distance: d,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            else
              for (
                let n = Math.max(0, o.start),
                  i = Math.min(r.count, o.start + o.count) - 1;
                n < i;
                n += d
              ) {
                if (
                  (l.fromBufferAttribute(r, n),
                  c.fromBufferAttribute(r, n + 1),
                  yc.distanceSqToSegment(l, c, h, u) > a)
                )
                  continue;
                h.applyMatrix4(this.matrixWorld);
                const i = t.ray.origin.distanceTo(h);
                i < t.near ||
                  i > t.far ||
                  e.push({
                    distance: i,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
          } else
            n.isGeometry &&
              console.error(
                "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
        }
        updateMorphTargets() {
          const t = this.geometry;
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              n = Object.keys(e);
            if (n.length > 0) {
              const t = e[n[0]];
              if (void 0 !== t) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = e);
                }
              }
            }
          } else {
            const e = t.morphTargets;
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      bc.prototype.isLine = !0;
      const wc = new si(),
        _c = new si();
      class Mc extends bc {
        constructor(t, e) {
          super(t, e), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.isBufferGeometry)
            if (null === t.index) {
              const e = t.attributes.position,
                n = [];
              for (let t = 0, i = e.count; t < i; t += 2)
                wc.fromBufferAttribute(e, t),
                  _c.fromBufferAttribute(e, t + 1),
                  (n[t] = 0 === t ? 0 : n[t - 1]),
                  (n[t + 1] = n[t] + wc.distanceTo(_c));
              t.setAttribute("lineDistance", new Ur(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
          else
            t.isGeometry &&
              console.error(
                "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          return this;
        }
      }
      Mc.prototype.isLineSegments = !0;
      class Sc extends bc {
        constructor(t, e) {
          super(t, e), (this.type = "LineLoop");
        }
      }
      Sc.prototype.isLineLoop = !0;
      class Ec extends wr {
        constructor(t) {
          super(),
            (this.type = "PointsMaterial"),
            (this.color = new Cr(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.size = t.size),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          );
        }
      }
      Ec.prototype.isPointsMaterial = !0;
      const Tc = new ki(),
        Ac = new Di(),
        Cc = new Ci(),
        Lc = new si();
      class Rc extends lr {
        constructor(t = new $r(), e = new Ec()) {
          super(),
            (this.type = "Points"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = t.params.Points.threshold,
            o = n.drawRange;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Cc.copy(n.boundingSphere),
            Cc.applyMatrix4(i),
            (Cc.radius += r),
            !1 === t.ray.intersectsSphere(Cc))
          )
            return;
          Tc.copy(i).invert(), Ac.copy(t.ray).applyMatrix4(Tc);
          const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = s * s;
          if (n.isBufferGeometry) {
            const r = n.index,
              s = n.attributes.position;
            if (null !== r)
              for (
                let n = Math.max(0, o.start),
                  l = Math.min(r.count, o.start + o.count);
                n < l;
                n++
              ) {
                const o = r.getX(n);
                Lc.fromBufferAttribute(s, o), Pc(Lc, o, a, i, t, e, this);
              }
            else
              for (
                let n = Math.max(0, o.start),
                  r = Math.min(s.count, o.start + o.count);
                n < r;
                n++
              )
                Lc.fromBufferAttribute(s, n), Pc(Lc, n, a, i, t, e, this);
          } else
            console.error(
              "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
        updateMorphTargets() {
          const t = this.geometry;
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              n = Object.keys(e);
            if (n.length > 0) {
              const t = e[n[0]];
              if (void 0 !== t) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = e);
                }
              }
            }
          } else {
            const e = t.morphTargets;
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
        }
      }
      function Pc(t, e, n, i, r, o, s) {
        const a = Ac.distanceSqToPoint(t);
        if (a < n) {
          const n = new si();
          Ac.closestPointToPoint(t, n), n.applyMatrix4(i);
          const l = r.ray.origin.distanceTo(n);
          if (l < r.near || l > r.far) return;
          o.push({
            distance: l,
            distanceToRay: Math.sqrt(a),
            point: n,
            index: e,
            face: null,
            object: s,
          });
        }
      }
      Rc.prototype.isPoints = !0;
      class Nc extends $n {
        constructor(t, e, n, i, r, o, s, a, l) {
          super(t, e, n, i, r, o, s, a, l),
            (this.format = void 0 !== s ? s : Dt),
            (this.minFilter = void 0 !== o ? o : yt),
            (this.magFilter = void 0 !== r ? r : yt),
            (this.generateMipmaps = !1);
          const c = this;
          "requestVideoFrameCallback" in t &&
            t.requestVideoFrameCallback(function e() {
              (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
            });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const t = this.image;
          !1 == "requestVideoFrameCallback" in t &&
            t.readyState >= t.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      Nc.prototype.isVideoTexture = !0;
      class Ic extends $n {
        constructor(t, e, n, i, r, o, s, a, l, c, u, h) {
          super(null, o, s, a, l, c, i, r, u, h),
            (this.image = { width: e, height: n }),
            (this.mipmaps = t),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      Ic.prototype.isCompressedTexture = !0;
      class Bc extends $n {
        constructor(t, e, n, i, r, o, s, a, l) {
          super(t, e, n, i, r, o, s, a, l), (this.needsUpdate = !0);
        }
      }
      Bc.prototype.isCanvasTexture = !0;
      class Oc extends $n {
        constructor(t, e, n, i, r, o, s, a, l, c) {
          if ((c = void 0 !== c ? c : Ut) !== Ut && c !== Vt)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === n && c === Ut && (n = Tt),
            void 0 === n && c === Vt && (n = Bt),
            super(null, i, r, o, s, a, c, n, l),
            (this.image = { width: t, height: e }),
            (this.magFilter = void 0 !== s ? s : pt),
            (this.minFilter = void 0 !== a ? a : pt),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      Oc.prototype.isDepthTexture = !0;
      class Dc extends $r {
        constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
          super(),
            (this.type = "CircleGeometry"),
            (this.parameters = {
              radius: t,
              segments: e,
              thetaStart: n,
              thetaLength: i,
            }),
            (e = Math.max(3, e));
          const r = [],
            o = [],
            s = [],
            a = [],
            l = new si(),
            c = new Yn();
          o.push(0, 0, 0), s.push(0, 0, 1), a.push(0.5, 0.5);
          for (let r = 0, u = 3; r <= e; r++, u += 3) {
            const h = n + (r / e) * i;
            (l.x = t * Math.cos(h)),
              (l.y = t * Math.sin(h)),
              o.push(l.x, l.y, l.z),
              s.push(0, 0, 1),
              (c.x = (o[u] / t + 1) / 2),
              (c.y = (o[u + 1] / t + 1) / 2),
              a.push(c.x, c.y);
          }
          for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
          this.setIndex(r),
            this.setAttribute("position", new Ur(o, 3)),
            this.setAttribute("normal", new Ur(s, 3)),
            this.setAttribute("uv", new Ur(a, 2));
        }
        static fromJSON(t) {
          return new Dc(t.radius, t.segments, t.thetaStart, t.thetaLength);
        }
      }
      class kc extends $r {
        constructor(
          t = 1,
          e = 1,
          n = 1,
          i = 8,
          r = 1,
          o = !1,
          s = 0,
          a = 2 * Math.PI
        ) {
          super(),
            (this.type = "CylinderGeometry"),
            (this.parameters = {
              radiusTop: t,
              radiusBottom: e,
              height: n,
              radialSegments: i,
              heightSegments: r,
              openEnded: o,
              thetaStart: s,
              thetaLength: a,
            });
          const l = this;
          (i = Math.floor(i)), (r = Math.floor(r));
          const c = [],
            u = [],
            h = [],
            d = [];
          let p = 0;
          const f = [],
            m = n / 2;
          let g = 0;
          function v(n) {
            const r = p,
              o = new Yn(),
              f = new si();
            let v = 0;
            const y = !0 === n ? t : e,
              x = !0 === n ? 1 : -1;
            for (let t = 1; t <= i; t++)
              u.push(0, m * x, 0), h.push(0, x, 0), d.push(0.5, 0.5), p++;
            const b = p;
            for (let t = 0; t <= i; t++) {
              const e = (t / i) * a + s,
                n = Math.cos(e),
                r = Math.sin(e);
              (f.x = y * r),
                (f.y = m * x),
                (f.z = y * n),
                u.push(f.x, f.y, f.z),
                h.push(0, x, 0),
                (o.x = 0.5 * n + 0.5),
                (o.y = 0.5 * r * x + 0.5),
                d.push(o.x, o.y),
                p++;
            }
            for (let t = 0; t < i; t++) {
              const e = r + t,
                i = b + t;
              !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), (v += 3);
            }
            l.addGroup(g, v, !0 === n ? 1 : 2), (g += v);
          }
          !(function () {
            const o = new si(),
              v = new si();
            let y = 0;
            const x = (e - t) / n;
            for (let l = 0; l <= r; l++) {
              const c = [],
                g = l / r,
                y = g * (e - t) + t;
              for (let t = 0; t <= i; t++) {
                const e = t / i,
                  r = e * a + s,
                  l = Math.sin(r),
                  f = Math.cos(r);
                (v.x = y * l),
                  (v.y = -g * n + m),
                  (v.z = y * f),
                  u.push(v.x, v.y, v.z),
                  o.set(l, x, f).normalize(),
                  h.push(o.x, o.y, o.z),
                  d.push(e, 1 - g),
                  c.push(p++);
              }
              f.push(c);
            }
            for (let t = 0; t < i; t++)
              for (let e = 0; e < r; e++) {
                const n = f[e][t],
                  i = f[e + 1][t],
                  r = f[e + 1][t + 1],
                  o = f[e][t + 1];
                c.push(n, i, o), c.push(i, r, o), (y += 6);
              }
            l.addGroup(g, y, 0), (g += y);
          })(),
            !1 === o && (t > 0 && v(!0), e > 0 && v(!1)),
            this.setIndex(c),
            this.setAttribute("position", new Ur(u, 3)),
            this.setAttribute("normal", new Ur(h, 3)),
            this.setAttribute("uv", new Ur(d, 2));
        }
        static fromJSON(t) {
          return new kc(
            t.radiusTop,
            t.radiusBottom,
            t.height,
            t.radialSegments,
            t.heightSegments,
            t.openEnded,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class Fc extends kc {
        constructor(
          t = 1,
          e = 1,
          n = 8,
          i = 1,
          r = !1,
          o = 0,
          s = 2 * Math.PI
        ) {
          super(0, t, e, n, i, r, o, s),
            (this.type = "ConeGeometry"),
            (this.parameters = {
              radius: t,
              height: e,
              radialSegments: n,
              heightSegments: i,
              openEnded: r,
              thetaStart: o,
              thetaLength: s,
            });
        }
        static fromJSON(t) {
          return new Fc(
            t.radius,
            t.height,
            t.radialSegments,
            t.heightSegments,
            t.openEnded,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class zc extends $r {
        constructor(t, e, n = 1, i = 0) {
          super(),
            (this.type = "PolyhedronGeometry"),
            (this.parameters = {
              vertices: t,
              indices: e,
              radius: n,
              detail: i,
            });
          const r = [],
            o = [];
          function s(t, e, n, i) {
            const r = i + 1,
              o = [];
            for (let i = 0; i <= r; i++) {
              o[i] = [];
              const s = t.clone().lerp(n, i / r),
                a = e.clone().lerp(n, i / r),
                l = r - i;
              for (let t = 0; t <= l; t++)
                o[i][t] = 0 === t && i === r ? s : s.clone().lerp(a, t / l);
            }
            for (let t = 0; t < r; t++)
              for (let e = 0; e < 2 * (r - t) - 1; e++) {
                const n = Math.floor(e / 2);
                e % 2 == 0
                  ? (a(o[t][n + 1]), a(o[t + 1][n]), a(o[t][n]))
                  : (a(o[t][n + 1]), a(o[t + 1][n + 1]), a(o[t + 1][n]));
              }
          }
          function a(t) {
            r.push(t.x, t.y, t.z);
          }
          function l(e, n) {
            const i = 3 * e;
            (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
          }
          function c(t, e, n, i) {
            i < 0 && 1 === t.x && (o[e] = t.x - 1),
              0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + 0.5);
          }
          function u(t) {
            return Math.atan2(t.z, -t.x);
          }
          !(function (t) {
            const n = new si(),
              i = new si(),
              r = new si();
            for (let o = 0; o < e.length; o += 3)
              l(e[o + 0], n), l(e[o + 1], i), l(e[o + 2], r), s(n, i, r, t);
          })(i),
            (function (t) {
              const e = new si();
              for (let n = 0; n < r.length; n += 3)
                (e.x = r[n + 0]),
                  (e.y = r[n + 1]),
                  (e.z = r[n + 2]),
                  e.normalize().multiplyScalar(t),
                  (r[n + 0] = e.x),
                  (r[n + 1] = e.y),
                  (r[n + 2] = e.z);
            })(n),
            (function () {
              const t = new si();
              for (let n = 0; n < r.length; n += 3) {
                (t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);
                const i = u(t) / 2 / Math.PI + 0.5,
                  s =
                    ((e = t),
                    Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) /
                      Math.PI +
                      0.5);
                o.push(i, 1 - s);
              }
              var e;
              (function () {
                const t = new si(),
                  e = new si(),
                  n = new si(),
                  i = new si(),
                  s = new Yn(),
                  a = new Yn(),
                  l = new Yn();
                for (let h = 0, d = 0; h < r.length; h += 9, d += 6) {
                  t.set(r[h + 0], r[h + 1], r[h + 2]),
                    e.set(r[h + 3], r[h + 4], r[h + 5]),
                    n.set(r[h + 6], r[h + 7], r[h + 8]),
                    s.set(o[d + 0], o[d + 1]),
                    a.set(o[d + 2], o[d + 3]),
                    l.set(o[d + 4], o[d + 5]),
                    i.copy(t).add(e).add(n).divideScalar(3);
                  const p = u(i);
                  c(s, d + 0, t, p), c(a, d + 2, e, p), c(l, d + 4, n, p);
                }
              })(),
                (function () {
                  for (let t = 0; t < o.length; t += 6) {
                    const e = o[t + 0],
                      n = o[t + 2],
                      i = o[t + 4],
                      r = Math.max(e, n, i),
                      s = Math.min(e, n, i);
                    r > 0.9 &&
                      s < 0.1 &&
                      (e < 0.2 && (o[t + 0] += 1),
                      n < 0.2 && (o[t + 2] += 1),
                      i < 0.2 && (o[t + 4] += 1));
                  }
                })();
            })(),
            this.setAttribute("position", new Ur(r, 3)),
            this.setAttribute("normal", new Ur(r.slice(), 3)),
            this.setAttribute("uv", new Ur(o, 2)),
            0 === i ? this.computeVertexNormals() : this.normalizeNormals();
        }
        static fromJSON(t) {
          return new zc(t.vertices, t.indices, t.radius, t.details);
        }
      }
      class Hc extends zc {
        constructor(t = 1, e = 0) {
          const n = (1 + Math.sqrt(5)) / 2,
            i = 1 / n;
          super(
            [
              -1,
              -1,
              -1,
              -1,
              -1,
              1,
              -1,
              1,
              -1,
              -1,
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              1,
              1,
              1,
              -1,
              1,
              1,
              1,
              0,
              -i,
              -n,
              0,
              -i,
              n,
              0,
              i,
              -n,
              0,
              i,
              n,
              -i,
              -n,
              0,
              -i,
              n,
              0,
              i,
              -n,
              0,
              i,
              n,
              0,
              -n,
              0,
              -i,
              n,
              0,
              -i,
              -n,
              0,
              i,
              n,
              0,
              i,
            ],
            [
              3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17,
              4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12,
              1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18,
              2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4,
              12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14,
              4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
            ],
            t,
            e
          ),
            (this.type = "DodecahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new Hc(t.radius, t.detail);
        }
      }
      const Uc = new si(),
        Vc = new si(),
        Gc = new si(),
        jc = new xr();
      class Wc extends $r {
        constructor(t, e) {
          if (
            (super(),
            (this.type = "EdgesGeometry"),
            (this.parameters = { thresholdAngle: e }),
            (e = void 0 !== e ? e : 1),
            !0 === t.isGeometry)
          )
            return void console.error(
              "THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
          const n = Math.cos(Fn * e),
            i = t.getIndex(),
            r = t.getAttribute("position"),
            o = i ? i.count : r.count,
            s = [0, 0, 0],
            a = ["a", "b", "c"],
            l = new Array(3),
            c = {},
            u = [];
          for (let t = 0; t < o; t += 3) {
            i
              ? ((s[0] = i.getX(t)),
                (s[1] = i.getX(t + 1)),
                (s[2] = i.getX(t + 2)))
              : ((s[0] = t), (s[1] = t + 1), (s[2] = t + 2));
            const { a: e, b: o, c: h } = jc;
            if (
              (e.fromBufferAttribute(r, s[0]),
              o.fromBufferAttribute(r, s[1]),
              h.fromBufferAttribute(r, s[2]),
              jc.getNormal(Gc),
              (l[0] = `${e.x},${e.y},${e.z}`),
              (l[1] = `${o.x},${o.y},${o.z}`),
              (l[2] = `${h.x},${h.y},${h.z}`),
              l[0] !== l[1] && l[1] !== l[2] && l[2] !== l[0])
            )
              for (let t = 0; t < 3; t++) {
                const e = (t + 1) % 3,
                  i = l[t],
                  r = l[e],
                  o = jc[a[t]],
                  h = jc[a[e]],
                  d = `${i}_${r}`,
                  p = `${r}_${i}`;
                p in c && c[p]
                  ? (Gc.dot(c[p].normal) <= n &&
                      (u.push(o.x, o.y, o.z), u.push(h.x, h.y, h.z)),
                    (c[p] = null))
                  : d in c ||
                    (c[d] = { index0: s[t], index1: s[e], normal: Gc.clone() });
              }
          }
          for (const t in c)
            if (c[t]) {
              const { index0: e, index1: n } = c[t];
              Uc.fromBufferAttribute(r, e),
                Vc.fromBufferAttribute(r, n),
                u.push(Uc.x, Uc.y, Uc.z),
                u.push(Vc.x, Vc.y, Vc.z);
            }
          this.setAttribute("position", new Ur(u, 3));
        }
      }
      class qc {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(t, e) {
          const n = this.getUtoTmapping(t);
          return this.getPoint(n, e);
        }
        getPoints(t = 5) {
          const e = [];
          for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
          return e;
        }
        getSpacedPoints(t = 5) {
          const e = [];
          for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
          return e;
        }
        getLength() {
          const t = this.getLengths();
          return t[t.length - 1];
        }
        getLengths(t = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === t + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const e = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          e.push(0);
          for (let o = 1; o <= t; o++)
            (n = this.getPoint(o / t)),
              (r += n.distanceTo(i)),
              e.push(r),
              (i = n);
          return (this.cacheArcLengths = e), e;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(t, e) {
          const n = this.getLengths();
          let i = 0;
          const r = n.length;
          let o;
          o = e || t * n[r - 1];
          let s,
            a = 0,
            l = r - 1;
          for (; a <= l; )
            if (((i = Math.floor(a + (l - a) / 2)), (s = n[i] - o), s < 0))
              a = i + 1;
            else {
              if (!(s > 0)) {
                l = i;
                break;
              }
              l = i - 1;
            }
          if (((i = l), n[i] === o)) return i / (r - 1);
          const c = n[i];
          return (i + (o - c) / (n[i + 1] - c)) / (r - 1);
        }
        getTangent(t, e) {
          const n = 1e-4;
          let i = t - n,
            r = t + n;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const o = this.getPoint(i),
            s = this.getPoint(r),
            a = e || (o.isVector2 ? new Yn() : new si());
          return a.copy(s).sub(o).normalize(), a;
        }
        getTangentAt(t, e) {
          const n = this.getUtoTmapping(t);
          return this.getTangent(n, e);
        }
        computeFrenetFrames(t, e) {
          const n = new si(),
            i = [],
            r = [],
            o = [],
            s = new si(),
            a = new ki();
          for (let e = 0; e <= t; e++) {
            const n = e / t;
            (i[e] = this.getTangentAt(n, new si())), i[e].normalize();
          }
          (r[0] = new si()), (o[0] = new si());
          let l = Number.MAX_VALUE;
          const c = Math.abs(i[0].x),
            u = Math.abs(i[0].y),
            h = Math.abs(i[0].z);
          c <= l && ((l = c), n.set(1, 0, 0)),
            u <= l && ((l = u), n.set(0, 1, 0)),
            h <= l && n.set(0, 0, 1),
            s.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], s),
            o[0].crossVectors(i[0], r[0]);
          for (let e = 1; e <= t; e++) {
            if (
              ((r[e] = r[e - 1].clone()),
              (o[e] = o[e - 1].clone()),
              s.crossVectors(i[e - 1], i[e]),
              s.length() > Number.EPSILON)
            ) {
              s.normalize();
              const t = Math.acos(Un(i[e - 1].dot(i[e]), -1, 1));
              r[e].applyMatrix4(a.makeRotationAxis(s, t));
            }
            o[e].crossVectors(i[e], r[e]);
          }
          if (!0 === e) {
            let e = Math.acos(Un(r[0].dot(r[t]), -1, 1));
            (e /= t), i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
            for (let n = 1; n <= t; n++)
              r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)),
                o[n].crossVectors(i[n], r[n]);
          }
          return { tangents: i, normals: r, binormals: o };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (t.arcLengthDivisions = this.arcLengthDivisions),
            (t.type = this.type),
            t
          );
        }
        fromJSON(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        }
      }
      class Xc extends qc {
        constructor(
          t = 0,
          e = 0,
          n = 1,
          i = 1,
          r = 0,
          o = 2 * Math.PI,
          s = !1,
          a = 0
        ) {
          super(),
            (this.type = "EllipseCurve"),
            (this.aX = t),
            (this.aY = e),
            (this.xRadius = n),
            (this.yRadius = i),
            (this.aStartAngle = r),
            (this.aEndAngle = o),
            (this.aClockwise = s),
            (this.aRotation = a);
        }
        getPoint(t, e) {
          const n = e || new Yn(),
            i = 2 * Math.PI;
          let r = this.aEndAngle - this.aStartAngle;
          const o = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += i;
          for (; r > i; ) r -= i;
          r < Number.EPSILON && (r = o ? 0 : i),
            !0 !== this.aClockwise || o || (r === i ? (r = -i) : (r -= i));
          const s = this.aStartAngle + t * r;
          let a = this.aX + this.xRadius * Math.cos(s),
            l = this.aY + this.yRadius * Math.sin(s);
          if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation),
              e = Math.sin(this.aRotation),
              n = a - this.aX,
              i = l - this.aY;
            (a = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);
          }
          return n.set(a, l);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.aX = this.aX),
            (t.aY = this.aY),
            (t.xRadius = this.xRadius),
            (t.yRadius = this.yRadius),
            (t.aStartAngle = this.aStartAngle),
            (t.aEndAngle = this.aEndAngle),
            (t.aClockwise = this.aClockwise),
            (t.aRotation = this.aRotation),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          );
        }
      }
      Xc.prototype.isEllipseCurve = !0;
      class Yc extends Xc {
        constructor(t, e, n, i, r, o) {
          super(t, e, n, n, i, r, o), (this.type = "ArcCurve");
        }
      }
      function Zc() {
        let t = 0,
          e = 0,
          n = 0,
          i = 0;
        function r(r, o, s, a) {
          (t = r),
            (e = s),
            (n = -3 * r + 3 * o - 2 * s - a),
            (i = 2 * r - 2 * o + s + a);
        }
        return {
          initCatmullRom: function (t, e, n, i, o) {
            r(e, n, o * (n - t), o * (i - e));
          },
          initNonuniformCatmullRom: function (t, e, n, i, o, s, a) {
            let l = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
              c = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
            (l *= s), (c *= s), r(e, n, l, c);
          },
          calc: function (r) {
            const o = r * r;
            return t + e * r + n * o + i * (o * r);
          },
        };
      }
      Yc.prototype.isArcCurve = !0;
      const Jc = new si(),
        Kc = new Zc(),
        Qc = new Zc(),
        $c = new Zc();
      class tu extends qc {
        constructor(t = [], e = !1, n = "centripetal", i = 0.5) {
          super(),
            (this.type = "CatmullRomCurve3"),
            (this.points = t),
            (this.closed = e),
            (this.curveType = n),
            (this.tension = i);
        }
        getPoint(t, e = new si()) {
          const n = e,
            i = this.points,
            r = i.length,
            o = (r - (this.closed ? 0 : 1)) * t;
          let s,
            a,
            l = Math.floor(o),
            c = o - l;
          this.closed
            ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
            : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
            this.closed || l > 0
              ? (s = i[(l - 1) % r])
              : (Jc.subVectors(i[0], i[1]).add(i[0]), (s = Jc));
          const u = i[l % r],
            h = i[(l + 1) % r];
          if (
            (this.closed || l + 2 < r
              ? (a = i[(l + 2) % r])
              : (Jc.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (a = Jc)),
            "centripetal" === this.curveType || "chordal" === this.curveType)
          ) {
            const t = "chordal" === this.curveType ? 0.5 : 0.25;
            let e = Math.pow(s.distanceToSquared(u), t),
              n = Math.pow(u.distanceToSquared(h), t),
              i = Math.pow(h.distanceToSquared(a), t);
            n < 1e-4 && (n = 1),
              e < 1e-4 && (e = n),
              i < 1e-4 && (i = n),
              Kc.initNonuniformCatmullRom(s.x, u.x, h.x, a.x, e, n, i),
              Qc.initNonuniformCatmullRom(s.y, u.y, h.y, a.y, e, n, i),
              $c.initNonuniformCatmullRom(s.z, u.z, h.z, a.z, e, n, i);
          } else
            "catmullrom" === this.curveType &&
              (Kc.initCatmullRom(s.x, u.x, h.x, a.x, this.tension),
              Qc.initCatmullRom(s.y, u.y, h.y, a.y, this.tension),
              $c.initCatmullRom(s.z, u.z, h.z, a.z, this.tension));
          return n.set(Kc.calc(c), Qc.calc(c), $c.calc(c)), n;
        }
        copy(t) {
          super.copy(t), (this.points = []);
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone());
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.points = [];
          for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray());
          }
          return (
            (t.closed = this.closed),
            (t.curveType = this.curveType),
            (t.tension = this.tension),
            t
          );
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = []);
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(new si().fromArray(n));
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          );
        }
      }
      function eu(t, e, n, i, r) {
        const o = 0.5 * (i - e),
          s = 0.5 * (r - n),
          a = t * t;
        return (
          (2 * n - 2 * i + o + s) * (t * a) +
          (-3 * n + 3 * i - 2 * o - s) * a +
          o * t +
          n
        );
      }
      function nu(t, e, n, i) {
        return (
          (function (t, e) {
            const n = 1 - t;
            return n * n * e;
          })(t, e) +
          (function (t, e) {
            return 2 * (1 - t) * t * e;
          })(t, n) +
          (function (t, e) {
            return t * t * e;
          })(t, i)
        );
      }
      function iu(t, e, n, i, r) {
        return (
          (function (t, e) {
            const n = 1 - t;
            return n * n * n * e;
          })(t, e) +
          (function (t, e) {
            const n = 1 - t;
            return 3 * n * n * t * e;
          })(t, n) +
          (function (t, e) {
            return 3 * (1 - t) * t * t * e;
          })(t, i) +
          (function (t, e) {
            return t * t * t * e;
          })(t, r)
        );
      }
      tu.prototype.isCatmullRomCurve3 = !0;
      class ru extends qc {
        constructor(t = new Yn(), e = new Yn(), n = new Yn(), i = new Yn()) {
          super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(t, e = new Yn()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            s = this.v3;
          return n.set(iu(t, i.x, r.x, o.x, s.x), iu(t, i.y, r.y, o.y, s.y)), n;
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }
      }
      ru.prototype.isCubicBezierCurve = !0;
      class ou extends qc {
        constructor(t = new si(), e = new si(), n = new si(), i = new si()) {
          super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n),
            (this.v3 = i);
        }
        getPoint(t, e = new si()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            s = this.v3;
          return (
            n.set(
              iu(t, i.x, r.x, o.x, s.x),
              iu(t, i.y, r.y, o.y, s.y),
              iu(t, i.z, r.z, o.z, s.z)
            ),
            n
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          );
        }
      }
      ou.prototype.isCubicBezierCurve3 = !0;
      class su extends qc {
        constructor(t = new Yn(), e = new Yn()) {
          super(), (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
        }
        getPoint(t, e = new Yn()) {
          const n = e;
          return (
            1 === t
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
            n
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        getTangent(t, e) {
          const n = e || new Yn();
          return n.copy(this.v2).sub(this.v1).normalize(), n;
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      su.prototype.isLineCurve = !0;
      class au extends qc {
        constructor(t = new si(), e = new si()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = t),
            (this.v2 = e);
        }
        getPoint(t, e = new si()) {
          const n = e;
          return (
            1 === t
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
            n
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      class lu extends qc {
        constructor(t = new Yn(), e = new Yn(), n = new Yn()) {
          super(),
            (this.type = "QuadraticBezierCurve"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n);
        }
        getPoint(t, e = new Yn()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return n.set(nu(t, i.x, r.x, o.x), nu(t, i.y, r.y, o.y)), n;
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      lu.prototype.isQuadraticBezierCurve = !0;
      class cu extends qc {
        constructor(t = new si(), e = new si(), n = new si()) {
          super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n);
        }
        getPoint(t, e = new si()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            o = this.v2;
          return (
            n.set(
              nu(t, i.x, r.x, o.x),
              nu(t, i.y, r.y, o.y),
              nu(t, i.z, r.z, o.z)
            ),
            n
          );
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          );
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      }
      cu.prototype.isQuadraticBezierCurve3 = !0;
      class uu extends qc {
        constructor(t = []) {
          super(), (this.type = "SplineCurve"), (this.points = t);
        }
        getPoint(t, e = new Yn()) {
          const n = e,
            i = this.points,
            r = (i.length - 1) * t,
            o = Math.floor(r),
            s = r - o,
            a = i[0 === o ? o : o - 1],
            l = i[o],
            c = i[o > i.length - 2 ? i.length - 1 : o + 1],
            u = i[o > i.length - 3 ? i.length - 1 : o + 2];
          return n.set(eu(s, a.x, l.x, c.x, u.x), eu(s, a.y, l.y, c.y, u.y)), n;
        }
        copy(t) {
          super.copy(t), (this.points = []);
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone());
          }
          return this;
        }
        toJSON() {
          const t = super.toJSON();
          t.points = [];
          for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = []);
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(new Yn().fromArray(n));
          }
          return this;
        }
      }
      uu.prototype.isSplineCurve = !0;
      var hu = Object.freeze({
        __proto__: null,
        ArcCurve: Yc,
        CatmullRomCurve3: tu,
        CubicBezierCurve: ru,
        CubicBezierCurve3: ou,
        EllipseCurve: Xc,
        LineCurve: su,
        LineCurve3: au,
        QuadraticBezierCurve: lu,
        QuadraticBezierCurve3: cu,
        SplineCurve: uu,
      });
      function du(t, e, n, i, r) {
        let o, s;
        if (
          r ===
          (function (t, e, n, i) {
            let r = 0;
            for (let o = e, s = n - i; o < n; o += i)
              (r += (t[s] - t[o]) * (t[o + 1] + t[s + 1])), (s = o);
            return r;
          })(t, e, n, i) >
            0
        )
          for (o = e; o < n; o += i) s = Iu(o, t[o], t[o + 1], s);
        else for (o = n - i; o >= e; o -= i) s = Iu(o, t[o], t[o + 1], s);
        return s && Au(s, s.next) && (Bu(s), (s = s.next)), s;
      }
      function pu(t, e) {
        if (!t) return t;
        e || (e = t);
        let n,
          i = t;
        do {
          if (
            ((n = !1),
            i.steiner || (!Au(i, i.next) && 0 !== Tu(i.prev, i, i.next)))
          )
            i = i.next;
          else {
            if ((Bu(i), (i = e = i.prev), i === i.next)) break;
            n = !0;
          }
        } while (n || i !== e);
        return e;
      }
      function fu(t, e, n, i, r, o, s) {
        if (!t) return;
        !s &&
          o &&
          (function (t, e, n, i) {
            let r = t;
            do {
              null === r.z && (r.z = _u(r.x, r.y, e, n, i)),
                (r.prevZ = r.prev),
                (r.nextZ = r.next),
                (r = r.next);
            } while (r !== t);
            (r.prevZ.nextZ = null),
              (r.prevZ = null),
              (function (t) {
                let e,
                  n,
                  i,
                  r,
                  o,
                  s,
                  a,
                  l,
                  c = 1;
                do {
                  for (n = t, t = null, o = null, s = 0; n; ) {
                    for (
                      s++, i = n, a = 0, e = 0;
                      e < c && (a++, (i = i.nextZ), i);
                      e++
                    );
                    for (l = c; a > 0 || (l > 0 && i); )
                      0 !== a && (0 === l || !i || n.z <= i.z)
                        ? ((r = n), (n = n.nextZ), a--)
                        : ((r = i), (i = i.nextZ), l--),
                        o ? (o.nextZ = r) : (t = r),
                        (r.prevZ = o),
                        (o = r);
                    n = i;
                  }
                  (o.nextZ = null), (c *= 2);
                } while (s > 1);
              })(r);
          })(t, i, r, o);
        let a,
          l,
          c = t;
        for (; t.prev !== t.next; )
          if (((a = t.prev), (l = t.next), o ? gu(t, i, r, o) : mu(t)))
            e.push(a.i / n),
              e.push(t.i / n),
              e.push(l.i / n),
              Bu(t),
              (t = l.next),
              (c = l.next);
          else if ((t = l) === c) {
            s
              ? 1 === s
                ? fu((t = vu(pu(t), e, n)), e, n, i, r, o, 2)
                : 2 === s && yu(t, e, n, i, r, o)
              : fu(pu(t), e, n, i, r, o, 1);
            break;
          }
      }
      function mu(t) {
        const e = t.prev,
          n = t,
          i = t.next;
        if (Tu(e, n, i) >= 0) return !1;
        let r = t.next.next;
        for (; r !== t.prev; ) {
          if (
            Su(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
            Tu(r.prev, r, r.next) >= 0
          )
            return !1;
          r = r.next;
        }
        return !0;
      }
      function gu(t, e, n, i) {
        const r = t.prev,
          o = t,
          s = t.next;
        if (Tu(r, o, s) >= 0) return !1;
        const a = r.x < o.x ? (r.x < s.x ? r.x : s.x) : o.x < s.x ? o.x : s.x,
          l = r.y < o.y ? (r.y < s.y ? r.y : s.y) : o.y < s.y ? o.y : s.y,
          c = r.x > o.x ? (r.x > s.x ? r.x : s.x) : o.x > s.x ? o.x : s.x,
          u = r.y > o.y ? (r.y > s.y ? r.y : s.y) : o.y > s.y ? o.y : s.y,
          h = _u(a, l, e, n, i),
          d = _u(c, u, e, n, i);
        let p = t.prevZ,
          f = t.nextZ;
        for (; p && p.z >= h && f && f.z <= d; ) {
          if (
            p !== t.prev &&
            p !== t.next &&
            Su(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
            Tu(p.prev, p, p.next) >= 0
          )
            return !1;
          if (
            ((p = p.prevZ),
            f !== t.prev &&
              f !== t.next &&
              Su(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
              Tu(f.prev, f, f.next) >= 0)
          )
            return !1;
          f = f.nextZ;
        }
        for (; p && p.z >= h; ) {
          if (
            p !== t.prev &&
            p !== t.next &&
            Su(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
            Tu(p.prev, p, p.next) >= 0
          )
            return !1;
          p = p.prevZ;
        }
        for (; f && f.z <= d; ) {
          if (
            f !== t.prev &&
            f !== t.next &&
            Su(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
            Tu(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.nextZ;
        }
        return !0;
      }
      function vu(t, e, n) {
        let i = t;
        do {
          const r = i.prev,
            o = i.next.next;
          !Au(r, o) &&
            Cu(r, i, i.next, o) &&
            Pu(r, o) &&
            Pu(o, r) &&
            (e.push(r.i / n),
            e.push(i.i / n),
            e.push(o.i / n),
            Bu(i),
            Bu(i.next),
            (i = t = o)),
            (i = i.next);
        } while (i !== t);
        return pu(i);
      }
      function yu(t, e, n, i, r, o) {
        let s = t;
        do {
          let t = s.next.next;
          for (; t !== s.prev; ) {
            if (s.i !== t.i && Eu(s, t)) {
              let a = Nu(s, t);
              return (
                (s = pu(s, s.next)),
                (a = pu(a, a.next)),
                fu(s, e, n, i, r, o),
                void fu(a, e, n, i, r, o)
              );
            }
            t = t.next;
          }
          s = s.next;
        } while (s !== t);
      }
      function xu(t, e) {
        return t.x - e.x;
      }
      function bu(t, e) {
        if (
          (e = (function (t, e) {
            let n = e;
            const i = t.x,
              r = t.y;
            let o,
              s = -1 / 0;
            do {
              if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                const t =
                  n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                if (t <= i && t > s) {
                  if (((s = t), t === i)) {
                    if (r === n.y) return n;
                    if (r === n.next.y) return n.next;
                  }
                  o = n.x < n.next.x ? n : n.next;
                }
              }
              n = n.next;
            } while (n !== e);
            if (!o) return null;
            if (i === s) return o;
            const a = o,
              l = o.x,
              c = o.y;
            let u,
              h = 1 / 0;
            n = o;
            do {
              i >= n.x &&
                n.x >= l &&
                i !== n.x &&
                Su(r < c ? i : s, r, l, c, r < c ? s : i, r, n.x, n.y) &&
                ((u = Math.abs(r - n.y) / (i - n.x)),
                Pu(n, t) &&
                  (u < h ||
                    (u === h && (n.x > o.x || (n.x === o.x && wu(o, n))))) &&
                  ((o = n), (h = u))),
                (n = n.next);
            } while (n !== a);
            return o;
          })(t, e))
        ) {
          const n = Nu(e, t);
          pu(e, e.next), pu(n, n.next);
        }
      }
      function wu(t, e) {
        return Tu(t.prev, t, e.prev) < 0 && Tu(e.next, t, t.next) < 0;
      }
      function _u(t, e, n, i, r) {
        return (
          (t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) |
          ((e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) <<
            1)
        );
      }
      function Mu(t) {
        let e = t,
          n = t;
        do {
          (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
        } while (e !== t);
        return n;
      }
      function Su(t, e, n, i, r, o, s, a) {
        return (
          (r - s) * (e - a) - (t - s) * (o - a) >= 0 &&
          (t - s) * (i - a) - (n - s) * (e - a) >= 0 &&
          (n - s) * (o - a) - (r - s) * (i - a) >= 0
        );
      }
      function Eu(t, e) {
        return (
          t.next.i !== e.i &&
          t.prev.i !== e.i &&
          !(function (t, e) {
            let n = t;
            do {
              if (
                n.i !== t.i &&
                n.next.i !== t.i &&
                n.i !== e.i &&
                n.next.i !== e.i &&
                Cu(n, n.next, t, e)
              )
                return !0;
              n = n.next;
            } while (n !== t);
            return !1;
          })(t, e) &&
          ((Pu(t, e) &&
            Pu(e, t) &&
            (function (t, e) {
              let n = t,
                i = !1;
              const r = (t.x + e.x) / 2,
                o = (t.y + e.y) / 2;
              do {
                n.y > o != n.next.y > o &&
                  n.next.y !== n.y &&
                  r < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
                  (i = !i),
                  (n = n.next);
              } while (n !== t);
              return i;
            })(t, e) &&
            (Tu(t.prev, t, e.prev) || Tu(t, e.prev, e))) ||
            (Au(t, e) &&
              Tu(t.prev, t, t.next) > 0 &&
              Tu(e.prev, e, e.next) > 0))
        );
      }
      function Tu(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
      }
      function Au(t, e) {
        return t.x === e.x && t.y === e.y;
      }
      function Cu(t, e, n, i) {
        const r = Ru(Tu(t, e, n)),
          o = Ru(Tu(t, e, i)),
          s = Ru(Tu(n, i, t)),
          a = Ru(Tu(n, i, e));
        return (
          (r !== o && s !== a) ||
          !(0 !== r || !Lu(t, n, e)) ||
          !(0 !== o || !Lu(t, i, e)) ||
          !(0 !== s || !Lu(n, t, i)) ||
          !(0 !== a || !Lu(n, e, i))
        );
      }
      function Lu(t, e, n) {
        return (
          e.x <= Math.max(t.x, n.x) &&
          e.x >= Math.min(t.x, n.x) &&
          e.y <= Math.max(t.y, n.y) &&
          e.y >= Math.min(t.y, n.y)
        );
      }
      function Ru(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      }
      function Pu(t, e) {
        return Tu(t.prev, t, t.next) < 0
          ? Tu(t, e, t.next) >= 0 && Tu(t, t.prev, e) >= 0
          : Tu(t, e, t.prev) < 0 || Tu(t, t.next, e) < 0;
      }
      function Nu(t, e) {
        const n = new Ou(t.i, t.x, t.y),
          i = new Ou(e.i, e.x, e.y),
          r = t.next,
          o = e.prev;
        return (
          (t.next = e),
          (e.prev = t),
          (n.next = r),
          (r.prev = n),
          (i.next = n),
          (n.prev = i),
          (o.next = i),
          (i.prev = o),
          i
        );
      }
      function Iu(t, e, n, i) {
        const r = new Ou(t, e, n);
        return (
          i
            ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
            : ((r.prev = r), (r.next = r)),
          r
        );
      }
      function Bu(t) {
        (t.next.prev = t.prev),
          (t.prev.next = t.next),
          t.prevZ && (t.prevZ.nextZ = t.nextZ),
          t.nextZ && (t.nextZ.prevZ = t.prevZ);
      }
      function Ou(t, e, n) {
        (this.i = t),
          (this.x = e),
          (this.y = n),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      class Du {
        static area(t) {
          const e = t.length;
          let n = 0;
          for (let i = e - 1, r = 0; r < e; i = r++)
            n += t[i].x * t[r].y - t[r].x * t[i].y;
          return 0.5 * n;
        }
        static isClockWise(t) {
          return Du.area(t) < 0;
        }
        static triangulateShape(t, e) {
          const n = [],
            i = [],
            r = [];
          ku(t), Fu(n, t);
          let o = t.length;
          e.forEach(ku);
          for (let t = 0; t < e.length; t++)
            i.push(o), (o += e[t].length), Fu(n, e[t]);
          const s = (function (t, e, n = 2) {
            const i = e && e.length,
              r = i ? e[0] * n : t.length;
            let o = du(t, 0, r, n, !0);
            const s = [];
            if (!o || o.next === o.prev) return s;
            let a, l, c, u, h, d, p;
            if (
              (i &&
                (o = (function (t, e, n, i) {
                  const r = [];
                  let o, s, a, l, c;
                  for (o = 0, s = e.length; o < s; o++)
                    (a = e[o] * i),
                      (l = o < s - 1 ? e[o + 1] * i : t.length),
                      (c = du(t, a, l, i, !1)),
                      c === c.next && (c.steiner = !0),
                      r.push(Mu(c));
                  for (r.sort(xu), o = 0; o < r.length; o++)
                    bu(r[o], n), (n = pu(n, n.next));
                  return n;
                })(t, e, o, n)),
              t.length > 80 * n)
            ) {
              (a = c = t[0]), (l = u = t[1]);
              for (let e = n; e < r; e += n)
                (h = t[e]),
                  (d = t[e + 1]),
                  h < a && (a = h),
                  d < l && (l = d),
                  h > c && (c = h),
                  d > u && (u = d);
              (p = Math.max(c - a, u - l)), (p = 0 !== p ? 1 / p : 0);
            }
            return fu(o, s, n, a, l, p), s;
          })(n, i);
          for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));
          return r;
        }
      }
      function ku(t) {
        const e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop();
      }
      function Fu(t, e) {
        for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
      }
      class zu extends $r {
        constructor(t, e) {
          super(),
            (this.type = "ExtrudeGeometry"),
            (this.parameters = { shapes: t, options: e }),
            (t = Array.isArray(t) ? t : [t]);
          const n = this,
            i = [],
            r = [];
          for (let e = 0, n = t.length; e < n; e++) o(t[e]);
          function o(t) {
            const o = [],
              s = void 0 !== e.curveSegments ? e.curveSegments : 12,
              a = void 0 !== e.steps ? e.steps : 1;
            let l = void 0 !== e.depth ? e.depth : 100,
              c = void 0 === e.bevelEnabled || e.bevelEnabled,
              u = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
              h = void 0 !== e.bevelSize ? e.bevelSize : u - 2,
              d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
              p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
            const f = e.extrudePath,
              m = void 0 !== e.UVGenerator ? e.UVGenerator : Hu;
            void 0 !== e.amount &&
              (console.warn(
                "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
              ),
              (l = e.amount));
            let g,
              v,
              y,
              x,
              b,
              w = !1;
            f &&
              ((g = f.getSpacedPoints(a)),
              (w = !0),
              (c = !1),
              (v = f.computeFrenetFrames(a, !1)),
              (y = new si()),
              (x = new si()),
              (b = new si())),
              c || ((p = 0), (u = 0), (h = 0), (d = 0));
            const _ = t.extractPoints(s);
            let M = _.shape;
            const S = _.holes;
            if (!Du.isClockWise(M)) {
              M = M.reverse();
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                Du.isClockWise(e) && (S[t] = e.reverse());
              }
            }
            const E = Du.triangulateShape(M, S),
              T = M;
            for (let t = 0, e = S.length; t < e; t++) {
              const e = S[t];
              M = M.concat(e);
            }
            function A(t, e, n) {
              return (
                e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                e.clone().multiplyScalar(n).add(t)
              );
            }
            const C = M.length,
              L = E.length;
            function R(t, e, n) {
              let i, r, o;
              const s = t.x - e.x,
                a = t.y - e.y,
                l = n.x - t.x,
                c = n.y - t.y,
                u = s * s + a * a,
                h = s * c - a * l;
              if (Math.abs(h) > Number.EPSILON) {
                const h = Math.sqrt(u),
                  d = Math.sqrt(l * l + c * c),
                  p = e.x - a / h,
                  f = e.y + s / h,
                  m =
                    ((n.x - c / d - p) * c - (n.y + l / d - f) * l) /
                    (s * c - a * l);
                (i = p + s * m - t.x), (r = f + a * m - t.y);
                const g = i * i + r * r;
                if (g <= 2) return new Yn(i, r);
                o = Math.sqrt(g / 2);
              } else {
                let t = !1;
                s > Number.EPSILON
                  ? l > Number.EPSILON && (t = !0)
                  : s < -Number.EPSILON
                  ? l < -Number.EPSILON && (t = !0)
                  : Math.sign(a) === Math.sign(c) && (t = !0),
                  t
                    ? ((i = -a), (r = s), (o = Math.sqrt(u)))
                    : ((i = s), (r = a), (o = Math.sqrt(u / 2)));
              }
              return new Yn(i / o, r / o);
            }
            const P = [];
            for (
              let t = 0, e = T.length, n = e - 1, i = t + 1;
              t < e;
              t++, n++, i++
            )
              n === e && (n = 0),
                i === e && (i = 0),
                (P[t] = R(T[t], T[n], T[i]));
            const N = [];
            let I,
              B = P.concat();
            for (let t = 0, e = S.length; t < e; t++) {
              const e = S[t];
              I = [];
              for (
                let t = 0, n = e.length, i = n - 1, r = t + 1;
                t < n;
                t++, i++, r++
              )
                i === n && (i = 0),
                  r === n && (r = 0),
                  (I[t] = R(e[t], e[i], e[r]));
              N.push(I), (B = B.concat(I));
            }
            for (let t = 0; t < p; t++) {
              const e = t / p,
                n = u * Math.cos((e * Math.PI) / 2),
                i = h * Math.sin((e * Math.PI) / 2) + d;
              for (let t = 0, e = T.length; t < e; t++) {
                const e = A(T[t], P[t], i);
                k(e.x, e.y, -n);
              }
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                I = N[t];
                for (let t = 0, r = e.length; t < r; t++) {
                  const r = A(e[t], I[t], i);
                  k(r.x, r.y, -n);
                }
              }
            }
            const O = h + d;
            for (let t = 0; t < C; t++) {
              const e = c ? A(M[t], B[t], O) : M[t];
              w
                ? (x.copy(v.normals[0]).multiplyScalar(e.x),
                  y.copy(v.binormals[0]).multiplyScalar(e.y),
                  b.copy(g[0]).add(x).add(y),
                  k(b.x, b.y, b.z))
                : k(e.x, e.y, 0);
            }
            for (let t = 1; t <= a; t++)
              for (let e = 0; e < C; e++) {
                const n = c ? A(M[e], B[e], O) : M[e];
                w
                  ? (x.copy(v.normals[t]).multiplyScalar(n.x),
                    y.copy(v.binormals[t]).multiplyScalar(n.y),
                    b.copy(g[t]).add(x).add(y),
                    k(b.x, b.y, b.z))
                  : k(n.x, n.y, (l / a) * t);
              }
            for (let t = p - 1; t >= 0; t--) {
              const e = t / p,
                n = u * Math.cos((e * Math.PI) / 2),
                i = h * Math.sin((e * Math.PI) / 2) + d;
              for (let t = 0, e = T.length; t < e; t++) {
                const e = A(T[t], P[t], i);
                k(e.x, e.y, l + n);
              }
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                I = N[t];
                for (let t = 0, r = e.length; t < r; t++) {
                  const r = A(e[t], I[t], i);
                  w
                    ? k(r.x, r.y + g[a - 1].y, g[a - 1].x + n)
                    : k(r.x, r.y, l + n);
                }
              }
            }
            function D(t, e) {
              let n = t.length;
              for (; --n >= 0; ) {
                const i = n;
                let r = n - 1;
                r < 0 && (r = t.length - 1);
                for (let t = 0, n = a + 2 * p; t < n; t++) {
                  const n = C * t,
                    o = C * (t + 1);
                  z(e + i + n, e + r + n, e + r + o, e + i + o);
                }
              }
            }
            function k(t, e, n) {
              o.push(t), o.push(e), o.push(n);
            }
            function F(t, e, r) {
              H(t), H(e), H(r);
              const o = i.length / 3,
                s = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
              U(s[0]), U(s[1]), U(s[2]);
            }
            function z(t, e, r, o) {
              H(t), H(e), H(o), H(e), H(r), H(o);
              const s = i.length / 3,
                a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
              U(a[0]), U(a[1]), U(a[3]), U(a[1]), U(a[2]), U(a[3]);
            }
            function H(t) {
              i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2]);
            }
            function U(t) {
              r.push(t.x), r.push(t.y);
            }
            !(function () {
              const t = i.length / 3;
              if (c) {
                let t = 0,
                  e = C * t;
                for (let t = 0; t < L; t++) {
                  const n = E[t];
                  F(n[2] + e, n[1] + e, n[0] + e);
                }
                (t = a + 2 * p), (e = C * t);
                for (let t = 0; t < L; t++) {
                  const n = E[t];
                  F(n[0] + e, n[1] + e, n[2] + e);
                }
              } else {
                for (let t = 0; t < L; t++) {
                  const e = E[t];
                  F(e[2], e[1], e[0]);
                }
                for (let t = 0; t < L; t++) {
                  const e = E[t];
                  F(e[0] + C * a, e[1] + C * a, e[2] + C * a);
                }
              }
              n.addGroup(t, i.length / 3 - t, 0);
            })(),
              (function () {
                const t = i.length / 3;
                let e = 0;
                D(T, e), (e += T.length);
                for (let t = 0, n = S.length; t < n; t++) {
                  const n = S[t];
                  D(n, e), (e += n.length);
                }
                n.addGroup(t, i.length / 3 - t, 1);
              })();
          }
          this.setAttribute("position", new Ur(i, 3)),
            this.setAttribute("uv", new Ur(r, 2)),
            this.computeVertexNormals();
        }
        toJSON() {
          const t = super.toJSON();
          return (function (t, e, n) {
            if (((n.shapes = []), Array.isArray(t)))
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e];
                n.shapes.push(i.uuid);
              }
            else n.shapes.push(t.uuid);
            return (
              void 0 !== e.extrudePath &&
                (n.options.extrudePath = e.extrudePath.toJSON()),
              n
            );
          })(this.parameters.shapes, this.parameters.options, t);
        }
        static fromJSON(t, e) {
          const n = [];
          for (let i = 0, r = t.shapes.length; i < r; i++) {
            const r = e[t.shapes[i]];
            n.push(r);
          }
          const i = t.options.extrudePath;
          return (
            void 0 !== i &&
              (t.options.extrudePath = new hu[i.type]().fromJSON(i)),
            new zu(n, t.options)
          );
        }
      }
      const Hu = {
        generateTopUV: function (t, e, n, i, r) {
          const o = e[3 * n],
            s = e[3 * n + 1],
            a = e[3 * i],
            l = e[3 * i + 1],
            c = e[3 * r],
            u = e[3 * r + 1];
          return [new Yn(o, s), new Yn(a, l), new Yn(c, u)];
        },
        generateSideWallUV: function (t, e, n, i, r, o) {
          const s = e[3 * n],
            a = e[3 * n + 1],
            l = e[3 * n + 2],
            c = e[3 * i],
            u = e[3 * i + 1],
            h = e[3 * i + 2],
            d = e[3 * r],
            p = e[3 * r + 1],
            f = e[3 * r + 2],
            m = e[3 * o],
            g = e[3 * o + 1],
            v = e[3 * o + 2];
          return Math.abs(a - u) < Math.abs(s - c)
            ? [
                new Yn(s, 1 - l),
                new Yn(c, 1 - h),
                new Yn(d, 1 - f),
                new Yn(m, 1 - v),
              ]
            : [
                new Yn(a, 1 - l),
                new Yn(u, 1 - h),
                new Yn(p, 1 - f),
                new Yn(g, 1 - v),
              ];
        },
      };
      class Uu extends zc {
        constructor(t = 1, e = 0) {
          const n = (1 + Math.sqrt(5)) / 2;
          super(
            [
              -1,
              n,
              0,
              1,
              n,
              0,
              -1,
              -n,
              0,
              1,
              -n,
              0,
              0,
              -1,
              n,
              0,
              1,
              n,
              0,
              -1,
              -n,
              0,
              1,
              -n,
              n,
              0,
              -1,
              n,
              0,
              1,
              -n,
              0,
              -1,
              -n,
              0,
              1,
            ],
            [
              0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
              4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6,
              8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
            ],
            t,
            e
          ),
            (this.type = "IcosahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new Uu(t.radius, t.detail);
        }
      }
      class Vu extends $r {
        constructor(t, e = 12, n = 0, i = 2 * Math.PI) {
          super(),
            (this.type = "LatheGeometry"),
            (this.parameters = {
              points: t,
              segments: e,
              phiStart: n,
              phiLength: i,
            }),
            (e = Math.floor(e)),
            (i = Un(i, 0, 2 * Math.PI));
          const r = [],
            o = [],
            s = [],
            a = 1 / e,
            l = new si(),
            c = new Yn();
          for (let r = 0; r <= e; r++) {
            const u = n + r * a * i,
              h = Math.sin(u),
              d = Math.cos(u);
            for (let n = 0; n <= t.length - 1; n++)
              (l.x = t[n].x * h),
                (l.y = t[n].y),
                (l.z = t[n].x * d),
                o.push(l.x, l.y, l.z),
                (c.x = r / e),
                (c.y = n / (t.length - 1)),
                s.push(c.x, c.y);
          }
          for (let n = 0; n < e; n++)
            for (let e = 0; e < t.length - 1; e++) {
              const i = e + n * t.length,
                o = i,
                s = i + t.length,
                a = i + t.length + 1,
                l = i + 1;
              r.push(o, s, l), r.push(s, a, l);
            }
          if (
            (this.setIndex(r),
            this.setAttribute("position", new Ur(o, 3)),
            this.setAttribute("uv", new Ur(s, 2)),
            this.computeVertexNormals(),
            i === 2 * Math.PI)
          ) {
            const n = this.attributes.normal.array,
              i = new si(),
              r = new si(),
              o = new si(),
              s = e * t.length * 3;
            for (let e = 0, a = 0; e < t.length; e++, a += 3)
              (i.x = n[a + 0]),
                (i.y = n[a + 1]),
                (i.z = n[a + 2]),
                (r.x = n[s + a + 0]),
                (r.y = n[s + a + 1]),
                (r.z = n[s + a + 2]),
                o.addVectors(i, r).normalize(),
                (n[a + 0] = n[s + a + 0] = o.x),
                (n[a + 1] = n[s + a + 1] = o.y),
                (n[a + 2] = n[s + a + 2] = o.z);
          }
        }
        static fromJSON(t) {
          return new Vu(t.points, t.segments, t.phiStart, t.phiLength);
        }
      }
      class Gu extends zc {
        constructor(t = 1, e = 0) {
          super(
            [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            [
              0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1,
              4, 2,
            ],
            t,
            e
          ),
            (this.type = "OctahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new Gu(t.radius, t.detail);
        }
      }
      class ju extends $r {
        constructor(t, e, n) {
          super(),
            (this.type = "ParametricGeometry"),
            (this.parameters = { func: t, slices: e, stacks: n });
          const i = [],
            r = [],
            o = [],
            s = [],
            a = 1e-5,
            l = new si(),
            c = new si(),
            u = new si(),
            h = new si(),
            d = new si();
          t.length < 3 &&
            console.error(
              "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
            );
          const p = e + 1;
          for (let i = 0; i <= n; i++) {
            const p = i / n;
            for (let n = 0; n <= e; n++) {
              const i = n / e;
              t(i, p, c),
                r.push(c.x, c.y, c.z),
                i - a >= 0
                  ? (t(i - a, p, u), h.subVectors(c, u))
                  : (t(i + a, p, u), h.subVectors(u, c)),
                p - a >= 0
                  ? (t(i, p - a, u), d.subVectors(c, u))
                  : (t(i, p + a, u), d.subVectors(u, c)),
                l.crossVectors(h, d).normalize(),
                o.push(l.x, l.y, l.z),
                s.push(i, p);
            }
          }
          for (let t = 0; t < n; t++)
            for (let n = 0; n < e; n++) {
              const e = t * p + n,
                r = t * p + n + 1,
                o = (t + 1) * p + n + 1,
                s = (t + 1) * p + n;
              i.push(e, r, s), i.push(r, o, s);
            }
          this.setIndex(i),
            this.setAttribute("position", new Ur(r, 3)),
            this.setAttribute("normal", new Ur(o, 3)),
            this.setAttribute("uv", new Ur(s, 2));
        }
      }
      class Wu extends $r {
        constructor(t = 0.5, e = 1, n = 8, i = 1, r = 0, o = 2 * Math.PI) {
          super(),
            (this.type = "RingGeometry"),
            (this.parameters = {
              innerRadius: t,
              outerRadius: e,
              thetaSegments: n,
              phiSegments: i,
              thetaStart: r,
              thetaLength: o,
            }),
            (n = Math.max(3, n));
          const s = [],
            a = [],
            l = [],
            c = [];
          let u = t;
          const h = (e - t) / (i = Math.max(1, i)),
            d = new si(),
            p = new Yn();
          for (let t = 0; t <= i; t++) {
            for (let t = 0; t <= n; t++) {
              const i = r + (t / n) * o;
              (d.x = u * Math.cos(i)),
                (d.y = u * Math.sin(i)),
                a.push(d.x, d.y, d.z),
                l.push(0, 0, 1),
                (p.x = (d.x / e + 1) / 2),
                (p.y = (d.y / e + 1) / 2),
                c.push(p.x, p.y);
            }
            u += h;
          }
          for (let t = 0; t < i; t++) {
            const e = t * (n + 1);
            for (let t = 0; t < n; t++) {
              const i = t + e,
                r = i,
                o = i + n + 1,
                a = i + n + 2,
                l = i + 1;
              s.push(r, o, l), s.push(o, a, l);
            }
          }
          this.setIndex(s),
            this.setAttribute("position", new Ur(a, 3)),
            this.setAttribute("normal", new Ur(l, 3)),
            this.setAttribute("uv", new Ur(c, 2));
        }
        static fromJSON(t) {
          return new Wu(
            t.innerRadius,
            t.outerRadius,
            t.thetaSegments,
            t.phiSegments,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class qu extends $r {
        constructor(t, e = 12) {
          super(),
            (this.type = "ShapeGeometry"),
            (this.parameters = { shapes: t, curveSegments: e });
          const n = [],
            i = [],
            r = [],
            o = [];
          let s = 0,
            a = 0;
          if (!1 === Array.isArray(t)) l(t);
          else
            for (let e = 0; e < t.length; e++)
              l(t[e]), this.addGroup(s, a, e), (s += a), (a = 0);
          function l(t) {
            const s = i.length / 3,
              l = t.extractPoints(e);
            let c = l.shape;
            const u = l.holes;
            !1 === Du.isClockWise(c) && (c = c.reverse());
            for (let t = 0, e = u.length; t < e; t++) {
              const e = u[t];
              !0 === Du.isClockWise(e) && (u[t] = e.reverse());
            }
            const h = Du.triangulateShape(c, u);
            for (let t = 0, e = u.length; t < e; t++) {
              const e = u[t];
              c = c.concat(e);
            }
            for (let t = 0, e = c.length; t < e; t++) {
              const e = c[t];
              i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y);
            }
            for (let t = 0, e = h.length; t < e; t++) {
              const e = h[t],
                i = e[0] + s,
                r = e[1] + s,
                o = e[2] + s;
              n.push(i, r, o), (a += 3);
            }
          }
          this.setIndex(n),
            this.setAttribute("position", new Ur(i, 3)),
            this.setAttribute("normal", new Ur(r, 3)),
            this.setAttribute("uv", new Ur(o, 2));
        }
        toJSON() {
          const t = super.toJSON();
          return (function (t, e) {
            if (((e.shapes = []), Array.isArray(t)))
              for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                e.shapes.push(i.uuid);
              }
            else e.shapes.push(t.uuid);
            return e;
          })(this.parameters.shapes, t);
        }
        static fromJSON(t, e) {
          const n = [];
          for (let i = 0, r = t.shapes.length; i < r; i++) {
            const r = e[t.shapes[i]];
            n.push(r);
          }
          return new qu(n, t.curveSegments);
        }
      }
      class Xu extends $r {
        constructor(
          t = 1,
          e = 32,
          n = 16,
          i = 0,
          r = 2 * Math.PI,
          o = 0,
          s = Math.PI
        ) {
          super(),
            (this.type = "SphereGeometry"),
            (this.parameters = {
              radius: t,
              widthSegments: e,
              heightSegments: n,
              phiStart: i,
              phiLength: r,
              thetaStart: o,
              thetaLength: s,
            }),
            (e = Math.max(3, Math.floor(e))),
            (n = Math.max(2, Math.floor(n)));
          const a = Math.min(o + s, Math.PI);
          let l = 0;
          const c = [],
            u = new si(),
            h = new si(),
            d = [],
            p = [],
            f = [],
            m = [];
          for (let d = 0; d <= n; d++) {
            const g = [],
              v = d / n;
            let y = 0;
            0 == d && 0 == o
              ? (y = 0.5 / e)
              : d == n && a == Math.PI && (y = -0.5 / e);
            for (let n = 0; n <= e; n++) {
              const a = n / e;
              (u.x = -t * Math.cos(i + a * r) * Math.sin(o + v * s)),
                (u.y = t * Math.cos(o + v * s)),
                (u.z = t * Math.sin(i + a * r) * Math.sin(o + v * s)),
                p.push(u.x, u.y, u.z),
                h.copy(u).normalize(),
                f.push(h.x, h.y, h.z),
                m.push(a + y, 1 - v),
                g.push(l++);
            }
            c.push(g);
          }
          for (let t = 0; t < n; t++)
            for (let i = 0; i < e; i++) {
              const e = c[t][i + 1],
                r = c[t][i],
                s = c[t + 1][i],
                l = c[t + 1][i + 1];
              (0 !== t || o > 0) && d.push(e, r, l),
                (t !== n - 1 || a < Math.PI) && d.push(r, s, l);
            }
          this.setIndex(d),
            this.setAttribute("position", new Ur(p, 3)),
            this.setAttribute("normal", new Ur(f, 3)),
            this.setAttribute("uv", new Ur(m, 2));
        }
        static fromJSON(t) {
          return new Xu(
            t.radius,
            t.widthSegments,
            t.heightSegments,
            t.phiStart,
            t.phiLength,
            t.thetaStart,
            t.thetaLength
          );
        }
      }
      class Yu extends zc {
        constructor(t = 1, e = 0) {
          super(
            [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
            t,
            e
          ),
            (this.type = "TetrahedronGeometry"),
            (this.parameters = { radius: t, detail: e });
        }
        static fromJSON(t) {
          return new Yu(t.radius, t.detail);
        }
      }
      class Zu extends zu {
        constructor(t, e = {}) {
          const n = e.font;
          if (!n || !n.isFont)
            return (
              console.error(
                "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
              ),
              new $r()
            );
          const i = n.generateShapes(t, e.size);
          (e.depth = void 0 !== e.height ? e.height : 50),
            void 0 === e.bevelThickness && (e.bevelThickness = 10),
            void 0 === e.bevelSize && (e.bevelSize = 8),
            void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
            super(i, e),
            (this.type = "TextGeometry");
        }
      }
      class Ju extends $r {
        constructor(t = 1, e = 0.4, n = 8, i = 6, r = 2 * Math.PI) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: t,
              tube: e,
              radialSegments: n,
              tubularSegments: i,
              arc: r,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const o = [],
            s = [],
            a = [],
            l = [],
            c = new si(),
            u = new si(),
            h = new si();
          for (let o = 0; o <= n; o++)
            for (let d = 0; d <= i; d++) {
              const p = (d / i) * r,
                f = (o / n) * Math.PI * 2;
              (u.x = (t + e * Math.cos(f)) * Math.cos(p)),
                (u.y = (t + e * Math.cos(f)) * Math.sin(p)),
                (u.z = e * Math.sin(f)),
                s.push(u.x, u.y, u.z),
                (c.x = t * Math.cos(p)),
                (c.y = t * Math.sin(p)),
                h.subVectors(u, c).normalize(),
                a.push(h.x, h.y, h.z),
                l.push(d / i),
                l.push(o / n);
            }
          for (let t = 1; t <= n; t++)
            for (let e = 1; e <= i; e++) {
              const n = (i + 1) * t + e - 1,
                r = (i + 1) * (t - 1) + e - 1,
                s = (i + 1) * (t - 1) + e,
                a = (i + 1) * t + e;
              o.push(n, r, a), o.push(r, s, a);
            }
          this.setIndex(o),
            this.setAttribute("position", new Ur(s, 3)),
            this.setAttribute("normal", new Ur(a, 3)),
            this.setAttribute("uv", new Ur(l, 2));
        }
        static fromJSON(t) {
          return new Ju(
            t.radius,
            t.tube,
            t.radialSegments,
            t.tubularSegments,
            t.arc
          );
        }
      }
      class Ku extends $r {
        constructor(t = 1, e = 0.4, n = 64, i = 8, r = 2, o = 3) {
          super(),
            (this.type = "TorusKnotGeometry"),
            (this.parameters = {
              radius: t,
              tube: e,
              tubularSegments: n,
              radialSegments: i,
              p: r,
              q: o,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const s = [],
            a = [],
            l = [],
            c = [],
            u = new si(),
            h = new si(),
            d = new si(),
            p = new si(),
            f = new si(),
            m = new si(),
            g = new si();
          for (let s = 0; s <= n; ++s) {
            const y = (s / n) * r * Math.PI * 2;
            v(y, r, o, t, d),
              v(y + 0.01, r, o, t, p),
              m.subVectors(p, d),
              g.addVectors(p, d),
              f.crossVectors(m, g),
              g.crossVectors(f, m),
              f.normalize(),
              g.normalize();
            for (let t = 0; t <= i; ++t) {
              const r = (t / i) * Math.PI * 2,
                o = -e * Math.cos(r),
                p = e * Math.sin(r);
              (u.x = d.x + (o * g.x + p * f.x)),
                (u.y = d.y + (o * g.y + p * f.y)),
                (u.z = d.z + (o * g.z + p * f.z)),
                a.push(u.x, u.y, u.z),
                h.subVectors(u, d).normalize(),
                l.push(h.x, h.y, h.z),
                c.push(s / n),
                c.push(t / i);
            }
          }
          for (let t = 1; t <= n; t++)
            for (let e = 1; e <= i; e++) {
              const n = (i + 1) * (t - 1) + (e - 1),
                r = (i + 1) * t + (e - 1),
                o = (i + 1) * t + e,
                a = (i + 1) * (t - 1) + e;
              s.push(n, r, a), s.push(r, o, a);
            }
          function v(t, e, n, i, r) {
            const o = Math.cos(t),
              s = Math.sin(t),
              a = (n / e) * t,
              l = Math.cos(a);
            (r.x = i * (2 + l) * 0.5 * o),
              (r.y = i * (2 + l) * s * 0.5),
              (r.z = i * Math.sin(a) * 0.5);
          }
          this.setIndex(s),
            this.setAttribute("position", new Ur(a, 3)),
            this.setAttribute("normal", new Ur(l, 3)),
            this.setAttribute("uv", new Ur(c, 2));
        }
        static fromJSON(t) {
          return new Ku(
            t.radius,
            t.tube,
            t.tubularSegments,
            t.radialSegments,
            t.p,
            t.q
          );
        }
      }
      class Qu extends $r {
        constructor(t, e = 64, n = 1, i = 8, r = !1) {
          super(),
            (this.type = "TubeGeometry"),
            (this.parameters = {
              path: t,
              tubularSegments: e,
              radius: n,
              radialSegments: i,
              closed: r,
            });
          const o = t.computeFrenetFrames(e, r);
          (this.tangents = o.tangents),
            (this.normals = o.normals),
            (this.binormals = o.binormals);
          const s = new si(),
            a = new si(),
            l = new Yn();
          let c = new si();
          const u = [],
            h = [],
            d = [],
            p = [];
          function f(r) {
            c = t.getPointAt(r / e, c);
            const l = o.normals[r],
              d = o.binormals[r];
            for (let t = 0; t <= i; t++) {
              const e = (t / i) * Math.PI * 2,
                r = Math.sin(e),
                o = -Math.cos(e);
              (a.x = o * l.x + r * d.x),
                (a.y = o * l.y + r * d.y),
                (a.z = o * l.z + r * d.z),
                a.normalize(),
                h.push(a.x, a.y, a.z),
                (s.x = c.x + n * a.x),
                (s.y = c.y + n * a.y),
                (s.z = c.z + n * a.z),
                u.push(s.x, s.y, s.z);
            }
          }
          !(function () {
            for (let t = 0; t < e; t++) f(t);
            f(!1 === r ? e : 0),
              (function () {
                for (let t = 0; t <= e; t++)
                  for (let n = 0; n <= i; n++)
                    (l.x = t / e), (l.y = n / i), d.push(l.x, l.y);
              })(),
              (function () {
                for (let t = 1; t <= e; t++)
                  for (let e = 1; e <= i; e++) {
                    const n = (i + 1) * (t - 1) + (e - 1),
                      r = (i + 1) * t + (e - 1),
                      o = (i + 1) * t + e,
                      s = (i + 1) * (t - 1) + e;
                    p.push(n, r, s), p.push(r, o, s);
                  }
              })();
          })(),
            this.setIndex(p),
            this.setAttribute("position", new Ur(u, 3)),
            this.setAttribute("normal", new Ur(h, 3)),
            this.setAttribute("uv", new Ur(d, 2));
        }
        toJSON() {
          const t = super.toJSON();
          return (t.path = this.parameters.path.toJSON()), t;
        }
        static fromJSON(t) {
          return new Qu(
            new hu[t.path.type]().fromJSON(t.path),
            t.tubularSegments,
            t.radius,
            t.radialSegments,
            t.closed
          );
        }
      }
      class $u extends $r {
        constructor(t) {
          if ((super(), (this.type = "WireframeGeometry"), !0 === t.isGeometry))
            return void console.error(
              "THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
          const e = [],
            n = new Set(),
            i = new si(),
            r = new si();
          if (null !== t.index) {
            const o = t.attributes.position,
              s = t.index;
            let a = t.groups;
            0 === a.length &&
              (a = [{ start: 0, count: s.count, materialIndex: 0 }]);
            for (let t = 0, l = a.length; t < l; ++t) {
              const l = a[t],
                c = l.start;
              for (let t = c, a = c + l.count; t < a; t += 3)
                for (let a = 0; a < 3; a++) {
                  const l = s.getX(t + a),
                    c = s.getX(t + ((a + 1) % 3));
                  i.fromBufferAttribute(o, l),
                    r.fromBufferAttribute(o, c),
                    !0 === th(i, r, n) &&
                      (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));
                }
            }
          } else {
            const o = t.attributes.position;
            for (let t = 0, s = o.count / 3; t < s; t++)
              for (let s = 0; s < 3; s++) {
                const a = 3 * t + s,
                  l = 3 * t + ((s + 1) % 3);
                i.fromBufferAttribute(o, a),
                  r.fromBufferAttribute(o, l),
                  !0 === th(i, r, n) &&
                    (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));
              }
          }
          this.setAttribute("position", new Ur(e, 3));
        }
      }
      function th(t, e, n) {
        const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
          r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
        return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i, r), !0);
      }
      var eh = Object.freeze({
        __proto__: null,
        BoxGeometry: wo,
        BoxBufferGeometry: wo,
        CircleGeometry: Dc,
        CircleBufferGeometry: Dc,
        ConeGeometry: Fc,
        ConeBufferGeometry: Fc,
        CylinderGeometry: kc,
        CylinderBufferGeometry: kc,
        DodecahedronGeometry: Hc,
        DodecahedronBufferGeometry: Hc,
        EdgesGeometry: Wc,
        ExtrudeGeometry: zu,
        ExtrudeBufferGeometry: zu,
        IcosahedronGeometry: Uu,
        IcosahedronBufferGeometry: Uu,
        LatheGeometry: Vu,
        LatheBufferGeometry: Vu,
        OctahedronGeometry: Gu,
        OctahedronBufferGeometry: Gu,
        ParametricGeometry: ju,
        ParametricBufferGeometry: ju,
        PlaneGeometry: Uo,
        PlaneBufferGeometry: Uo,
        PolyhedronGeometry: zc,
        PolyhedronBufferGeometry: zc,
        RingGeometry: Wu,
        RingBufferGeometry: Wu,
        ShapeGeometry: qu,
        ShapeBufferGeometry: qu,
        SphereGeometry: Xu,
        SphereBufferGeometry: Xu,
        TetrahedronGeometry: Yu,
        TetrahedronBufferGeometry: Yu,
        TextGeometry: Zu,
        TextBufferGeometry: Zu,
        TorusGeometry: Ju,
        TorusBufferGeometry: Ju,
        TorusKnotGeometry: Ku,
        TorusKnotBufferGeometry: Ku,
        TubeGeometry: Qu,
        TubeBufferGeometry: Qu,
        WireframeGeometry: $u,
      });
      class nh extends wr {
        constructor(t) {
          super(),
            (this.type = "ShadowMaterial"),
            (this.color = new Cr(0)),
            (this.transparent = !0),
            this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this;
        }
      }
      nh.prototype.isShadowMaterial = !0;
      class ih extends wr {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new Cr(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Cr(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sn),
            (this.normalScale = new Yn(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: "" }),
            this.color.copy(t.color),
            (this.roughness = t.roughness),
            (this.metalness = t.metalness),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.roughnessMap = t.roughnessMap),
            (this.metalnessMap = t.metalnessMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.envMapIntensity = t.envMapIntensity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      ih.prototype.isMeshStandardMaterial = !0;
      class rh extends ih {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoat = 0),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new Yn(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.reflectivity = 0.5),
            Object.defineProperty(this, "ior", {
              get: function () {
                return (
                  (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
                );
              },
              set: function (t) {
                this.reflectivity = Un((2.5 * (t - 1)) / (t + 1), 0, 1);
              },
            }),
            (this.sheen = null),
            (this.transmission = 0),
            (this.transmissionMap = null),
            (this.thickness = 0.01),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationTint = new Cr(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularTint = new Cr(1, 1, 1)),
            (this.specularTintMap = null),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = t.clearcoat),
            (this.clearcoatMap = t.clearcoatMap),
            (this.clearcoatRoughness = t.clearcoatRoughness),
            (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = t.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
            (this.reflectivity = t.reflectivity),
            t.sheen
              ? (this.sheen = (this.sheen || new Cr()).copy(t.sheen))
              : (this.sheen = null),
            (this.transmission = t.transmission),
            (this.transmissionMap = t.transmissionMap),
            (this.thickness = t.thickness),
            (this.thicknessMap = t.thicknessMap),
            (this.attenuationDistance = t.attenuationDistance),
            this.attenuationTint.copy(t.attenuationTint),
            (this.specularIntensity = t.specularIntensity),
            (this.specularIntensityMap = t.specularIntensityMap),
            this.specularTint.copy(t.specularTint),
            (this.specularTintMap = t.specularTintMap),
            this
          );
        }
      }
      rh.prototype.isMeshPhysicalMaterial = !0;
      class oh extends wr {
        constructor(t) {
          super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new Cr(16777215)),
            (this.specular = new Cr(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Cr(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sn),
            (this.normalScale = new Yn(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Y),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            (this.shininess = t.shininess),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      oh.prototype.isMeshPhongMaterial = !0;
      class sh extends wr {
        constructor(t) {
          super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new Cr(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Cr(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sn),
            (this.normalScale = new Yn(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.gradientMap = t.gradientMap),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          );
        }
      }
      sh.prototype.isMeshToonMaterial = !0;
      class ah extends wr {
        constructor(t) {
          super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sn),
            (this.normalScale = new Yn(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      ah.prototype.isMeshNormalMaterial = !0;
      class lh extends wr {
        constructor(t) {
          super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new Cr(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Cr(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Y),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          );
        }
      }
      lh.prototype.isMeshLambertMaterial = !0;
      class ch extends wr {
        constructor(t) {
          super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new Cr(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sn),
            (this.normalScale = new Yn(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { MATCAP: "" }),
            this.color.copy(t.color),
            (this.matcap = t.matcap),
            (this.map = t.map),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.flatShading = t.flatShading),
            this
          );
        }
      }
      ch.prototype.isMeshMatcapMaterial = !0;
      class uh extends fc {
        constructor(t) {
          super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.scale = t.scale),
            (this.dashSize = t.dashSize),
            (this.gapSize = t.gapSize),
            this
          );
        }
      }
      uh.prototype.isLineDashedMaterial = !0;
      var hh = Object.freeze({
        __proto__: null,
        ShadowMaterial: nh,
        SpriteMaterial: Il,
        RawShaderMaterial: Qo,
        ShaderMaterial: Eo,
        PointsMaterial: Ec,
        MeshPhysicalMaterial: rh,
        MeshStandardMaterial: ih,
        MeshPhongMaterial: oh,
        MeshToonMaterial: sh,
        MeshNormalMaterial: ah,
        MeshLambertMaterial: lh,
        MeshDepthMaterial: pl,
        MeshDistanceMaterial: fl,
        MeshBasicMaterial: Lr,
        MeshMatcapMaterial: ch,
        LineDashedMaterial: uh,
        LineBasicMaterial: fc,
        Material: wr,
      });
      const dh = {
        arraySlice: function (t, e, n) {
          return dh.isTypedArray(t)
            ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
            : t.slice(e, n);
        },
        convertArray: function (t, e, n) {
          return !t || (!n && t.constructor === e)
            ? t
            : "number" == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t);
        },
        isTypedArray: function (t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView);
        },
        getKeyframeOrder: function (t) {
          const e = t.length,
            n = new Array(e);
          for (let t = 0; t !== e; ++t) n[t] = t;
          return (
            n.sort(function (e, n) {
              return t[e] - t[n];
            }),
            n
          );
        },
        sortedArray: function (t, e, n) {
          const i = t.length,
            r = new t.constructor(i);
          for (let o = 0, s = 0; s !== i; ++o) {
            const i = n[o] * e;
            for (let n = 0; n !== e; ++n) r[s++] = t[i + n];
          }
          return r;
        },
        flattenJSON: function (t, e, n, i) {
          let r = 1,
            o = t[0];
          for (; void 0 !== o && void 0 === o[i]; ) o = t[r++];
          if (void 0 === o) return;
          let s = o[i];
          if (void 0 !== s)
            if (Array.isArray(s))
              do {
                (s = o[i]),
                  void 0 !== s && (e.push(o.time), n.push.apply(n, s)),
                  (o = t[r++]);
              } while (void 0 !== o);
            else if (void 0 !== s.toArray)
              do {
                (s = o[i]),
                  void 0 !== s && (e.push(o.time), s.toArray(n, n.length)),
                  (o = t[r++]);
              } while (void 0 !== o);
            else
              do {
                (s = o[i]),
                  void 0 !== s && (e.push(o.time), n.push(s)),
                  (o = t[r++]);
              } while (void 0 !== o);
        },
        subclip: function (t, e, n, i, r = 30) {
          const o = t.clone();
          o.name = e;
          const s = [];
          for (let t = 0; t < o.tracks.length; ++t) {
            const e = o.tracks[t],
              a = e.getValueSize(),
              l = [],
              c = [];
            for (let t = 0; t < e.times.length; ++t) {
              const o = e.times[t] * r;
              if (!(o < n || o >= i)) {
                l.push(e.times[t]);
                for (let n = 0; n < a; ++n) c.push(e.values[t * a + n]);
              }
            }
            0 !== l.length &&
              ((e.times = dh.convertArray(l, e.times.constructor)),
              (e.values = dh.convertArray(c, e.values.constructor)),
              s.push(e));
          }
          o.tracks = s;
          let a = 1 / 0;
          for (let t = 0; t < o.tracks.length; ++t)
            a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
          for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);
          return o.resetDuration(), o;
        },
        makeClipAdditive: function (t, e = 0, n = t, i = 30) {
          i <= 0 && (i = 30);
          const r = n.tracks.length,
            o = e / i;
          for (let e = 0; e < r; ++e) {
            const i = n.tracks[e],
              r = i.ValueTypeName;
            if ("bool" === r || "string" === r) continue;
            const s = t.tracks.find(function (t) {
              return t.name === i.name && t.ValueTypeName === r;
            });
            if (void 0 === s) continue;
            let a = 0;
            const l = i.getValueSize();
            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (a = l / 3);
            let c = 0;
            const u = s.getValueSize();
            s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (c = u / 3);
            const h = i.times.length - 1;
            let d;
            if (o <= i.times[0]) {
              const t = a,
                e = l - a;
              d = dh.arraySlice(i.values, t, e);
            } else if (o >= i.times[h]) {
              const t = h * l + a,
                e = t + l - a;
              d = dh.arraySlice(i.values, t, e);
            } else {
              const t = i.createInterpolant(),
                e = a,
                n = l - a;
              t.evaluate(o), (d = dh.arraySlice(t.resultBuffer, e, n));
            }
            "quaternion" === r &&
              new oi().fromArray(d).normalize().conjugate().toArray(d);
            const p = s.times.length;
            for (let t = 0; t < p; ++t) {
              const e = t * u + c;
              if ("quaternion" === r)
                oi.multiplyQuaternionsFlat(s.values, e, d, 0, s.values, e);
              else {
                const t = u - 2 * c;
                for (let n = 0; n < t; ++n) s.values[e + n] -= d[n];
              }
            }
          }
          return (t.blendMode = We), t;
        },
      };
      class ph {
        constructor(t, e, n, i) {
          (this.parameterPositions = t),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
            (this.sampleValues = e),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(t) {
          const e = this.parameterPositions;
          let n = this._cachedIndex,
            i = e[n],
            r = e[n - 1];
          t: {
            e: {
              let o;
              n: {
                i: if (!(t < i)) {
                  for (let o = n + 2; ; ) {
                    if (void 0 === i) {
                      if (t < r) break i;
                      return (
                        (n = e.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, t, r)
                      );
                    }
                    if (n === o) break;
                    if (((r = i), (i = e[++n]), t < i)) break e;
                  }
                  o = e.length;
                  break n;
                }
                if (t >= r) break t;
                {
                  const s = e[1];
                  t < s && ((n = 2), (r = s));
                  for (let o = n - 2; ; ) {
                    if (void 0 === r)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, t, i)
                      );
                    if (n === o) break;
                    if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                  }
                  (o = n), (n = 0);
                }
              }
              for (; n < o; ) {
                const i = (n + o) >>> 1;
                t < e[i] ? (o = i) : (n = i + 1);
              }
              if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
              if (void 0 === i)
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, r, t)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, t, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(t) {
          const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = t * i;
          for (let t = 0; t !== i; ++t) e[t] = n[r + t];
          return e;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      (ph.prototype.beforeStart_ = ph.prototype.copySampleValue_),
        (ph.prototype.afterEnd_ = ph.prototype.copySampleValue_);
      class fh extends ph {
        constructor(t, e, n, i) {
          super(t, e, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: Ue, endingEnd: Ue });
        }
        intervalChanged_(t, e, n) {
          const i = this.parameterPositions;
          let r = t - 2,
            o = t + 1,
            s = i[r],
            a = i[o];
          if (void 0 === s)
            switch (this.getSettings_().endingStart) {
              case Ve:
                (r = t), (s = 2 * e - n);
                break;
              case Ge:
                (r = i.length - 2), (s = e + i[r] - i[r + 1]);
                break;
              default:
                (r = t), (s = n);
            }
          if (void 0 === a)
            switch (this.getSettings_().endingEnd) {
              case Ve:
                (o = t), (a = 2 * n - e);
                break;
              case Ge:
                (o = 1), (a = n + i[1] - i[0]);
                break;
              default:
                (o = t - 1), (a = e);
            }
          const l = 0.5 * (n - e),
            c = this.valueSize;
          (this._weightPrev = l / (e - s)),
            (this._weightNext = l / (a - n)),
            (this._offsetPrev = r * c),
            (this._offsetNext = o * c);
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = t * s,
            l = a - s,
            c = this._offsetPrev,
            u = this._offsetNext,
            h = this._weightPrev,
            d = this._weightNext,
            p = (n - e) / (i - e),
            f = p * p,
            m = f * p,
            g = -h * m + 2 * h * f - h * p,
            v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
            y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
            x = d * m - d * f;
          for (let t = 0; t !== s; ++t)
            r[t] = g * o[c + t] + v * o[l + t] + y * o[a + t] + x * o[u + t];
          return r;
        }
      }
      class mh extends ph {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = t * s,
            l = a - s,
            c = (n - e) / (i - e),
            u = 1 - c;
          for (let t = 0; t !== s; ++t) r[t] = o[l + t] * u + o[a + t] * c;
          return r;
        }
      }
      class gh extends ph {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        interpolate_(t) {
          return this.copySampleValue_(t - 1);
        }
      }
      class vh {
        constructor(t, e, n, i) {
          if (void 0 === t)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === e || 0 === e.length)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + t
            );
          (this.name = t),
            (this.times = dh.convertArray(e, this.TimeBufferType)),
            (this.values = dh.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(t) {
          const e = t.constructor;
          let n;
          if (e.toJSON !== this.toJSON) n = e.toJSON(t);
          else {
            n = {
              name: t.name,
              times: dh.convertArray(t.times, Array),
              values: dh.convertArray(t.values, Array),
            };
            const e = t.getInterpolation();
            e !== t.DefaultInterpolation && (n.interpolation = e);
          }
          return (n.type = t.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(t) {
          return new gh(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodLinear(t) {
          return new mh(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodSmooth(t) {
          return new fh(this.times, this.values, this.getValueSize(), t);
        }
        setInterpolation(t) {
          let e;
          switch (t) {
            case Fe:
              e = this.InterpolantFactoryMethodDiscrete;
              break;
            case ze:
              e = this.InterpolantFactoryMethodLinear;
              break;
            case He:
              e = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === e) {
            const e =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (t === this.DefaultInterpolation) throw new Error(e);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", e), this;
          }
          return (this.createInterpolant = e), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Fe;
            case this.InterpolantFactoryMethodLinear:
              return ze;
            case this.InterpolantFactoryMethodSmooth:
              return He;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(t) {
          if (0 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
          }
          return this;
        }
        scale(t) {
          if (1 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
          }
          return this;
        }
        trim(t, e) {
          const n = this.times,
            i = n.length;
          let r = 0,
            o = i - 1;
          for (; r !== i && n[r] < t; ) ++r;
          for (; -1 !== o && n[o] > e; ) --o;
          if ((++o, 0 !== r || o !== i)) {
            r >= o && ((o = Math.max(o, 1)), (r = o - 1));
            const t = this.getValueSize();
            (this.times = dh.arraySlice(n, r, o)),
              (this.values = dh.arraySlice(this.values, r * t, o * t));
          }
          return this;
        }
        validate() {
          let t = !0;
          const e = this.getValueSize();
          e - Math.floor(e) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (t = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          0 === r &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (t = !1));
          let o = null;
          for (let e = 0; e !== r; e++) {
            const i = n[e];
            if ("number" == typeof i && isNaN(i)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                e,
                i
              ),
                (t = !1);
              break;
            }
            if (null !== o && o > i) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                e,
                i,
                o
              ),
                (t = !1);
              break;
            }
            o = i;
          }
          if (void 0 !== i && dh.isTypedArray(i))
            for (let e = 0, n = i.length; e !== n; ++e) {
              const n = i[e];
              if (isNaN(n)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  e,
                  n
                ),
                  (t = !1);
                break;
              }
            }
          return t;
        }
        optimize() {
          const t = dh.arraySlice(this.times),
            e = dh.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === He,
            r = t.length - 1;
          let o = 1;
          for (let s = 1; s < r; ++s) {
            let r = !1;
            const a = t[s];
            if (a !== t[s + 1] && (1 !== s || a !== t[0]))
              if (i) r = !0;
              else {
                const t = s * n,
                  i = t - n,
                  o = t + n;
                for (let s = 0; s !== n; ++s) {
                  const n = e[t + s];
                  if (n !== e[i + s] || n !== e[o + s]) {
                    r = !0;
                    break;
                  }
                }
              }
            if (r) {
              if (s !== o) {
                t[o] = t[s];
                const i = s * n,
                  r = o * n;
                for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
              }
              ++o;
            }
          }
          if (r > 0) {
            t[o] = t[r];
            for (let t = r * n, i = o * n, s = 0; s !== n; ++s)
              e[i + s] = e[t + s];
            ++o;
          }
          return (
            o !== t.length
              ? ((this.times = dh.arraySlice(t, 0, o)),
                (this.values = dh.arraySlice(e, 0, o * n)))
              : ((this.times = t), (this.values = e)),
            this
          );
        }
        clone() {
          const t = dh.arraySlice(this.times, 0),
            e = dh.arraySlice(this.values, 0),
            n = new (0, this.constructor)(this.name, t, e);
          return (n.createInterpolant = this.createInterpolant), n;
        }
      }
      (vh.prototype.TimeBufferType = Float32Array),
        (vh.prototype.ValueBufferType = Float32Array),
        (vh.prototype.DefaultInterpolation = ze);
      class yh extends vh {}
      (yh.prototype.ValueTypeName = "bool"),
        (yh.prototype.ValueBufferType = Array),
        (yh.prototype.DefaultInterpolation = Fe),
        (yh.prototype.InterpolantFactoryMethodLinear = void 0),
        (yh.prototype.InterpolantFactoryMethodSmooth = void 0);
      class xh extends vh {}
      xh.prototype.ValueTypeName = "color";
      class bh extends vh {}
      bh.prototype.ValueTypeName = "number";
      class wh extends ph {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = (n - e) / (i - e);
          let l = t * s;
          for (let t = l + s; l !== t; l += 4)
            oi.slerpFlat(r, 0, o, l - s, o, l, a);
          return r;
        }
      }
      class _h extends vh {
        InterpolantFactoryMethodLinear(t) {
          return new wh(this.times, this.values, this.getValueSize(), t);
        }
      }
      (_h.prototype.ValueTypeName = "quaternion"),
        (_h.prototype.DefaultInterpolation = ze),
        (_h.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Mh extends vh {}
      (Mh.prototype.ValueTypeName = "string"),
        (Mh.prototype.ValueBufferType = Array),
        (Mh.prototype.DefaultInterpolation = Fe),
        (Mh.prototype.InterpolantFactoryMethodLinear = void 0),
        (Mh.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Sh extends vh {}
      Sh.prototype.ValueTypeName = "vector";
      class Eh {
        constructor(t, e = -1, n, i = je) {
          (this.name = t),
            (this.tracks = n),
            (this.duration = e),
            (this.blendMode = i),
            (this.uuid = Hn()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(t) {
          const e = [],
            n = t.tracks,
            i = 1 / (t.fps || 1);
          for (let t = 0, r = n.length; t !== r; ++t) e.push(Th(n[t]).scale(i));
          const r = new this(t.name, t.duration, e, t.blendMode);
          return (r.uuid = t.uuid), r;
        }
        static toJSON(t) {
          const e = [],
            n = t.tracks,
            i = {
              name: t.name,
              duration: t.duration,
              tracks: e,
              uuid: t.uuid,
              blendMode: t.blendMode,
            };
          for (let t = 0, i = n.length; t !== i; ++t) e.push(vh.toJSON(n[t]));
          return i;
        }
        static CreateFromMorphTargetSequence(t, e, n, i) {
          const r = e.length,
            o = [];
          for (let t = 0; t < r; t++) {
            let s = [],
              a = [];
            s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
            const l = dh.getKeyframeOrder(s);
            (s = dh.sortedArray(s, 1, l)),
              (a = dh.sortedArray(a, 1, l)),
              i || 0 !== s[0] || (s.push(r), a.push(a[0])),
              o.push(
                new bh(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(
                  1 / n
                )
              );
          }
          return new this(t, -1, o);
        }
        static findByName(t, e) {
          let n = t;
          if (!Array.isArray(t)) {
            const e = t;
            n = (e.geometry && e.geometry.animations) || e.animations;
          }
          for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(t, e, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e],
              o = n.name.match(r);
            if (o && o.length > 1) {
              const t = o[1];
              let e = i[t];
              e || (i[t] = e = []), e.push(n);
            }
          }
          const o = [];
          for (const t in i)
            o.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
          return o;
        }
        static parseAnimation(t, e) {
          if (!t)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (t, e, n, i, r) {
              if (0 !== n.length) {
                const o = [],
                  s = [];
                dh.flattenJSON(n, o, s, i),
                  0 !== o.length && r.push(new t(e, o, s));
              }
            },
            i = [],
            r = t.name || "default",
            o = t.fps || 30,
            s = t.blendMode;
          let a = t.length || -1;
          const l = t.hierarchy || [];
          for (let t = 0; t < l.length; t++) {
            const r = l[t].keys;
            if (r && 0 !== r.length)
              if (r[0].morphTargets) {
                const t = {};
                let e;
                for (e = 0; e < r.length; e++)
                  if (r[e].morphTargets)
                    for (let n = 0; n < r[e].morphTargets.length; n++)
                      t[r[e].morphTargets[n]] = -1;
                for (const n in t) {
                  const t = [],
                    o = [];
                  for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                    const i = r[e];
                    t.push(i.time), o.push(i.morphTarget === n ? 1 : 0);
                  }
                  i.push(new bh(".morphTargetInfluence[" + n + "]", t, o));
                }
                a = t.length * (o || 1);
              } else {
                const o = ".bones[" + e[t].name + "]";
                n(Sh, o + ".position", r, "pos", i),
                  n(_h, o + ".quaternion", r, "rot", i),
                  n(Sh, o + ".scale", r, "scl", i);
              }
          }
          return 0 === i.length ? null : new this(r, a, i, s);
        }
        resetDuration() {
          let t = 0;
          for (let e = 0, n = this.tracks.length; e !== n; ++e) {
            const n = this.tracks[e];
            t = Math.max(t, n.times[n.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration);
          return this;
        }
        validate() {
          let t = !0;
          for (let e = 0; e < this.tracks.length; e++)
            t = t && this.tracks[e].validate();
          return t;
        }
        optimize() {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].optimize();
          return this;
        }
        clone() {
          const t = [];
          for (let e = 0; e < this.tracks.length; e++)
            t.push(this.tracks[e].clone());
          return new this.constructor(
            this.name,
            this.duration,
            t,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function Th(t) {
        if (void 0 === t.type)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = (function (t) {
          switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return bh;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Sh;
            case "color":
              return xh;
            case "quaternion":
              return _h;
            case "bool":
            case "boolean":
              return yh;
            case "string":
              return Mh;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
        })(t.type);
        if (void 0 === t.times) {
          const e = [],
            n = [];
          dh.flattenJSON(t.keys, e, n, "value"), (t.times = e), (t.values = n);
        }
        return void 0 !== e.parse
          ? e.parse(t)
          : new e(t.name, t.times, t.values, t.interpolation);
      }
      const Ah = {
        enabled: !1,
        files: {},
        add: function (t, e) {
          !1 !== this.enabled && (this.files[t] = e);
        },
        get: function (t) {
          if (!1 !== this.enabled) return this.files[t];
        },
        remove: function (t) {
          delete this.files[t];
        },
        clear: function () {
          this.files = {};
        },
      };
      class Ch {
        constructor(t, e, n) {
          const i = this;
          let r,
            o = !1,
            s = 0,
            a = 0;
          const l = [];
          (this.onStart = void 0),
            (this.onLoad = t),
            (this.onProgress = e),
            (this.onError = n),
            (this.itemStart = function (t) {
              a++,
                !1 === o && void 0 !== i.onStart && i.onStart(t, s, a),
                (o = !0);
            }),
            (this.itemEnd = function (t) {
              s++,
                void 0 !== i.onProgress && i.onProgress(t, s, a),
                s === a && ((o = !1), void 0 !== i.onLoad && i.onLoad());
            }),
            (this.itemError = function (t) {
              void 0 !== i.onError && i.onError(t);
            }),
            (this.resolveURL = function (t) {
              return r ? r(t) : t;
            }),
            (this.setURLModifier = function (t) {
              return (r = t), this;
            }),
            (this.addHandler = function (t, e) {
              return l.push(t, e), this;
            }),
            (this.removeHandler = function (t) {
              const e = l.indexOf(t);
              return -1 !== e && l.splice(e, 2), this;
            }),
            (this.getHandler = function (t) {
              for (let e = 0, n = l.length; e < n; e += 2) {
                const n = l[e],
                  i = l[e + 1];
                if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
              }
              return null;
            });
        }
      }
      const Lh = new Ch();
      class Rh {
        constructor(t) {
          (this.manager = void 0 !== t ? t : Lh),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(t, e) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(t, i, e, r);
          });
        }
        parse() {}
        setCrossOrigin(t) {
          return (this.crossOrigin = t), this;
        }
        setWithCredentials(t) {
          return (this.withCredentials = t), this;
        }
        setPath(t) {
          return (this.path = t), this;
        }
        setResourcePath(t) {
          return (this.resourcePath = t), this;
        }
        setRequestHeader(t) {
          return (this.requestHeader = t), this;
        }
      }
      const Ph = {};
      class Nh extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = this,
            o = Ah.get(t);
          if (void 0 !== o)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(o), r.manager.itemEnd(t);
              }, 0),
              o
            );
          if (void 0 !== Ph[t])
            return void Ph[t].push({ onLoad: e, onProgress: n, onError: i });
          const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
          let a;
          if (s) {
            const n = s[1],
              o = !!s[2];
            let a = s[3];
            (a = decodeURIComponent(a)), o && (a = atob(a));
            try {
              let i;
              const o = (this.responseType || "").toLowerCase();
              switch (o) {
                case "arraybuffer":
                case "blob":
                  const t = new Uint8Array(a.length);
                  for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                  i =
                    "blob" === o ? new Blob([t.buffer], { type: n }) : t.buffer;
                  break;
                case "document":
                  const e = new DOMParser();
                  i = e.parseFromString(a, n);
                  break;
                case "json":
                  i = JSON.parse(a);
                  break;
                default:
                  i = a;
              }
              setTimeout(function () {
                e && e(i), r.manager.itemEnd(t);
              }, 0);
            } catch (e) {
              setTimeout(function () {
                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
              }, 0);
            }
          } else {
            (Ph[t] = []),
              Ph[t].push({ onLoad: e, onProgress: n, onError: i }),
              (a = new XMLHttpRequest()),
              a.open("GET", t, !0),
              a.addEventListener(
                "load",
                function (e) {
                  const n = this.response,
                    i = Ph[t];
                  if (
                    (delete Ph[t], 200 === this.status || 0 === this.status)
                  ) {
                    0 === this.status &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received."),
                      Ah.add(t, n);
                    for (let t = 0, e = i.length; t < e; t++) {
                      const e = i[t];
                      e.onLoad && e.onLoad(n);
                    }
                    r.manager.itemEnd(t);
                  } else {
                    for (let t = 0, n = i.length; t < n; t++) {
                      const n = i[t];
                      n.onError && n.onError(e);
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t);
                  }
                },
                !1
              ),
              a.addEventListener(
                "progress",
                function (e) {
                  const n = Ph[t];
                  for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    i.onProgress && i.onProgress(e);
                  }
                },
                !1
              ),
              a.addEventListener(
                "error",
                function (e) {
                  const n = Ph[t];
                  delete Ph[t];
                  for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    i.onError && i.onError(e);
                  }
                  r.manager.itemError(t), r.manager.itemEnd(t);
                },
                !1
              ),
              a.addEventListener(
                "abort",
                function (e) {
                  const n = Ph[t];
                  delete Ph[t];
                  for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    i.onError && i.onError(e);
                  }
                  r.manager.itemError(t), r.manager.itemEnd(t);
                },
                !1
              ),
              void 0 !== this.responseType &&
                (a.responseType = this.responseType),
              void 0 !== this.withCredentials &&
                (a.withCredentials = this.withCredentials),
              a.overrideMimeType &&
                a.overrideMimeType(
                  void 0 !== this.mimeType ? this.mimeType : "text/plain"
                );
            for (const t in this.requestHeader)
              a.setRequestHeader(t, this.requestHeader[t]);
            a.send(null);
          }
          return r.manager.itemStart(t), a;
        }
        setResponseType(t) {
          return (this.responseType = t), this;
        }
        setMimeType(t) {
          return (this.mimeType = t), this;
        }
      }
      class Ih extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            o = new Nh(this.manager);
          o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              t,
              function (n) {
                try {
                  e(r.parse(JSON.parse(n)));
                } catch (e) {
                  i ? i(e) : console.error(e), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        }
        parse(t) {
          const e = [];
          for (let n = 0; n < t.length; n++) {
            const i = Eh.parse(t[n]);
            e.push(i);
          }
          return e;
        }
      }
      class Bh extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            o = [],
            s = new Ic(),
            a = new Nh(this.manager);
          a.setPath(this.path),
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(r.withCredentials);
          let l = 0;
          function c(c) {
            a.load(
              t[c],
              function (t) {
                const n = r.parse(t, !0);
                (o[c] = {
                  width: n.width,
                  height: n.height,
                  format: n.format,
                  mipmaps: n.mipmaps,
                }),
                  (l += 1),
                  6 === l &&
                    (1 === n.mipmapCount && (s.minFilter = yt),
                    (s.image = o),
                    (s.format = n.format),
                    (s.needsUpdate = !0),
                    e && e(s));
              },
              n,
              i
            );
          }
          if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e) c(e);
          else
            a.load(
              t,
              function (t) {
                const n = r.parse(t, !0);
                if (n.isCubemap) {
                  const t = n.mipmaps.length / n.mipmapCount;
                  for (let e = 0; e < t; e++) {
                    o[e] = { mipmaps: [] };
                    for (let t = 0; t < n.mipmapCount; t++)
                      o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                        (o[e].format = n.format),
                        (o[e].width = n.width),
                        (o[e].height = n.height);
                  }
                  s.image = o;
                } else
                  (s.image.width = n.width),
                    (s.image.height = n.height),
                    (s.mipmaps = n.mipmaps);
                1 === n.mipmapCount && (s.minFilter = yt),
                  (s.format = n.format),
                  (s.needsUpdate = !0),
                  e && e(s);
              },
              n,
              i
            );
          return s;
        }
      }
      class Oh extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = this,
            o = Ah.get(t);
          if (void 0 !== o)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(o), r.manager.itemEnd(t);
              }, 0),
              o
            );
          const s = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "img"
          );
          function a() {
            s.removeEventListener("load", a, !1),
              s.removeEventListener("error", l, !1),
              Ah.add(t, this),
              e && e(this),
              r.manager.itemEnd(t);
          }
          function l(e) {
            s.removeEventListener("load", a, !1),
              s.removeEventListener("error", l, !1),
              i && i(e),
              r.manager.itemError(t),
              r.manager.itemEnd(t);
          }
          return (
            s.addEventListener("load", a, !1),
            s.addEventListener("error", l, !1),
            "data:" !== t.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (s.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            (s.src = t),
            s
          );
        }
      }
      class Dh extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = new Ro(),
            o = new Oh(this.manager);
          o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
          let s = 0;
          function a(n) {
            o.load(
              t[n],
              function (t) {
                (r.images[n] = t),
                  s++,
                  6 === s && ((r.needsUpdate = !0), e && e(r));
              },
              void 0,
              i
            );
          }
          for (let e = 0; e < t.length; ++e) a(e);
          return r;
        }
      }
      class kh extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            o = new oc(),
            s = new Nh(this.manager);
          return (
            s.setResponseType("arraybuffer"),
            s.setRequestHeader(this.requestHeader),
            s.setPath(this.path),
            s.setWithCredentials(r.withCredentials),
            s.load(
              t,
              function (t) {
                const n = r.parse(t);
                n &&
                  (void 0 !== n.image
                    ? (o.image = n.image)
                    : void 0 !== n.data &&
                      ((o.image.width = n.width),
                      (o.image.height = n.height),
                      (o.image.data = n.data)),
                  (o.wrapS = void 0 !== n.wrapS ? n.wrapS : ht),
                  (o.wrapT = void 0 !== n.wrapT ? n.wrapT : ht),
                  (o.magFilter = void 0 !== n.magFilter ? n.magFilter : yt),
                  (o.minFilter = void 0 !== n.minFilter ? n.minFilter : yt),
                  (o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                  void 0 !== n.encoding && (o.encoding = n.encoding),
                  void 0 !== n.flipY && (o.flipY = n.flipY),
                  void 0 !== n.format && (o.format = n.format),
                  void 0 !== n.type && (o.type = n.type),
                  void 0 !== n.mipmaps &&
                    ((o.mipmaps = n.mipmaps), (o.minFilter = wt)),
                  1 === n.mipmapCount && (o.minFilter = yt),
                  void 0 !== n.generateMipmaps &&
                    (o.generateMipmaps = n.generateMipmaps),
                  (o.needsUpdate = !0),
                  e && e(o, n));
              },
              n,
              i
            ),
            o
          );
        }
      }
      class Fh extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = new $n(),
            o = new Oh(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              t,
              function (n) {
                r.image = n;
                const i =
                  t.search(/\.jpe?g($|\?)/i) > 0 ||
                  0 === t.search(/^data\:image\/jpeg/);
                (r.format = i ? Dt : kt),
                  (r.needsUpdate = !0),
                  void 0 !== e && e(r);
              },
              n,
              i
            ),
            r
          );
        }
      }
      class zh extends qc {
        constructor() {
          super(),
            (this.type = "CurvePath"),
            (this.curves = []),
            (this.autoClose = !1);
        }
        add(t) {
          this.curves.push(t);
        }
        closePath() {
          const t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
          t.equals(e) || this.curves.push(new su(e, t));
        }
        getPoint(t) {
          const e = t * this.getLength(),
            n = this.getCurveLengths();
          let i = 0;
          for (; i < n.length; ) {
            if (n[i] >= e) {
              const t = n[i] - e,
                r = this.curves[i],
                o = r.getLength(),
                s = 0 === o ? 0 : 1 - t / o;
              return r.getPointAt(s);
            }
            i++;
          }
          return null;
        }
        getLength() {
          const t = this.getCurveLengths();
          return t[t.length - 1];
        }
        updateArcLengths() {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          const t = [];
          let e = 0;
          for (let n = 0, i = this.curves.length; n < i; n++)
            (e += this.curves[n].getLength()), t.push(e);
          return (this.cacheLengths = t), t;
        }
        getSpacedPoints(t = 40) {
          const e = [];
          for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
          return this.autoClose && e.push(e[0]), e;
        }
        getPoints(t = 12) {
          const e = [];
          let n;
          for (let i = 0, r = this.curves; i < r.length; i++) {
            const o = r[i],
              s =
                o && o.isEllipseCurve
                  ? 2 * t
                  : o && (o.isLineCurve || o.isLineCurve3)
                  ? 1
                  : o && o.isSplineCurve
                  ? t * o.points.length
                  : t,
              a = o.getPoints(s);
            for (let t = 0; t < a.length; t++) {
              const i = a[t];
              (n && n.equals(i)) || (e.push(i), (n = i));
            }
          }
          return (
            this.autoClose &&
              e.length > 1 &&
              !e[e.length - 1].equals(e[0]) &&
              e.push(e[0]),
            e
          );
        }
        copy(t) {
          super.copy(t), (this.curves = []);
          for (let e = 0, n = t.curves.length; e < n; e++) {
            const n = t.curves[e];
            this.curves.push(n.clone());
          }
          return (this.autoClose = t.autoClose), this;
        }
        toJSON() {
          const t = super.toJSON();
          (t.autoClose = this.autoClose), (t.curves = []);
          for (let e = 0, n = this.curves.length; e < n; e++) {
            const n = this.curves[e];
            t.curves.push(n.toJSON());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
          for (let e = 0, n = t.curves.length; e < n; e++) {
            const n = t.curves[e];
            this.curves.push(new hu[n.type]().fromJSON(n));
          }
          return this;
        }
      }
      class Hh extends zh {
        constructor(t) {
          super(),
            (this.type = "Path"),
            (this.currentPoint = new Yn()),
            t && this.setFromPoints(t);
        }
        setFromPoints(t) {
          this.moveTo(t[0].x, t[0].y);
          for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
          return this;
        }
        moveTo(t, e) {
          return this.currentPoint.set(t, e), this;
        }
        lineTo(t, e) {
          const n = new su(this.currentPoint.clone(), new Yn(t, e));
          return this.curves.push(n), this.currentPoint.set(t, e), this;
        }
        quadraticCurveTo(t, e, n, i) {
          const r = new lu(
            this.currentPoint.clone(),
            new Yn(t, e),
            new Yn(n, i)
          );
          return this.curves.push(r), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(t, e, n, i, r, o) {
          const s = new ru(
            this.currentPoint.clone(),
            new Yn(t, e),
            new Yn(n, i),
            new Yn(r, o)
          );
          return this.curves.push(s), this.currentPoint.set(r, o), this;
        }
        splineThru(t) {
          const e = [this.currentPoint.clone()].concat(t),
            n = new uu(e);
          return (
            this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
          );
        }
        arc(t, e, n, i, r, o) {
          const s = this.currentPoint.x,
            a = this.currentPoint.y;
          return this.absarc(t + s, e + a, n, i, r, o), this;
        }
        absarc(t, e, n, i, r, o) {
          return this.absellipse(t, e, n, n, i, r, o), this;
        }
        ellipse(t, e, n, i, r, o, s, a) {
          const l = this.currentPoint.x,
            c = this.currentPoint.y;
          return this.absellipse(t + l, e + c, n, i, r, o, s, a), this;
        }
        absellipse(t, e, n, i, r, o, s, a) {
          const l = new Xc(t, e, n, i, r, o, s, a);
          if (this.curves.length > 0) {
            const t = l.getPoint(0);
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
          }
          this.curves.push(l);
          const c = l.getPoint(1);
          return this.currentPoint.copy(c), this;
        }
        copy(t) {
          return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.currentPoint = this.currentPoint.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
          );
        }
      }
      class Uh extends Hh {
        constructor(t) {
          super(t),
            (this.uuid = Hn()),
            (this.type = "Shape"),
            (this.holes = []);
        }
        getPointsHoles(t) {
          const e = [];
          for (let n = 0, i = this.holes.length; n < i; n++)
            e[n] = this.holes[n].getPoints(t);
          return e;
        }
        extractPoints(t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
        }
        copy(t) {
          super.copy(t), (this.holes = []);
          for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e];
            this.holes.push(n.clone());
          }
          return this;
        }
        toJSON() {
          const t = super.toJSON();
          (t.uuid = this.uuid), (t.holes = []);
          for (let e = 0, n = this.holes.length; e < n; e++) {
            const n = this.holes[e];
            t.holes.push(n.toJSON());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
          for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e];
            this.holes.push(new Hh().fromJSON(n));
          }
          return this;
        }
      }
      class Vh extends lr {
        constructor(t, e = 1) {
          super(),
            (this.type = "Light"),
            (this.color = new Cr(t)),
            (this.intensity = e);
        }
        dispose() {}
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
          );
        }
      }
      Vh.prototype.isLight = !0;
      class Gh extends Vh {
        constructor(t, e, n) {
          super(t, n),
            (this.type = "HemisphereLight"),
            this.position.copy(lr.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new Cr(e));
        }
        copy(t) {
          return (
            Vh.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
          );
        }
      }
      Gh.prototype.isHemisphereLight = !0;
      const jh = new ki(),
        Wh = new si(),
        qh = new si();
      class Xh {
        constructor(t) {
          (this.camera = t),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.mapSize = new Yn(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new ki()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Fo()),
            (this._frameExtents = new Yn(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new ei(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t) {
          const e = this.camera,
            n = this.matrix;
          Wh.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(Wh),
            qh.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(qh),
            e.updateMatrixWorld(),
            jh.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(jh),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(e.projectionMatrix),
            n.multiply(e.matrixWorldInverse);
        }
        getViewport(t) {
          return this._viewports[t];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(t) {
          return (
            (this.camera = t.camera.clone()),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = {};
          return (
            0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          );
        }
      }
      class Yh extends Xh {
        constructor() {
          super(new Ao(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(t) {
          const e = this.camera,
            n = 2 * zn * t.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far;
          (n === e.fov && i === e.aspect && r === e.far) ||
            ((e.fov = n),
            (e.aspect = i),
            (e.far = r),
            e.updateProjectionMatrix()),
            super.updateMatrices(t);
        }
        copy(t) {
          return super.copy(t), (this.focus = t.focus), this;
        }
      }
      Yh.prototype.isSpotLightShadow = !0;
      class Zh extends Vh {
        constructor(t, e, n = 0, i = Math.PI / 3, r = 0, o = 1) {
          super(t, e),
            (this.type = "SpotLight"),
            this.position.copy(lr.DefaultUp),
            this.updateMatrix(),
            (this.target = new lr()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = o),
            (this.shadow = new Yh());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(t) {
          this.intensity = t / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      Zh.prototype.isSpotLight = !0;
      const Jh = new ki(),
        Kh = new si(),
        Qh = new si();
      class $h extends Xh {
        constructor() {
          super(new Ao(90, 1, 0.5, 500)),
            (this._frameExtents = new Yn(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new ei(2, 1, 1, 1),
              new ei(0, 1, 1, 1),
              new ei(3, 1, 1, 1),
              new ei(1, 1, 1, 1),
              new ei(3, 0, 1, 1),
              new ei(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new si(1, 0, 0),
              new si(-1, 0, 0),
              new si(0, 0, 1),
              new si(0, 0, -1),
              new si(0, 1, 0),
              new si(0, -1, 0),
            ]),
            (this._cubeUps = [
              new si(0, 1, 0),
              new si(0, 1, 0),
              new si(0, 1, 0),
              new si(0, 1, 0),
              new si(0, 0, 1),
              new si(0, 0, -1),
            ]);
        }
        updateMatrices(t, e = 0) {
          const n = this.camera,
            i = this.matrix,
            r = t.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            Kh.setFromMatrixPosition(t.matrixWorld),
            n.position.copy(Kh),
            Qh.copy(n.position),
            Qh.add(this._cubeDirections[e]),
            n.up.copy(this._cubeUps[e]),
            n.lookAt(Qh),
            n.updateMatrixWorld(),
            i.makeTranslation(-Kh.x, -Kh.y, -Kh.z),
            Jh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Jh);
        }
      }
      $h.prototype.isPointLightShadow = !0;
      class td extends Vh {
        constructor(t, e, n = 0, i = 1) {
          super(t, e),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new $h());
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(t) {
          this.intensity = t / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      td.prototype.isPointLight = !0;
      class ed extends Xh {
        constructor() {
          super(new Ko(-5, 5, 5, -5, 0.5, 500));
        }
      }
      ed.prototype.isDirectionalLightShadow = !0;
      class nd extends Vh {
        constructor(t, e) {
          super(t, e),
            (this.type = "DirectionalLight"),
            this.position.copy(lr.DefaultUp),
            this.updateMatrix(),
            (this.target = new lr()),
            (this.shadow = new ed());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return (
            super.copy(t),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        }
      }
      nd.prototype.isDirectionalLight = !0;
      class id extends Vh {
        constructor(t, e) {
          super(t, e), (this.type = "AmbientLight");
        }
      }
      id.prototype.isAmbientLight = !0;
      class rd extends Vh {
        constructor(t, e, n = 10, i = 10) {
          super(t, e),
            (this.type = "RectAreaLight"),
            (this.width = n),
            (this.height = i);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.width = this.width), (e.object.height = this.height), e
          );
        }
      }
      rd.prototype.isRectAreaLight = !0;
      class od {
        constructor() {
          this.coefficients = [];
          for (let t = 0; t < 9; t++) this.coefficients.push(new si());
        }
        set(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
          return this;
        }
        zero() {
          for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
          return this;
        }
        getAt(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            o = this.coefficients;
          return (
            e.copy(o[0]).multiplyScalar(0.282095),
            e.addScaledVector(o[1], 0.488603 * i),
            e.addScaledVector(o[2], 0.488603 * r),
            e.addScaledVector(o[3], 0.488603 * n),
            e.addScaledVector(o[4], n * i * 1.092548),
            e.addScaledVector(o[5], i * r * 1.092548),
            e.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
            e.addScaledVector(o[7], n * r * 1.092548),
            e.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
            e
          );
        }
        getIrradianceAt(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            o = this.coefficients;
          return (
            e.copy(o[0]).multiplyScalar(0.886227),
            e.addScaledVector(o[1], 1.023328 * i),
            e.addScaledVector(o[2], 1.023328 * r),
            e.addScaledVector(o[3], 1.023328 * n),
            e.addScaledVector(o[4], 0.858086 * n * i),
            e.addScaledVector(o[5], 0.858086 * i * r),
            e.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
            e.addScaledVector(o[7], 0.858086 * n * r),
            e.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
            e
          );
        }
        add(t) {
          for (let e = 0; e < 9; e++)
            this.coefficients[e].add(t.coefficients[e]);
          return this;
        }
        addScaledSH(t, e) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(t.coefficients[n], e);
          return this;
        }
        scale(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
          return this;
        }
        lerp(t, e) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(t.coefficients[n], e);
          return this;
        }
        equals(t) {
          for (let e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
          return !0;
        }
        copy(t) {
          return this.set(t.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(t, e = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.coefficients;
          for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
          return t;
        }
        static getBasisAt(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z;
          (e[0] = 0.282095),
            (e[1] = 0.488603 * i),
            (e[2] = 0.488603 * r),
            (e[3] = 0.488603 * n),
            (e[4] = 1.092548 * n * i),
            (e[5] = 1.092548 * i * r),
            (e[6] = 0.315392 * (3 * r * r - 1)),
            (e[7] = 1.092548 * n * r),
            (e[8] = 0.546274 * (n * n - i * i));
        }
      }
      od.prototype.isSphericalHarmonics3 = !0;
      class sd extends Vh {
        constructor(t = new od(), e = 1) {
          super(void 0, e), (this.sh = t);
        }
        copy(t) {
          return super.copy(t), this.sh.copy(t.sh), this;
        }
        fromJSON(t) {
          return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (e.object.sh = this.sh.toArray()), e;
        }
      }
      sd.prototype.isLightProbe = !0;
      class ad extends Rh {
        constructor(t) {
          super(t), (this.textures = {});
        }
        load(t, e, n, i) {
          const r = this,
            o = new Nh(r.manager);
          o.setPath(r.path),
            o.setRequestHeader(r.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(
              t,
              function (n) {
                try {
                  e(r.parse(JSON.parse(n)));
                } catch (e) {
                  i ? i(e) : console.error(e), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        }
        parse(t) {
          const e = this.textures;
          function n(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.MaterialLoader: Undefined texture", t),
              e[t]
            );
          }
          const i = new hh[t.type]();
          if (
            (void 0 !== t.uuid && (i.uuid = t.uuid),
            void 0 !== t.name && (i.name = t.name),
            void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color),
            void 0 !== t.roughness && (i.roughness = t.roughness),
            void 0 !== t.metalness && (i.metalness = t.metalness),
            void 0 !== t.sheen && (i.sheen = new Cr().setHex(t.sheen)),
            void 0 !== t.emissive &&
              void 0 !== i.emissive &&
              i.emissive.setHex(t.emissive),
            void 0 !== t.specular &&
              void 0 !== i.specular &&
              i.specular.setHex(t.specular),
            void 0 !== t.specularIntensity &&
              (i.specularIntensity = t.specularIntensity),
            void 0 !== t.specularTint &&
              void 0 !== i.specularTint &&
              i.specularTint.setHex(t.specularTint),
            void 0 !== t.shininess && (i.shininess = t.shininess),
            void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
            void 0 !== t.clearcoatRoughness &&
              (i.clearcoatRoughness = t.clearcoatRoughness),
            void 0 !== t.transmission && (i.transmission = t.transmission),
            void 0 !== t.thickness && (i.thickness = t.thickness),
            void 0 !== t.attenuationDistance &&
              (i.attenuationDistance = t.attenuationDistance),
            void 0 !== t.attenuationTint &&
              void 0 !== i.attenuationTint &&
              i.attenuationTint.setHex(t.attenuationTint),
            void 0 !== t.fog && (i.fog = t.fog),
            void 0 !== t.flatShading && (i.flatShading = t.flatShading),
            void 0 !== t.blending && (i.blending = t.blending),
            void 0 !== t.combine && (i.combine = t.combine),
            void 0 !== t.side && (i.side = t.side),
            void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide),
            void 0 !== t.opacity && (i.opacity = t.opacity),
            void 0 !== t.transparent && (i.transparent = t.transparent),
            void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (i.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
            void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
            void 0 !== t.stencilWriteMask &&
              (i.stencilWriteMask = t.stencilWriteMask),
            void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
            void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
            void 0 !== t.stencilFuncMask &&
              (i.stencilFuncMask = t.stencilFuncMask),
            void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
            void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
            void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
            void 0 !== t.wireframe && (i.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth &&
              (i.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap &&
              (i.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin &&
              (i.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (i.rotation = t.rotation),
            1 !== t.linewidth && (i.linewidth = t.linewidth),
            void 0 !== t.dashSize && (i.dashSize = t.dashSize),
            void 0 !== t.gapSize && (i.gapSize = t.gapSize),
            void 0 !== t.scale && (i.scale = t.scale),
            void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor &&
              (i.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits &&
              (i.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.dithering && (i.dithering = t.dithering),
            void 0 !== t.alphaToCoverage &&
              (i.alphaToCoverage = t.alphaToCoverage),
            void 0 !== t.premultipliedAlpha &&
              (i.premultipliedAlpha = t.premultipliedAlpha),
            void 0 !== t.visible && (i.visible = t.visible),
            void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
            void 0 !== t.userData && (i.userData = t.userData),
            void 0 !== t.vertexColors &&
              ("number" == typeof t.vertexColors
                ? (i.vertexColors = t.vertexColors > 0)
                : (i.vertexColors = t.vertexColors)),
            void 0 !== t.uniforms)
          )
            for (const e in t.uniforms) {
              const r = t.uniforms[e];
              switch (((i.uniforms[e] = {}), r.type)) {
                case "t":
                  i.uniforms[e].value = n(r.value);
                  break;
                case "c":
                  i.uniforms[e].value = new Cr().setHex(r.value);
                  break;
                case "v2":
                  i.uniforms[e].value = new Yn().fromArray(r.value);
                  break;
                case "v3":
                  i.uniforms[e].value = new si().fromArray(r.value);
                  break;
                case "v4":
                  i.uniforms[e].value = new ei().fromArray(r.value);
                  break;
                case "m3":
                  i.uniforms[e].value = new Zn().fromArray(r.value);
                  break;
                case "m4":
                  i.uniforms[e].value = new ki().fromArray(r.value);
                  break;
                default:
                  i.uniforms[e].value = r.value;
              }
            }
          if (
            (void 0 !== t.defines && (i.defines = t.defines),
            void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader &&
              (i.fragmentShader = t.fragmentShader),
            void 0 !== t.extensions)
          )
            for (const e in t.extensions) i.extensions[e] = t.extensions[e];
          if (
            (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
            void 0 !== t.size && (i.size = t.size),
            void 0 !== t.sizeAttenuation &&
              (i.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (i.map = n(t.map)),
            void 0 !== t.matcap && (i.matcap = n(t.matcap)),
            void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
            void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
            void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
            void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
            void 0 !== t.normalScale)
          ) {
            let e = t.normalScale;
            !1 === Array.isArray(e) && (e = [e, e]),
              (i.normalScale = new Yn().fromArray(e));
          }
          return (
            void 0 !== t.displacementMap &&
              (i.displacementMap = n(t.displacementMap)),
            void 0 !== t.displacementScale &&
              (i.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias &&
              (i.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
            void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
            void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
            void 0 !== t.emissiveIntensity &&
              (i.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
            void 0 !== t.specularIntensityMap &&
              (i.specularIntensityMap = n(t.specularIntensityMap)),
            void 0 !== t.specularTintMap &&
              (i.specularTintMap = n(t.specularTintMap)),
            void 0 !== t.envMap && (i.envMap = n(t.envMap)),
            void 0 !== t.envMapIntensity &&
              (i.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
            void 0 !== t.refractionRatio &&
              (i.refractionRatio = t.refractionRatio),
            void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
            void 0 !== t.lightMapIntensity &&
              (i.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
            void 0 !== t.aoMapIntensity &&
              (i.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
            void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
            void 0 !== t.clearcoatRoughnessMap &&
              (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
            void 0 !== t.clearcoatNormalMap &&
              (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
            void 0 !== t.clearcoatNormalScale &&
              (i.clearcoatNormalScale = new Yn().fromArray(
                t.clearcoatNormalScale
              )),
            void 0 !== t.transmissionMap &&
              (i.transmissionMap = n(t.transmissionMap)),
            void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)),
            i
          );
        }
        setTextures(t) {
          return (this.textures = t), this;
        }
      }
      class ld {
        static decodeText(t) {
          if ("undefined" != typeof TextDecoder)
            return new TextDecoder().decode(t);
          let e = "";
          for (let n = 0, i = t.length; n < i; n++)
            e += String.fromCharCode(t[n]);
          try {
            return decodeURIComponent(escape(e));
          } catch (t) {
            return e;
          }
        }
        static extractUrlBase(t) {
          const e = t.lastIndexOf("/");
          return -1 === e ? "./" : t.substr(0, e + 1);
        }
      }
      class cd extends $r {
        constructor() {
          super(),
            (this.type = "InstancedBufferGeometry"),
            (this.instanceCount = 1 / 0);
        }
        copy(t) {
          return super.copy(t), (this.instanceCount = t.instanceCount), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = super.toJSON(this);
          return (
            (t.instanceCount = this.instanceCount),
            (t.isInstancedBufferGeometry = !0),
            t
          );
        }
      }
      cd.prototype.isInstancedBufferGeometry = !0;
      class ud extends Nr {
        constructor(t, e, n, i = 1) {
          "number" == typeof n &&
            ((i = n),
            (n = !1),
            console.error(
              "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
            )),
            super(t, e, n),
            (this.meshPerAttribute = i);
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          );
        }
        toJSON() {
          const t = super.toJSON();
          return (
            (t.meshPerAttribute = this.meshPerAttribute),
            (t.isInstancedBufferAttribute = !0),
            t
          );
        }
      }
      ud.prototype.isInstancedBufferAttribute = !0;
      class hd extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            o = new Nh(r.manager);
          o.setPath(r.path),
            o.setRequestHeader(r.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(
              t,
              function (n) {
                try {
                  e(r.parse(JSON.parse(n)));
                } catch (e) {
                  i ? i(e) : console.error(e), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        }
        parse(t) {
          const e = {},
            n = {};
          function i(t, i) {
            if (void 0 !== e[i]) return e[i];
            const r = t.interleavedBuffers[i],
              o = (function (t, e) {
                if (void 0 !== n[e]) return n[e];
                const i = t.arrayBuffers[e],
                  r = new Uint32Array(i).buffer;
                return (n[e] = r), r;
              })(t, r.buffer),
              s = Wr(r.type, o),
              a = new Rl(s, r.stride);
            return (a.uuid = r.uuid), (e[i] = a), a;
          }
          const r = t.isInstancedBufferGeometry ? new cd() : new $r(),
            o = t.data.index;
          if (void 0 !== o) {
            const t = Wr(o.type, o.array);
            r.setIndex(new Nr(t, 1));
          }
          const s = t.data.attributes;
          for (const e in s) {
            const n = s[e];
            let o;
            if (n.isInterleavedBufferAttribute) {
              const e = i(t.data, n.data);
              o = new Nl(e, n.itemSize, n.offset, n.normalized);
            } else {
              const t = Wr(n.type, n.array);
              o = new (n.isInstancedBufferAttribute ? ud : Nr)(
                t,
                n.itemSize,
                n.normalized
              );
            }
            void 0 !== n.name && (o.name = n.name),
              void 0 !== n.usage && o.setUsage(n.usage),
              void 0 !== n.updateRange &&
                ((o.updateRange.offset = n.updateRange.offset),
                (o.updateRange.count = n.updateRange.count)),
              r.setAttribute(e, o);
          }
          const a = t.data.morphAttributes;
          if (a)
            for (const e in a) {
              const n = a[e],
                o = [];
              for (let e = 0, r = n.length; e < r; e++) {
                const r = n[e];
                let s;
                if (r.isInterleavedBufferAttribute) {
                  const e = i(t.data, r.data);
                  s = new Nl(e, r.itemSize, r.offset, r.normalized);
                } else {
                  const t = Wr(r.type, r.array);
                  s = new Nr(t, r.itemSize, r.normalized);
                }
                void 0 !== r.name && (s.name = r.name), o.push(s);
              }
              r.morphAttributes[e] = o;
            }
          t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
          const l = t.data.groups || t.data.drawcalls || t.data.offsets;
          if (void 0 !== l)
            for (let t = 0, e = l.length; t !== e; ++t) {
              const e = l[t];
              r.addGroup(e.start, e.count, e.materialIndex);
            }
          const c = t.data.boundingSphere;
          if (void 0 !== c) {
            const t = new si();
            void 0 !== c.center && t.fromArray(c.center),
              (r.boundingSphere = new Ci(t, c.radius));
          }
          return (
            t.name && (r.name = t.name),
            t.userData && (r.userData = t.userData),
            r
          );
        }
      }
      class dd extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            o = "" === this.path ? ld.extractUrlBase(t) : this.path;
          this.resourcePath = this.resourcePath || o;
          const s = new Nh(this.manager);
          s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              t,
              function (n) {
                let o = null;
                try {
                  o = JSON.parse(n);
                } catch (e) {
                  return (
                    void 0 !== i && i(e),
                    void console.error(
                      "THREE:ObjectLoader: Can't parse " + t + ".",
                      e.message
                    )
                  );
                }
                const s = o.metadata;
                void 0 !== s &&
                void 0 !== s.type &&
                "geometry" !== s.type.toLowerCase()
                  ? r.parse(o, e)
                  : console.error("THREE.ObjectLoader: Can't load " + t);
              },
              n,
              i
            );
        }
        async loadAsync(t, e) {
          const n = "" === this.path ? ld.extractUrlBase(t) : this.path;
          this.resourcePath = this.resourcePath || n;
          const i = new Nh(this.manager);
          i.setPath(this.path),
            i.setRequestHeader(this.requestHeader),
            i.setWithCredentials(this.withCredentials);
          const r = await i.loadAsync(t, e),
            o = JSON.parse(r),
            s = o.metadata;
          if (
            void 0 === s ||
            void 0 === s.type ||
            "geometry" === s.type.toLowerCase()
          )
            throw new Error("THREE.ObjectLoader: Can't load " + t);
          return await this.parseAsync(o);
        }
        parse(t, e) {
          const n = this.parseAnimations(t.animations),
            i = this.parseShapes(t.shapes),
            r = this.parseGeometries(t.geometries, i),
            o = this.parseImages(t.images, function () {
              void 0 !== e && e(l);
            }),
            s = this.parseTextures(t.textures, o),
            a = this.parseMaterials(t.materials, s),
            l = this.parseObject(t.object, r, a, s, n),
            c = this.parseSkeletons(t.skeletons, l);
          if ((this.bindSkeletons(l, c), void 0 !== e)) {
            let t = !1;
            for (const e in o)
              if (o[e] instanceof HTMLImageElement) {
                t = !0;
                break;
              }
            !1 === t && e(l);
          }
          return l;
        }
        async parseAsync(t) {
          const e = this.parseAnimations(t.animations),
            n = this.parseShapes(t.shapes),
            i = this.parseGeometries(t.geometries, n),
            r = await this.parseImagesAsync(t.images),
            o = this.parseTextures(t.textures, r),
            s = this.parseMaterials(t.materials, o),
            a = this.parseObject(t.object, i, s, o, e),
            l = this.parseSkeletons(t.skeletons, a);
          return this.bindSkeletons(a, l), a;
        }
        parseShapes(t) {
          const e = {};
          if (void 0 !== t)
            for (let n = 0, i = t.length; n < i; n++) {
              const i = new Uh().fromJSON(t[n]);
              e[i.uuid] = i;
            }
          return e;
        }
        parseSkeletons(t, e) {
          const n = {},
            i = {};
          if (
            (e.traverse(function (t) {
              t.isBone && (i[t.uuid] = t);
            }),
            void 0 !== t)
          )
            for (let e = 0, r = t.length; e < r; e++) {
              const r = new lc().fromJSON(t[e], i);
              n[r.uuid] = r;
            }
          return n;
        }
        parseGeometries(t, e) {
          const n = {};
          if (void 0 !== t) {
            const i = new hd();
            for (let r = 0, o = t.length; r < o; r++) {
              let o;
              const s = t[r];
              switch (s.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  o = i.parse(s);
                  break;
                case "Geometry":
                  console.error(
                    "THREE.ObjectLoader: The legacy Geometry type is no longer supported."
                  );
                  break;
                default:
                  s.type in eh
                    ? (o = eh[s.type].fromJSON(s, e))
                    : console.warn(
                        `THREE.ObjectLoader: Unsupported geometry type "${s.type}"`
                      );
              }
              (o.uuid = s.uuid),
                void 0 !== s.name && (o.name = s.name),
                !0 === o.isBufferGeometry &&
                  void 0 !== s.userData &&
                  (o.userData = s.userData),
                (n[s.uuid] = o);
            }
          }
          return n;
        }
        parseMaterials(t, e) {
          const n = {},
            i = {};
          if (void 0 !== t) {
            const r = new ad();
            r.setTextures(e);
            for (let e = 0, o = t.length; e < o; e++) {
              const o = t[e];
              if ("MultiMaterial" === o.type) {
                const t = [];
                for (let e = 0; e < o.materials.length; e++) {
                  const i = o.materials[e];
                  void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)),
                    t.push(n[i.uuid]);
                }
                i[o.uuid] = t;
              } else
                void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)),
                  (i[o.uuid] = n[o.uuid]);
            }
          }
          return i;
        }
        parseAnimations(t) {
          const e = {};
          if (void 0 !== t)
            for (let n = 0; n < t.length; n++) {
              const i = t[n],
                r = Eh.parse(i);
              e[r.uuid] = r;
            }
          return e;
        }
        parseImages(t, e) {
          const n = this,
            i = {};
          let r;
          function o(t) {
            if ("string" == typeof t) {
              const e = t;
              return (function (t) {
                return (
                  n.manager.itemStart(t),
                  r.load(
                    t,
                    function () {
                      n.manager.itemEnd(t);
                    },
                    void 0,
                    function () {
                      n.manager.itemError(t), n.manager.itemEnd(t);
                    }
                  )
                );
              })(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e);
            }
            return t.data
              ? { data: Wr(t.type, t.data), width: t.width, height: t.height }
              : null;
          }
          if (void 0 !== t && t.length > 0) {
            const n = new Ch(e);
            (r = new Oh(n)), r.setCrossOrigin(this.crossOrigin);
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e],
                r = n.url;
              if (Array.isArray(r)) {
                i[n.uuid] = [];
                for (let t = 0, e = r.length; t < e; t++) {
                  const e = o(r[t]);
                  null !== e &&
                    (e instanceof HTMLImageElement
                      ? i[n.uuid].push(e)
                      : i[n.uuid].push(new oc(e.data, e.width, e.height)));
                }
              } else {
                const t = o(n.url);
                null !== t && (i[n.uuid] = t);
              }
            }
          }
          return i;
        }
        async parseImagesAsync(t) {
          const e = this,
            n = {};
          let i;
          async function r(t) {
            if ("string" == typeof t) {
              const n = t,
                r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)
                  ? n
                  : e.resourcePath + n;
              return await i.loadAsync(r);
            }
            return t.data
              ? { data: Wr(t.type, t.data), width: t.width, height: t.height }
              : null;
          }
          if (void 0 !== t && t.length > 0) {
            (i = new Oh(this.manager)), i.setCrossOrigin(this.crossOrigin);
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e],
                o = i.url;
              if (Array.isArray(o)) {
                n[i.uuid] = [];
                for (let t = 0, e = o.length; t < e; t++) {
                  const e = o[t],
                    s = await r(e);
                  null !== s &&
                    (s instanceof HTMLImageElement
                      ? n[i.uuid].push(s)
                      : n[i.uuid].push(new oc(s.data, s.width, s.height)));
                }
              } else {
                const t = await r(i.url);
                null !== t && (n[i.uuid] = t);
              }
            }
          }
          return n;
        }
        parseTextures(t, e) {
          function n(t, e) {
            return "number" == typeof t
              ? t
              : (console.warn(
                  "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                  t
                ),
                e[t]);
          }
          const i = {};
          if (void 0 !== t)
            for (let r = 0, o = t.length; r < o; r++) {
              const o = t[r];
              let s;
              void 0 === o.image &&
                console.warn(
                  'THREE.ObjectLoader: No "image" specified for',
                  o.uuid
                ),
                void 0 === e[o.image] &&
                  console.warn("THREE.ObjectLoader: Undefined image", o.image);
              const a = e[o.image];
              Array.isArray(a)
                ? ((s = new Ro(a)), 6 === a.length && (s.needsUpdate = !0))
                : ((s =
                    a && a.data
                      ? new oc(a.data, a.width, a.height)
                      : new $n(a)),
                  a && (s.needsUpdate = !0)),
                (s.uuid = o.uuid),
                void 0 !== o.name && (s.name = o.name),
                void 0 !== o.mapping && (s.mapping = n(o.mapping, pd)),
                void 0 !== o.offset && s.offset.fromArray(o.offset),
                void 0 !== o.repeat && s.repeat.fromArray(o.repeat),
                void 0 !== o.center && s.center.fromArray(o.center),
                void 0 !== o.rotation && (s.rotation = o.rotation),
                void 0 !== o.wrap &&
                  ((s.wrapS = n(o.wrap[0], fd)), (s.wrapT = n(o.wrap[1], fd))),
                void 0 !== o.format && (s.format = o.format),
                void 0 !== o.type && (s.type = o.type),
                void 0 !== o.encoding && (s.encoding = o.encoding),
                void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, md)),
                void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, md)),
                void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy),
                void 0 !== o.flipY && (s.flipY = o.flipY),
                void 0 !== o.premultiplyAlpha &&
                  (s.premultiplyAlpha = o.premultiplyAlpha),
                void 0 !== o.unpackAlignment &&
                  (s.unpackAlignment = o.unpackAlignment),
                (i[o.uuid] = s);
            }
          return i;
        }
        parseObject(t, e, n, i, r) {
          let o, s, a;
          function l(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.ObjectLoader: Undefined geometry", t),
              e[t]
            );
          }
          function c(t) {
            if (void 0 !== t) {
              if (Array.isArray(t)) {
                const e = [];
                for (let i = 0, r = t.length; i < r; i++) {
                  const r = t[i];
                  void 0 === n[r] &&
                    console.warn("THREE.ObjectLoader: Undefined material", r),
                    e.push(n[r]);
                }
                return e;
              }
              return (
                void 0 === n[t] &&
                  console.warn("THREE.ObjectLoader: Undefined material", t),
                n[t]
              );
            }
          }
          function u(t) {
            return (
              void 0 === i[t] &&
                console.warn("THREE.ObjectLoader: Undefined texture", t),
              i[t]
            );
          }
          switch (t.type) {
            case "Scene":
              (o = new Ll()),
                void 0 !== t.background &&
                  (Number.isInteger(t.background)
                    ? (o.background = new Cr(t.background))
                    : (o.background = u(t.background))),
                void 0 !== t.environment && (o.environment = u(t.environment)),
                void 0 !== t.fog &&
                  ("Fog" === t.fog.type
                    ? (o.fog = new Cl(t.fog.color, t.fog.near, t.fog.far))
                    : "FogExp2" === t.fog.type &&
                      (o.fog = new Al(t.fog.color, t.fog.density)));
              break;
            case "PerspectiveCamera":
              (o = new Ao(t.fov, t.aspect, t.near, t.far)),
                void 0 !== t.focus && (o.focus = t.focus),
                void 0 !== t.zoom && (o.zoom = t.zoom),
                void 0 !== t.filmGauge && (o.filmGauge = t.filmGauge),
                void 0 !== t.filmOffset && (o.filmOffset = t.filmOffset),
                void 0 !== t.view && (o.view = Object.assign({}, t.view));
              break;
            case "OrthographicCamera":
              (o = new Ko(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                void 0 !== t.zoom && (o.zoom = t.zoom),
                void 0 !== t.view && (o.view = Object.assign({}, t.view));
              break;
            case "AmbientLight":
              o = new id(t.color, t.intensity);
              break;
            case "DirectionalLight":
              o = new nd(t.color, t.intensity);
              break;
            case "PointLight":
              o = new td(t.color, t.intensity, t.distance, t.decay);
              break;
            case "RectAreaLight":
              o = new rd(t.color, t.intensity, t.width, t.height);
              break;
            case "SpotLight":
              o = new Zh(
                t.color,
                t.intensity,
                t.distance,
                t.angle,
                t.penumbra,
                t.decay
              );
              break;
            case "HemisphereLight":
              o = new Gh(t.color, t.groundColor, t.intensity);
              break;
            case "LightProbe":
              o = new sd().fromJSON(t);
              break;
            case "SkinnedMesh":
              (s = l(t.geometry)),
                (a = c(t.material)),
                (o = new ic(s, a)),
                void 0 !== t.bindMode && (o.bindMode = t.bindMode),
                void 0 !== t.bindMatrix && o.bindMatrix.fromArray(t.bindMatrix),
                void 0 !== t.skeleton && (o.skeleton = t.skeleton);
              break;
            case "Mesh":
              (s = l(t.geometry)), (a = c(t.material)), (o = new xo(s, a));
              break;
            case "InstancedMesh":
              (s = l(t.geometry)), (a = c(t.material));
              const e = t.count,
                n = t.instanceMatrix,
                i = t.instanceColor;
              (o = new pc(s, a, e)),
                (o.instanceMatrix = new Nr(new Float32Array(n.array), 16)),
                void 0 !== i &&
                  (o.instanceColor = new Nr(
                    new Float32Array(i.array),
                    i.itemSize
                  ));
              break;
            case "LOD":
              o = new Kl();
              break;
            case "Line":
              o = new bc(l(t.geometry), c(t.material));
              break;
            case "LineLoop":
              o = new Sc(l(t.geometry), c(t.material));
              break;
            case "LineSegments":
              o = new Mc(l(t.geometry), c(t.material));
              break;
            case "PointCloud":
            case "Points":
              o = new Rc(l(t.geometry), c(t.material));
              break;
            case "Sprite":
              o = new Xl(c(t.material));
              break;
            case "Group":
              o = new bl();
              break;
            case "Bone":
              o = new rc();
              break;
            default:
              o = new lr();
          }
          if (
            ((o.uuid = t.uuid),
            void 0 !== t.name && (o.name = t.name),
            void 0 !== t.matrix
              ? (o.matrix.fromArray(t.matrix),
                void 0 !== t.matrixAutoUpdate &&
                  (o.matrixAutoUpdate = t.matrixAutoUpdate),
                o.matrixAutoUpdate &&
                  o.matrix.decompose(o.position, o.quaternion, o.scale))
              : (void 0 !== t.position && o.position.fromArray(t.position),
                void 0 !== t.rotation && o.rotation.fromArray(t.rotation),
                void 0 !== t.quaternion && o.quaternion.fromArray(t.quaternion),
                void 0 !== t.scale && o.scale.fromArray(t.scale)),
            void 0 !== t.castShadow && (o.castShadow = t.castShadow),
            void 0 !== t.receiveShadow && (o.receiveShadow = t.receiveShadow),
            t.shadow &&
              (void 0 !== t.shadow.bias && (o.shadow.bias = t.shadow.bias),
              void 0 !== t.shadow.normalBias &&
                (o.shadow.normalBias = t.shadow.normalBias),
              void 0 !== t.shadow.radius && (o.shadow.radius = t.shadow.radius),
              void 0 !== t.shadow.mapSize &&
                o.shadow.mapSize.fromArray(t.shadow.mapSize),
              void 0 !== t.shadow.camera &&
                (o.shadow.camera = this.parseObject(t.shadow.camera))),
            void 0 !== t.visible && (o.visible = t.visible),
            void 0 !== t.frustumCulled && (o.frustumCulled = t.frustumCulled),
            void 0 !== t.renderOrder && (o.renderOrder = t.renderOrder),
            void 0 !== t.userData && (o.userData = t.userData),
            void 0 !== t.layers && (o.layers.mask = t.layers),
            void 0 !== t.children)
          ) {
            const s = t.children;
            for (let t = 0; t < s.length; t++)
              o.add(this.parseObject(s[t], e, n, i, r));
          }
          if (void 0 !== t.animations) {
            const e = t.animations;
            for (let t = 0; t < e.length; t++) {
              const n = e[t];
              o.animations.push(r[n]);
            }
          }
          if ("LOD" === t.type) {
            void 0 !== t.autoUpdate && (o.autoUpdate = t.autoUpdate);
            const e = t.levels;
            for (let t = 0; t < e.length; t++) {
              const n = e[t],
                i = o.getObjectByProperty("uuid", n.object);
              void 0 !== i && o.addLevel(i, n.distance);
            }
          }
          return o;
        }
        bindSkeletons(t, e) {
          0 !== Object.keys(e).length &&
            t.traverse(function (t) {
              if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                const n = e[t.skeleton];
                void 0 === n
                  ? console.warn(
                      "THREE.ObjectLoader: No skeleton found with UUID:",
                      t.skeleton
                    )
                  : t.bind(n, t.bindMatrix);
              }
            });
        }
        setTexturePath(t) {
          return (
            console.warn(
              "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
            ),
            this.setResourcePath(t)
          );
        }
      }
      const pd = {
          UVMapping: it,
          CubeReflectionMapping: rt,
          CubeRefractionMapping: ot,
          EquirectangularReflectionMapping: st,
          EquirectangularRefractionMapping: at,
          CubeUVReflectionMapping: lt,
          CubeUVRefractionMapping: ct,
        },
        fd = {
          RepeatWrapping: ut,
          ClampToEdgeWrapping: ht,
          MirroredRepeatWrapping: dt,
        },
        md = {
          NearestFilter: pt,
          NearestMipmapNearestFilter: ft,
          NearestMipmapLinearFilter: gt,
          LinearFilter: yt,
          LinearMipmapNearestFilter: xt,
          LinearMipmapLinearFilter: wt,
        };
      class gd extends Rh {
        constructor(t) {
          super(t),
            "undefined" == typeof createImageBitmap &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            "undefined" == typeof fetch &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(t) {
          return (this.options = t), this;
        }
        load(t, e, n, i) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          const r = this,
            o = Ah.get(t);
          if (void 0 !== o)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(o), r.manager.itemEnd(t);
              }, 0),
              o
            );
          const s = {};
          (s.credentials =
            "anonymous" === this.crossOrigin ? "same-origin" : "include"),
            (s.headers = this.requestHeader),
            fetch(t, s)
              .then(function (t) {
                return t.blob();
              })
              .then(function (t) {
                return createImageBitmap(
                  t,
                  Object.assign(r.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (n) {
                Ah.add(t, n), e && e(n), r.manager.itemEnd(t);
              })
              .catch(function (e) {
                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
              }),
            r.manager.itemStart(t);
        }
      }
      gd.prototype.isImageBitmapLoader = !0;
      class vd {
        constructor() {
          (this.type = "ShapePath"),
            (this.color = new Cr()),
            (this.subPaths = []),
            (this.currentPath = null);
        }
        moveTo(t, e) {
          return (
            (this.currentPath = new Hh()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e),
            this
          );
        }
        lineTo(t, e) {
          return this.currentPath.lineTo(t, e), this;
        }
        quadraticCurveTo(t, e, n, i) {
          return this.currentPath.quadraticCurveTo(t, e, n, i), this;
        }
        bezierCurveTo(t, e, n, i, r, o) {
          return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this;
        }
        splineThru(t) {
          return this.currentPath.splineThru(t), this;
        }
        toShapes(t, e) {
          function n(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n],
                r = new Uh();
              (r.curves = i.curves), e.push(r);
            }
            return e;
          }
          function i(t, e) {
            const n = e.length;
            let i = !1;
            for (let r = n - 1, o = 0; o < n; r = o++) {
              let n = e[r],
                s = e[o],
                a = s.x - n.x,
                l = s.y - n.y;
              if (Math.abs(l) > Number.EPSILON) {
                if (
                  (l < 0 && ((n = e[o]), (a = -a), (s = e[r]), (l = -l)),
                  t.y < n.y || t.y > s.y)
                )
                  continue;
                if (t.y === n.y) {
                  if (t.x === n.x) return !0;
                } else {
                  const e = l * (t.x - n.x) - a * (t.y - n.y);
                  if (0 === e) return !0;
                  if (e < 0) continue;
                  i = !i;
                }
              } else {
                if (t.y !== n.y) continue;
                if ((s.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= s.x))
                  return !0;
              }
            }
            return i;
          }
          const r = Du.isClockWise,
            o = this.subPaths;
          if (0 === o.length) return [];
          if (!0 === e) return n(o);
          let s, a, l;
          const c = [];
          if (1 === o.length)
            return (
              (a = o[0]), (l = new Uh()), (l.curves = a.curves), c.push(l), c
            );
          let u = !r(o[0].getPoints());
          u = t ? !u : u;
          const h = [],
            d = [];
          let p,
            f,
            m = [],
            g = 0;
          (d[g] = void 0), (m[g] = []);
          for (let e = 0, n = o.length; e < n; e++)
            (a = o[e]),
              (p = a.getPoints()),
              (s = r(p)),
              (s = t ? !s : s),
              s
                ? (!u && d[g] && g++,
                  (d[g] = { s: new Uh(), p }),
                  (d[g].s.curves = a.curves),
                  u && g++,
                  (m[g] = []))
                : m[g].push({ h: a, p: p[0] });
          if (!d[0]) return n(o);
          if (d.length > 1) {
            let t = !1;
            const e = [];
            for (let t = 0, e = d.length; t < e; t++) h[t] = [];
            for (let n = 0, r = d.length; n < r; n++) {
              const r = m[n];
              for (let o = 0; o < r.length; o++) {
                const s = r[o];
                let a = !0;
                for (let r = 0; r < d.length; r++)
                  i(s.p, d[r].p) &&
                    (n !== r && e.push({ froms: n, tos: r, hole: o }),
                    a ? ((a = !1), h[r].push(s)) : (t = !0));
                a && h[n].push(s);
              }
            }
            e.length > 0 && (t || (m = h));
          }
          for (let t = 0, e = d.length; t < e; t++) {
            (l = d[t].s), c.push(l), (f = m[t]);
            for (let t = 0, e = f.length; t < e; t++) l.holes.push(f[t].h);
          }
          return c;
        }
      }
      class yd {
        constructor(t) {
          (this.type = "Font"), (this.data = t);
        }
        generateShapes(t, e = 100) {
          const n = [],
            i = (function (t, e, n) {
              const i = Array.from(t),
                r = e / n.resolution,
                o =
                  (n.boundingBox.yMax -
                    n.boundingBox.yMin +
                    n.underlineThickness) *
                  r,
                s = [];
              let a = 0,
                l = 0;
              for (let t = 0; t < i.length; t++) {
                const e = i[t];
                if ("\n" === e) (a = 0), (l -= o);
                else {
                  const t = xd(e, r, a, l, n);
                  (a += t.offsetX), s.push(t.path);
                }
              }
              return s;
            })(t, e, this.data);
          for (let t = 0, e = i.length; t < e; t++)
            Array.prototype.push.apply(n, i[t].toShapes());
          return n;
        }
      }
      function xd(t, e, n, i, r) {
        const o = r.glyphs[t] || r.glyphs["?"];
        if (!o)
          return void console.error(
            'THREE.Font: character "' +
              t +
              '" does not exists in font family ' +
              r.familyName +
              "."
          );
        const s = new vd();
        let a, l, c, u, h, d, p, f;
        if (o.o) {
          const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
          for (let r = 0, o = t.length; r < o; )
            switch (t[r++]) {
              case "m":
                (a = t[r++] * e + n), (l = t[r++] * e + i), s.moveTo(a, l);
                break;
              case "l":
                (a = t[r++] * e + n), (l = t[r++] * e + i), s.lineTo(a, l);
                break;
              case "q":
                (c = t[r++] * e + n),
                  (u = t[r++] * e + i),
                  (h = t[r++] * e + n),
                  (d = t[r++] * e + i),
                  s.quadraticCurveTo(h, d, c, u);
                break;
              case "b":
                (c = t[r++] * e + n),
                  (u = t[r++] * e + i),
                  (h = t[r++] * e + n),
                  (d = t[r++] * e + i),
                  (p = t[r++] * e + n),
                  (f = t[r++] * e + i),
                  s.bezierCurveTo(h, d, p, f, c, u);
            }
        }
        return { offsetX: o.ha * e, path: s };
      }
      yd.prototype.isFont = !0;
      class bd extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            o = new Nh(this.manager);
          o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(
              t,
              function (t) {
                let n;
                try {
                  n = JSON.parse(t);
                } catch (e) {
                  console.warn(
                    "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                  ),
                    (n = JSON.parse(t.substring(65, t.length - 2)));
                }
                const i = r.parse(n);
                e && e(i);
              },
              n,
              i
            );
        }
        parse(t) {
          return new yd(t);
        }
      }
      let wd;
      const _d = {
        getContext: function () {
          return (
            void 0 === wd &&
              (wd = new (window.AudioContext || window.webkitAudioContext)()),
            wd
          );
        },
        setContext: function (t) {
          wd = t;
        },
      };
      class Md extends Rh {
        constructor(t) {
          super(t);
        }
        load(t, e, n, i) {
          const r = this,
            o = new Nh(this.manager);
          o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              t,
              function (n) {
                try {
                  const t = n.slice(0);
                  _d.getContext().decodeAudioData(t, function (t) {
                    e(t);
                  });
                } catch (e) {
                  i ? i(e) : console.error(e), r.manager.itemError(t);
                }
              },
              n,
              i
            );
        }
      }
      class Sd extends sd {
        constructor(t, e, n = 1) {
          super(void 0, n);
          const i = new Cr().set(t),
            r = new Cr().set(e),
            o = new si(i.r, i.g, i.b),
            s = new si(r.r, r.g, r.b),
            a = Math.sqrt(Math.PI),
            l = a * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),
            this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(l);
        }
      }
      Sd.prototype.isHemisphereLightProbe = !0;
      class Ed extends sd {
        constructor(t, e = 1) {
          super(void 0, e);
          const n = new Cr().set(t);
          this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      Ed.prototype.isAmbientLightProbe = !0;
      const Td = new ki(),
        Ad = new ki();
      class Cd {
        constructor() {
          (this.type = "StereoCamera"),
            (this.aspect = 1),
            (this.eyeSep = 0.064),
            (this.cameraL = new Ao()),
            this.cameraL.layers.enable(1),
            (this.cameraL.matrixAutoUpdate = !1),
            (this.cameraR = new Ao()),
            this.cameraR.layers.enable(2),
            (this.cameraR.matrixAutoUpdate = !1),
            (this._cache = {
              focus: null,
              fov: null,
              aspect: null,
              near: null,
              far: null,
              zoom: null,
              eyeSep: null,
            });
        }
        update(t) {
          const e = this._cache;
          if (
            e.focus !== t.focus ||
            e.fov !== t.fov ||
            e.aspect !== t.aspect * this.aspect ||
            e.near !== t.near ||
            e.far !== t.far ||
            e.zoom !== t.zoom ||
            e.eyeSep !== this.eyeSep
          ) {
            (e.focus = t.focus),
              (e.fov = t.fov),
              (e.aspect = t.aspect * this.aspect),
              (e.near = t.near),
              (e.far = t.far),
              (e.zoom = t.zoom),
              (e.eyeSep = this.eyeSep);
            const n = t.projectionMatrix.clone(),
              i = e.eyeSep / 2,
              r = (i * e.near) / e.focus,
              o = (e.near * Math.tan(Fn * e.fov * 0.5)) / e.zoom;
            let s, a;
            (Ad.elements[12] = -i),
              (Td.elements[12] = i),
              (s = -o * e.aspect + r),
              (a = o * e.aspect + r),
              (n.elements[0] = (2 * e.near) / (a - s)),
              (n.elements[8] = (a + s) / (a - s)),
              this.cameraL.projectionMatrix.copy(n),
              (s = -o * e.aspect - r),
              (a = o * e.aspect - r),
              (n.elements[0] = (2 * e.near) / (a - s)),
              (n.elements[8] = (a + s) / (a - s)),
              this.cameraR.projectionMatrix.copy(n);
          }
          this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Ad),
            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Td);
        }
      }
      class Ld {
        constructor(t = !0) {
          (this.autoStart = t),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = Rd()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let t = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const e = Rd();
            (t = (e - this.oldTime) / 1e3),
              (this.oldTime = e),
              (this.elapsedTime += t);
          }
          return t;
        }
      }
      function Rd() {
        return ("undefined" == typeof performance ? Date : performance).now();
      }
      const Pd = new si(),
        Nd = new oi(),
        Id = new si(),
        Bd = new si();
      class Od extends lr {
        constructor() {
          super(),
            (this.type = "AudioListener"),
            (this.context = _d.getContext()),
            (this.gain = this.context.createGain()),
            this.gain.connect(this.context.destination),
            (this.filter = null),
            (this.timeDelta = 0),
            (this._clock = new Ld());
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          return (
            null !== this.filter &&
              (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination),
              this.gain.connect(this.context.destination),
              (this.filter = null)),
            this
          );
        }
        getFilter() {
          return this.filter;
        }
        setFilter(t) {
          return (
            null !== this.filter
              ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination))
              : this.gain.disconnect(this.context.destination),
            (this.filter = t),
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
          );
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(t) {
          return (
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
            this
          );
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t);
          const e = this.context.listener,
            n = this.up;
          if (
            ((this.timeDelta = this._clock.getDelta()),
            this.matrixWorld.decompose(Pd, Nd, Id),
            Bd.set(0, 0, -1).applyQuaternion(Nd),
            e.positionX)
          ) {
            const t = this.context.currentTime + this.timeDelta;
            e.positionX.linearRampToValueAtTime(Pd.x, t),
              e.positionY.linearRampToValueAtTime(Pd.y, t),
              e.positionZ.linearRampToValueAtTime(Pd.z, t),
              e.forwardX.linearRampToValueAtTime(Bd.x, t),
              e.forwardY.linearRampToValueAtTime(Bd.y, t),
              e.forwardZ.linearRampToValueAtTime(Bd.z, t),
              e.upX.linearRampToValueAtTime(n.x, t),
              e.upY.linearRampToValueAtTime(n.y, t),
              e.upZ.linearRampToValueAtTime(n.z, t);
          } else
            e.setPosition(Pd.x, Pd.y, Pd.z),
              e.setOrientation(Bd.x, Bd.y, Bd.z, n.x, n.y, n.z);
        }
      }
      class Dd extends lr {
        constructor(t) {
          super(),
            (this.type = "Audio"),
            (this.listener = t),
            (this.context = t.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(t.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = t),
            this.connect(),
            this
          );
        }
        setMediaElementSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(t)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(t)),
            this.connect(),
            this
          );
        }
        setBuffer(t) {
          return (
            (this.buffer = t),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(t = 0) {
          if (!0 === this.isPlaying)
            return void console.warn("THREE.Audio: Audio is already playing.");
          if (!1 === this.hasPlaybackControl)
            return void console.warn(
              "THREE.Audio: this Audio has no playback control."
            );
          this._startedAt = this.context.currentTime + t;
          const e = this.context.createBufferSource();
          return (
            (e.buffer = this.buffer),
            (e.loop = this.loop),
            (e.loopStart = this.loopStart),
            (e.loopEnd = this.loopEnd),
            (e.onended = this.onEnded.bind(this)),
            e.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = e),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (!1 !== this.hasPlaybackControl)
            return (
              !0 === this.isPlaying &&
                ((this._progress +=
                  Math.max(this.context.currentTime - this._startedAt, 0) *
                  this.playbackRate),
                !0 === this.loop &&
                  (this._progress =
                    this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        stop() {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this._progress = 0),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(t) {
          return (
            t || (t = []),
            !0 === this._connected
              ? (this.disconnect(), (this.filters = t.slice()), this.connect())
              : (this.filters = t.slice()),
            this
          );
        }
        setDetune(t) {
          if (((this.detune = t), void 0 !== this.source.detune))
            return (
              !0 === this.isPlaying &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(t) {
          return this.setFilters(t ? [t] : []);
        }
        setPlaybackRate(t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.playbackRate = t),
              !0 === this.isPlaying &&
                this.source.playbackRate.setTargetAtTime(
                  this.playbackRate,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.loop = t),
              !0 === this.isPlaying && (this.source.loop = this.loop),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        setLoopStart(t) {
          return (this.loopStart = t), this;
        }
        setLoopEnd(t) {
          return (this.loopEnd = t), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(t) {
          return (
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
            this
          );
        }
      }
      const kd = new si(),
        Fd = new oi(),
        zd = new si(),
        Hd = new si();
      class Ud extends Dd {
        constructor(t) {
          super(t),
            (this.panner = this.context.createPanner()),
            (this.panner.panningModel = "HRTF"),
            this.panner.connect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(t) {
          return (this.panner.refDistance = t), this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(t) {
          return (this.panner.rolloffFactor = t), this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(t) {
          return (this.panner.distanceModel = t), this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(t) {
          return (this.panner.maxDistance = t), this;
        }
        setDirectionalCone(t, e, n) {
          return (
            (this.panner.coneInnerAngle = t),
            (this.panner.coneOuterAngle = e),
            (this.panner.coneOuterGain = n),
            this
          );
        }
        updateMatrixWorld(t) {
          if (
            (super.updateMatrixWorld(t),
            !0 === this.hasPlaybackControl && !1 === this.isPlaying)
          )
            return;
          this.matrixWorld.decompose(kd, Fd, zd),
            Hd.set(0, 0, 1).applyQuaternion(Fd);
          const e = this.panner;
          if (e.positionX) {
            const t = this.context.currentTime + this.listener.timeDelta;
            e.positionX.linearRampToValueAtTime(kd.x, t),
              e.positionY.linearRampToValueAtTime(kd.y, t),
              e.positionZ.linearRampToValueAtTime(kd.z, t),
              e.orientationX.linearRampToValueAtTime(Hd.x, t),
              e.orientationY.linearRampToValueAtTime(Hd.y, t),
              e.orientationZ.linearRampToValueAtTime(Hd.z, t);
          } else
            e.setPosition(kd.x, kd.y, kd.z), e.setOrientation(Hd.x, Hd.y, Hd.z);
        }
      }
      class Vd {
        constructor(t, e = 2048) {
          (this.analyser = t.context.createAnalyser()),
            (this.analyser.fftSize = e),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            t.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let t = 0;
          const e = this.getFrequencyData();
          for (let n = 0; n < e.length; n++) t += e[n];
          return t / e.length;
        }
      }
      class Gd {
        constructor(t, e, n) {
          let i, r, o;
          switch (((this.binding = t), (this.valueSize = n), e)) {
            case "quaternion":
              (i = this._slerp),
                (r = this._slerpAdditive),
                (o = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(6 * n)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (r = this._select),
                (o = this._setAdditiveIdentityOther),
                (this.buffer = new Array(5 * n));
              break;
            default:
              (i = this._lerp),
                (r = this._lerpAdditive),
                (o = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(5 * n));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = o),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(t, e) {
          const n = this.buffer,
            i = this.valueSize,
            r = t * i + i;
          let o = this.cumulativeWeight;
          if (0 === o) {
            for (let t = 0; t !== i; ++t) n[r + t] = n[t];
            o = e;
          } else {
            o += e;
            const t = e / o;
            this._mixBufferRegion(n, r, 0, t, i);
          }
          this.cumulativeWeight = o;
        }
        accumulateAdditive(t) {
          const e = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, i, 0, t, n),
            (this.cumulativeWeightAdditive += t);
        }
        apply(t) {
          const e = this.valueSize,
            n = this.buffer,
            i = t * e + e,
            r = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            s = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const t = e * this._origIndex;
            this._mixBufferRegion(n, i, t, 1 - r, e);
          }
          o > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
          for (let t = e, r = e + e; t !== r; ++t)
            if (n[t] !== n[t + e]) {
              s.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const t = this.binding,
            e = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          t.getValue(e, i);
          for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const t = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t);
        }
        _setAdditiveIdentityNumeric() {
          const t = this._addIndex * this.valueSize,
            e = t + this.valueSize;
          for (let n = t; n < e; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const t = this._origIndex * this.valueSize,
            e = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[e + n] = this.buffer[t + n];
        }
        _select(t, e, n, i, r) {
          if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
        }
        _slerp(t, e, n, i) {
          oi.slerpFlat(t, e, t, e, t, n, i);
        }
        _slerpAdditive(t, e, n, i, r) {
          const o = this._workIndex * r;
          oi.multiplyQuaternionsFlat(t, o, t, e, t, n),
            oi.slerpFlat(t, e, t, e, t, o, i);
        }
        _lerp(t, e, n, i, r) {
          const o = 1 - i;
          for (let s = 0; s !== r; ++s) {
            const r = e + s;
            t[r] = t[r] * o + t[n + s] * i;
          }
        }
        _lerpAdditive(t, e, n, i, r) {
          for (let o = 0; o !== r; ++o) {
            const r = e + o;
            t[r] = t[r] + t[n + o] * i;
          }
        }
      }
      const jd = new RegExp("[\\[\\]\\.:\\/]", "g"),
        Wd = "[^\\[\\]\\.:\\/]",
        qd = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        Xd = /((?:WC+[\/:])*)/.source.replace("WC", Wd),
        Yd = /(WCOD+)?/.source.replace("WCOD", qd),
        Zd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Wd),
        Jd = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Wd),
        Kd = new RegExp("^" + Xd + Yd + Zd + Jd + "$"),
        Qd = ["material", "materials", "bones"];
      class $d {
        constructor(t, e, n) {
          (this.path = e),
            (this.parsedPath = n || $d.parseTrackName(e)),
            (this.node = $d.findNode(t, this.parsedPath.nodeName) || t),
            (this.rootNode = t),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(t, e, n) {
          return t && t.isAnimationObjectGroup
            ? new $d.Composite(t, e, n)
            : new $d(t, e, n);
        }
        static sanitizeNodeName(t) {
          return t.replace(/\s/g, "_").replace(jd, "");
        }
        static parseTrackName(t) {
          const e = Kd.exec(t);
          if (!e)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
          const n = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (void 0 !== i && -1 !== i) {
            const t = n.nodeName.substring(i + 1);
            -1 !== Qd.indexOf(t) &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + t
            );
          return n;
        }
        static findNode(t, e) {
          if (
            !e ||
            "" === e ||
            "." === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t;
          if (t.skeleton) {
            const n = t.skeleton.getBoneByName(e);
            if (void 0 !== n) return n;
          }
          if (t.children) {
            const n = function (t) {
                for (let i = 0; i < t.length; i++) {
                  const r = t[i];
                  if (r.name === e || r.uuid === e) return r;
                  const o = n(r.children);
                  if (o) return o;
                }
                return null;
              },
              i = n(t.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
          t[e] = this.node[this.propertyName];
        }
        _getValue_array(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
        }
        _getValue_arrayElement(t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(t, e) {
          this.resolvedProperty.toArray(t, e);
        }
        _setValue_direct(t, e) {
          this.targetObject[this.propertyName] = t[e];
        }
        _setValue_direct_setNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
        }
        _setValue_array_setNeedsUpdate(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(t, e) {
          this.resolvedProperty.fromArray(t, e);
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(t, e) {
          this.bind(), this.getValue(t, e);
        }
        _setValue_unbound(t, e) {
          this.bind(), this.setValue(t, e);
        }
        bind() {
          let t = this.node;
          const e = this.parsedPath,
            n = e.objectName,
            i = e.propertyName;
          let r = e.propertyIndex;
          if (
            (t ||
              ((t = $d.findNode(this.rootNode, e.nodeName) || this.rootNode),
              (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !t)
          )
            return void console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
          if (n) {
            let i = e.objectIndex;
            switch (n) {
              case "materials":
                if (!t.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!t.material.materials)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                t = t.material.materials;
                break;
              case "bones":
                if (!t.skeleton)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                t = t.skeleton.bones;
                for (let e = 0; e < t.length; e++)
                  if (t[e].name === i) {
                    i = e;
                    break;
                  }
                break;
              default:
                if (void 0 === t[n])
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                t = t[n];
            }
            if (void 0 !== i) {
              if (void 0 === t[i])
                return void console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  t
                );
              t = t[i];
            }
          }
          const o = t[i];
          if (void 0 === o) {
            const n = e.nodeName;
            return void console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                n +
                "." +
                i +
                " but it wasn't found.",
              t
            );
          }
          let s = this.Versioning.None;
          (this.targetObject = t),
            void 0 !== t.needsUpdate
              ? (s = this.Versioning.NeedsUpdate)
              : void 0 !== t.matrixWorldNeedsUpdate &&
                (s = this.Versioning.MatrixWorldNeedsUpdate);
          let a = this.BindingType.Direct;
          if (void 0 !== r) {
            if ("morphTargetInfluences" === i) {
              if (!t.geometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
              if (!t.geometry.isBufferGeometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                  this
                );
              if (!t.geometry.morphAttributes)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
              void 0 !== t.morphTargetDictionary[r] &&
                (r = t.morphTargetDictionary[r]);
            }
            (a = this.BindingType.ArrayElement),
              (this.resolvedProperty = o),
              (this.propertyIndex = r);
          } else
            void 0 !== o.fromArray && void 0 !== o.toArray
              ? ((a = this.BindingType.HasFromToArray),
                (this.resolvedProperty = o))
              : Array.isArray(o)
              ? ((a = this.BindingType.EntireArray),
                (this.resolvedProperty = o))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[a]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[a][s]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      ($d.Composite = class {
        constructor(t, e, n) {
          const i = n || $d.parseTrackName(e);
          (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
        }
        getValue(t, e) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          void 0 !== i && i.getValue(t, e);
        }
        setValue(t, e) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(t, e);
        }
        bind() {
          const t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, n = t.length;
            e !== n;
            ++e
          )
            t[e].bind();
        }
        unbind() {
          const t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, n = t.length;
            e !== n;
            ++e
          )
            t[e].unbind();
        }
      }),
        ($d.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        ($d.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        ($d.prototype.GetterByBindingType = [
          $d.prototype._getValue_direct,
          $d.prototype._getValue_array,
          $d.prototype._getValue_arrayElement,
          $d.prototype._getValue_toArray,
        ]),
        ($d.prototype.SetterByBindingTypeAndVersioning = [
          [
            $d.prototype._setValue_direct,
            $d.prototype._setValue_direct_setNeedsUpdate,
            $d.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            $d.prototype._setValue_array,
            $d.prototype._setValue_array_setNeedsUpdate,
            $d.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            $d.prototype._setValue_arrayElement,
            $d.prototype._setValue_arrayElement_setNeedsUpdate,
            $d.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            $d.prototype._setValue_fromArray,
            $d.prototype._setValue_fromArray_setNeedsUpdate,
            $d.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      class tp {
        constructor() {
          (this.uuid = Hn()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
          const t = {};
          this._indicesByUUID = t;
          for (let e = 0, n = arguments.length; e !== n; ++e)
            t[arguments[e].uuid] = e;
          (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
          const e = this;
          this.stats = {
            objects: {
              get total() {
                return e._objects.length;
              },
              get inUse() {
                return this.total - e.nCachedObjects_;
              },
            },
            get bindingsPerObject() {
              return e._bindings.length;
            },
          };
        }
        add() {
          const t = this._objects,
            e = this._indicesByUUID,
            n = this._paths,
            i = this._parsedPaths,
            r = this._bindings,
            o = r.length;
          let s,
            a = t.length,
            l = this.nCachedObjects_;
          for (let c = 0, u = arguments.length; c !== u; ++c) {
            const u = arguments[c],
              h = u.uuid;
            let d = e[h];
            if (void 0 === d) {
              (d = a++), (e[h] = d), t.push(u);
              for (let t = 0, e = o; t !== e; ++t)
                r[t].push(new $d(u, n[t], i[t]));
            } else if (d < l) {
              s = t[d];
              const a = --l,
                c = t[a];
              (e[c.uuid] = d), (t[d] = c), (e[h] = a), (t[a] = u);
              for (let t = 0, e = o; t !== e; ++t) {
                const e = r[t],
                  o = e[a];
                let s = e[d];
                (e[d] = o),
                  void 0 === s && (s = new $d(u, n[t], i[t])),
                  (e[a] = s);
              }
            } else
              t[d] !== s &&
                console.error(
                  "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                );
          }
          this.nCachedObjects_ = l;
        }
        remove() {
          const t = this._objects,
            e = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_;
          for (let o = 0, s = arguments.length; o !== s; ++o) {
            const s = arguments[o],
              a = s.uuid,
              l = e[a];
            if (void 0 !== l && l >= r) {
              const o = r++,
                c = t[o];
              (e[c.uuid] = l), (t[l] = c), (e[a] = o), (t[o] = s);
              for (let t = 0, e = i; t !== e; ++t) {
                const e = n[t],
                  i = e[o],
                  r = e[l];
                (e[l] = i), (e[o] = r);
              }
            }
          }
          this.nCachedObjects_ = r;
        }
        uncache() {
          const t = this._objects,
            e = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_,
            o = t.length;
          for (let s = 0, a = arguments.length; s !== a; ++s) {
            const a = arguments[s].uuid,
              l = e[a];
            if (void 0 !== l)
              if ((delete e[a], l < r)) {
                const s = --r,
                  a = t[s],
                  c = --o,
                  u = t[c];
                (e[a.uuid] = l),
                  (t[l] = a),
                  (e[u.uuid] = s),
                  (t[s] = u),
                  t.pop();
                for (let t = 0, e = i; t !== e; ++t) {
                  const e = n[t],
                    i = e[s],
                    r = e[c];
                  (e[l] = i), (e[s] = r), e.pop();
                }
              } else {
                const r = --o,
                  s = t[r];
                r > 0 && (e[s.uuid] = l), (t[l] = s), t.pop();
                for (let t = 0, e = i; t !== e; ++t) {
                  const e = n[t];
                  (e[l] = e[r]), e.pop();
                }
              }
          }
          this.nCachedObjects_ = r;
        }
        subscribe_(t, e) {
          const n = this._bindingsIndicesByPath;
          let i = n[t];
          const r = this._bindings;
          if (void 0 !== i) return r[i];
          const o = this._paths,
            s = this._parsedPaths,
            a = this._objects,
            l = a.length,
            c = this.nCachedObjects_,
            u = new Array(l);
          (i = r.length), (n[t] = i), o.push(t), s.push(e), r.push(u);
          for (let n = c, i = a.length; n !== i; ++n) {
            const i = a[n];
            u[n] = new $d(i, t, e);
          }
          return u;
        }
        unsubscribe_(t) {
          const e = this._bindingsIndicesByPath,
            n = e[t];
          if (void 0 !== n) {
            const i = this._paths,
              r = this._parsedPaths,
              o = this._bindings,
              s = o.length - 1,
              a = o[s];
            (e[t[s]] = n),
              (o[n] = a),
              o.pop(),
              (r[n] = r[s]),
              r.pop(),
              (i[n] = i[s]),
              i.pop();
          }
        }
      }
      tp.prototype.isAnimationObjectGroup = !0;
      class ep {
        constructor(t, e, n = null, i = e.blendMode) {
          (this._mixer = t),
            (this._clip = e),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = e.tracks,
            o = r.length,
            s = new Array(o),
            a = { endingStart: Ue, endingEnd: Ue };
          for (let t = 0; t !== o; ++t) {
            const e = r[t].createInterpolant(null);
            (s[t] = e), (e.settings = a);
          }
          (this._interpolantSettings = a),
            (this._interpolants = s),
            (this._propertyBindings = new Array(o)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = De),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(t) {
          return (this._startTime = t), this;
        }
        setLoop(t, e) {
          return (this.loop = t), (this.repetitions = e), this;
        }
        setEffectiveWeight(t) {
          return (
            (this.weight = t),
            (this._effectiveWeight = this.enabled ? t : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(t) {
          return this._scheduleFading(t, 0, 1);
        }
        fadeOut(t) {
          return this._scheduleFading(t, 1, 0);
        }
        crossFadeFrom(t, e, n) {
          if ((t.fadeOut(e), this.fadeIn(e), n)) {
            const n = this._clip.duration,
              i = t._clip.duration,
              r = i / n,
              o = n / i;
            t.warp(1, r, e), this.warp(o, 1, e);
          }
          return this;
        }
        crossFadeTo(t, e, n) {
          return t.crossFadeFrom(this, e, n);
        }
        stopFading() {
          const t = this._weightInterpolant;
          return (
            null !== t &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        }
        setEffectiveTimeScale(t) {
          return (
            (this.timeScale = t),
            (this._effectiveTimeScale = this.paused ? 0 : t),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping();
        }
        syncWith(t) {
          return (
            (this.time = t.time),
            (this.timeScale = t.timeScale),
            this.stopWarping()
          );
        }
        halt(t) {
          return this.warp(this._effectiveTimeScale, 0, t);
        }
        warp(t, e, n) {
          const i = this._mixer,
            r = i.time,
            o = this.timeScale;
          let s = this._timeScaleInterpolant;
          null === s &&
            ((s = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = s));
          const a = s.parameterPositions,
            l = s.sampleValues;
          return (
            (a[0] = r), (a[1] = r + n), (l[0] = t / o), (l[1] = e / o), this
          );
        }
        stopWarping() {
          const t = this._timeScaleInterpolant;
          return (
            null !== t &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(t, e, n, i) {
          if (!this.enabled) return void this._updateWeight(t);
          const r = this._startTime;
          if (null !== r) {
            const i = (t - r) * n;
            if (i < 0 || 0 === n) return;
            (this._startTime = null), (e = n * i);
          }
          e *= this._updateTimeScale(t);
          const o = this._updateTime(e),
            s = this._updateWeight(t);
          if (s > 0) {
            const t = this._interpolants,
              e = this._propertyBindings;
            switch (this.blendMode) {
              case We:
                for (let n = 0, i = t.length; n !== i; ++n)
                  t[n].evaluate(o), e[n].accumulateAdditive(s);
                break;
              case je:
              default:
                for (let n = 0, r = t.length; n !== r; ++n)
                  t[n].evaluate(o), e[n].accumulate(i, s);
            }
          }
        }
        _updateWeight(t) {
          let e = 0;
          if (this.enabled) {
            e = this.weight;
            const n = this._weightInterpolant;
            if (null !== n) {
              const i = n.evaluate(t)[0];
              (e *= i),
                t > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === i && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = e), e;
        }
        _updateTimeScale(t) {
          let e = 0;
          if (!this.paused) {
            e = this.timeScale;
            const n = this._timeScaleInterpolant;
            null !== n &&
              ((e *= n.evaluate(t)[0]),
              t > n.parameterPositions[1] &&
                (this.stopWarping(),
                0 === e ? (this.paused = !0) : (this.timeScale = e)));
          }
          return (this._effectiveTimeScale = e), e;
        }
        _updateTime(t) {
          const e = this._clip.duration,
            n = this.loop;
          let i = this.time + t,
            r = this._loopCount;
          const o = n === ke;
          if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;
          if (n === Oe) {
            -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            t: {
              if (i >= e) i = e;
              else {
                if (!(i < 0)) {
                  this.time = i;
                  break t;
                }
                i = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: t < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === r &&
                (t >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, o))
                  : this._setEndings(0 === this.repetitions, !0, o)),
              i >= e || i < 0)
            ) {
              const n = Math.floor(i / e);
              (i -= e * n), (r += Math.abs(n));
              const s = this.repetitions - r;
              if (s <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = t > 0 ? e : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1,
                  });
              else {
                if (1 === s) {
                  const e = t < 0;
                  this._setEndings(e, !e, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: n,
                  });
              }
            } else this.time = i;
            if (o && 1 == (1 & r)) return e - i;
          }
          return i;
        }
        _setEndings(t, e, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = Ve), (i.endingEnd = Ve))
            : ((i.endingStart = t ? (this.zeroSlopeAtStart ? Ve : Ue) : Ge),
              (i.endingEnd = e ? (this.zeroSlopeAtEnd ? Ve : Ue) : Ge));
        }
        _scheduleFading(t, e, n) {
          const i = this._mixer,
            r = i.time;
          let o = this._weightInterpolant;
          null === o &&
            ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
          const s = o.parameterPositions,
            a = o.sampleValues;
          return (s[0] = r), (a[0] = e), (s[1] = r + t), (a[1] = n), this;
        }
      }
      class np extends On {
        constructor(t) {
          super(),
            (this._root = t),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(t, e) {
          const n = t._localRoot || this._root,
            i = t._clip.tracks,
            r = i.length,
            o = t._propertyBindings,
            s = t._interpolants,
            a = n.uuid,
            l = this._bindingsByRootAndName;
          let c = l[a];
          void 0 === c && ((c = {}), (l[a] = c));
          for (let t = 0; t !== r; ++t) {
            const r = i[t],
              l = r.name;
            let u = c[l];
            if (void 0 !== u) o[t] = u;
            else {
              if (((u = o[t]), void 0 !== u)) {
                null === u._cacheIndex &&
                  (++u.referenceCount, this._addInactiveBinding(u, a, l));
                continue;
              }
              const i = e && e._propertyBindings[t].binding.parsedPath;
              (u = new Gd(
                $d.create(n, l, i),
                r.ValueTypeName,
                r.getValueSize()
              )),
                ++u.referenceCount,
                this._addInactiveBinding(u, a, l),
                (o[t] = u);
            }
            s[t].resultBuffer = u.buffer;
          }
        }
        _activateAction(t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              const e = (t._localRoot || this._root).uuid,
                n = t._clip.uuid,
                i = this._actionsByClip[n];
              this._bindAction(t, i && i.knownActions[0]),
                this._addInactiveAction(t, n, e);
            }
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 == n.useCount++ &&
                (this._lendBinding(n), n.saveOriginalState());
            }
            this._lendAction(t);
          }
        }
        _deactivateAction(t) {
          if (this._isActiveAction(t)) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 == --n.useCount &&
                (n.restoreOriginalState(), this._takeBackBinding(n));
            }
            this._takeBackAction(t);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const t = this;
          this.stats = {
            actions: {
              get total() {
                return t._actions.length;
              },
              get inUse() {
                return t._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return t._bindings.length;
              },
              get inUse() {
                return t._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length;
              },
              get inUse() {
                return t._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(t) {
          const e = t._cacheIndex;
          return null !== e && e < this._nActiveActions;
        }
        _addInactiveAction(t, e, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let o = r[e];
          if (void 0 === o)
            (o = { knownActions: [t], actionByRoot: {} }),
              (t._byClipCacheIndex = 0),
              (r[e] = o);
          else {
            const e = o.knownActions;
            (t._byClipCacheIndex = e.length), e.push(t);
          }
          (t._cacheIndex = i.length), i.push(t), (o.actionByRoot[n] = t);
        }
        _removeInactiveAction(t) {
          const e = this._actions,
            n = e[e.length - 1],
            i = t._cacheIndex;
          (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
          const r = t._clip.uuid,
            o = this._actionsByClip,
            s = o[r],
            a = s.knownActions,
            l = a[a.length - 1],
            c = t._byClipCacheIndex;
          (l._byClipCacheIndex = c),
            (a[c] = l),
            a.pop(),
            (t._byClipCacheIndex = null),
            delete s.actionByRoot[(t._localRoot || this._root).uuid],
            0 === a.length && delete o[r],
            this._removeInactiveBindingsForAction(t);
        }
        _removeInactiveBindingsForAction(t) {
          const e = t._propertyBindings;
          for (let t = 0, n = e.length; t !== n; ++t) {
            const n = e[t];
            0 == --n.referenceCount && this._removeInactiveBinding(n);
          }
        }
        _lendAction(t) {
          const e = this._actions,
            n = t._cacheIndex,
            i = this._nActiveActions++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        }
        _takeBackAction(t) {
          const e = this._actions,
            n = t._cacheIndex,
            i = --this._nActiveActions,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        }
        _addInactiveBinding(t, e, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let o = i[e];
          void 0 === o && ((o = {}), (i[e] = o)),
            (o[n] = t),
            (t._cacheIndex = r.length),
            r.push(t);
        }
        _removeInactiveBinding(t) {
          const e = this._bindings,
            n = t.binding,
            i = n.rootNode.uuid,
            r = n.path,
            o = this._bindingsByRootAndName,
            s = o[i],
            a = e[e.length - 1],
            l = t._cacheIndex;
          (a._cacheIndex = l),
            (e[l] = a),
            e.pop(),
            delete s[r],
            0 === Object.keys(s).length && delete o[i];
        }
        _lendBinding(t) {
          const e = this._bindings,
            n = t._cacheIndex,
            i = this._nActiveBindings++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        }
        _takeBackBinding(t) {
          const e = this._bindings,
            n = t._cacheIndex,
            i = --this._nActiveBindings,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        }
        _lendControlInterpolant() {
          const t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++;
          let n = t[e];
          return (
            void 0 === n &&
              ((n = new mh(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )),
              (n.__cacheIndex = e),
              (t[e] = n)),
            n
          );
        }
        _takeBackControlInterpolant(t) {
          const e = this._controlInterpolants,
            n = t.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = e[i];
          (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
        }
        clipAction(t, e, n) {
          const i = e || this._root,
            r = i.uuid;
          let o = "string" == typeof t ? Eh.findByName(i, t) : t;
          const s = null !== o ? o.uuid : t,
            a = this._actionsByClip[s];
          let l = null;
          if (
            (void 0 === n && (n = null !== o ? o.blendMode : je), void 0 !== a)
          ) {
            const t = a.actionByRoot[r];
            if (void 0 !== t && t.blendMode === n) return t;
            (l = a.knownActions[0]), null === o && (o = l._clip);
          }
          if (null === o) return null;
          const c = new ep(this, o, e, n);
          return this._bindAction(c, l), this._addInactiveAction(c, s, r), c;
        }
        existingAction(t, e) {
          const n = e || this._root,
            i = n.uuid,
            r = "string" == typeof t ? Eh.findByName(n, t) : t,
            o = r ? r.uuid : t,
            s = this._actionsByClip[o];
          return (void 0 !== s && s.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const t = this._actions;
          for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
          return this;
        }
        update(t) {
          t *= this.timeScale;
          const e = this._actions,
            n = this._nActiveActions,
            i = (this.time += t),
            r = Math.sign(t),
            o = (this._accuIndex ^= 1);
          for (let s = 0; s !== n; ++s) e[s]._update(i, t, r, o);
          const s = this._bindings,
            a = this._nActiveBindings;
          for (let t = 0; t !== a; ++t) s[t].apply(o);
          return this;
        }
        setTime(t) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(t);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(t) {
          const e = this._actions,
            n = t.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (void 0 !== r) {
            const t = r.knownActions;
            for (let n = 0, i = t.length; n !== i; ++n) {
              const i = t[n];
              this._deactivateAction(i);
              const r = i._cacheIndex,
                o = e[e.length - 1];
              (i._cacheIndex = null),
                (i._byClipCacheIndex = null),
                (o._cacheIndex = r),
                (e[r] = o),
                e.pop(),
                this._removeInactiveBindingsForAction(i);
            }
            delete i[n];
          }
        }
        uncacheRoot(t) {
          const e = t.uuid,
            n = this._actionsByClip;
          for (const t in n) {
            const i = n[t].actionByRoot[e];
            void 0 !== i &&
              (this._deactivateAction(i), this._removeInactiveAction(i));
          }
          const i = this._bindingsByRootAndName[e];
          if (void 0 !== i)
            for (const t in i) {
              const e = i[t];
              e.restoreOriginalState(), this._removeInactiveBinding(e);
            }
        }
        uncacheAction(t, e) {
          const n = this.existingAction(t, e);
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      np.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class ip {
        constructor(t) {
          "string" == typeof t &&
            (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            (t = arguments[1])),
            (this.value = t);
        }
        clone() {
          return new ip(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }
      }
      class rp extends Rl {
        constructor(t, e, n = 1) {
          super(t, e), (this.meshPerAttribute = n);
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          );
        }
        clone(t) {
          const e = super.clone(t);
          return (e.meshPerAttribute = this.meshPerAttribute), e;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.isInstancedInterleavedBuffer = !0),
            (e.meshPerAttribute = this.meshPerAttribute),
            e
          );
        }
      }
      rp.prototype.isInstancedInterleavedBuffer = !0;
      class op {
        constructor(t, e, n, i, r) {
          (this.buffer = t),
            (this.type = e),
            (this.itemSize = n),
            (this.elementSize = i),
            (this.count = r),
            (this.version = 0);
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setBuffer(t) {
          return (this.buffer = t), this;
        }
        setType(t, e) {
          return (this.type = t), (this.elementSize = e), this;
        }
        setItemSize(t) {
          return (this.itemSize = t), this;
        }
        setCount(t) {
          return (this.count = t), this;
        }
      }
      op.prototype.isGLBufferAttribute = !0;
      class sp {
        constructor(t, e, n = 0, i = 1 / 0) {
          (this.ray = new Di(t, e)),
            (this.near = n),
            (this.far = i),
            (this.camera = null),
            (this.layers = new Yi()),
            (this.params = {
              Mesh: {},
              Line: { threshold: 1 },
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {},
            });
        }
        set(t, e) {
          this.ray.set(t, e);
        }
        setFromCamera(t, e) {
          e && e.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
              this.ray.direction
                .set(t.x, t.y, 0.5)
                .unproject(e)
                .sub(this.ray.origin)
                .normalize(),
              (this.camera = e))
            : e && e.isOrthographicCamera
            ? (this.ray.origin
                .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                .unproject(e),
              this.ray.direction
                .set(0, 0, -1)
                .transformDirection(e.matrixWorld),
              (this.camera = e))
            : console.error(
                "THREE.Raycaster: Unsupported camera type: " + e.type
              );
        }
        intersectObject(t, e = !1, n = []) {
          return lp(t, this, n, e), n.sort(ap), n;
        }
        intersectObjects(t, e = !1, n = []) {
          for (let i = 0, r = t.length; i < r; i++) lp(t[i], this, n, e);
          return n.sort(ap), n;
        }
      }
      function ap(t, e) {
        return t.distance - e.distance;
      }
      function lp(t, e, n, i) {
        if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
          const i = t.children;
          for (let t = 0, r = i.length; t < r; t++) lp(i[t], e, n, !0);
        }
      }
      class cp {
        constructor(t = 1, e = 0, n = 0) {
          return (this.radius = t), (this.phi = e), (this.theta = n), this;
        }
        set(t, e, n) {
          return (this.radius = t), (this.phi = e), (this.theta = n), this;
        }
        copy(t) {
          return (
            (this.radius = t.radius),
            (this.phi = t.phi),
            (this.theta = t.theta),
            this
          );
        }
        makeSafe() {
          const t = 1e-6;
          return (
            (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
          );
        }
        setFromVector3(t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        }
        setFromCartesianCoords(t, e, n) {
          return (
            (this.radius = Math.sqrt(t * t + e * e + n * n)),
            0 === this.radius
              ? ((this.theta = 0), (this.phi = 0))
              : ((this.theta = Math.atan2(t, n)),
                (this.phi = Math.acos(Un(e / this.radius, -1, 1)))),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class up {
        constructor(t = 1, e = 0, n = 0) {
          return (this.radius = t), (this.theta = e), (this.y = n), this;
        }
        set(t, e, n) {
          return (this.radius = t), (this.theta = e), (this.y = n), this;
        }
        copy(t) {
          return (
            (this.radius = t.radius),
            (this.theta = t.theta),
            (this.y = t.y),
            this
          );
        }
        setFromVector3(t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        }
        setFromCartesianCoords(t, e, n) {
          return (
            (this.radius = Math.sqrt(t * t + n * n)),
            (this.theta = Math.atan2(t, n)),
            (this.y = e),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const hp = new Yn();
      class dp {
        constructor(t = new Yn(1 / 0, 1 / 0), e = new Yn(-1 / 0, -1 / 0)) {
          (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const n = hp.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y)
          );
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y
          );
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return hp.copy(t).clamp(this.min, this.max).sub(t).length();
        }
        intersect(t) {
          return this.min.max(t.min), this.max.min(t.max), this;
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      dp.prototype.isBox2 = !0;
      const pp = new si(),
        fp = new si();
      class mp {
        constructor(t = new si(), e = new si()) {
          (this.start = t), (this.end = e);
        }
        set(t, e) {
          return this.start.copy(t), this.end.copy(e), this;
        }
        copy(t) {
          return this.start.copy(t.start), this.end.copy(t.end), this;
        }
        getCenter(t) {
          return t.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(t) {
          return t.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t, e) {
          return this.delta(e).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(t, e) {
          pp.subVectors(t, this.start), fp.subVectors(this.end, this.start);
          const n = fp.dot(fp);
          let i = fp.dot(pp) / n;
          return e && (i = Un(i, 0, 1)), i;
        }
        closestPointToPoint(t, e, n) {
          const i = this.closestPointToPointParameter(t, e);
          return this.delta(n).multiplyScalar(i).add(this.start);
        }
        applyMatrix4(t) {
          return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
        }
        equals(t) {
          return t.start.equals(this.start) && t.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class gp extends lr {
        constructor(t) {
          super(),
            (this.material = t),
            (this.render = function () {}),
            (this.hasPositions = !1),
            (this.hasNormals = !1),
            (this.hasColors = !1),
            (this.hasUvs = !1),
            (this.positionArray = null),
            (this.normalArray = null),
            (this.colorArray = null),
            (this.uvArray = null),
            (this.count = 0);
        }
      }
      gp.prototype.isImmediateRenderObject = !0;
      const vp = new si();
      class yp extends lr {
        constructor(t, e) {
          super(),
            (this.light = t),
            this.light.updateMatrixWorld(),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = e);
          const n = new $r(),
            i = [
              0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
              1, 1, 0, 0, 0, 0, -1, 1,
            ];
          for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
            const r = (t / n) * Math.PI * 2,
              o = (e / n) * Math.PI * 2;
            i.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1);
          }
          n.setAttribute("position", new Ur(i, 3));
          const r = new fc({ fog: !1, toneMapped: !1 });
          (this.cone = new Mc(n, r)), this.add(this.cone), this.update();
        }
        dispose() {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const t = this.light.distance ? this.light.distance : 1e3,
            e = t * Math.tan(this.light.angle);
          this.cone.scale.set(e, e, t),
            vp.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(vp),
            void 0 !== this.color
              ? this.cone.material.color.set(this.color)
              : this.cone.material.color.copy(this.light.color);
        }
      }
      const xp = new si(),
        bp = new ki(),
        wp = new ki();
      class _p extends Mc {
        constructor(t) {
          const e = Mp(t),
            n = new $r(),
            i = [],
            r = [],
            o = new Cr(0, 0, 1),
            s = new Cr(0, 1, 0);
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            n.parent &&
              n.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(o.r, o.g, o.b),
              r.push(s.r, s.g, s.b));
          }
          n.setAttribute("position", new Ur(i, 3)),
            n.setAttribute("color", new Ur(r, 3)),
            super(
              n,
              new fc({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0,
              })
            ),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = t),
            (this.bones = e),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(t) {
          const e = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          wp.copy(this.root.matrixWorld).invert();
          for (let t = 0, n = 0; t < e.length; t++) {
            const r = e[t];
            r.parent &&
              r.parent.isBone &&
              (bp.multiplyMatrices(wp, r.matrixWorld),
              xp.setFromMatrixPosition(bp),
              i.setXYZ(n, xp.x, xp.y, xp.z),
              bp.multiplyMatrices(wp, r.parent.matrixWorld),
              xp.setFromMatrixPosition(bp),
              i.setXYZ(n + 1, xp.x, xp.y, xp.z),
              (n += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(t);
        }
      }
      function Mp(t) {
        const e = [];
        t && t.isBone && e.push(t);
        for (let n = 0; n < t.children.length; n++)
          e.push.apply(e, Mp(t.children[n]));
        return e;
      }
      class Sp extends xo {
        constructor(t, e, n) {
          super(
            new Xu(e, 4, 2),
            new Lr({ wireframe: !0, fog: !1, toneMapped: !1 })
          ),
            (this.light = t),
            this.light.updateMatrixWorld(),
            (this.color = n),
            (this.type = "PointLightHelper"),
            (this.matrix = this.light.matrixWorld),
            (this.matrixAutoUpdate = !1),
            this.update();
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
        update() {
          void 0 !== this.color
            ? this.material.color.set(this.color)
            : this.material.color.copy(this.light.color);
        }
      }
      const Ep = new si(),
        Tp = new Cr(),
        Ap = new Cr();
      class Cp extends lr {
        constructor(t, e, n) {
          super(),
            (this.light = t),
            this.light.updateMatrixWorld(),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = n);
          const i = new Gu(e);
          i.rotateY(0.5 * Math.PI),
            (this.material = new Lr({
              wireframe: !0,
              fog: !1,
              toneMapped: !1,
            })),
            void 0 === this.color && (this.material.vertexColors = !0);
          const r = i.getAttribute("position"),
            o = new Float32Array(3 * r.count);
          i.setAttribute("color", new Nr(o, 3)),
            this.add(new xo(i, this.material)),
            this.update();
        }
        dispose() {
          this.children[0].geometry.dispose(),
            this.children[0].material.dispose();
        }
        update() {
          const t = this.children[0];
          if (void 0 !== this.color) this.material.color.set(this.color);
          else {
            const e = t.geometry.getAttribute("color");
            Tp.copy(this.light.color), Ap.copy(this.light.groundColor);
            for (let t = 0, n = e.count; t < n; t++) {
              const i = t < n / 2 ? Tp : Ap;
              e.setXYZ(t, i.r, i.g, i.b);
            }
            e.needsUpdate = !0;
          }
          t.lookAt(Ep.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      }
      class Lp extends Mc {
        constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
          (n = new Cr(n)), (i = new Cr(i));
          const r = e / 2,
            o = t / e,
            s = t / 2,
            a = [],
            l = [];
          for (let t = 0, c = 0, u = -s; t <= e; t++, u += o) {
            a.push(-s, 0, u, s, 0, u), a.push(u, 0, -s, u, 0, s);
            const e = t === r ? n : i;
            e.toArray(l, c),
              (c += 3),
              e.toArray(l, c),
              (c += 3),
              e.toArray(l, c),
              (c += 3),
              e.toArray(l, c),
              (c += 3);
          }
          const c = new $r();
          c.setAttribute("position", new Ur(a, 3)),
            c.setAttribute("color", new Ur(l, 3)),
            super(c, new fc({ vertexColors: !0, toneMapped: !1 })),
            (this.type = "GridHelper");
        }
      }
      class Rp extends Mc {
        constructor(t = 10, e = 16, n = 8, i = 64, r = 4473924, o = 8947848) {
          (r = new Cr(r)), (o = new Cr(o));
          const s = [],
            a = [];
          for (let n = 0; n <= e; n++) {
            const i = (n / e) * (2 * Math.PI),
              l = Math.sin(i) * t,
              c = Math.cos(i) * t;
            s.push(0, 0, 0), s.push(l, 0, c);
            const u = 1 & n ? r : o;
            a.push(u.r, u.g, u.b), a.push(u.r, u.g, u.b);
          }
          for (let e = 0; e <= n; e++) {
            const l = 1 & e ? r : o,
              c = t - (t / n) * e;
            for (let t = 0; t < i; t++) {
              let e = (t / i) * (2 * Math.PI),
                n = Math.sin(e) * c,
                r = Math.cos(e) * c;
              s.push(n, 0, r),
                a.push(l.r, l.g, l.b),
                (e = ((t + 1) / i) * (2 * Math.PI)),
                (n = Math.sin(e) * c),
                (r = Math.cos(e) * c),
                s.push(n, 0, r),
                a.push(l.r, l.g, l.b);
            }
          }
          const l = new $r();
          l.setAttribute("position", new Ur(s, 3)),
            l.setAttribute("color", new Ur(a, 3)),
            super(l, new fc({ vertexColors: !0, toneMapped: !1 })),
            (this.type = "PolarGridHelper");
        }
      }
      const Pp = new si(),
        Np = new si(),
        Ip = new si();
      class Bp extends lr {
        constructor(t, e, n) {
          super(),
            (this.light = t),
            this.light.updateMatrixWorld(),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.color = n),
            void 0 === e && (e = 1);
          let i = new $r();
          i.setAttribute(
            "position",
            new Ur([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
          );
          const r = new fc({ fog: !1, toneMapped: !1 });
          (this.lightPlane = new bc(i, r)),
            this.add(this.lightPlane),
            (i = new $r()),
            i.setAttribute("position", new Ur([0, 0, 0, 0, 0, 1], 3)),
            (this.targetLine = new bc(i, r)),
            this.add(this.targetLine),
            this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose();
        }
        update() {
          Pp.setFromMatrixPosition(this.light.matrixWorld),
            Np.setFromMatrixPosition(this.light.target.matrixWorld),
            Ip.subVectors(Np, Pp),
            this.lightPlane.lookAt(Np),
            void 0 !== this.color
              ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color))
              : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(Np),
            (this.targetLine.scale.z = Ip.length());
        }
      }
      const Op = new si(),
        Dp = new To();
      class kp extends Mc {
        constructor(t) {
          const e = new $r(),
            n = new fc({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
            i = [],
            r = [],
            o = {},
            s = new Cr(16755200),
            a = new Cr(16711680),
            l = new Cr(43775),
            c = new Cr(16777215),
            u = new Cr(3355443);
          function h(t, e, n) {
            d(t, n), d(e, n);
          }
          function d(t, e) {
            i.push(0, 0, 0),
              r.push(e.r, e.g, e.b),
              void 0 === o[t] && (o[t] = []),
              o[t].push(i.length / 3 - 1);
          }
          h("n1", "n2", s),
            h("n2", "n4", s),
            h("n4", "n3", s),
            h("n3", "n1", s),
            h("f1", "f2", s),
            h("f2", "f4", s),
            h("f4", "f3", s),
            h("f3", "f1", s),
            h("n1", "f1", s),
            h("n2", "f2", s),
            h("n3", "f3", s),
            h("n4", "f4", s),
            h("p", "n1", a),
            h("p", "n2", a),
            h("p", "n3", a),
            h("p", "n4", a),
            h("u1", "u2", l),
            h("u2", "u3", l),
            h("u3", "u1", l),
            h("c", "t", c),
            h("p", "c", u),
            h("cn1", "cn2", u),
            h("cn3", "cn4", u),
            h("cf1", "cf2", u),
            h("cf3", "cf4", u),
            e.setAttribute("position", new Ur(i, 3)),
            e.setAttribute("color", new Ur(r, 3)),
            super(e, n),
            (this.type = "CameraHelper"),
            (this.camera = t),
            this.camera.updateProjectionMatrix &&
              this.camera.updateProjectionMatrix(),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1),
            (this.pointMap = o),
            this.update();
        }
        update() {
          const t = this.geometry,
            e = this.pointMap;
          Dp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            Fp("c", e, t, Dp, 0, 0, -1),
            Fp("t", e, t, Dp, 0, 0, 1),
            Fp("n1", e, t, Dp, -1, -1, -1),
            Fp("n2", e, t, Dp, 1, -1, -1),
            Fp("n3", e, t, Dp, -1, 1, -1),
            Fp("n4", e, t, Dp, 1, 1, -1),
            Fp("f1", e, t, Dp, -1, -1, 1),
            Fp("f2", e, t, Dp, 1, -1, 1),
            Fp("f3", e, t, Dp, -1, 1, 1),
            Fp("f4", e, t, Dp, 1, 1, 1),
            Fp("u1", e, t, Dp, 0.7, 1.1, -1),
            Fp("u2", e, t, Dp, -0.7, 1.1, -1),
            Fp("u3", e, t, Dp, 0, 2, -1),
            Fp("cf1", e, t, Dp, -1, 0, 1),
            Fp("cf2", e, t, Dp, 1, 0, 1),
            Fp("cf3", e, t, Dp, 0, -1, 1),
            Fp("cf4", e, t, Dp, 0, 1, 1),
            Fp("cn1", e, t, Dp, -1, 0, -1),
            Fp("cn2", e, t, Dp, 1, 0, -1),
            Fp("cn3", e, t, Dp, 0, -1, -1),
            Fp("cn4", e, t, Dp, 0, 1, -1),
            (t.getAttribute("position").needsUpdate = !0);
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      function Fp(t, e, n, i, r, o, s) {
        Op.set(r, o, s).unproject(i);
        const a = e[t];
        if (void 0 !== a) {
          const t = n.getAttribute("position");
          for (let e = 0, n = a.length; e < n; e++)
            t.setXYZ(a[e], Op.x, Op.y, Op.z);
        }
      }
      const zp = new ci();
      class Hp extends Mc {
        constructor(t, e = 16776960) {
          const n = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
              3, 7,
            ]),
            i = new Float32Array(24),
            r = new $r();
          r.setIndex(new Nr(n, 1)),
            r.setAttribute("position", new Nr(i, 3)),
            super(r, new fc({ color: e, toneMapped: !1 })),
            (this.object = t),
            (this.type = "BoxHelper"),
            (this.matrixAutoUpdate = !1),
            this.update();
        }
        update(t) {
          if (
            (void 0 !== t &&
              console.warn(
                "THREE.BoxHelper: .update() has no longer arguments."
              ),
            void 0 !== this.object && zp.setFromObject(this.object),
            zp.isEmpty())
          )
            return;
          const e = zp.min,
            n = zp.max,
            i = this.geometry.attributes.position,
            r = i.array;
          (r[0] = n.x),
            (r[1] = n.y),
            (r[2] = n.z),
            (r[3] = e.x),
            (r[4] = n.y),
            (r[5] = n.z),
            (r[6] = e.x),
            (r[7] = e.y),
            (r[8] = n.z),
            (r[9] = n.x),
            (r[10] = e.y),
            (r[11] = n.z),
            (r[12] = n.x),
            (r[13] = n.y),
            (r[14] = e.z),
            (r[15] = e.x),
            (r[16] = n.y),
            (r[17] = e.z),
            (r[18] = e.x),
            (r[19] = e.y),
            (r[20] = e.z),
            (r[21] = n.x),
            (r[22] = e.y),
            (r[23] = e.z),
            (i.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
        }
        setFromObject(t) {
          return (this.object = t), this.update(), this;
        }
        copy(t) {
          return (
            Mc.prototype.copy.call(this, t), (this.object = t.object), this
          );
        }
      }
      class Up extends Mc {
        constructor(t, e = 16776960) {
          const n = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
              3, 7,
            ]),
            i = new $r();
          i.setIndex(new Nr(n, 1)),
            i.setAttribute(
              "position",
              new Ur(
                [
                  1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                  -1, -1, -1, 1, -1, -1,
                ],
                3
              )
            ),
            super(i, new fc({ color: e, toneMapped: !1 })),
            (this.box = t),
            (this.type = "Box3Helper"),
            this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(t) {
          const e = this.box;
          e.isEmpty() ||
            (e.getCenter(this.position),
            e.getSize(this.scale),
            this.scale.multiplyScalar(0.5),
            super.updateMatrixWorld(t));
        }
      }
      class Vp extends bc {
        constructor(t, e = 1, n = 16776960) {
          const i = n,
            r = new $r();
          r.setAttribute(
            "position",
            new Ur(
              [
                1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1,
                -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
              ],
              3
            )
          ),
            r.computeBoundingSphere(),
            super(r, new fc({ color: i, toneMapped: !1 })),
            (this.type = "PlaneHelper"),
            (this.plane = t),
            (this.size = e);
          const o = new $r();
          o.setAttribute(
            "position",
            new Ur(
              [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
              3
            )
          ),
            o.computeBoundingSphere(),
            this.add(
              new xo(
                o,
                new Lr({
                  color: i,
                  opacity: 0.2,
                  transparent: !0,
                  depthWrite: !1,
                  toneMapped: !1,
                })
              )
            );
        }
        updateMatrixWorld(t) {
          let e = -this.plane.constant;
          Math.abs(e) < 1e-8 && (e = 1e-8),
            this.scale.set(0.5 * this.size, 0.5 * this.size, e),
            (this.children[0].material.side = e < 0 ? f : p),
            this.lookAt(this.plane.normal),
            super.updateMatrixWorld(t);
        }
      }
      const Gp = new si();
      let jp, Wp;
      class qp extends lr {
        constructor(
          t = new si(0, 0, 1),
          e = new si(0, 0, 0),
          n = 1,
          i = 16776960,
          r = 0.2 * n,
          o = 0.2 * r
        ) {
          super(),
            (this.type = "ArrowHelper"),
            void 0 === jp &&
              ((jp = new $r()),
              jp.setAttribute("position", new Ur([0, 0, 0, 0, 1, 0], 3)),
              (Wp = new kc(0, 0.5, 1, 5, 1)),
              Wp.translate(0, -0.5, 0)),
            this.position.copy(e),
            (this.line = new bc(jp, new fc({ color: i, toneMapped: !1 }))),
            (this.line.matrixAutoUpdate = !1),
            this.add(this.line),
            (this.cone = new xo(Wp, new Lr({ color: i, toneMapped: !1 }))),
            (this.cone.matrixAutoUpdate = !1),
            this.add(this.cone),
            this.setDirection(t),
            this.setLength(n, r, o);
        }
        setDirection(t) {
          if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
          else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
          else {
            Gp.set(t.z, 0, -t.x).normalize();
            const e = Math.acos(t.y);
            this.quaternion.setFromAxisAngle(Gp, e);
          }
        }
        setLength(t, e = 0.2 * t, n = 0.2 * e) {
          this.line.scale.set(1, Math.max(1e-4, t - e), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(n, e, n),
            (this.cone.position.y = t),
            this.cone.updateMatrix();
        }
        setColor(t) {
          this.line.material.color.set(t), this.cone.material.color.set(t);
        }
        copy(t) {
          return (
            super.copy(t, !1),
            this.line.copy(t.line),
            this.cone.copy(t.cone),
            this
          );
        }
      }
      class Xp extends Mc {
        constructor(t = 1) {
          const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            n = new $r();
          n.setAttribute("position", new Ur(e, 3)),
            n.setAttribute(
              "color",
              new Ur(
                [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                3
              )
            ),
            super(n, new fc({ vertexColors: !0, toneMapped: !1 })),
            (this.type = "AxesHelper");
        }
        setColors(t, e, n) {
          const i = new Cr(),
            r = this.geometry.attributes.color.array;
          return (
            i.set(t),
            i.toArray(r, 0),
            i.toArray(r, 3),
            i.set(e),
            i.toArray(r, 6),
            i.toArray(r, 9),
            i.set(n),
            i.toArray(r, 12),
            i.toArray(r, 15),
            (this.geometry.attributes.color.needsUpdate = !0),
            this
          );
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      const Yp = new Float32Array(1),
        Zp = new Int32Array(Yp.buffer);
      class Jp {
        static toHalfFloat(t) {
          Yp[0] = t;
          const e = Zp[0];
          let n = (e >> 16) & 32768,
            i = (e >> 12) & 2047;
          const r = (e >> 23) & 255;
          return r < 103
            ? n
            : r > 142
            ? ((n |= 31744), (n |= (255 == r ? 0 : 1) && 8388607 & e), n)
            : r < 113
            ? ((i |= 2048), (n |= (i >> (114 - r)) + ((i >> (113 - r)) & 1)), n)
            : ((n |= ((r - 112) << 10) | (i >> 1)), (n += 1 & i), n);
        }
      }
      const Kp = 0,
        Qp = 1,
        $p = 0,
        tf = 1,
        ef = 2;
      function nf(t) {
        return (
          console.warn(
            "THREE.MeshFaceMaterial has been removed. Use an Array instead."
          ),
          t
        );
      }
      function rf(t = []) {
        return (
          console.warn(
            "THREE.MultiMaterial has been removed. Use an Array instead."
          ),
          (t.isMultiMaterial = !0),
          (t.materials = t),
          (t.clone = function () {
            return t.slice();
          }),
          t
        );
      }
      function of(t, e) {
        return (
          console.warn("THREE.PointCloud has been renamed to THREE.Points."),
          new Rc(t, e)
        );
      }
      function sf(t) {
        return (
          console.warn("THREE.Particle has been renamed to THREE.Sprite."),
          new Xl(t)
        );
      }
      function af(t, e) {
        return (
          console.warn(
            "THREE.ParticleSystem has been renamed to THREE.Points."
          ),
          new Rc(t, e)
        );
      }
      function lf(t) {
        return (
          console.warn(
            "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Ec(t)
        );
      }
      function cf(t) {
        return (
          console.warn(
            "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Ec(t)
        );
      }
      function uf(t) {
        return (
          console.warn(
            "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
          ),
          new Ec(t)
        );
      }
      function hf(t, e, n) {
        return (
          console.warn(
            "THREE.Vertex has been removed. Use THREE.Vector3 instead."
          ),
          new si(t, e, n)
        );
      }
      function df(t, e) {
        return (
          console.warn(
            "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
          ),
          new Nr(t, e).setUsage(En)
        );
      }
      function pf(t, e) {
        return (
          console.warn(
            "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
          ),
          new Ir(t, e)
        );
      }
      function ff(t, e) {
        return (
          console.warn(
            "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
          ),
          new Br(t, e)
        );
      }
      function mf(t, e) {
        return (
          console.warn(
            "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
          ),
          new Or(t, e)
        );
      }
      function gf(t, e) {
        return (
          console.warn(
            "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
          ),
          new Dr(t, e)
        );
      }
      function vf(t, e) {
        return (
          console.warn(
            "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
          ),
          new kr(t, e)
        );
      }
      function yf(t, e) {
        return (
          console.warn(
            "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
          ),
          new Fr(t, e)
        );
      }
      function xf(t, e) {
        return (
          console.warn(
            "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
          ),
          new zr(t, e)
        );
      }
      function bf(t, e) {
        return (
          console.warn(
            "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
          ),
          new Ur(t, e)
        );
      }
      function wf(t, e) {
        return (
          console.warn(
            "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
          ),
          new Vr(t, e)
        );
      }
      function _f(t) {
        return (
          console.warn(
            "THREE.AxisHelper has been renamed to THREE.AxesHelper."
          ),
          new Xp(t)
        );
      }
      function Mf(t, e) {
        return (
          console.warn(
            "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
          ),
          new Hp(t, e)
        );
      }
      function Sf(t, e) {
        return (
          console.warn(
            "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
          ),
          new Mc(
            new Wc(t.geometry),
            new fc({ color: void 0 !== e ? e : 16777215 })
          )
        );
      }
      function Ef(t, e) {
        return (
          console.warn(
            "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
          ),
          new Mc(
            new $u(t.geometry),
            new fc({ color: void 0 !== e ? e : 16777215 })
          )
        );
      }
      function Tf(t) {
        return (
          console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
          new Nh(t)
        );
      }
      function Af(t) {
        return (
          console.warn(
            "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
          ),
          new kh(t)
        );
      }
      function Cf(t, e, n) {
        return (
          console.warn(
            "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
          ),
          new Po(t, n)
        );
      }
      function Lf() {
        console.error("THREE.CanvasRenderer has been removed");
      }
      function Rf() {
        console.error("THREE.JSONLoader has been removed.");
      }
      (qc.create = function (t, e) {
        return (
          console.log("THREE.Curve.create() has been deprecated"),
          (t.prototype = Object.create(qc.prototype)),
          (t.prototype.constructor = t),
          (t.prototype.getPoint = e),
          t
        );
      }),
        (Hh.prototype.fromPoints = function (t) {
          return (
            console.warn(
              "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
            ),
            this.setFromPoints(t)
          );
        }),
        (Lp.prototype.setColors = function () {
          console.error(
            "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
          );
        }),
        (_p.prototype.update = function () {
          console.error(
            "THREE.SkeletonHelper: update() no longer needs to be called."
          );
        }),
        (Rh.prototype.extractUrlBase = function (t) {
          return (
            console.warn(
              "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
            ),
            ld.extractUrlBase(t)
          );
        }),
        (Rh.Handlers = {
          add: function () {
            console.error(
              "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
            );
          },
          get: function () {
            console.error(
              "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
            );
          },
        }),
        (dp.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Box2: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        (dp.prototype.empty = function () {
          return (
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        }),
        (dp.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        }),
        (dp.prototype.size = function (t) {
          return (
            console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        }),
        (ci.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Box3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        (ci.prototype.empty = function () {
          return (
            console.warn(
              "THREE.Box3: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        }),
        (ci.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        }),
        (ci.prototype.isIntersectionSphere = function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        }),
        (ci.prototype.size = function (t) {
          return (
            console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        }),
        (Ci.prototype.empty = function () {
          return (
            console.warn(
              "THREE.Sphere: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        }),
        (Fo.prototype.setFromMatrix = function (t) {
          return (
            console.warn(
              "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
            ),
            this.setFromProjectionMatrix(t)
          );
        }),
        (mp.prototype.center = function (t) {
          return (
            console.warn(
              "THREE.Line3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        }),
        (Zn.prototype.flattenToArrayOffset = function (t, e) {
          return (
            console.warn(
              "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        }),
        (Zn.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        }),
        (Zn.prototype.multiplyVector3Array = function () {
          console.error(
            "THREE.Matrix3: .multiplyVector3Array() has been removed."
          );
        }),
        (Zn.prototype.applyToBufferAttribute = function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        }),
        (Zn.prototype.applyToVector3Array = function () {
          console.error(
            "THREE.Matrix3: .applyToVector3Array() has been removed."
          );
        }),
        (Zn.prototype.getInverse = function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
            ),
            this.copy(t).invert()
          );
        }),
        (ki.prototype.extractPosition = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
            ),
            this.copyPosition(t)
          );
        }),
        (ki.prototype.flattenToArrayOffset = function (t, e) {
          return (
            console.warn(
              "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        }),
        (ki.prototype.getPosition = function () {
          return (
            console.warn(
              "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
            ),
            new si().setFromMatrixColumn(this, 3)
          );
        }),
        (ki.prototype.setRotationFromQuaternion = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
            ),
            this.makeRotationFromQuaternion(t)
          );
        }),
        (ki.prototype.multiplyToArray = function () {
          console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        }),
        (ki.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (ki.prototype.multiplyVector4 = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (ki.prototype.multiplyVector3Array = function () {
          console.error(
            "THREE.Matrix4: .multiplyVector3Array() has been removed."
          );
        }),
        (ki.prototype.rotateAxis = function (t) {
          console.warn(
            "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
          ),
            t.transformDirection(this);
        }),
        (ki.prototype.crossVector = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (ki.prototype.translate = function () {
          console.error("THREE.Matrix4: .translate() has been removed.");
        }),
        (ki.prototype.rotateX = function () {
          console.error("THREE.Matrix4: .rotateX() has been removed.");
        }),
        (ki.prototype.rotateY = function () {
          console.error("THREE.Matrix4: .rotateY() has been removed.");
        }),
        (ki.prototype.rotateZ = function () {
          console.error("THREE.Matrix4: .rotateZ() has been removed.");
        }),
        (ki.prototype.rotateByAxis = function () {
          console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        }),
        (ki.prototype.applyToBufferAttribute = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        }),
        (ki.prototype.applyToVector3Array = function () {
          console.error(
            "THREE.Matrix4: .applyToVector3Array() has been removed."
          );
        }),
        (ki.prototype.makeFrustum = function (t, e, n, i, r, o) {
          return (
            console.warn(
              "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
            ),
            this.makePerspective(t, e, i, n, r, o)
          );
        }),
        (ki.prototype.getInverse = function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
            ),
            this.copy(t).invert()
          );
        }),
        (Oo.prototype.isIntersectionLine = function (t) {
          return (
            console.warn(
              "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
            ),
            this.intersectsLine(t)
          );
        }),
        (oi.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
            ),
            t.applyQuaternion(this)
          );
        }),
        (oi.prototype.inverse = function () {
          return (
            console.warn(
              "THREE.Quaternion: .inverse() has been renamed to invert()."
            ),
            this.invert()
          );
        }),
        (Di.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        }),
        (Di.prototype.isIntersectionPlane = function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
            ),
            this.intersectsPlane(t)
          );
        }),
        (Di.prototype.isIntersectionSphere = function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        }),
        (xr.prototype.area = function () {
          return (
            console.warn(
              "THREE.Triangle: .area() has been renamed to .getArea()."
            ),
            this.getArea()
          );
        }),
        (xr.prototype.barycoordFromPoint = function (t, e) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            this.getBarycoord(t, e)
          );
        }),
        (xr.prototype.midpoint = function (t) {
          return (
            console.warn(
              "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
            ),
            this.getMidpoint(t)
          );
        }),
        (xr.prototypenormal = function (t) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            this.getNormal(t)
          );
        }),
        (xr.prototype.plane = function (t) {
          return (
            console.warn(
              "THREE.Triangle: .plane() has been renamed to .getPlane()."
            ),
            this.getPlane(t)
          );
        }),
        (xr.barycoordFromPoint = function (t, e, n, i, r) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            xr.getBarycoord(t, e, n, i, r)
          );
        }),
        (xr.normal = function (t, e, n, i) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            xr.getNormal(t, e, n, i)
          );
        }),
        (Uh.prototype.extractAllPoints = function (t) {
          return (
            console.warn(
              "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
            ),
            this.extractPoints(t)
          );
        }),
        (Uh.prototype.extrude = function (t) {
          return (
            console.warn(
              "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
            ),
            new zu(this, t)
          );
        }),
        (Uh.prototype.makeGeometry = function (t) {
          return (
            console.warn(
              "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
            ),
            new qu(this, t)
          );
        }),
        (Yn.prototype.fromAttribute = function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        }),
        (Yn.prototype.distanceToManhattan = function (t) {
          return (
            console.warn(
              "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        }),
        (Yn.prototype.lengthManhattan = function () {
          return (
            console.warn(
              "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }),
        (si.prototype.setEulerFromRotationMatrix = function () {
          console.error(
            "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
          );
        }),
        (si.prototype.setEulerFromQuaternion = function () {
          console.error(
            "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
          );
        }),
        (si.prototype.getPositionFromMatrix = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
            ),
            this.setFromMatrixPosition(t)
          );
        }),
        (si.prototype.getScaleFromMatrix = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
            ),
            this.setFromMatrixScale(t)
          );
        }),
        (si.prototype.getColumnFromMatrix = function (t, e) {
          return (
            console.warn(
              "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
            ),
            this.setFromMatrixColumn(e, t)
          );
        }),
        (si.prototype.applyProjection = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
            ),
            this.applyMatrix4(t)
          );
        }),
        (si.prototype.fromAttribute = function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        }),
        (si.prototype.distanceToManhattan = function (t) {
          return (
            console.warn(
              "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        }),
        (si.prototype.lengthManhattan = function () {
          return (
            console.warn(
              "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }),
        (ei.prototype.fromAttribute = function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        }),
        (ei.prototype.lengthManhattan = function () {
          return (
            console.warn(
              "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        }),
        (lr.prototype.getChildByName = function (t) {
          return (
            console.warn(
              "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
            ),
            this.getObjectByName(t)
          );
        }),
        (lr.prototype.renderDepth = function () {
          console.warn(
            "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
          );
        }),
        (lr.prototype.translate = function (t, e) {
          return (
            console.warn(
              "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
            ),
            this.translateOnAxis(e, t)
          );
        }),
        (lr.prototype.getWorldRotation = function () {
          console.error(
            "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
          );
        }),
        (lr.prototype.applyMatrix = function (t) {
          return (
            console.warn(
              "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
            ),
            this.applyMatrix4(t)
          );
        }),
        Object.defineProperties(lr.prototype, {
          eulerOrder: {
            get: function () {
              return (
                console.warn(
                  "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                this.rotation.order
              );
            },
            set: function (t) {
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
                (this.rotation.order = t);
            },
          },
          useQuaternion: {
            get: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
            set: function () {
              console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
              );
            },
          },
        }),
        (xo.prototype.setDrawMode = function () {
          console.error(
            "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
          );
        }),
        Object.defineProperties(xo.prototype, {
          drawMode: {
            get: function () {
              return (
                console.error(
                  "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                ),
                qe
              );
            },
            set: function () {
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
              );
            },
          },
        }),
        (ic.prototype.initBones = function () {
          console.error("THREE.SkinnedMesh: initBones() has been removed.");
        }),
        (Ao.prototype.setLens = function (t, e) {
          console.warn(
            "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
          ),
            void 0 !== e && (this.filmGauge = e),
            this.setFocalLength(t);
        }),
        Object.defineProperties(Vh.prototype, {
          onlyShadow: {
            set: function () {
              console.warn("THREE.Light: .onlyShadow has been removed.");
            },
          },
          shadowCameraFov: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
              ),
                (this.shadow.camera.fov = t);
            },
          },
          shadowCameraLeft: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
              ),
                (this.shadow.camera.left = t);
            },
          },
          shadowCameraRight: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
              ),
                (this.shadow.camera.right = t);
            },
          },
          shadowCameraTop: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
              ),
                (this.shadow.camera.top = t);
            },
          },
          shadowCameraBottom: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
              ),
                (this.shadow.camera.bottom = t);
            },
          },
          shadowCameraNear: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
              ),
                (this.shadow.camera.near = t);
            },
          },
          shadowCameraFar: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
              ),
                (this.shadow.camera.far = t);
            },
          },
          shadowCameraVisible: {
            set: function () {
              console.warn(
                "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
              );
            },
          },
          shadowBias: {
            set: function (t) {
              console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                (this.shadow.bias = t);
            },
          },
          shadowDarkness: {
            set: function () {
              console.warn("THREE.Light: .shadowDarkness has been removed.");
            },
          },
          shadowMapWidth: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
              ),
                (this.shadow.mapSize.width = t);
            },
          },
          shadowMapHeight: {
            set: function (t) {
              console.warn(
                "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
              ),
                (this.shadow.mapSize.height = t);
            },
          },
        }),
        Object.defineProperties(Nr.prototype, {
          length: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                ),
                this.array.length
              );
            },
          },
          dynamic: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                ),
                this.usage === En
              );
            },
            set: function () {
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
                this.setUsage(En);
            },
          },
        }),
        (Nr.prototype.setDynamic = function (t) {
          return (
            console.warn(
              "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? En : Sn),
            this
          );
        }),
        (Nr.prototype.copyIndicesArray = function () {
          console.error(
            "THREE.BufferAttribute: .copyIndicesArray() has been removed."
          );
        }),
        (Nr.prototype.setArray = function () {
          console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        }),
        ($r.prototype.addIndex = function (t) {
          console.warn(
            "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
          ),
            this.setIndex(t);
        }),
        ($r.prototype.addAttribute = function (t, e) {
          return (
            console.warn(
              "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
            ),
            (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
              ? "index" === t
                ? (console.warn(
                    "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                  ),
                  this.setIndex(e),
                  this)
                : this.setAttribute(t, e)
              : (console.warn(
                  "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                ),
                this.setAttribute(t, new Nr(arguments[1], arguments[2])))
          );
        }),
        ($r.prototype.addDrawCall = function (t, e, n) {
          void 0 !== n &&
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
            ),
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
            ),
            this.addGroup(t, e);
        }),
        ($r.prototype.clearDrawCalls = function () {
          console.warn(
            "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
          ),
            this.clearGroups();
        }),
        ($r.prototype.computeOffsets = function () {
          console.warn(
            "THREE.BufferGeometry: .computeOffsets() has been removed."
          );
        }),
        ($r.prototype.removeAttribute = function (t) {
          return (
            console.warn(
              "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
            ),
            this.deleteAttribute(t)
          );
        }),
        ($r.prototype.applyMatrix = function (t) {
          return (
            console.warn(
              "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
            ),
            this.applyMatrix4(t)
          );
        }),
        Object.defineProperties($r.prototype, {
          drawcalls: {
            get: function () {
              return (
                console.error(
                  "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
          offsets: {
            get: function () {
              return (
                console.warn(
                  "THREE.BufferGeometry: .offsets has been renamed to .groups."
                ),
                this.groups
              );
            },
          },
        }),
        (Rl.prototype.setDynamic = function (t) {
          return (
            console.warn(
              "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
            ),
            this.setUsage(!0 === t ? En : Sn),
            this
          );
        }),
        (Rl.prototype.setArray = function () {
          console.error(
            "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
          );
        }),
        (zu.prototype.getArrays = function () {
          console.error(
            "THREE.ExtrudeGeometry: .getArrays() has been removed."
          );
        }),
        (zu.prototype.addShapeList = function () {
          console.error(
            "THREE.ExtrudeGeometry: .addShapeList() has been removed."
          );
        }),
        (zu.prototype.addShape = function () {
          console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
        }),
        (Ll.prototype.dispose = function () {
          console.error("THREE.Scene: .dispose() has been removed.");
        }),
        (ip.prototype.onUpdate = function () {
          return (
            console.warn(
              "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
            ),
            this
          );
        }),
        Object.defineProperties(wr.prototype, {
          wrapAround: {
            get: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .wrapAround has been removed.");
            },
          },
          overdraw: {
            get: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
            set: function () {
              console.warn("THREE.Material: .overdraw has been removed.");
            },
          },
          wrapRGB: {
            get: function () {
              return (
                console.warn("THREE.Material: .wrapRGB has been removed."),
                new Cr()
              );
            },
          },
          shading: {
            get: function () {
              console.error(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              );
            },
            set: function (t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = t === g);
            },
          },
          stencilMask: {
            get: function () {
              return (
                console.warn(
                  "THREE." +
                    this.type +
                    ": .stencilMask has been removed. Use .stencilFuncMask instead."
                ),
                this.stencilFuncMask
              );
            },
            set: function (t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
                (this.stencilFuncMask = t);
            },
          },
          vertexTangents: {
            get: function () {
              console.warn(
                "THREE." + this.type + ": .vertexTangents has been removed."
              );
            },
            set: function () {
              console.warn(
                "THREE." + this.type + ": .vertexTangents has been removed."
              );
            },
          },
        }),
        Object.defineProperties(Eo.prototype, {
          derivatives: {
            get: function () {
              return (
                console.warn(
                  "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                this.extensions.derivatives
              );
            },
            set: function (t) {
              console.warn(
                "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
                (this.extensions.derivatives = t);
            },
          },
        }),
        (El.prototype.clearTarget = function (t, e, n, i) {
          console.warn(
            "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
          ),
            this.setRenderTarget(t),
            this.clear(e, n, i);
        }),
        (El.prototype.animate = function (t) {
          console.warn(
            "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
          ),
            this.setAnimationLoop(t);
        }),
        (El.prototype.getCurrentRenderTarget = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
            ),
            this.getRenderTarget()
          );
        }),
        (El.prototype.getMaxAnisotropy = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
            ),
            this.capabilities.getMaxAnisotropy()
          );
        }),
        (El.prototype.getPrecision = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
            ),
            this.capabilities.precision
          );
        }),
        (El.prototype.resetGLState = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
            ),
            this.state.reset()
          );
        }),
        (El.prototype.supportsFloatTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
            ),
            this.extensions.get("OES_texture_float")
          );
        }),
        (El.prototype.supportsHalfFloatTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
            ),
            this.extensions.get("OES_texture_half_float")
          );
        }),
        (El.prototype.supportsStandardDerivatives = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
            ),
            this.extensions.get("OES_standard_derivatives")
          );
        }),
        (El.prototype.supportsCompressedTextureS3TC = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
          );
        }),
        (El.prototype.supportsCompressedTexturePVRTC = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
          );
        }),
        (El.prototype.supportsBlendMinMax = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
            ),
            this.extensions.get("EXT_blend_minmax")
          );
        }),
        (El.prototype.supportsVertexTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
            ),
            this.capabilities.vertexTextures
          );
        }),
        (El.prototype.supportsInstancedArrays = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
            ),
            this.extensions.get("ANGLE_instanced_arrays")
          );
        }),
        (El.prototype.enableScissorTest = function (t) {
          console.warn(
            "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
          ),
            this.setScissorTest(t);
        }),
        (El.prototype.initMaterial = function () {
          console.warn(
            "THREE.WebGLRenderer: .initMaterial() has been removed."
          );
        }),
        (El.prototype.addPrePlugin = function () {
          console.warn(
            "THREE.WebGLRenderer: .addPrePlugin() has been removed."
          );
        }),
        (El.prototype.addPostPlugin = function () {
          console.warn(
            "THREE.WebGLRenderer: .addPostPlugin() has been removed."
          );
        }),
        (El.prototype.updateShadowMap = function () {
          console.warn(
            "THREE.WebGLRenderer: .updateShadowMap() has been removed."
          );
        }),
        (El.prototype.setFaceCulling = function () {
          console.warn(
            "THREE.WebGLRenderer: .setFaceCulling() has been removed."
          );
        }),
        (El.prototype.allocTextureUnit = function () {
          console.warn(
            "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
          );
        }),
        (El.prototype.setTexture = function () {
          console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
        }),
        (El.prototype.setTexture2D = function () {
          console.warn(
            "THREE.WebGLRenderer: .setTexture2D() has been removed."
          );
        }),
        (El.prototype.setTextureCube = function () {
          console.warn(
            "THREE.WebGLRenderer: .setTextureCube() has been removed."
          );
        }),
        (El.prototype.getActiveMipMapLevel = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
            ),
            this.getActiveMipmapLevel()
          );
        }),
        Object.defineProperties(El.prototype, {
          shadowMapEnabled: {
            get: function () {
              return this.shadowMap.enabled;
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
              ),
                (this.shadowMap.enabled = t);
            },
          },
          shadowMapType: {
            get: function () {
              return this.shadowMap.type;
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
              ),
                (this.shadowMap.type = t);
            },
          },
          shadowMapCullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          context: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                ),
                this.getContext()
              );
            },
          },
          vr: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .vr has been renamed to .xr"
                ),
                this.xr
              );
            },
          },
          gammaInput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                ),
                !1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              );
            },
          },
          gammaOutput: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                ),
                !1
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
                (this.outputEncoding = !0 === t ? Je : Ze);
            },
          },
          toneMappingWhitePoint: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                ),
                1
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              );
            },
          },
        }),
        Object.defineProperties(ml.prototype, {
          cullFace: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderReverseSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
          renderSingleSided: {
            get: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
            set: function () {
              console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
              );
            },
          },
        }),
        Object.defineProperties(ni.prototype, {
          wrapS: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                this.texture.wrapS
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
                (this.texture.wrapS = t);
            },
          },
          wrapT: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                this.texture.wrapT
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
                (this.texture.wrapT = t);
            },
          },
          magFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                this.texture.magFilter
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
                (this.texture.magFilter = t);
            },
          },
          minFilter: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                this.texture.minFilter
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
                (this.texture.minFilter = t);
            },
          },
          anisotropy: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                this.texture.anisotropy
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
                (this.texture.anisotropy = t);
            },
          },
          offset: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                this.texture.offset
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
                (this.texture.offset = t);
            },
          },
          repeat: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                this.texture.repeat
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
                (this.texture.repeat = t);
            },
          },
          format: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                this.texture.format
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
                (this.texture.format = t);
            },
          },
          type: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                this.texture.type
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
                (this.texture.type = t);
            },
          },
          generateMipmaps: {
            get: function () {
              return (
                console.warn(
                  "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                this.texture.generateMipmaps
              );
            },
            set: function (t) {
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
                (this.texture.generateMipmaps = t);
            },
          },
        }),
        (Dd.prototype.load = function (t) {
          console.warn(
            "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
          );
          const e = this;
          return (
            new Md().load(t, function (t) {
              e.setBuffer(t);
            }),
            this
          );
        }),
        (Vd.prototype.getData = function () {
          return (
            console.warn(
              "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
            ),
            this.getFrequencyData()
          );
        }),
        (Lo.prototype.updateCubeMap = function (t, e) {
          return (
            console.warn(
              "THREE.CubeCamera: .updateCubeMap() is now .update()."
            ),
            this.update(t, e)
          );
        }),
        (Lo.prototype.clear = function (t, e, n, i) {
          return (
            console.warn(
              "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
            ),
            this.renderTarget.clear(t, e, n, i)
          );
        }),
        (Kn.crossOrigin = void 0),
        (Kn.loadTexture = function (t, e, n, i) {
          console.warn(
            "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
          );
          const r = new Fh();
          r.setCrossOrigin(this.crossOrigin);
          const o = r.load(t, n, void 0, i);
          return e && (o.mapping = e), o;
        }),
        (Kn.loadTextureCube = function (t, e, n, i) {
          console.warn(
            "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
          );
          const r = new Dh();
          r.setCrossOrigin(this.crossOrigin);
          const o = r.load(t, n, void 0, i);
          return e && (o.mapping = e), o;
        }),
        (Kn.loadCompressedTexture = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
          );
        }),
        (Kn.loadCompressedTextureCube = function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
          );
        });
      const Pf = {
        createMultiMaterialObject: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        detach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
        attach: function () {
          console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
          );
        },
      };
      function Nf() {
        console.error(
          "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
        );
      }
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: e } })
        ),
        "undefined" != typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = e));
      class If extends Rh {
        constructor(t) {
          super(t),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new Ff(t);
            }),
            this.register(function (t) {
              return new Hf(t);
            }),
            this.register(function (t) {
              return new Uf(t);
            }),
            this.register(function (t) {
              return new zf(t);
            }),
            this.register(function (t) {
              return new Df(t);
            }),
            this.register(function (t) {
              return new Vf(t);
            });
        }
        load(t, e, n, i) {
          const r = this;
          let o;
          (o =
            "" !== this.resourcePath
              ? this.resourcePath
              : "" !== this.path
              ? this.path
              : ld.extractUrlBase(t)),
            this.manager.itemStart(t);
          const s = function (e) {
              i ? i(e) : console.error(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t);
            },
            a = new Nh(this.manager);
          a.setPath(this.path),
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
              t,
              function (n) {
                try {
                  r.parse(
                    n,
                    o,
                    function (n) {
                      e(n), r.manager.itemEnd(t);
                    },
                    s
                  );
                } catch (t) {
                  s(t);
                }
              },
              n,
              s
            );
        }
        setDRACOLoader(t) {
          return (this.dracoLoader = t), this;
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
          );
        }
        setKTX2Loader(t) {
          return (this.ktx2Loader = t), this;
        }
        setMeshoptDecoder(t) {
          return (this.meshoptDecoder = t), this;
        }
        register(t) {
          return (
            -1 === this.pluginCallbacks.indexOf(t) &&
              this.pluginCallbacks.push(t),
            this
          );
        }
        unregister(t) {
          return (
            -1 !== this.pluginCallbacks.indexOf(t) &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
            this
          );
        }
        parse(t, e, n, i) {
          let r;
          const o = {},
            s = {};
          if ("string" == typeof t) r = t;
          else if (ld.decodeText(new Uint8Array(t, 0, 4)) === Gf) {
            try {
              o[Of.KHR_BINARY_GLTF] = new jf(t);
            } catch (t) {
              return void (i && i(t));
            }
            r = o[Of.KHR_BINARY_GLTF].content;
          } else r = ld.decodeText(new Uint8Array(t));
          const a = JSON.parse(r);
          if (void 0 === a.asset || a.asset.version[0] < 2)
            return void (
              i &&
              i(
                new Error(
                  "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                )
              )
            );
          const l = new hm(a, {
            path: e || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          l.fileLoader.setRequestHeader(this.requestHeader);
          for (let t = 0; t < this.pluginCallbacks.length; t++) {
            const e = this.pluginCallbacks[t](l);
            (s[e.name] = e), (o[e.name] = !0);
          }
          if (a.extensionsUsed)
            for (let t = 0; t < a.extensionsUsed.length; ++t) {
              const e = a.extensionsUsed[t],
                n = a.extensionsRequired || [];
              switch (e) {
                case Of.KHR_MATERIALS_UNLIT:
                  o[e] = new kf();
                  break;
                case Of.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  o[e] = new Yf();
                  break;
                case Of.KHR_DRACO_MESH_COMPRESSION:
                  o[e] = new Wf(a, this.dracoLoader);
                  break;
                case Of.KHR_TEXTURE_TRANSFORM:
                  o[e] = new qf();
                  break;
                case Of.KHR_MESH_QUANTIZATION:
                  o[e] = new Zf();
                  break;
                default:
                  n.indexOf(e) >= 0 &&
                    void 0 === s[e] &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + e + '".'
                    );
              }
            }
          l.setExtensions(o), l.setPlugins(s), l.parse(n, i);
        }
      }
      function Bf() {
        let t = {};
        return {
          get: function (e) {
            return t[e];
          },
          add: function (e, n) {
            t[e] = n;
          },
          remove: function (e) {
            delete t[e];
          },
          removeAll: function () {
            t = {};
          },
        };
      }
      const Of = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
          "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      };
      class Df {
        constructor(t) {
          (this.parser = t),
            (this.name = Of.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const t = this.parser,
            e = this.parser.json.nodes || [];
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            i.extensions &&
              i.extensions[this.name] &&
              void 0 !== i.extensions[this.name].light &&
              t._addNodeRef(this.cache, i.extensions[this.name].light);
          }
        }
        _loadLight(t) {
          const e = this.parser,
            n = "light:" + t;
          let i = e.cache.get(n);
          if (i) return i;
          const r = e.json,
            o = (((r.extensions && r.extensions[this.name]) || {}).lights ||
              [])[t];
          let s;
          const a = new Cr(16777215);
          void 0 !== o.color && a.fromArray(o.color);
          const l = void 0 !== o.range ? o.range : 0;
          switch (o.type) {
            case "directional":
              (s = new nd(a)), s.target.position.set(0, 0, -1), s.add(s.target);
              break;
            case "point":
              (s = new td(a)), (s.distance = l);
              break;
            case "spot":
              (s = new Zh(a)),
                (s.distance = l),
                (o.spot = o.spot || {}),
                (o.spot.innerConeAngle =
                  void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0),
                (o.spot.outerConeAngle =
                  void 0 !== o.spot.outerConeAngle
                    ? o.spot.outerConeAngle
                    : Math.PI / 4),
                (s.angle = o.spot.outerConeAngle),
                (s.penumbra =
                  1 - o.spot.innerConeAngle / o.spot.outerConeAngle),
                s.target.position.set(0, 0, -1),
                s.add(s.target);
              break;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unexpected light type: " + o.type
              );
          }
          return (
            s.position.set(0, 0, 0),
            (s.decay = 2),
            void 0 !== o.intensity && (s.intensity = o.intensity),
            (s.name = e.createUniqueName(o.name || "light_" + t)),
            (i = Promise.resolve(s)),
            e.cache.add(n, i),
            i
          );
        }
        createNodeAttachment(t) {
          const e = this,
            n = this.parser,
            i = n.json.nodes[t],
            r = ((i.extensions && i.extensions[this.name]) || {}).light;
          return void 0 === r
            ? null
            : this._loadLight(r).then(function (t) {
                return n._getNodeRef(e.cache, r, t);
              });
        }
      }
      class kf {
        constructor() {
          this.name = Of.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return Lr;
        }
        extendParams(t, e, n) {
          const i = [];
          (t.color = new Cr(1, 1, 1)), (t.opacity = 1);
          const r = e.pbrMetallicRoughness;
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const e = r.baseColorFactor;
              t.color.fromArray(e), (t.opacity = e[3]);
            }
            void 0 !== r.baseColorTexture &&
              i.push(n.assignTexture(t, "map", r.baseColorTexture));
          }
          return Promise.all(i);
        }
      }
      class Ff {
        constructor(t) {
          (this.parser = t), (this.name = Of.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t];
          return e.extensions && e.extensions[this.name] ? rh : null;
        }
        extendMaterialParams(t, e) {
          const n = this.parser,
            i = n.json.materials[t];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            o = i.extensions[this.name];
          if (
            (void 0 !== o.clearcoatFactor && (e.clearcoat = o.clearcoatFactor),
            void 0 !== o.clearcoatTexture &&
              r.push(n.assignTexture(e, "clearcoatMap", o.clearcoatTexture)),
            void 0 !== o.clearcoatRoughnessFactor &&
              (e.clearcoatRoughness = o.clearcoatRoughnessFactor),
            void 0 !== o.clearcoatRoughnessTexture &&
              r.push(
                n.assignTexture(
                  e,
                  "clearcoatRoughnessMap",
                  o.clearcoatRoughnessTexture
                )
              ),
            void 0 !== o.clearcoatNormalTexture &&
              (r.push(
                n.assignTexture(
                  e,
                  "clearcoatNormalMap",
                  o.clearcoatNormalTexture
                )
              ),
              void 0 !== o.clearcoatNormalTexture.scale))
          ) {
            const t = o.clearcoatNormalTexture.scale;
            e.clearcoatNormalScale = new Yn(t, -t);
          }
          return Promise.all(r);
        }
      }
      class zf {
        constructor(t) {
          (this.parser = t), (this.name = Of.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t];
          return e.extensions && e.extensions[this.name] ? rh : null;
        }
        extendMaterialParams(t, e) {
          const n = this.parser,
            i = n.json.materials[t];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            o = i.extensions[this.name];
          return (
            void 0 !== o.transmissionFactor &&
              (e.transmission = o.transmissionFactor),
            void 0 !== o.transmissionTexture &&
              r.push(
                n.assignTexture(e, "transmissionMap", o.transmissionTexture)
              ),
            Promise.all(r)
          );
        }
      }
      class Hf {
        constructor(t) {
          (this.parser = t), (this.name = Of.KHR_TEXTURE_BASISU);
        }
        loadTexture(t) {
          const e = this.parser,
            n = e.json,
            i = n.textures[t];
          if (!i.extensions || !i.extensions[this.name]) return null;
          const r = i.extensions[this.name],
            o = n.images[r.source],
            s = e.options.ktx2Loader;
          if (!s) {
            if (
              n.extensionsRequired &&
              n.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
              );
            return null;
          }
          return e.loadTextureImage(t, o, s);
        }
      }
      class Uf {
        constructor(t) {
          (this.parser = t),
            (this.name = Of.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        loadTexture(t) {
          const e = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[t];
          if (!r.extensions || !r.extensions[e]) return null;
          const o = r.extensions[e],
            s = i.images[o.source];
          let a = n.textureLoader;
          if (s.uri) {
            const t = n.options.manager.getHandler(s.uri);
            null !== t && (a = t);
          }
          return this.detectSupport().then(function (r) {
            if (r) return n.loadTextureImage(t, s, a);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
              throw new Error(
                "THREE.GLTFLoader: WebP required by asset but unsupported."
              );
            return n.loadTexture(t);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (t) {
                const e = new Image();
                (e.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (e.onload = e.onerror =
                    function () {
                      t(1 === e.height);
                    });
              })),
            this.isSupported
          );
        }
      }
      class Vf {
        constructor(t) {
          (this.name = Of.EXT_MESHOPT_COMPRESSION), (this.parser = t);
        }
        loadBufferView(t) {
          const e = this.parser.json,
            n = e.bufferViews[t];
          if (n.extensions && n.extensions[this.name]) {
            const t = n.extensions[this.name],
              i = this.parser.getDependency("buffer", t.buffer),
              r = this.parser.options.meshoptDecoder;
            if (!r || !r.supported) {
              if (
                e.extensionsRequired &&
                e.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                );
              return null;
            }
            return Promise.all([i, r.ready]).then(function (e) {
              const n = t.byteOffset || 0,
                i = t.byteLength || 0,
                o = t.count,
                s = t.byteStride,
                a = new ArrayBuffer(o * s),
                l = new Uint8Array(e[0], n, i);
              return (
                r.decodeGltfBuffer(
                  new Uint8Array(a),
                  o,
                  s,
                  l,
                  t.mode,
                  t.filter
                ),
                a
              );
            });
          }
          return null;
        }
      }
      const Gf = "glTF";
      class jf {
        constructor(t) {
          (this.name = Of.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          const e = new DataView(t, 0, 12);
          if (
            ((this.header = {
              magic: ld.decodeText(new Uint8Array(t.slice(0, 4))),
              version: e.getUint32(4, !0),
              length: e.getUint32(8, !0),
            }),
            this.header.magic !== Gf)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const n = this.header.length - 12,
            i = new DataView(t, 12);
          let r = 0;
          for (; r < n; ) {
            const e = i.getUint32(r, !0);
            r += 4;
            const n = i.getUint32(r, !0);
            if (((r += 4), 1313821514 === n)) {
              const n = new Uint8Array(t, 12 + r, e);
              this.content = ld.decodeText(n);
            } else if (5130562 === n) {
              const n = 12 + r;
              this.body = t.slice(n, n + e);
            }
            r += e;
          }
          if (null === this.content)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class Wf {
        constructor(t, e) {
          if (!e)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = Of.KHR_DRACO_MESH_COMPRESSION),
            (this.json = t),
            (this.dracoLoader = e),
            this.dracoLoader.preload();
        }
        decodePrimitive(t, e) {
          const n = this.json,
            i = this.dracoLoader,
            r = t.extensions[this.name].bufferView,
            o = t.extensions[this.name].attributes,
            s = {},
            a = {},
            l = {};
          for (const t in o) {
            const e = em[t] || t.toLowerCase();
            s[e] = o[t];
          }
          for (const e in t.attributes) {
            const i = em[e] || e.toLowerCase();
            if (void 0 !== o[e]) {
              const r = n.accessors[t.attributes[e]],
                o = Kf[r.componentType];
              (l[i] = o), (a[i] = !0 === r.normalized);
            }
          }
          return e.getDependency("bufferView", r).then(function (t) {
            return new Promise(function (e) {
              i.decodeDracoFile(
                t,
                function (t) {
                  for (const e in t.attributes) {
                    const n = t.attributes[e],
                      i = a[e];
                    void 0 !== i && (n.normalized = i);
                  }
                  e(t);
                },
                s,
                l
              );
            });
          });
        }
      }
      class qf {
        constructor() {
          this.name = Of.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(t, e) {
          return (
            void 0 !== e.texCoord &&
              console.warn(
                'THREE.GLTFLoader: Custom UV sets in "' +
                  this.name +
                  '" extension not yet supported.'
              ),
            (void 0 === e.offset &&
              void 0 === e.rotation &&
              void 0 === e.scale) ||
              ((t = t.clone()),
              void 0 !== e.offset && t.offset.fromArray(e.offset),
              void 0 !== e.rotation && (t.rotation = e.rotation),
              void 0 !== e.scale && t.repeat.fromArray(e.scale),
              (t.needsUpdate = !0)),
            t
          );
        }
      }
      class Xf extends ih {
        constructor(t) {
          super(), (this.isGLTFSpecularGlossinessMaterial = !0);
          const e = [
              "#ifdef USE_SPECULARMAP",
              "\tuniform sampler2D specularMap;",
              "#endif",
            ].join("\n"),
            n = [
              "#ifdef USE_GLOSSINESSMAP",
              "\tuniform sampler2D glossinessMap;",
              "#endif",
            ].join("\n"),
            i = [
              "vec3 specularFactor = specular;",
              "#ifdef USE_SPECULARMAP",
              "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
              "\ttexelSpecular = sRGBToLinear( texelSpecular );",
              "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "\tspecularFactor *= texelSpecular.rgb;",
              "#endif",
            ].join("\n"),
            r = [
              "float glossinessFactor = glossiness;",
              "#ifdef USE_GLOSSINESSMAP",
              "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
              "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
              "\tglossinessFactor *= texelGlossiness.a;",
              "#endif",
            ].join("\n"),
            o = [
              "PhysicalMaterial material;",
              "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
              "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
              "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
              "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
              "material.specularRoughness += geometryRoughness;",
              "material.specularRoughness = min( material.specularRoughness, 1.0 );",
              "material.specularColor = specularFactor;",
            ].join("\n"),
            s = {
              specular: { value: new Cr().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            };
          (this._extraUniforms = s),
            (this.onBeforeCompile = function (t) {
              for (const e in s) t.uniforms[e] = s[e];
              t.fragmentShader = t.fragmentShader
                .replace("uniform float roughness;", "uniform vec3 specular;")
                .replace(
                  "uniform float metalness;",
                  "uniform float glossiness;"
                )
                .replace("#include <roughnessmap_pars_fragment>", e)
                .replace("#include <metalnessmap_pars_fragment>", n)
                .replace("#include <roughnessmap_fragment>", i)
                .replace("#include <metalnessmap_fragment>", r)
                .replace("#include <lights_physical_fragment>", o);
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return s.specular.value;
                },
                set: function (t) {
                  s.specular.value = t;
                },
              },
              specularMap: {
                get: function () {
                  return s.specularMap.value;
                },
                set: function (t) {
                  (s.specularMap.value = t),
                    t
                      ? (this.defines.USE_SPECULARMAP = "")
                      : delete this.defines.USE_SPECULARMAP;
                },
              },
              glossiness: {
                get: function () {
                  return s.glossiness.value;
                },
                set: function (t) {
                  s.glossiness.value = t;
                },
              },
              glossinessMap: {
                get: function () {
                  return s.glossinessMap.value;
                },
                set: function (t) {
                  (s.glossinessMap.value = t),
                    t
                      ? ((this.defines.USE_GLOSSINESSMAP = ""),
                        (this.defines.USE_UV = ""))
                      : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV);
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.specularMap = t.specularMap),
            this.specular.copy(t.specular),
            (this.glossinessMap = t.glossinessMap),
            (this.glossiness = t.glossiness),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
          );
        }
      }
      class Yf {
        constructor() {
          (this.name = Of.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
            (this.specularGlossinessParams = [
              "color",
              "map",
              "lightMap",
              "lightMapIntensity",
              "aoMap",
              "aoMapIntensity",
              "emissive",
              "emissiveIntensity",
              "emissiveMap",
              "bumpMap",
              "bumpScale",
              "normalMap",
              "normalMapType",
              "displacementMap",
              "displacementScale",
              "displacementBias",
              "specularMap",
              "specular",
              "glossinessMap",
              "glossiness",
              "alphaMap",
              "envMap",
              "envMapIntensity",
              "refractionRatio",
            ]);
        }
        getMaterialType() {
          return Xf;
        }
        extendParams(t, e, n) {
          const i = e.extensions[this.name];
          (t.color = new Cr(1, 1, 1)), (t.opacity = 1);
          const r = [];
          if (Array.isArray(i.diffuseFactor)) {
            const e = i.diffuseFactor;
            t.color.fromArray(e), (t.opacity = e[3]);
          }
          if (
            (void 0 !== i.diffuseTexture &&
              r.push(n.assignTexture(t, "map", i.diffuseTexture)),
            (t.emissive = new Cr(0, 0, 0)),
            (t.glossiness =
              void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
            (t.specular = new Cr(1, 1, 1)),
            Array.isArray(i.specularFactor) &&
              t.specular.fromArray(i.specularFactor),
            void 0 !== i.specularGlossinessTexture)
          ) {
            const e = i.specularGlossinessTexture;
            r.push(n.assignTexture(t, "glossinessMap", e)),
              r.push(n.assignTexture(t, "specularMap", e));
          }
          return Promise.all(r);
        }
        createMaterial(t) {
          const e = new Xf(t);
          return (
            (e.fog = !0),
            (e.color = t.color),
            (e.map = void 0 === t.map ? null : t.map),
            (e.lightMap = null),
            (e.lightMapIntensity = 1),
            (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
            (e.aoMapIntensity = 1),
            (e.emissive = t.emissive),
            (e.emissiveIntensity = 1),
            (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
            (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
            (e.bumpScale = 1),
            (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
            (e.normalMapType = sn),
            t.normalScale && (e.normalScale = t.normalScale),
            (e.displacementMap = null),
            (e.displacementScale = 1),
            (e.displacementBias = 0),
            (e.specularMap = void 0 === t.specularMap ? null : t.specularMap),
            (e.specular = t.specular),
            (e.glossinessMap =
              void 0 === t.glossinessMap ? null : t.glossinessMap),
            (e.glossiness = t.glossiness),
            (e.alphaMap = null),
            (e.envMap = void 0 === t.envMap ? null : t.envMap),
            (e.envMapIntensity = 1),
            (e.refractionRatio = 0.98),
            e
          );
        }
      }
      class Zf {
        constructor() {
          this.name = Of.KHR_MESH_QUANTIZATION;
        }
      }
      class Jf extends ph {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        copySampleValue_(t) {
          const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = t * i * 3 + i;
          for (let t = 0; t !== i; t++) e[t] = n[r + t];
          return e;
        }
      }
      (Jf.prototype.beforeStart_ = Jf.prototype.copySampleValue_),
        (Jf.prototype.afterEnd_ = Jf.prototype.copySampleValue_),
        (Jf.prototype.interpolate_ = function (t, e, n, i) {
          const r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = 2 * s,
            l = 3 * s,
            c = i - e,
            u = (n - e) / c,
            h = u * u,
            d = h * u,
            p = t * l,
            f = p - l,
            m = -2 * d + 3 * h,
            g = d - h,
            v = 1 - m,
            y = g - h + u;
          for (let t = 0; t !== s; t++) {
            const e = o[f + t + s],
              n = o[f + t + a] * c,
              i = o[p + t + s],
              l = o[p + t] * c;
            r[t] = v * e + y * n + m * i + g * l;
          }
          return r;
        });
      const Kf = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        Qf = { 9728: pt, 9729: yt, 9984: ft, 9985: xt, 9986: gt, 9987: wt },
        $f = { 33071: ht, 33648: dt, 10497: ut },
        tm = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        em = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv2",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        nm = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences",
        },
        im = { CUBICSPLINE: void 0, LINEAR: ze, STEP: Fe };
      function rm(t, e) {
        return "string" != typeof t || "" === t
          ? ""
          : (/^https?:\/\//i.test(e) &&
              /^\//.test(t) &&
              (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(t) ||
            /^data:.*,.*$/i.test(t) ||
            /^blob:.*$/i.test(t)
              ? t
              : e + t);
      }
      function om(t, e, n) {
        for (const i in n.extensions)
          void 0 === t[i] &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[i] = n.extensions[i]));
      }
      function sm(t, e) {
        void 0 !== e.extras &&
          ("object" == typeof e.extras
            ? Object.assign(t.userData, e.extras)
            : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
              ));
      }
      function am(t, e) {
        if ((t.updateMorphTargets(), void 0 !== e.weights))
          for (let n = 0, i = e.weights.length; n < i; n++)
            t.morphTargetInfluences[n] = e.weights[n];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const n = e.extras.targetNames;
          if (t.morphTargetInfluences.length === n.length) {
            t.morphTargetDictionary = {};
            for (let e = 0, i = n.length; e < i; e++)
              t.morphTargetDictionary[n[e]] = e;
          } else
            console.warn(
              "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
            );
        }
      }
      function lm(t) {
        const e = t.extensions && t.extensions[Of.KHR_DRACO_MESH_COMPRESSION];
        let n;
        return (
          (n = e
            ? "draco:" + e.bufferView + ":" + e.indices + ":" + cm(e.attributes)
            : t.indices + ":" + cm(t.attributes) + ":" + t.mode),
          n
        );
      }
      function cm(t) {
        let e = "";
        const n = Object.keys(t).sort();
        for (let i = 0, r = n.length; i < r; i++)
          e += n[i] + ":" + t[n[i]] + ";";
        return e;
      }
      function um(t) {
        switch (t) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unsupported normalized accessor component type."
            );
        }
      }
      class hm {
        constructor(t = {}, e = {}) {
          (this.json = t),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = e),
            (this.cache = new Bf()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {}),
            "undefined" != typeof createImageBitmap &&
            !1 === /Firefox/.test(navigator.userAgent)
              ? (this.textureLoader = new gd(this.options.manager))
              : (this.textureLoader = new Fh(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new Nh(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            "use-credentials" === this.options.crossOrigin &&
              this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(t) {
          this.extensions = t;
        }
        setPlugins(t) {
          this.plugins = t;
        }
        parse(t, e) {
          const n = this,
            i = this.json,
            r = this.extensions;
          this.cache.removeAll(),
            this._invokeAll(function (t) {
              return t._markDefs && t._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (t) {
                return t.beforeRoot && t.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([
                  n.getDependencies("scene"),
                  n.getDependencies("animation"),
                  n.getDependencies("camera"),
                ]);
              })
              .then(function (e) {
                const o = {
                  scene: e[0][i.scene || 0],
                  scenes: e[0],
                  animations: e[1],
                  cameras: e[2],
                  asset: i.asset,
                  parser: n,
                  userData: {},
                };
                om(r, o, i),
                  sm(o, i),
                  Promise.all(
                    n._invokeAll(function (t) {
                      return t.afterRoot && t.afterRoot(o);
                    })
                  ).then(function () {
                    t(o);
                  });
              })
              .catch(e);
        }
        _markDefs() {
          const t = this.json.nodes || [],
            e = this.json.skins || [],
            n = this.json.meshes || [];
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n].joints;
            for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0;
          }
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e];
            void 0 !== i.mesh &&
              (this._addNodeRef(this.meshCache, i.mesh),
              void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
              void 0 !== i.camera &&
                this._addNodeRef(this.cameraCache, i.camera);
          }
        }
        _addNodeRef(t, e) {
          void 0 !== e &&
            (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
        }
        _getNodeRef(t, e, n) {
          if (t.refs[e] <= 1) return n;
          const i = n.clone();
          return (i.name += "_instance_" + t.uses[e]++), i;
        }
        _invokeOne(t) {
          const e = Object.values(this.plugins);
          e.push(this);
          for (let n = 0; n < e.length; n++) {
            const i = t(e[n]);
            if (i) return i;
          }
          return null;
        }
        _invokeAll(t) {
          const e = Object.values(this.plugins);
          e.unshift(this);
          const n = [];
          for (let i = 0; i < e.length; i++) {
            const r = t(e[i]);
            r && n.push(r);
          }
          return n;
        }
        getDependency(t, e) {
          const n = t + ":" + e;
          let i = this.cache.get(n);
          if (!i) {
            switch (t) {
              case "scene":
                i = this.loadScene(e);
                break;
              case "node":
                i = this.loadNode(e);
                break;
              case "mesh":
                i = this._invokeOne(function (t) {
                  return t.loadMesh && t.loadMesh(e);
                });
                break;
              case "accessor":
                i = this.loadAccessor(e);
                break;
              case "bufferView":
                i = this._invokeOne(function (t) {
                  return t.loadBufferView && t.loadBufferView(e);
                });
                break;
              case "buffer":
                i = this.loadBuffer(e);
                break;
              case "material":
                i = this._invokeOne(function (t) {
                  return t.loadMaterial && t.loadMaterial(e);
                });
                break;
              case "texture":
                i = this._invokeOne(function (t) {
                  return t.loadTexture && t.loadTexture(e);
                });
                break;
              case "skin":
                i = this.loadSkin(e);
                break;
              case "animation":
                i = this.loadAnimation(e);
                break;
              case "camera":
                i = this.loadCamera(e);
                break;
              default:
                throw new Error("Unknown type: " + t);
            }
            this.cache.add(n, i);
          }
          return i;
        }
        getDependencies(t) {
          let e = this.cache.get(t);
          if (!e) {
            const n = this,
              i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
            (e = Promise.all(
              i.map(function (e, i) {
                return n.getDependency(t, i);
              })
            )),
              this.cache.add(t, e);
          }
          return e;
        }
        loadBuffer(t) {
          const e = this.json.buffers[t],
            n = this.fileLoader;
          if (e.type && "arraybuffer" !== e.type)
            throw new Error(
              "THREE.GLTFLoader: " + e.type + " buffer type is not supported."
            );
          if (void 0 === e.uri && 0 === t)
            return Promise.resolve(this.extensions[Of.KHR_BINARY_GLTF].body);
          const i = this.options;
          return new Promise(function (t, r) {
            n.load(rm(e.uri, i.path), t, void 0, function () {
              r(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'
                )
              );
            });
          });
        }
        loadBufferView(t) {
          const e = this.json.bufferViews[t];
          return this.getDependency("buffer", e.buffer).then(function (t) {
            const n = e.byteLength || 0,
              i = e.byteOffset || 0;
            return t.slice(i, i + n);
          });
        }
        loadAccessor(t) {
          const e = this,
            n = this.json,
            i = this.json.accessors[t];
          if (void 0 === i.bufferView && void 0 === i.sparse)
            return Promise.resolve(null);
          const r = [];
          return (
            void 0 !== i.bufferView
              ? r.push(this.getDependency("bufferView", i.bufferView))
              : r.push(null),
            void 0 !== i.sparse &&
              (r.push(
                this.getDependency("bufferView", i.sparse.indices.bufferView)
              ),
              r.push(
                this.getDependency("bufferView", i.sparse.values.bufferView)
              )),
            Promise.all(r).then(function (t) {
              const r = t[0],
                o = tm[i.type],
                s = Kf[i.componentType],
                a = s.BYTES_PER_ELEMENT,
                l = a * o,
                c = i.byteOffset || 0,
                u =
                  void 0 !== i.bufferView
                    ? n.bufferViews[i.bufferView].byteStride
                    : void 0,
                h = !0 === i.normalized;
              let d, p;
              if (u && u !== l) {
                const t = Math.floor(c / u),
                  n =
                    "InterleavedBuffer:" +
                    i.bufferView +
                    ":" +
                    i.componentType +
                    ":" +
                    t +
                    ":" +
                    i.count;
                let l = e.cache.get(n);
                l ||
                  ((d = new s(r, t * u, (i.count * u) / a)),
                  (l = new Rl(d, u / a)),
                  e.cache.add(n, l)),
                  (p = new Nl(l, o, (c % u) / a, h));
              } else (d = null === r ? new s(i.count * o) : new s(r, c, i.count * o)), (p = new Nr(d, o, h));
              if (void 0 !== i.sparse) {
                const e = tm.SCALAR,
                  n = Kf[i.sparse.indices.componentType],
                  a = i.sparse.indices.byteOffset || 0,
                  l = i.sparse.values.byteOffset || 0,
                  c = new n(t[1], a, i.sparse.count * e),
                  u = new s(t[2], l, i.sparse.count * o);
                null !== r &&
                  (p = new Nr(p.array.slice(), p.itemSize, p.normalized));
                for (let t = 0, e = c.length; t < e; t++) {
                  const e = c[t];
                  if (
                    (p.setX(e, u[t * o]),
                    o >= 2 && p.setY(e, u[t * o + 1]),
                    o >= 3 && p.setZ(e, u[t * o + 2]),
                    o >= 4 && p.setW(e, u[t * o + 3]),
                    o >= 5)
                  )
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                    );
                }
              }
              return p;
            })
          );
        }
        loadTexture(t) {
          const e = this.json,
            n = this.options,
            i = e.textures[t],
            r = e.images[i.source];
          let o = this.textureLoader;
          if (r.uri) {
            const t = n.manager.getHandler(r.uri);
            null !== t && (o = t);
          }
          return this.loadTextureImage(t, r, o);
        }
        loadTextureImage(t, e, n) {
          const i = this,
            r = this.json,
            o = this.options,
            s = r.textures[t],
            a = (e.uri || e.bufferView) + ":" + s.sampler;
          if (this.textureCache[a]) return this.textureCache[a];
          const l = self.URL || self.webkitURL;
          let c = e.uri || "",
            u = !1,
            h = !0;
          const d =
            c.search(/\.jpe?g($|\?)/i) > 0 ||
            0 === c.search(/^data\:image\/jpeg/);
          if (
            (("image/jpeg" === e.mimeType || d) && (h = !1),
            void 0 !== e.bufferView)
          )
            c = i.getDependency("bufferView", e.bufferView).then(function (t) {
              if ("image/png" === e.mimeType) {
                const e = new DataView(t, 25, 1).getUint8(0, !1);
                h = 6 === e || 4 === e || 3 === e;
              }
              u = !0;
              const n = new Blob([t], { type: e.mimeType });
              return (c = l.createObjectURL(n)), c;
            });
          else if (void 0 === e.uri)
            throw new Error(
              "THREE.GLTFLoader: Image " + t + " is missing URI and bufferView"
            );
          const p = Promise.resolve(c)
            .then(function (t) {
              return new Promise(function (e, i) {
                let r = e;
                !0 === n.isImageBitmapLoader &&
                  (r = function (t) {
                    const n = new $n(t);
                    (n.needsUpdate = !0), e(n);
                  }),
                  n.load(rm(t, o.path), r, void 0, i);
              });
            })
            .then(function (e) {
              !0 === u && l.revokeObjectURL(c),
                (e.flipY = !1),
                s.name && (e.name = s.name),
                h || (e.format = Dt);
              const n = (r.samplers || {})[s.sampler] || {};
              return (
                (e.magFilter = Qf[n.magFilter] || yt),
                (e.minFilter = Qf[n.minFilter] || wt),
                (e.wrapS = $f[n.wrapS] || ut),
                (e.wrapT = $f[n.wrapT] || ut),
                i.associations.set(e, { type: "textures", index: t }),
                e
              );
            })
            .catch(function () {
              return (
                console.error("THREE.GLTFLoader: Couldn't load texture", c),
                null
              );
            });
          return (this.textureCache[a] = p), p;
        }
        assignTexture(t, e, n) {
          const i = this;
          return this.getDependency("texture", n.index).then(function (r) {
            if (
              (void 0 === n.texCoord ||
                0 == n.texCoord ||
                ("aoMap" === e && 1 == n.texCoord) ||
                console.warn(
                  "THREE.GLTFLoader: Custom UV set " +
                    n.texCoord +
                    " for texture " +
                    e +
                    " not yet supported."
                ),
              i.extensions[Of.KHR_TEXTURE_TRANSFORM])
            ) {
              const t =
                void 0 !== n.extensions
                  ? n.extensions[Of.KHR_TEXTURE_TRANSFORM]
                  : void 0;
              if (t) {
                const e = i.associations.get(r);
                (r = i.extensions[Of.KHR_TEXTURE_TRANSFORM].extendTexture(
                  r,
                  t
                )),
                  i.associations.set(r, e);
              }
            }
            t[e] = r;
          });
        }
        assignFinalMaterial(t) {
          const e = t.geometry;
          let n = t.material;
          const i = void 0 !== e.attributes.tangent,
            r = void 0 !== e.attributes.color,
            o = void 0 === e.attributes.normal,
            s = Object.keys(e.morphAttributes).length > 0,
            a = s && void 0 !== e.morphAttributes.normal;
          if (t.isPoints) {
            const t = "PointsMaterial:" + n.uuid;
            let e = this.cache.get(t);
            e ||
              ((e = new Ec()),
              wr.prototype.copy.call(e, n),
              e.color.copy(n.color),
              (e.map = n.map),
              (e.sizeAttenuation = !1),
              this.cache.add(t, e)),
              (n = e);
          } else if (t.isLine) {
            const t = "LineBasicMaterial:" + n.uuid;
            let e = this.cache.get(t);
            e ||
              ((e = new fc()),
              wr.prototype.copy.call(e, n),
              e.color.copy(n.color),
              this.cache.add(t, e)),
              (n = e);
          }
          if (i || r || o || s) {
            let t = "ClonedMaterial:" + n.uuid + ":";
            n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"),
              i && (t += "vertex-tangents:"),
              r && (t += "vertex-colors:"),
              o && (t += "flat-shading:"),
              s && (t += "morph-targets:"),
              a && (t += "morph-normals:");
            let e = this.cache.get(t);
            e ||
              ((e = n.clone()),
              r && (e.vertexColors = !0),
              o && (e.flatShading = !0),
              s && (e.morphTargets = !0),
              a && (e.morphNormals = !0),
              i &&
                ((e.vertexTangents = !0),
                e.normalScale && (e.normalScale.y *= -1),
                e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
              this.cache.add(t, e),
              this.associations.set(e, this.associations.get(n))),
              (n = e);
          }
          n.aoMap &&
            void 0 === e.attributes.uv2 &&
            void 0 !== e.attributes.uv &&
            e.setAttribute("uv2", e.attributes.uv),
            (t.material = n);
        }
        getMaterialType() {
          return ih;
        }
        loadMaterial(t) {
          const e = this,
            n = this.json,
            i = this.extensions,
            r = n.materials[t];
          let o;
          const s = {},
            a = r.extensions || {},
            l = [];
          if (a[Of.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const t = i[Of.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            (o = t.getMaterialType()), l.push(t.extendParams(s, r, e));
          } else if (a[Of.KHR_MATERIALS_UNLIT]) {
            const t = i[Of.KHR_MATERIALS_UNLIT];
            (o = t.getMaterialType()), l.push(t.extendParams(s, r, e));
          } else {
            const n = r.pbrMetallicRoughness || {};
            if (
              ((s.color = new Cr(1, 1, 1)),
              (s.opacity = 1),
              Array.isArray(n.baseColorFactor))
            ) {
              const t = n.baseColorFactor;
              s.color.fromArray(t), (s.opacity = t[3]);
            }
            void 0 !== n.baseColorTexture &&
              l.push(e.assignTexture(s, "map", n.baseColorTexture)),
              (s.metalness =
                void 0 !== n.metallicFactor ? n.metallicFactor : 1),
              (s.roughness =
                void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
              void 0 !== n.metallicRoughnessTexture &&
                (l.push(
                  e.assignTexture(s, "metalnessMap", n.metallicRoughnessTexture)
                ),
                l.push(
                  e.assignTexture(s, "roughnessMap", n.metallicRoughnessTexture)
                )),
              (o = this._invokeOne(function (e) {
                return e.getMaterialType && e.getMaterialType(t);
              })),
              l.push(
                Promise.all(
                  this._invokeAll(function (e) {
                    return (
                      e.extendMaterialParams && e.extendMaterialParams(t, s)
                    );
                  })
                )
              );
          }
          !0 === r.doubleSided && (s.side = m);
          const c = r.alphaMode || "OPAQUE";
          return (
            "BLEND" === c
              ? ((s.transparent = !0), (s.depthWrite = !1))
              : ((s.transparent = !1),
                "MASK" === c &&
                  (s.alphaTest =
                    void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
            void 0 !== r.normalTexture &&
              o !== Lr &&
              (l.push(e.assignTexture(s, "normalMap", r.normalTexture)),
              (s.normalScale = new Yn(1, -1)),
              void 0 !== r.normalTexture.scale &&
                s.normalScale.set(
                  r.normalTexture.scale,
                  -r.normalTexture.scale
                )),
            void 0 !== r.occlusionTexture &&
              o !== Lr &&
              (l.push(e.assignTexture(s, "aoMap", r.occlusionTexture)),
              void 0 !== r.occlusionTexture.strength &&
                (s.aoMapIntensity = r.occlusionTexture.strength)),
            void 0 !== r.emissiveFactor &&
              o !== Lr &&
              (s.emissive = new Cr().fromArray(r.emissiveFactor)),
            void 0 !== r.emissiveTexture &&
              o !== Lr &&
              l.push(e.assignTexture(s, "emissiveMap", r.emissiveTexture)),
            Promise.all(l).then(function () {
              let n;
              return (
                (n =
                  o === Xf
                    ? i[
                        Of.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                      ].createMaterial(s)
                    : new o(s)),
                r.name && (n.name = r.name),
                n.map && (n.map.encoding = Je),
                n.emissiveMap && (n.emissiveMap.encoding = Je),
                sm(n, r),
                e.associations.set(n, { type: "materials", index: t }),
                r.extensions && om(i, n, r),
                n
              );
            })
          );
        }
        createUniqueName(t) {
          const e = $d.sanitizeNodeName(t || "");
          let n = e;
          for (let t = 1; this.nodeNamesUsed[n]; ++t) n = e + "_" + t;
          return (this.nodeNamesUsed[n] = !0), n;
        }
        loadGeometries(t) {
          const e = this,
            n = this.extensions,
            i = this.primitiveCache;
          function r(t) {
            return n[Of.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(t, e)
              .then(function (n) {
                return pm(n, t, e);
              });
          }
          const o = [];
          for (let n = 0, s = t.length; n < s; n++) {
            const s = t[n],
              a = lm(s),
              l = i[a];
            if (l) o.push(l.promise);
            else {
              let t;
              (t =
                s.extensions && s.extensions[Of.KHR_DRACO_MESH_COMPRESSION]
                  ? r(s)
                  : pm(new $r(), s, e)),
                (i[a] = { primitive: s, promise: t }),
                o.push(t);
            }
          }
          return Promise.all(o);
        }
        loadMesh(t) {
          const e = this,
            n = this.json,
            i = this.extensions,
            r = n.meshes[t],
            o = r.primitives,
            s = [];
          for (let t = 0, e = o.length; t < e; t++) {
            const e =
              void 0 === o[t].material
                ? (void 0 === (a = this.cache).DefaultMaterial &&
                    (a.DefaultMaterial = new ih({
                      color: 16777215,
                      emissive: 0,
                      metalness: 1,
                      roughness: 1,
                      transparent: !1,
                      depthTest: !0,
                      side: p,
                    })),
                  a.DefaultMaterial)
                : this.getDependency("material", o[t].material);
            s.push(e);
          }
          var a;
          return (
            s.push(e.loadGeometries(o)),
            Promise.all(s).then(function (n) {
              const s = n.slice(0, n.length - 1),
                a = n[n.length - 1],
                l = [];
              for (let n = 0, c = a.length; n < c; n++) {
                const c = a[n],
                  u = o[n];
                let h;
                const d = s[n];
                if (
                  4 === u.mode ||
                  5 === u.mode ||
                  6 === u.mode ||
                  void 0 === u.mode
                )
                  (h = !0 === r.isSkinnedMesh ? new ic(c, d) : new xo(c, d)),
                    !0 !== h.isSkinnedMesh ||
                      h.geometry.attributes.skinWeight.normalized ||
                      h.normalizeSkinWeights(),
                    5 === u.mode
                      ? (h.geometry = fm(h.geometry, Xe))
                      : 6 === u.mode && (h.geometry = fm(h.geometry, Ye));
                else if (1 === u.mode) h = new Mc(c, d);
                else if (3 === u.mode) h = new bc(c, d);
                else if (2 === u.mode) h = new Sc(c, d);
                else {
                  if (0 !== u.mode)
                    throw new Error(
                      "THREE.GLTFLoader: Primitive mode unsupported: " + u.mode
                    );
                  h = new Rc(c, d);
                }
                Object.keys(h.geometry.morphAttributes).length > 0 && am(h, r),
                  (h.name = e.createUniqueName(r.name || "mesh_" + t)),
                  sm(h, r),
                  u.extensions && om(i, h, u),
                  e.assignFinalMaterial(h),
                  l.push(h);
              }
              if (1 === l.length) return l[0];
              const c = new bl();
              for (let t = 0, e = l.length; t < e; t++) c.add(l[t]);
              return c;
            })
          );
        }
        loadCamera(t) {
          let e;
          const n = this.json.cameras[t],
            i = n[n.type];
          if (i)
            return (
              "perspective" === n.type
                ? (e = new Ao(
                    Xn.radToDeg(i.yfov),
                    i.aspectRatio || 1,
                    i.znear || 1,
                    i.zfar || 2e6
                  ))
                : "orthographic" === n.type &&
                  (e = new Ko(
                    -i.xmag,
                    i.xmag,
                    i.ymag,
                    -i.ymag,
                    i.znear,
                    i.zfar
                  )),
              n.name && (e.name = this.createUniqueName(n.name)),
              sm(e, n),
              Promise.resolve(e)
            );
          console.warn("THREE.GLTFLoader: Missing camera parameters.");
        }
        loadSkin(t) {
          const e = this.json.skins[t],
            n = { joints: e.joints };
          return void 0 === e.inverseBindMatrices
            ? Promise.resolve(n)
            : this.getDependency("accessor", e.inverseBindMatrices).then(
                function (t) {
                  return (n.inverseBindMatrices = t), n;
                }
              );
        }
        loadAnimation(t) {
          const e = this.json.animations[t],
            n = [],
            i = [],
            r = [],
            o = [],
            s = [];
          for (let t = 0, a = e.channels.length; t < a; t++) {
            const a = e.channels[t],
              l = e.samplers[a.sampler],
              c = a.target,
              u = void 0 !== c.node ? c.node : c.id,
              h = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
              d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
            n.push(this.getDependency("node", u)),
              i.push(this.getDependency("accessor", h)),
              r.push(this.getDependency("accessor", d)),
              o.push(l),
              s.push(c);
          }
          return Promise.all([
            Promise.all(n),
            Promise.all(i),
            Promise.all(r),
            Promise.all(o),
            Promise.all(s),
          ]).then(function (n) {
            const i = n[0],
              r = n[1],
              o = n[2],
              s = n[3],
              a = n[4],
              l = [];
            for (let t = 0, e = i.length; t < e; t++) {
              const e = i[t],
                n = r[t],
                c = o[t],
                u = s[t],
                h = a[t];
              if (void 0 === e) continue;
              let d;
              switch (
                (e.updateMatrix(), (e.matrixAutoUpdate = !0), nm[h.path])
              ) {
                case nm.weights:
                  d = bh;
                  break;
                case nm.rotation:
                  d = _h;
                  break;
                case nm.position:
                case nm.scale:
                default:
                  d = Sh;
              }
              const p = e.name ? e.name : e.uuid,
                f = void 0 !== u.interpolation ? im[u.interpolation] : ze,
                m = [];
              nm[h.path] === nm.weights
                ? e.traverse(function (t) {
                    !0 === t.isMesh &&
                      t.morphTargetInfluences &&
                      m.push(t.name ? t.name : t.uuid);
                  })
                : m.push(p);
              let g = c.array;
              if (c.normalized) {
                const t = um(g.constructor),
                  e = new Float32Array(g.length);
                for (let n = 0, i = g.length; n < i; n++) e[n] = g[n] * t;
                g = e;
              }
              for (let t = 0, e = m.length; t < e; t++) {
                const e = new d(m[t] + "." + nm[h.path], n.array, g, f);
                "CUBICSPLINE" === u.interpolation &&
                  ((e.createInterpolant = function (t) {
                    return new Jf(
                      this.times,
                      this.values,
                      this.getValueSize() / 3,
                      t
                    );
                  }),
                  (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                    !0)),
                  l.push(e);
              }
            }
            const c = e.name ? e.name : "animation_" + t;
            return new Eh(c, void 0, l);
          });
        }
        createNodeMesh(t) {
          const e = this.json,
            n = this,
            i = e.nodes[t];
          return void 0 === i.mesh
            ? null
            : n.getDependency("mesh", i.mesh).then(function (t) {
                const e = n._getNodeRef(n.meshCache, i.mesh, t);
                return (
                  void 0 !== i.weights &&
                    e.traverse(function (t) {
                      if (t.isMesh)
                        for (let e = 0, n = i.weights.length; e < n; e++)
                          t.morphTargetInfluences[e] = i.weights[e];
                    }),
                  e
                );
              });
        }
        loadNode(t) {
          const e = this.json,
            n = this.extensions,
            i = this,
            r = e.nodes[t],
            o = r.name ? i.createUniqueName(r.name) : "";
          return (function () {
            const e = [],
              n = i._invokeOne(function (e) {
                return e.createNodeMesh && e.createNodeMesh(t);
              });
            return (
              n && e.push(n),
              void 0 !== r.camera &&
                e.push(
                  i.getDependency("camera", r.camera).then(function (t) {
                    return i._getNodeRef(i.cameraCache, r.camera, t);
                  })
                ),
              i
                ._invokeAll(function (e) {
                  return e.createNodeAttachment && e.createNodeAttachment(t);
                })
                .forEach(function (t) {
                  e.push(t);
                }),
              Promise.all(e)
            );
          })().then(function (e) {
            let s;
            if (
              ((s =
                !0 === r.isBone
                  ? new rc()
                  : e.length > 1
                  ? new bl()
                  : 1 === e.length
                  ? e[0]
                  : new lr()),
              s !== e[0])
            )
              for (let t = 0, n = e.length; t < n; t++) s.add(e[t]);
            if (
              (r.name && ((s.userData.name = r.name), (s.name = o)),
              sm(s, r),
              r.extensions && om(n, s, r),
              void 0 !== r.matrix)
            ) {
              const t = new ki();
              t.fromArray(r.matrix), s.applyMatrix4(t);
            } else void 0 !== r.translation && s.position.fromArray(r.translation), void 0 !== r.rotation && s.quaternion.fromArray(r.rotation), void 0 !== r.scale && s.scale.fromArray(r.scale);
            return i.associations.set(s, { type: "nodes", index: t }), s;
          });
        }
        loadScene(t) {
          const e = this.json,
            n = this.extensions,
            i = this.json.scenes[t],
            r = this,
            o = new bl();
          i.name && (o.name = r.createUniqueName(i.name)),
            sm(o, i),
            i.extensions && om(n, o, i);
          const s = i.nodes || [],
            a = [];
          for (let t = 0, n = s.length; t < n; t++) a.push(dm(s[t], o, e, r));
          return Promise.all(a).then(function () {
            return o;
          });
        }
      }
      function dm(t, e, n, i) {
        const r = n.nodes[t];
        return i
          .getDependency("node", t)
          .then(function (t) {
            if (void 0 === r.skin) return t;
            let e;
            return i
              .getDependency("skin", r.skin)
              .then(function (t) {
                e = t;
                const n = [];
                for (let t = 0, r = e.joints.length; t < r; t++)
                  n.push(i.getDependency("node", e.joints[t]));
                return Promise.all(n);
              })
              .then(function (n) {
                return (
                  t.traverse(function (t) {
                    if (!t.isMesh) return;
                    const i = [],
                      r = [];
                    for (let t = 0, o = n.length; t < o; t++) {
                      const o = n[t];
                      if (o) {
                        i.push(o);
                        const n = new ki();
                        void 0 !== e.inverseBindMatrices &&
                          n.fromArray(e.inverseBindMatrices.array, 16 * t),
                          r.push(n);
                      } else
                        console.warn(
                          'THREE.GLTFLoader: Joint "%s" could not be found.',
                          e.joints[t]
                        );
                    }
                    t.bind(new lc(i, r), t.matrixWorld);
                  }),
                  t
                );
              });
          })
          .then(function (t) {
            e.add(t);
            const o = [];
            if (r.children) {
              const e = r.children;
              for (let r = 0, s = e.length; r < s; r++) {
                const s = e[r];
                o.push(dm(s, t, n, i));
              }
            }
            return Promise.all(o);
          });
      }
      function pm(t, e, n) {
        const i = e.attributes,
          r = [];
        function o(e, i) {
          return n.getDependency("accessor", e).then(function (e) {
            t.setAttribute(i, e);
          });
        }
        for (const e in i) {
          const n = em[e] || e.toLowerCase();
          n in t.attributes || r.push(o(i[e], n));
        }
        if (void 0 !== e.indices && !t.index) {
          const i = n.getDependency("accessor", e.indices).then(function (e) {
            t.setIndex(e);
          });
          r.push(i);
        }
        return (
          sm(t, e),
          (function (t, e, n) {
            const i = e.attributes,
              r = new ci();
            if (void 0 === i.POSITION) return;
            {
              const t = n.json.accessors[i.POSITION],
                e = t.min,
                o = t.max;
              if (void 0 === e || void 0 === o)
                return void console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
              if (
                (r.set(new si(e[0], e[1], e[2]), new si(o[0], o[1], o[2])),
                t.normalized)
              ) {
                const e = um(Kf[t.componentType]);
                r.min.multiplyScalar(e), r.max.multiplyScalar(e);
              }
            }
            const o = e.targets;
            if (void 0 !== o) {
              const t = new si(),
                e = new si();
              for (let i = 0, r = o.length; i < r; i++) {
                const r = o[i];
                if (void 0 !== r.POSITION) {
                  const i = n.json.accessors[r.POSITION],
                    o = i.min,
                    s = i.max;
                  if (void 0 !== o && void 0 !== s) {
                    if (
                      (e.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))),
                      e.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))),
                      e.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))),
                      i.normalized)
                    ) {
                      const t = um(Kf[i.componentType]);
                      e.multiplyScalar(t);
                    }
                    t.max(e);
                  } else
                    console.warn(
                      "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                    );
                }
              }
              r.expandByVector(t);
            }
            t.boundingBox = r;
            const s = new Ci();
            r.getCenter(s.center),
              (s.radius = r.min.distanceTo(r.max) / 2),
              (t.boundingSphere = s);
          })(t, e, n),
          Promise.all(r).then(function () {
            return void 0 !== e.targets
              ? (function (t, e, n) {
                  let i = !1,
                    r = !1;
                  for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t];
                    if (
                      (void 0 !== n.POSITION && (i = !0),
                      void 0 !== n.NORMAL && (r = !0),
                      i && r)
                    )
                      break;
                  }
                  if (!i && !r) return Promise.resolve(t);
                  const o = [],
                    s = [];
                  for (let a = 0, l = e.length; a < l; a++) {
                    const l = e[a];
                    if (i) {
                      const e =
                        void 0 !== l.POSITION
                          ? n.getDependency("accessor", l.POSITION)
                          : t.attributes.position;
                      o.push(e);
                    }
                    if (r) {
                      const e =
                        void 0 !== l.NORMAL
                          ? n.getDependency("accessor", l.NORMAL)
                          : t.attributes.normal;
                      s.push(e);
                    }
                  }
                  return Promise.all([Promise.all(o), Promise.all(s)]).then(
                    function (e) {
                      const n = e[0],
                        o = e[1];
                      return (
                        i && (t.morphAttributes.position = n),
                        r && (t.morphAttributes.normal = o),
                        (t.morphTargetsRelative = !0),
                        t
                      );
                    }
                  );
                })(t, e.targets, n)
              : t;
          })
        );
      }
      function fm(t, e) {
        let n = t.getIndex();
        if (null === n) {
          const e = [],
            i = t.getAttribute("position");
          if (void 0 === i)
            return (
              console.error(
                "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
              ),
              t
            );
          for (let t = 0; t < i.count; t++) e.push(t);
          t.setIndex(e), (n = t.getIndex());
        }
        const i = n.count - 2,
          r = [];
        if (e === Ye)
          for (let t = 1; t <= i; t++)
            r.push(n.getX(0)), r.push(n.getX(t)), r.push(n.getX(t + 1));
        else
          for (let t = 0; t < i; t++)
            t % 2 == 0
              ? (r.push(n.getX(t)),
                r.push(n.getX(t + 1)),
                r.push(n.getX(t + 2)))
              : (r.push(n.getX(t + 2)),
                r.push(n.getX(t + 1)),
                r.push(n.getX(t)));
        r.length / 3 !== i &&
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
          );
        const o = t.clone();
        return o.setIndex(r), o;
      }
      n(873);
      const mm = { type: "change" },
        gm = { type: "start" },
        vm = { type: "end" };
      class ym extends On {
        constructor(t, e) {
          super(),
            void 0 === e &&
              console.warn(
                'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
              ),
            e === document &&
              console.error(
                'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
              ),
            (this.object = t),
            (this.domElement = e),
            (this.domElement.style.touchAction = "none"),
            (this.enabled = !0),
            (this.target = new si()),
            (this.minDistance = 0),
            (this.maxDistance = 1 / 0),
            (this.minZoom = 0),
            (this.maxZoom = 1 / 0),
            (this.minPolarAngle = 0),
            (this.maxPolarAngle = Math.PI),
            (this.minAzimuthAngle = -1 / 0),
            (this.maxAzimuthAngle = 1 / 0),
            (this.enableDamping = !1),
            (this.dampingFactor = 0.05),
            (this.enableZoom = !0),
            (this.zoomSpeed = 1),
            (this.enableRotate = !0),
            (this.rotateSpeed = 1),
            (this.enablePan = !0),
            (this.panSpeed = 1),
            (this.screenSpacePanning = !0),
            (this.keyPanSpeed = 7),
            (this.autoRotate = !1),
            (this.autoRotateSpeed = 2),
            (this.keys = {
              LEFT: "ArrowLeft",
              UP: "ArrowUp",
              RIGHT: "ArrowRight",
              BOTTOM: "ArrowDown",
            }),
            (this.mouseButtons = {
              LEFT: i.ROTATE,
              MIDDLE: i.DOLLY,
              RIGHT: i.PAN,
            }),
            (this.touches = { ONE: r.ROTATE, TWO: r.DOLLY_PAN }),
            (this.target0 = this.target.clone()),
            (this.position0 = this.object.position.clone()),
            (this.zoom0 = this.object.zoom),
            (this._domElementKeyEvents = null),
            (this.getPolarAngle = function () {
              return l.phi;
            }),
            (this.getAzimuthalAngle = function () {
              return l.theta;
            }),
            (this.getDistance = function () {
              return this.object.position.distanceTo(this.target);
            }),
            (this.listenToKeyEvents = function (t) {
              t.addEventListener("keydown", W), (this._domElementKeyEvents = t);
            }),
            (this.saveState = function () {
              n.target0.copy(n.target),
                n.position0.copy(n.object.position),
                (n.zoom0 = n.object.zoom);
            }),
            (this.reset = function () {
              n.target.copy(n.target0),
                n.object.position.copy(n.position0),
                (n.object.zoom = n.zoom0),
                n.object.updateProjectionMatrix(),
                n.dispatchEvent(mm),
                n.update(),
                (s = o.NONE);
            }),
            (this.update = (function () {
              const e = new si(),
                i = new oi().setFromUnitVectors(t.up, new si(0, 1, 0)),
                r = i.clone().invert(),
                p = new si(),
                f = new oi(),
                m = 2 * Math.PI;
              return function () {
                const t = n.object.position;
                e.copy(t).sub(n.target),
                  e.applyQuaternion(i),
                  l.setFromVector3(e),
                  n.autoRotate &&
                    s === o.NONE &&
                    E(((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed),
                  n.enableDamping
                    ? ((l.theta += c.theta * n.dampingFactor),
                      (l.phi += c.phi * n.dampingFactor))
                    : ((l.theta += c.theta), (l.phi += c.phi));
                let g = n.minAzimuthAngle,
                  v = n.maxAzimuthAngle;
                return (
                  isFinite(g) &&
                    isFinite(v) &&
                    (g < -Math.PI ? (g += m) : g > Math.PI && (g -= m),
                    v < -Math.PI ? (v += m) : v > Math.PI && (v -= m),
                    (l.theta =
                      g <= v
                        ? Math.max(g, Math.min(v, l.theta))
                        : l.theta > (g + v) / 2
                        ? Math.max(g, l.theta)
                        : Math.min(v, l.theta))),
                  (l.phi = Math.max(
                    n.minPolarAngle,
                    Math.min(n.maxPolarAngle, l.phi)
                  )),
                  l.makeSafe(),
                  (l.radius *= u),
                  (l.radius = Math.max(
                    n.minDistance,
                    Math.min(n.maxDistance, l.radius)
                  )),
                  !0 === n.enableDamping
                    ? n.target.addScaledVector(h, n.dampingFactor)
                    : n.target.add(h),
                  e.setFromSpherical(l),
                  e.applyQuaternion(r),
                  t.copy(n.target).add(e),
                  n.object.lookAt(n.target),
                  !0 === n.enableDamping
                    ? ((c.theta *= 1 - n.dampingFactor),
                      (c.phi *= 1 - n.dampingFactor),
                      h.multiplyScalar(1 - n.dampingFactor))
                    : (c.set(0, 0, 0), h.set(0, 0, 0)),
                  (u = 1),
                  !!(
                    d ||
                    p.distanceToSquared(n.object.position) > a ||
                    8 * (1 - f.dot(n.object.quaternion)) > a
                  ) &&
                    (n.dispatchEvent(mm),
                    p.copy(n.object.position),
                    f.copy(n.object.quaternion),
                    (d = !1),
                    !0)
                );
              };
            })()),
            (this.dispose = function () {
              n.domElement.removeEventListener("contextmenu", q),
                n.domElement.removeEventListener("pointerdown", H),
                n.domElement.removeEventListener("pointercancel", G),
                n.domElement.removeEventListener("wheel", j),
                n.domElement.removeEventListener("pointermove", U),
                n.domElement.removeEventListener("pointerup", V),
                null !== n._domElementKeyEvents &&
                  n._domElementKeyEvents.removeEventListener("keydown", W);
            });
          const n = this,
            o = {
              NONE: -1,
              ROTATE: 0,
              DOLLY: 1,
              PAN: 2,
              TOUCH_ROTATE: 3,
              TOUCH_PAN: 4,
              TOUCH_DOLLY_PAN: 5,
              TOUCH_DOLLY_ROTATE: 6,
            };
          let s = o.NONE;
          const a = 1e-6,
            l = new cp(),
            c = new cp();
          let u = 1;
          const h = new si();
          let d = !1;
          const p = new Yn(),
            f = new Yn(),
            m = new Yn(),
            g = new Yn(),
            v = new Yn(),
            y = new Yn(),
            x = new Yn(),
            b = new Yn(),
            w = new Yn(),
            _ = [],
            M = {};
          function S() {
            return Math.pow(0.95, n.zoomSpeed);
          }
          function E(t) {
            c.theta -= t;
          }
          function T(t) {
            c.phi -= t;
          }
          const A = (function () {
              const t = new si();
              return function (e, n) {
                t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), h.add(t);
              };
            })(),
            C = (function () {
              const t = new si();
              return function (e, i) {
                !0 === n.screenSpacePanning
                  ? t.setFromMatrixColumn(i, 1)
                  : (t.setFromMatrixColumn(i, 0),
                    t.crossVectors(n.object.up, t)),
                  t.multiplyScalar(e),
                  h.add(t);
              };
            })(),
            L = (function () {
              const t = new si();
              return function (e, i) {
                const r = n.domElement;
                if (n.object.isPerspectiveCamera) {
                  const o = n.object.position;
                  t.copy(o).sub(n.target);
                  let s = t.length();
                  (s *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
                    A((2 * e * s) / r.clientHeight, n.object.matrix),
                    C((2 * i * s) / r.clientHeight, n.object.matrix);
                } else
                  n.object.isOrthographicCamera
                    ? (A(
                        (e * (n.object.right - n.object.left)) /
                          n.object.zoom /
                          r.clientWidth,
                        n.object.matrix
                      ),
                      C(
                        (i * (n.object.top - n.object.bottom)) /
                          n.object.zoom /
                          r.clientHeight,
                        n.object.matrix
                      ))
                    : (console.warn(
                        "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                      ),
                      (n.enablePan = !1));
              };
            })();
          function R(t) {
            n.object.isPerspectiveCamera
              ? (u /= t)
              : n.object.isOrthographicCamera
              ? ((n.object.zoom = Math.max(
                  n.minZoom,
                  Math.min(n.maxZoom, n.object.zoom * t)
                )),
                n.object.updateProjectionMatrix(),
                (d = !0))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                ),
                (n.enableZoom = !1));
          }
          function P(t) {
            n.object.isPerspectiveCamera
              ? (u *= t)
              : n.object.isOrthographicCamera
              ? ((n.object.zoom = Math.max(
                  n.minZoom,
                  Math.min(n.maxZoom, n.object.zoom / t)
                )),
                n.object.updateProjectionMatrix(),
                (d = !0))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                ),
                (n.enableZoom = !1));
          }
          function N(t) {
            p.set(t.clientX, t.clientY);
          }
          function I(t) {
            g.set(t.clientX, t.clientY);
          }
          function B() {
            if (1 === _.length) p.set(_[0].pageX, _[0].pageY);
            else {
              const t = 0.5 * (_[0].pageX + _[1].pageX),
                e = 0.5 * (_[0].pageY + _[1].pageY);
              p.set(t, e);
            }
          }
          function O() {
            if (1 === _.length) g.set(_[0].pageX, _[0].pageY);
            else {
              const t = 0.5 * (_[0].pageX + _[1].pageX),
                e = 0.5 * (_[0].pageY + _[1].pageY);
              g.set(t, e);
            }
          }
          function D() {
            const t = _[0].pageX - _[1].pageX,
              e = _[0].pageY - _[1].pageY,
              n = Math.sqrt(t * t + e * e);
            x.set(0, n);
          }
          function k(t) {
            if (1 == _.length) f.set(t.pageX, t.pageY);
            else {
              const e = Z(t),
                n = 0.5 * (t.pageX + e.x),
                i = 0.5 * (t.pageY + e.y);
              f.set(n, i);
            }
            m.subVectors(f, p).multiplyScalar(n.rotateSpeed);
            const e = n.domElement;
            E((2 * Math.PI * m.x) / e.clientHeight),
              T((2 * Math.PI * m.y) / e.clientHeight),
              p.copy(f);
          }
          function F(t) {
            if (1 === _.length) v.set(t.pageX, t.pageY);
            else {
              const e = Z(t),
                n = 0.5 * (t.pageX + e.x),
                i = 0.5 * (t.pageY + e.y);
              v.set(n, i);
            }
            y.subVectors(v, g).multiplyScalar(n.panSpeed),
              L(y.x, y.y),
              g.copy(v);
          }
          function z(t) {
            const e = Z(t),
              i = t.pageX - e.x,
              r = t.pageY - e.y,
              o = Math.sqrt(i * i + r * r);
            b.set(0, o),
              w.set(0, Math.pow(b.y / x.y, n.zoomSpeed)),
              R(w.y),
              x.copy(b);
          }
          function H(t) {
            !1 !== n.enabled &&
              (0 === _.length &&
                (n.domElement.setPointerCapture(t.pointerId),
                n.domElement.addEventListener("pointermove", U),
                n.domElement.addEventListener("pointerup", V)),
              (function (t) {
                _.push(t);
              })(t),
              "touch" === t.pointerType
                ? (function (t) {
                    switch ((Y(t), _.length)) {
                      case 1:
                        switch (n.touches.ONE) {
                          case r.ROTATE:
                            if (!1 === n.enableRotate) return;
                            B(), (s = o.TOUCH_ROTATE);
                            break;
                          case r.PAN:
                            if (!1 === n.enablePan) return;
                            O(), (s = o.TOUCH_PAN);
                            break;
                          default:
                            s = o.NONE;
                        }
                        break;
                      case 2:
                        switch (n.touches.TWO) {
                          case r.DOLLY_PAN:
                            if (!1 === n.enableZoom && !1 === n.enablePan)
                              return;
                            n.enableZoom && D(),
                              n.enablePan && O(),
                              (s = o.TOUCH_DOLLY_PAN);
                            break;
                          case r.DOLLY_ROTATE:
                            if (!1 === n.enableZoom && !1 === n.enableRotate)
                              return;
                            n.enableZoom && D(),
                              n.enableRotate && B(),
                              (s = o.TOUCH_DOLLY_ROTATE);
                            break;
                          default:
                            s = o.NONE;
                        }
                        break;
                      default:
                        s = o.NONE;
                    }
                    s !== o.NONE && n.dispatchEvent(gm);
                  })(t)
                : (function (t) {
                    let e;
                    switch (t.button) {
                      case 0:
                        e = n.mouseButtons.LEFT;
                        break;
                      case 1:
                        e = n.mouseButtons.MIDDLE;
                        break;
                      case 2:
                        e = n.mouseButtons.RIGHT;
                        break;
                      default:
                        e = -1;
                    }
                    switch (e) {
                      case i.DOLLY:
                        if (!1 === n.enableZoom) return;
                        !(function (t) {
                          x.set(t.clientX, t.clientY);
                        })(t),
                          (s = o.DOLLY);
                        break;
                      case i.ROTATE:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                          if (!1 === n.enablePan) return;
                          I(t), (s = o.PAN);
                        } else {
                          if (!1 === n.enableRotate) return;
                          N(t), (s = o.ROTATE);
                        }
                        break;
                      case i.PAN:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                          if (!1 === n.enableRotate) return;
                          N(t), (s = o.ROTATE);
                        } else {
                          if (!1 === n.enablePan) return;
                          I(t), (s = o.PAN);
                        }
                        break;
                      default:
                        s = o.NONE;
                    }
                    s !== o.NONE && n.dispatchEvent(gm);
                  })(t));
          }
          function U(t) {
            !1 !== n.enabled &&
              ("touch" === t.pointerType
                ? (function (t) {
                    switch ((Y(t), s)) {
                      case o.TOUCH_ROTATE:
                        if (!1 === n.enableRotate) return;
                        k(t), n.update();
                        break;
                      case o.TOUCH_PAN:
                        if (!1 === n.enablePan) return;
                        F(t), n.update();
                        break;
                      case o.TOUCH_DOLLY_PAN:
                        if (!1 === n.enableZoom && !1 === n.enablePan) return;
                        !(function (t) {
                          n.enableZoom && z(t), n.enablePan && F(t);
                        })(t),
                          n.update();
                        break;
                      case o.TOUCH_DOLLY_ROTATE:
                        if (!1 === n.enableZoom && !1 === n.enableRotate)
                          return;
                        !(function (t) {
                          n.enableZoom && z(t), n.enableRotate && k(t);
                        })(t),
                          n.update();
                        break;
                      default:
                        s = o.NONE;
                    }
                  })(t)
                : (function (t) {
                    if (!1 !== n.enabled)
                      switch (s) {
                        case o.ROTATE:
                          if (!1 === n.enableRotate) return;
                          !(function (t) {
                            f.set(t.clientX, t.clientY),
                              m.subVectors(f, p).multiplyScalar(n.rotateSpeed);
                            const e = n.domElement;
                            E((2 * Math.PI * m.x) / e.clientHeight),
                              T((2 * Math.PI * m.y) / e.clientHeight),
                              p.copy(f),
                              n.update();
                          })(t);
                          break;
                        case o.DOLLY:
                          if (!1 === n.enableZoom) return;
                          !(function (t) {
                            b.set(t.clientX, t.clientY),
                              w.subVectors(b, x),
                              w.y > 0 ? R(S()) : w.y < 0 && P(S()),
                              x.copy(b),
                              n.update();
                          })(t);
                          break;
                        case o.PAN:
                          if (!1 === n.enablePan) return;
                          !(function (t) {
                            v.set(t.clientX, t.clientY),
                              y.subVectors(v, g).multiplyScalar(n.panSpeed),
                              L(y.x, y.y),
                              g.copy(v),
                              n.update();
                          })(t);
                      }
                  })(t));
          }
          function V(t) {
            !1 !== n.enabled &&
              (t.pointerType,
              n.dispatchEvent(vm),
              (s = o.NONE),
              X(t),
              0 === _.length &&
                (n.domElement.releasePointerCapture(t.pointerId),
                n.domElement.removeEventListener("pointermove", U),
                n.domElement.removeEventListener("pointerup", V)));
          }
          function G(t) {
            X(t);
          }
          function j(t) {
            !1 === n.enabled ||
              !1 === n.enableZoom ||
              (s !== o.NONE && s !== o.ROTATE) ||
              (t.preventDefault(),
              n.dispatchEvent(gm),
              (function (t) {
                t.deltaY < 0 ? P(S()) : t.deltaY > 0 && R(S()), n.update();
              })(t),
              n.dispatchEvent(vm));
          }
          function W(t) {
            !1 !== n.enabled &&
              !1 !== n.enablePan &&
              (function (t) {
                let e = !1;
                switch (t.code) {
                  case n.keys.UP:
                    L(0, n.keyPanSpeed), (e = !0);
                    break;
                  case n.keys.BOTTOM:
                    L(0, -n.keyPanSpeed), (e = !0);
                    break;
                  case n.keys.LEFT:
                    L(n.keyPanSpeed, 0), (e = !0);
                    break;
                  case n.keys.RIGHT:
                    L(-n.keyPanSpeed, 0), (e = !0);
                }
                e && (t.preventDefault(), n.update());
              })(t);
          }
          function q(t) {
            !1 !== n.enabled && t.preventDefault();
          }
          function X(t) {
            delete M[t.pointerId];
            for (let e = 0; e < _.length; e++)
              if (_[e].pointerId == t.pointerId) return void _.splice(e, 1);
          }
          function Y(t) {
            let e = M[t.pointerId];
            void 0 === e && ((e = new Yn()), (M[t.pointerId] = e)),
              e.set(t.pageX, t.pageY);
          }
          function Z(t) {
            const e = t.pointerId === _[0].pointerId ? _[1] : _[0];
            return M[e.pointerId];
          }
          n.domElement.addEventListener("contextmenu", q),
            n.domElement.addEventListener("pointerdown", H),
            n.domElement.addEventListener("pointercancel", G),
            n.domElement.addEventListener("wheel", j, { passive: !1 }),
            this.update();
        }
      }
      function xm(t, e) {
        var n = t.__state.conversionName.toString(),
          i = Math.round(t.r),
          r = Math.round(t.g),
          o = Math.round(t.b),
          s = t.a,
          a = Math.round(t.h),
          l = t.s.toFixed(1),
          c = t.v.toFixed(1);
        if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
          for (var u = t.hex.toString(16); u.length < 6; ) u = "0" + u;
          return "#" + u;
        }
        return "CSS_RGB" === n
          ? "rgb(" + i + "," + r + "," + o + ")"
          : "CSS_RGBA" === n
          ? "rgba(" + i + "," + r + "," + o + "," + s + ")"
          : "HEX" === n
          ? "0x" + t.hex.toString(16)
          : "RGB_ARRAY" === n
          ? "[" + i + "," + r + "," + o + "]"
          : "RGBA_ARRAY" === n
          ? "[" + i + "," + r + "," + o + "," + s + "]"
          : "RGB_OBJ" === n
          ? "{r:" + i + ",g:" + r + ",b:" + o + "}"
          : "RGBA_OBJ" === n
          ? "{r:" + i + ",g:" + r + ",b:" + o + ",a:" + s + "}"
          : "HSV_OBJ" === n
          ? "{h:" + a + ",s:" + l + ",v:" + c + "}"
          : "HSVA_OBJ" === n
          ? "{h:" + a + ",s:" + l + ",v:" + c + ",a:" + s + "}"
          : "unknown format";
      }
      var bm = Array.prototype.forEach,
        wm = Array.prototype.slice,
        _m = {
          BREAK: {},
          extend: function (t) {
            return (
              this.each(
                wm.call(arguments, 1),
                function (e) {
                  (this.isObject(e) ? Object.keys(e) : []).forEach(
                    function (n) {
                      this.isUndefined(e[n]) || (t[n] = e[n]);
                    }.bind(this)
                  );
                },
                this
              ),
              t
            );
          },
          defaults: function (t) {
            return (
              this.each(
                wm.call(arguments, 1),
                function (e) {
                  (this.isObject(e) ? Object.keys(e) : []).forEach(
                    function (n) {
                      this.isUndefined(t[n]) && (t[n] = e[n]);
                    }.bind(this)
                  );
                },
                this
              ),
              t
            );
          },
          compose: function () {
            var t = wm.call(arguments);
            return function () {
              for (var e = wm.call(arguments), n = t.length - 1; n >= 0; n--)
                e = [t[n].apply(this, e)];
              return e[0];
            };
          },
          each: function (t, e, n) {
            if (t)
              if (bm && t.forEach && t.forEach === bm) t.forEach(e, n);
              else if (t.length === t.length + 0) {
                var i,
                  r = void 0;
                for (r = 0, i = t.length; r < i; r++)
                  if (r in t && e.call(n, t[r], r) === this.BREAK) return;
              } else
                for (var o in t) if (e.call(n, t[o], o) === this.BREAK) return;
          },
          defer: function (t) {
            setTimeout(t, 0);
          },
          debounce: function (t, e, n) {
            var i = void 0;
            return function () {
              var r = this,
                o = arguments;
              function s() {
                (i = null), n || t.apply(r, o);
              }
              var a = n || !i;
              clearTimeout(i), (i = setTimeout(s, e)), a && t.apply(r, o);
            };
          },
          toArray: function (t) {
            return t.toArray ? t.toArray() : wm.call(t);
          },
          isUndefined: function (t) {
            return void 0 === t;
          },
          isNull: function (t) {
            return null === t;
          },
          isNaN: (function (t) {
            function e() {
              return t.apply(this, arguments);
            }
            return (
              (e.toString = function () {
                return t.toString();
              }),
              e
            );
          })(function (t) {
            return isNaN(t);
          }),
          isArray:
            Array.isArray ||
            function (t) {
              return t.constructor === Array;
            },
          isObject: function (t) {
            return t === Object(t);
          },
          isNumber: function (t) {
            return t === t + 0;
          },
          isString: function (t) {
            return t === t + "";
          },
          isBoolean: function (t) {
            return !1 === t || !0 === t;
          },
          isFunction: function (t) {
            return t instanceof Function;
          },
        },
        Mm = [
          {
            litmus: _m.isString,
            conversions: {
              THREE_CHAR_HEX: {
                read: function (t) {
                  var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                  return (
                    null !== e && {
                      space: "HEX",
                      hex: parseInt(
                        "0x" +
                          e[1].toString() +
                          e[1].toString() +
                          e[2].toString() +
                          e[2].toString() +
                          e[3].toString() +
                          e[3].toString(),
                        0
                      ),
                    }
                  );
                },
                write: xm,
              },
              SIX_CHAR_HEX: {
                read: function (t) {
                  var e = t.match(/^#([A-F0-9]{6})$/i);
                  return (
                    null !== e && {
                      space: "HEX",
                      hex: parseInt("0x" + e[1].toString(), 0),
                    }
                  );
                },
                write: xm,
              },
              CSS_RGB: {
                read: function (t) {
                  var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                  return (
                    null !== e && {
                      space: "RGB",
                      r: parseFloat(e[1]),
                      g: parseFloat(e[2]),
                      b: parseFloat(e[3]),
                    }
                  );
                },
                write: xm,
              },
              CSS_RGBA: {
                read: function (t) {
                  var e = t.match(
                    /^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/
                  );
                  return (
                    null !== e && {
                      space: "RGB",
                      r: parseFloat(e[1]),
                      g: parseFloat(e[2]),
                      b: parseFloat(e[3]),
                      a: parseFloat(e[4]),
                    }
                  );
                },
                write: xm,
              },
            },
          },
          {
            litmus: _m.isNumber,
            conversions: {
              HEX: {
                read: function (t) {
                  return { space: "HEX", hex: t, conversionName: "HEX" };
                },
                write: function (t) {
                  return t.hex;
                },
              },
            },
          },
          {
            litmus: _m.isArray,
            conversions: {
              RGB_ARRAY: {
                read: function (t) {
                  return (
                    3 === t.length && {
                      space: "RGB",
                      r: t[0],
                      g: t[1],
                      b: t[2],
                    }
                  );
                },
                write: function (t) {
                  return [t.r, t.g, t.b];
                },
              },
              RGBA_ARRAY: {
                read: function (t) {
                  return (
                    4 === t.length && {
                      space: "RGB",
                      r: t[0],
                      g: t[1],
                      b: t[2],
                      a: t[3],
                    }
                  );
                },
                write: function (t) {
                  return [t.r, t.g, t.b, t.a];
                },
              },
            },
          },
          {
            litmus: _m.isObject,
            conversions: {
              RGBA_OBJ: {
                read: function (t) {
                  return (
                    !!(
                      _m.isNumber(t.r) &&
                      _m.isNumber(t.g) &&
                      _m.isNumber(t.b) &&
                      _m.isNumber(t.a)
                    ) && { space: "RGB", r: t.r, g: t.g, b: t.b, a: t.a }
                  );
                },
                write: function (t) {
                  return { r: t.r, g: t.g, b: t.b, a: t.a };
                },
              },
              RGB_OBJ: {
                read: function (t) {
                  return (
                    !!(
                      _m.isNumber(t.r) &&
                      _m.isNumber(t.g) &&
                      _m.isNumber(t.b)
                    ) && { space: "RGB", r: t.r, g: t.g, b: t.b }
                  );
                },
                write: function (t) {
                  return { r: t.r, g: t.g, b: t.b };
                },
              },
              HSVA_OBJ: {
                read: function (t) {
                  return (
                    !!(
                      _m.isNumber(t.h) &&
                      _m.isNumber(t.s) &&
                      _m.isNumber(t.v) &&
                      _m.isNumber(t.a)
                    ) && { space: "HSV", h: t.h, s: t.s, v: t.v, a: t.a }
                  );
                },
                write: function (t) {
                  return { h: t.h, s: t.s, v: t.v, a: t.a };
                },
              },
              HSV_OBJ: {
                read: function (t) {
                  return (
                    !!(
                      _m.isNumber(t.h) &&
                      _m.isNumber(t.s) &&
                      _m.isNumber(t.v)
                    ) && { space: "HSV", h: t.h, s: t.s, v: t.v }
                  );
                },
                write: function (t) {
                  return { h: t.h, s: t.s, v: t.v };
                },
              },
            },
          },
        ],
        Sm = void 0,
        Em = void 0,
        Tm = function () {
          Em = !1;
          var t = arguments.length > 1 ? _m.toArray(arguments) : arguments[0];
          return (
            _m.each(Mm, function (e) {
              if (e.litmus(t))
                return (
                  _m.each(e.conversions, function (e, n) {
                    if (((Sm = e.read(t)), !1 === Em && !1 !== Sm))
                      return (
                        (Em = Sm),
                        (Sm.conversionName = n),
                        (Sm.conversion = e),
                        _m.BREAK
                      );
                  }),
                  _m.BREAK
                );
            }),
            Em
          );
        },
        Am = void 0,
        Cm = {
          hsv_to_rgb: function (t, e, n) {
            var i = Math.floor(t / 60) % 6,
              r = t / 60 - Math.floor(t / 60),
              o = n * (1 - e),
              s = n * (1 - r * e),
              a = n * (1 - (1 - r) * e),
              l = [
                [n, a, o],
                [s, n, o],
                [o, n, a],
                [o, s, n],
                [a, o, n],
                [n, o, s],
              ][i];
            return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] };
          },
          rgb_to_hsv: function (t, e, n) {
            var i = Math.min(t, e, n),
              r = Math.max(t, e, n),
              o = r - i,
              s = void 0;
            return 0 === r
              ? { h: NaN, s: 0, v: 0 }
              : ((s =
                  t === r
                    ? (e - n) / o
                    : e === r
                    ? 2 + (n - t) / o
                    : 4 + (t - e) / o),
                (s /= 6) < 0 && (s += 1),
                { h: 360 * s, s: o / r, v: r / 255 });
          },
          rgb_to_hex: function (t, e, n) {
            var i = this.hex_with_component(0, 2, t);
            return (
              (i = this.hex_with_component(i, 1, e)),
              this.hex_with_component(i, 0, n)
            );
          },
          component_from_hex: function (t, e) {
            return (t >> (8 * e)) & 255;
          },
          hex_with_component: function (t, e, n) {
            return (n << (Am = 8 * e)) | (t & ~(255 << Am));
          },
        },
        Lm =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  "function" == typeof Symbol &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? "symbol"
                  : typeof t;
              },
        Rm = function (t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        },
        Pm = (function () {
          function t(t, e) {
            for (var n = 0; n < e.length; n++) {
              var i = e[n];
              (i.enumerable = i.enumerable || !1),
                (i.configurable = !0),
                "value" in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i);
            }
          }
          return function (e, n, i) {
            return n && t(e.prototype, n), i && t(e, i), e;
          };
        })(),
        Nm = function t(e, n, i) {
          null === e && (e = Function.prototype);
          var r = Object.getOwnPropertyDescriptor(e, n);
          if (void 0 === r) {
            var o = Object.getPrototypeOf(e);
            return null === o ? void 0 : t(o, n, i);
          }
          if ("value" in r) return r.value;
          var s = r.get;
          return void 0 !== s ? s.call(i) : void 0;
        },
        Im = function (t, e) {
          if ("function" != typeof e && null !== e)
            throw new TypeError(
              "Super expression must either be null or a function, not " +
                typeof e
            );
          (t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: !1,
              writable: !0,
              configurable: !0,
            },
          })),
            e &&
              (Object.setPrototypeOf
                ? Object.setPrototypeOf(t, e)
                : (t.__proto__ = e));
        },
        Bm = function (t, e) {
          if (!t)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return !e || ("object" != typeof e && "function" != typeof e) ? t : e;
        },
        Om = (function () {
          function t() {
            if (
              (Rm(this, t),
              (this.__state = Tm.apply(this, arguments)),
              !1 === this.__state)
            )
              throw new Error("Failed to interpret color arguments");
            this.__state.a = this.__state.a || 1;
          }
          return (
            Pm(t, [
              {
                key: "toString",
                value: function () {
                  return xm(this);
                },
              },
              {
                key: "toHexString",
                value: function () {
                  return xm(this, !0);
                },
              },
              {
                key: "toOriginal",
                value: function () {
                  return this.__state.conversion.write(this);
                },
              },
            ]),
            t
          );
        })();
      function Dm(t, e, n) {
        Object.defineProperty(t, e, {
          get: function () {
            return (
              "RGB" === this.__state.space || Om.recalculateRGB(this, e, n),
              this.__state[e]
            );
          },
          set: function (t) {
            "RGB" !== this.__state.space &&
              (Om.recalculateRGB(this, e, n), (this.__state.space = "RGB")),
              (this.__state[e] = t);
          },
        });
      }
      function km(t, e) {
        Object.defineProperty(t, e, {
          get: function () {
            return (
              "HSV" === this.__state.space || Om.recalculateHSV(this),
              this.__state[e]
            );
          },
          set: function (t) {
            "HSV" !== this.__state.space &&
              (Om.recalculateHSV(this), (this.__state.space = "HSV")),
              (this.__state[e] = t);
          },
        });
      }
      (Om.recalculateRGB = function (t, e, n) {
        if ("HEX" === t.__state.space)
          t.__state[e] = Cm.component_from_hex(t.__state.hex, n);
        else {
          if ("HSV" !== t.__state.space)
            throw new Error("Corrupted color state");
          _m.extend(
            t.__state,
            Cm.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v)
          );
        }
      }),
        (Om.recalculateHSV = function (t) {
          var e = Cm.rgb_to_hsv(t.r, t.g, t.b);
          _m.extend(t.__state, { s: e.s, v: e.v }),
            _m.isNaN(e.h)
              ? _m.isUndefined(t.__state.h) && (t.__state.h = 0)
              : (t.__state.h = e.h);
        }),
        (Om.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"]),
        Dm(Om.prototype, "r", 2),
        Dm(Om.prototype, "g", 1),
        Dm(Om.prototype, "b", 0),
        km(Om.prototype, "h"),
        km(Om.prototype, "s"),
        km(Om.prototype, "v"),
        Object.defineProperty(Om.prototype, "a", {
          get: function () {
            return this.__state.a;
          },
          set: function (t) {
            this.__state.a = t;
          },
        }),
        Object.defineProperty(Om.prototype, "hex", {
          get: function () {
            return (
              "HEX" !== this.__state.space &&
                ((this.__state.hex = Cm.rgb_to_hex(this.r, this.g, this.b)),
                (this.__state.space = "HEX")),
              this.__state.hex
            );
          },
          set: function (t) {
            (this.__state.space = "HEX"), (this.__state.hex = t);
          },
        });
      var Fm = (function () {
          function t(e, n) {
            Rm(this, t),
              (this.initialValue = e[n]),
              (this.domElement = document.createElement("div")),
              (this.object = e),
              (this.property = n),
              (this.__onChange = void 0),
              (this.__onFinishChange = void 0);
          }
          return (
            Pm(t, [
              {
                key: "onChange",
                value: function (t) {
                  return (this.__onChange = t), this;
                },
              },
              {
                key: "onFinishChange",
                value: function (t) {
                  return (this.__onFinishChange = t), this;
                },
              },
              {
                key: "setValue",
                value: function (t) {
                  return (
                    (this.object[this.property] = t),
                    this.__onChange && this.__onChange.call(this, t),
                    this.updateDisplay(),
                    this
                  );
                },
              },
              {
                key: "getValue",
                value: function () {
                  return this.object[this.property];
                },
              },
              {
                key: "updateDisplay",
                value: function () {
                  return this;
                },
              },
              {
                key: "isModified",
                value: function () {
                  return this.initialValue !== this.getValue();
                },
              },
            ]),
            t
          );
        })(),
        zm = {};
      _m.each(
        {
          HTMLEvents: ["change"],
          MouseEvents: [
            "click",
            "mousemove",
            "mousedown",
            "mouseup",
            "mouseover",
          ],
          KeyboardEvents: ["keydown"],
        },
        function (t, e) {
          _m.each(t, function (t) {
            zm[t] = e;
          });
        }
      );
      var Hm = /(\d+(\.\d+)?)px/;
      function Um(t) {
        if ("0" === t || _m.isUndefined(t)) return 0;
        var e = t.match(Hm);
        return _m.isNull(e) ? 0 : parseFloat(e[1]);
      }
      var Vm = {
          makeSelectable: function (t, e) {
            void 0 !== t &&
              void 0 !== t.style &&
              ((t.onselectstart = e
                ? function () {
                    return !1;
                  }
                : function () {}),
              (t.style.MozUserSelect = e ? "auto" : "none"),
              (t.style.KhtmlUserSelect = e ? "auto" : "none"),
              (t.unselectable = e ? "on" : "off"));
          },
          makeFullscreen: function (t, e, n) {
            var i = n,
              r = e;
            _m.isUndefined(r) && (r = !0),
              _m.isUndefined(i) && (i = !0),
              (t.style.position = "absolute"),
              r && ((t.style.left = 0), (t.style.right = 0)),
              i && ((t.style.top = 0), (t.style.bottom = 0));
          },
          fakeEvent: function (t, e, n, i) {
            var r = n || {},
              o = zm[e];
            if (!o) throw new Error("Event type " + e + " not supported.");
            var s = document.createEvent(o);
            switch (o) {
              case "MouseEvents":
                var a = r.x || r.clientX || 0,
                  l = r.y || r.clientY || 0;
                s.initMouseEvent(
                  e,
                  r.bubbles || !1,
                  r.cancelable || !0,
                  window,
                  r.clickCount || 1,
                  0,
                  0,
                  a,
                  l,
                  !1,
                  !1,
                  !1,
                  !1,
                  0,
                  null
                );
                break;
              case "KeyboardEvents":
                var c = s.initKeyboardEvent || s.initKeyEvent;
                _m.defaults(r, {
                  cancelable: !0,
                  ctrlKey: !1,
                  altKey: !1,
                  shiftKey: !1,
                  metaKey: !1,
                  keyCode: void 0,
                  charCode: void 0,
                }),
                  c(
                    e,
                    r.bubbles || !1,
                    r.cancelable,
                    window,
                    r.ctrlKey,
                    r.altKey,
                    r.shiftKey,
                    r.metaKey,
                    r.keyCode,
                    r.charCode
                  );
                break;
              default:
                s.initEvent(e, r.bubbles || !1, r.cancelable || !0);
            }
            _m.defaults(s, i), t.dispatchEvent(s);
          },
          bind: function (t, e, n, i) {
            var r = i || !1;
            return (
              t.addEventListener
                ? t.addEventListener(e, n, r)
                : t.attachEvent && t.attachEvent("on" + e, n),
              Vm
            );
          },
          unbind: function (t, e, n, i) {
            var r = i || !1;
            return (
              t.removeEventListener
                ? t.removeEventListener(e, n, r)
                : t.detachEvent && t.detachEvent("on" + e, n),
              Vm
            );
          },
          addClass: function (t, e) {
            if (void 0 === t.className) t.className = e;
            else if (t.className !== e) {
              var n = t.className.split(/ +/);
              -1 === n.indexOf(e) &&
                (n.push(e),
                (t.className = n
                  .join(" ")
                  .replace(/^\s+/, "")
                  .replace(/\s+$/, "")));
            }
            return Vm;
          },
          removeClass: function (t, e) {
            if (e)
              if (t.className === e) t.removeAttribute("class");
              else {
                var n = t.className.split(/ +/),
                  i = n.indexOf(e);
                -1 !== i && (n.splice(i, 1), (t.className = n.join(" ")));
              }
            else t.className = void 0;
            return Vm;
          },
          hasClass: function (t, e) {
            return (
              new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) ||
              !1
            );
          },
          getWidth: function (t) {
            var e = getComputedStyle(t);
            return (
              Um(e["border-left-width"]) +
              Um(e["border-right-width"]) +
              Um(e["padding-left"]) +
              Um(e["padding-right"]) +
              Um(e.width)
            );
          },
          getHeight: function (t) {
            var e = getComputedStyle(t);
            return (
              Um(e["border-top-width"]) +
              Um(e["border-bottom-width"]) +
              Um(e["padding-top"]) +
              Um(e["padding-bottom"]) +
              Um(e.height)
            );
          },
          getOffset: function (t) {
            var e = t,
              n = { left: 0, top: 0 };
            if (e.offsetParent)
              do {
                (n.left += e.offsetLeft),
                  (n.top += e.offsetTop),
                  (e = e.offsetParent);
              } while (e);
            return n;
          },
          isActive: function (t) {
            return t === document.activeElement && (t.type || t.href);
          },
        },
        Gm = (function (t) {
          function e(t, n) {
            Rm(this, e);
            var i = Bm(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
              ),
              r = i;
            return (
              (i.__prev = i.getValue()),
              (i.__checkbox = document.createElement("input")),
              i.__checkbox.setAttribute("type", "checkbox"),
              Vm.bind(
                i.__checkbox,
                "change",
                function () {
                  r.setValue(!r.__prev);
                },
                !1
              ),
              i.domElement.appendChild(i.__checkbox),
              i.updateDisplay(),
              i
            );
          }
          return (
            Im(e, t),
            Pm(e, [
              {
                key: "setValue",
                value: function (t) {
                  var n = Nm(
                    e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                    "setValue",
                    this
                  ).call(this, t);
                  return (
                    this.__onFinishChange &&
                      this.__onFinishChange.call(this, this.getValue()),
                    (this.__prev = this.getValue()),
                    n
                  );
                },
              },
              {
                key: "updateDisplay",
                value: function () {
                  return (
                    !0 === this.getValue()
                      ? (this.__checkbox.setAttribute("checked", "checked"),
                        (this.__checkbox.checked = !0),
                        (this.__prev = !0))
                      : ((this.__checkbox.checked = !1), (this.__prev = !1)),
                    Nm(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      "updateDisplay",
                      this
                    ).call(this)
                  );
                },
              },
            ]),
            e
          );
        })(Fm),
        jm = (function (t) {
          function e(t, n, i) {
            Rm(this, e);
            var r = Bm(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
              ),
              o = i,
              s = r;
            if (
              ((r.__select = document.createElement("select")), _m.isArray(o))
            ) {
              var a = {};
              _m.each(o, function (t) {
                a[t] = t;
              }),
                (o = a);
            }
            return (
              _m.each(o, function (t, e) {
                var n = document.createElement("option");
                (n.innerHTML = e),
                  n.setAttribute("value", t),
                  s.__select.appendChild(n);
              }),
              r.updateDisplay(),
              Vm.bind(r.__select, "change", function () {
                var t = this.options[this.selectedIndex].value;
                s.setValue(t);
              }),
              r.domElement.appendChild(r.__select),
              r
            );
          }
          return (
            Im(e, t),
            Pm(e, [
              {
                key: "setValue",
                value: function (t) {
                  var n = Nm(
                    e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                    "setValue",
                    this
                  ).call(this, t);
                  return (
                    this.__onFinishChange &&
                      this.__onFinishChange.call(this, this.getValue()),
                    n
                  );
                },
              },
              {
                key: "updateDisplay",
                value: function () {
                  return Vm.isActive(this.__select)
                    ? this
                    : ((this.__select.value = this.getValue()),
                      Nm(
                        e.prototype.__proto__ ||
                          Object.getPrototypeOf(e.prototype),
                        "updateDisplay",
                        this
                      ).call(this));
                },
              },
            ]),
            e
          );
        })(Fm),
        Wm = (function (t) {
          function e(t, n) {
            Rm(this, e);
            var i = Bm(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
              ),
              r = i;
            function o() {
              r.setValue(r.__input.value);
            }
            return (
              (i.__input = document.createElement("input")),
              i.__input.setAttribute("type", "text"),
              Vm.bind(i.__input, "keyup", o),
              Vm.bind(i.__input, "change", o),
              Vm.bind(i.__input, "blur", function () {
                r.__onFinishChange && r.__onFinishChange.call(r, r.getValue());
              }),
              Vm.bind(i.__input, "keydown", function (t) {
                13 === t.keyCode && this.blur();
              }),
              i.updateDisplay(),
              i.domElement.appendChild(i.__input),
              i
            );
          }
          return (
            Im(e, t),
            Pm(e, [
              {
                key: "updateDisplay",
                value: function () {
                  return (
                    Vm.isActive(this.__input) ||
                      (this.__input.value = this.getValue()),
                    Nm(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      "updateDisplay",
                      this
                    ).call(this)
                  );
                },
              },
            ]),
            e
          );
        })(Fm);
      function qm(t) {
        var e = t.toString();
        return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0;
      }
      var Xm = (function (t) {
          function e(t, n, i) {
            Rm(this, e);
            var r = Bm(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
              ),
              o = i || {};
            return (
              (r.__min = o.min),
              (r.__max = o.max),
              (r.__step = o.step),
              _m.isUndefined(r.__step)
                ? 0 === r.initialValue
                  ? (r.__impliedStep = 1)
                  : (r.__impliedStep =
                      Math.pow(
                        10,
                        Math.floor(
                          Math.log(Math.abs(r.initialValue)) / Math.LN10
                        )
                      ) / 10)
                : (r.__impliedStep = r.__step),
              (r.__precision = qm(r.__impliedStep)),
              r
            );
          }
          return (
            Im(e, t),
            Pm(e, [
              {
                key: "setValue",
                value: function (t) {
                  var n = t;
                  return (
                    void 0 !== this.__min && n < this.__min
                      ? (n = this.__min)
                      : void 0 !== this.__max &&
                        n > this.__max &&
                        (n = this.__max),
                    void 0 !== this.__step &&
                      n % this.__step != 0 &&
                      (n = Math.round(n / this.__step) * this.__step),
                    Nm(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      "setValue",
                      this
                    ).call(this, n)
                  );
                },
              },
              {
                key: "min",
                value: function (t) {
                  return (this.__min = t), this;
                },
              },
              {
                key: "max",
                value: function (t) {
                  return (this.__max = t), this;
                },
              },
              {
                key: "step",
                value: function (t) {
                  return (
                    (this.__step = t),
                    (this.__impliedStep = t),
                    (this.__precision = qm(t)),
                    this
                  );
                },
              },
            ]),
            e
          );
        })(Fm),
        Ym = (function (t) {
          function e(t, n, i) {
            Rm(this, e);
            var r = Bm(
              this,
              (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, i)
            );
            r.__truncationSuspended = !1;
            var o = r,
              s = void 0;
            function a() {
              o.__onFinishChange && o.__onFinishChange.call(o, o.getValue());
            }
            function l(t) {
              var e = s - t.clientY;
              o.setValue(o.getValue() + e * o.__impliedStep), (s = t.clientY);
            }
            function c() {
              Vm.unbind(window, "mousemove", l),
                Vm.unbind(window, "mouseup", c),
                a();
            }
            return (
              (r.__input = document.createElement("input")),
              r.__input.setAttribute("type", "text"),
              Vm.bind(r.__input, "change", function () {
                var t = parseFloat(o.__input.value);
                _m.isNaN(t) || o.setValue(t);
              }),
              Vm.bind(r.__input, "blur", function () {
                a();
              }),
              Vm.bind(r.__input, "mousedown", function (t) {
                Vm.bind(window, "mousemove", l),
                  Vm.bind(window, "mouseup", c),
                  (s = t.clientY);
              }),
              Vm.bind(r.__input, "keydown", function (t) {
                13 === t.keyCode &&
                  ((o.__truncationSuspended = !0),
                  this.blur(),
                  (o.__truncationSuspended = !1),
                  a());
              }),
              r.updateDisplay(),
              r.domElement.appendChild(r.__input),
              r
            );
          }
          return (
            Im(e, t),
            Pm(e, [
              {
                key: "updateDisplay",
                value: function () {
                  var t, n, i;
                  return (
                    (this.__input.value = this.__truncationSuspended
                      ? this.getValue()
                      : ((t = this.getValue()),
                        (n = this.__precision),
                        (i = Math.pow(10, n)),
                        Math.round(t * i) / i)),
                    Nm(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      "updateDisplay",
                      this
                    ).call(this)
                  );
                },
              },
            ]),
            e
          );
        })(Xm);
      function Zm(t, e, n, i, r) {
        return i + ((t - e) / (n - e)) * (r - i);
      }
      var Jm = (function (t) {
          function e(t, n, i, r, o) {
            Rm(this, e);
            var s = Bm(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {
                  min: i,
                  max: r,
                  step: o,
                })
              ),
              a = s;
            function l(t) {
              t.preventDefault();
              var e = a.__background.getBoundingClientRect();
              return (
                a.setValue(Zm(t.clientX, e.left, e.right, a.__min, a.__max)), !1
              );
            }
            function c() {
              Vm.unbind(window, "mousemove", l),
                Vm.unbind(window, "mouseup", c),
                a.__onFinishChange && a.__onFinishChange.call(a, a.getValue());
            }
            function u(t) {
              var e = t.touches[0].clientX,
                n = a.__background.getBoundingClientRect();
              a.setValue(Zm(e, n.left, n.right, a.__min, a.__max));
            }
            function h() {
              Vm.unbind(window, "touchmove", u),
                Vm.unbind(window, "touchend", h),
                a.__onFinishChange && a.__onFinishChange.call(a, a.getValue());
            }
            return (
              (s.__background = document.createElement("div")),
              (s.__foreground = document.createElement("div")),
              Vm.bind(s.__background, "mousedown", function (t) {
                document.activeElement.blur(),
                  Vm.bind(window, "mousemove", l),
                  Vm.bind(window, "mouseup", c),
                  l(t);
              }),
              Vm.bind(s.__background, "touchstart", function (t) {
                1 === t.touches.length &&
                  (Vm.bind(window, "touchmove", u),
                  Vm.bind(window, "touchend", h),
                  u(t));
              }),
              Vm.addClass(s.__background, "slider"),
              Vm.addClass(s.__foreground, "slider-fg"),
              s.updateDisplay(),
              s.__background.appendChild(s.__foreground),
              s.domElement.appendChild(s.__background),
              s
            );
          }
          return (
            Im(e, t),
            Pm(e, [
              {
                key: "updateDisplay",
                value: function () {
                  var t =
                    (this.getValue() - this.__min) / (this.__max - this.__min);
                  return (
                    (this.__foreground.style.width = 100 * t + "%"),
                    Nm(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      "updateDisplay",
                      this
                    ).call(this)
                  );
                },
              },
            ]),
            e
          );
        })(Xm),
        Km = (function (t) {
          function e(t, n, i) {
            Rm(this, e);
            var r = Bm(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
              ),
              o = r;
            return (
              (r.__button = document.createElement("div")),
              (r.__button.innerHTML = void 0 === i ? "Fire" : i),
              Vm.bind(r.__button, "click", function (t) {
                return t.preventDefault(), o.fire(), !1;
              }),
              Vm.addClass(r.__button, "button"),
              r.domElement.appendChild(r.__button),
              r
            );
          }
          return (
            Im(e, t),
            Pm(e, [
              {
                key: "fire",
                value: function () {
                  this.__onChange && this.__onChange.call(this),
                    this.getValue().call(this.object),
                    this.__onFinishChange &&
                      this.__onFinishChange.call(this, this.getValue());
                },
              },
            ]),
            e
          );
        })(Fm),
        Qm = (function (t) {
          function e(t, n) {
            Rm(this, e);
            var i = Bm(
              this,
              (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
            );
            (i.__color = new Om(i.getValue())), (i.__temp = new Om(0));
            var r = i;
            (i.domElement = document.createElement("div")),
              Vm.makeSelectable(i.domElement, !1),
              (i.__selector = document.createElement("div")),
              (i.__selector.className = "selector"),
              (i.__saturation_field = document.createElement("div")),
              (i.__saturation_field.className = "saturation-field"),
              (i.__field_knob = document.createElement("div")),
              (i.__field_knob.className = "field-knob"),
              (i.__field_knob_border = "2px solid "),
              (i.__hue_knob = document.createElement("div")),
              (i.__hue_knob.className = "hue-knob"),
              (i.__hue_field = document.createElement("div")),
              (i.__hue_field.className = "hue-field"),
              (i.__input = document.createElement("input")),
              (i.__input.type = "text"),
              (i.__input_textShadow = "0 1px 1px "),
              Vm.bind(i.__input, "keydown", function (t) {
                13 === t.keyCode && h.call(this);
              }),
              Vm.bind(i.__input, "blur", h),
              Vm.bind(i.__selector, "mousedown", function () {
                Vm.addClass(this, "drag").bind(window, "mouseup", function () {
                  Vm.removeClass(r.__selector, "drag");
                });
              }),
              Vm.bind(i.__selector, "touchstart", function () {
                Vm.addClass(this, "drag").bind(window, "touchend", function () {
                  Vm.removeClass(r.__selector, "drag");
                });
              });
            var o,
              s = document.createElement("div");
            function a(t) {
              p(t),
                Vm.bind(window, "mousemove", p),
                Vm.bind(window, "touchmove", p),
                Vm.bind(window, "mouseup", c),
                Vm.bind(window, "touchend", c);
            }
            function l(t) {
              f(t),
                Vm.bind(window, "mousemove", f),
                Vm.bind(window, "touchmove", f),
                Vm.bind(window, "mouseup", u),
                Vm.bind(window, "touchend", u);
            }
            function c() {
              Vm.unbind(window, "mousemove", p),
                Vm.unbind(window, "touchmove", p),
                Vm.unbind(window, "mouseup", c),
                Vm.unbind(window, "touchend", c),
                d();
            }
            function u() {
              Vm.unbind(window, "mousemove", f),
                Vm.unbind(window, "touchmove", f),
                Vm.unbind(window, "mouseup", u),
                Vm.unbind(window, "touchend", u),
                d();
            }
            function h() {
              var t = Tm(this.value);
              !1 !== t
                ? ((r.__color.__state = t), r.setValue(r.__color.toOriginal()))
                : (this.value = r.__color.toString());
            }
            function d() {
              r.__onFinishChange &&
                r.__onFinishChange.call(r, r.__color.toOriginal());
            }
            function p(t) {
              -1 === t.type.indexOf("touch") && t.preventDefault();
              var e = r.__saturation_field.getBoundingClientRect(),
                n = (t.touches && t.touches[0]) || t,
                i = n.clientX,
                o = n.clientY,
                s = (i - e.left) / (e.right - e.left),
                a = 1 - (o - e.top) / (e.bottom - e.top);
              return (
                a > 1 ? (a = 1) : a < 0 && (a = 0),
                s > 1 ? (s = 1) : s < 0 && (s = 0),
                (r.__color.v = a),
                (r.__color.s = s),
                r.setValue(r.__color.toOriginal()),
                !1
              );
            }
            function f(t) {
              -1 === t.type.indexOf("touch") && t.preventDefault();
              var e = r.__hue_field.getBoundingClientRect(),
                n =
                  1 -
                  (((t.touches && t.touches[0]) || t).clientY - e.top) /
                    (e.bottom - e.top);
              return (
                n > 1 ? (n = 1) : n < 0 && (n = 0),
                (r.__color.h = 360 * n),
                r.setValue(r.__color.toOriginal()),
                !1
              );
            }
            return (
              _m.extend(i.__selector.style, {
                width: "122px",
                height: "102px",
                padding: "3px",
                backgroundColor: "#222",
                boxShadow: "0px 1px 3px rgba(0,0,0,0.3)",
              }),
              _m.extend(i.__field_knob.style, {
                position: "absolute",
                width: "12px",
                height: "12px",
                border:
                  i.__field_knob_border + (i.__color.v < 0.5 ? "#fff" : "#000"),
                boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                borderRadius: "12px",
                zIndex: 1,
              }),
              _m.extend(i.__hue_knob.style, {
                position: "absolute",
                width: "15px",
                height: "2px",
                borderRight: "4px solid #fff",
                zIndex: 1,
              }),
              _m.extend(i.__saturation_field.style, {
                width: "100px",
                height: "100px",
                border: "1px solid #555",
                marginRight: "3px",
                display: "inline-block",
                cursor: "pointer",
              }),
              _m.extend(s.style, {
                width: "100%",
                height: "100%",
                background: "none",
              }),
              tg(s, "top", "rgba(0,0,0,0)", "#000"),
              _m.extend(i.__hue_field.style, {
                width: "15px",
                height: "100px",
                border: "1px solid #555",
                cursor: "ns-resize",
                position: "absolute",
                top: "3px",
                right: "3px",
              }),
              ((o = i.__hue_field).style.background = ""),
              (o.style.cssText +=
                "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);"),
              (o.style.cssText +=
                "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
              (o.style.cssText +=
                "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
              (o.style.cssText +=
                "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
              (o.style.cssText +=
                "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
              _m.extend(i.__input.style, {
                outline: "none",
                textAlign: "center",
                color: "#fff",
                border: 0,
                fontWeight: "bold",
                textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)",
              }),
              Vm.bind(i.__saturation_field, "mousedown", a),
              Vm.bind(i.__saturation_field, "touchstart", a),
              Vm.bind(i.__field_knob, "mousedown", a),
              Vm.bind(i.__field_knob, "touchstart", a),
              Vm.bind(i.__hue_field, "mousedown", l),
              Vm.bind(i.__hue_field, "touchstart", l),
              i.__saturation_field.appendChild(s),
              i.__selector.appendChild(i.__field_knob),
              i.__selector.appendChild(i.__saturation_field),
              i.__selector.appendChild(i.__hue_field),
              i.__hue_field.appendChild(i.__hue_knob),
              i.domElement.appendChild(i.__input),
              i.domElement.appendChild(i.__selector),
              i.updateDisplay(),
              i
            );
          }
          return (
            Im(e, t),
            Pm(e, [
              {
                key: "updateDisplay",
                value: function () {
                  var t = Tm(this.getValue());
                  if (!1 !== t) {
                    var e = !1;
                    _m.each(
                      Om.COMPONENTS,
                      function (n) {
                        if (
                          !_m.isUndefined(t[n]) &&
                          !_m.isUndefined(this.__color.__state[n]) &&
                          t[n] !== this.__color.__state[n]
                        )
                          return (e = !0), {};
                      },
                      this
                    ),
                      e && _m.extend(this.__color.__state, t);
                  }
                  _m.extend(this.__temp.__state, this.__color.__state),
                    (this.__temp.a = 1);
                  var n =
                      this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0,
                    i = 255 - n;
                  _m.extend(this.__field_knob.style, {
                    marginLeft: 100 * this.__color.s - 7 + "px",
                    marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                    backgroundColor: this.__temp.toHexString(),
                    border:
                      this.__field_knob_border +
                      "rgb(" +
                      n +
                      "," +
                      n +
                      "," +
                      n +
                      ")",
                  }),
                    (this.__hue_knob.style.marginTop =
                      100 * (1 - this.__color.h / 360) + "px"),
                    (this.__temp.s = 1),
                    (this.__temp.v = 1),
                    tg(
                      this.__saturation_field,
                      "left",
                      "#fff",
                      this.__temp.toHexString()
                    ),
                    (this.__input.value = this.__color.toString()),
                    _m.extend(this.__input.style, {
                      backgroundColor: this.__color.toHexString(),
                      color: "rgb(" + n + "," + n + "," + n + ")",
                      textShadow:
                        this.__input_textShadow +
                        "rgba(" +
                        i +
                        "," +
                        i +
                        "," +
                        i +
                        ",.7)",
                    });
                },
              },
            ]),
            e
          );
        })(Fm),
        $m = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
      function tg(t, e, n, i) {
        (t.style.background = ""),
          _m.each($m, function (r) {
            t.style.cssText +=
              "background: " +
              r +
              "linear-gradient(" +
              e +
              ", " +
              n +
              " 0%, " +
              i +
              " 100%); ";
          });
      }
      var eg =
          '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
        ng = function (t, e) {
          var n = t[e];
          return _m.isArray(arguments[2]) || _m.isObject(arguments[2])
            ? new jm(t, e, arguments[2])
            : _m.isNumber(n)
            ? _m.isNumber(arguments[2]) && _m.isNumber(arguments[3])
              ? _m.isNumber(arguments[4])
                ? new Jm(t, e, arguments[2], arguments[3], arguments[4])
                : new Jm(t, e, arguments[2], arguments[3])
              : _m.isNumber(arguments[4])
              ? new Ym(t, e, {
                  min: arguments[2],
                  max: arguments[3],
                  step: arguments[4],
                })
              : new Ym(t, e, { min: arguments[2], max: arguments[3] })
            : _m.isString(n)
            ? new Wm(t, e)
            : _m.isFunction(n)
            ? new Km(t, e, "")
            : _m.isBoolean(n)
            ? new Gm(t, e)
            : null;
        },
        ig =
          window.requestAnimationFrame ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          window.oRequestAnimationFrame ||
          window.msRequestAnimationFrame ||
          function (t) {
            setTimeout(t, 1e3 / 60);
          },
        rg = (function () {
          function t() {
            Rm(this, t),
              (this.backgroundElement = document.createElement("div")),
              _m.extend(this.backgroundElement.style, {
                backgroundColor: "rgba(0,0,0,0.8)",
                top: 0,
                left: 0,
                display: "none",
                zIndex: "1000",
                opacity: 0,
                WebkitTransition: "opacity 0.2s linear",
                transition: "opacity 0.2s linear",
              }),
              Vm.makeFullscreen(this.backgroundElement),
              (this.backgroundElement.style.position = "fixed"),
              (this.domElement = document.createElement("div")),
              _m.extend(this.domElement.style, {
                position: "fixed",
                display: "none",
                zIndex: "1001",
                opacity: 0,
                WebkitTransition:
                  "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                transition: "transform 0.2s ease-out, opacity 0.2s linear",
              }),
              document.body.appendChild(this.backgroundElement),
              document.body.appendChild(this.domElement);
            var e = this;
            Vm.bind(this.backgroundElement, "click", function () {
              e.hide();
            });
          }
          return (
            Pm(t, [
              {
                key: "show",
                value: function () {
                  var t = this;
                  (this.backgroundElement.style.display = "block"),
                    (this.domElement.style.display = "block"),
                    (this.domElement.style.opacity = 0),
                    (this.domElement.style.webkitTransform = "scale(1.1)"),
                    this.layout(),
                    _m.defer(function () {
                      (t.backgroundElement.style.opacity = 1),
                        (t.domElement.style.opacity = 1),
                        (t.domElement.style.webkitTransform = "scale(1)");
                    });
                },
              },
              {
                key: "hide",
                value: function () {
                  var t = this,
                    e = function e() {
                      (t.domElement.style.display = "none"),
                        (t.backgroundElement.style.display = "none"),
                        Vm.unbind(t.domElement, "webkitTransitionEnd", e),
                        Vm.unbind(t.domElement, "transitionend", e),
                        Vm.unbind(t.domElement, "oTransitionEnd", e);
                    };
                  Vm.bind(this.domElement, "webkitTransitionEnd", e),
                    Vm.bind(this.domElement, "transitionend", e),
                    Vm.bind(this.domElement, "oTransitionEnd", e),
                    (this.backgroundElement.style.opacity = 0),
                    (this.domElement.style.opacity = 0),
                    (this.domElement.style.webkitTransform = "scale(1.1)");
                },
              },
              {
                key: "layout",
                value: function () {
                  (this.domElement.style.left =
                    window.innerWidth / 2 -
                    Vm.getWidth(this.domElement) / 2 +
                    "px"),
                    (this.domElement.style.top =
                      window.innerHeight / 2 -
                      Vm.getHeight(this.domElement) / 2 +
                      "px");
                },
              },
            ]),
            t
          );
        })();
      !(function (t, e) {
        var n = e || document,
          i = document.createElement("style");
        (i.type = "text/css"), (i.innerHTML = t);
        var r = n.getElementsByTagName("head")[0];
        try {
          r.appendChild(i);
        } catch (t) {}
      })(
        (function (t) {
          if ("undefined" != typeof window) {
            var e = document.createElement("style");
            return (
              e.setAttribute("type", "text/css"),
              (e.innerHTML = t),
              document.head.appendChild(e),
              t
            );
          }
        })(
          ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"
        )
      );
      var og = "Default",
        sg = (function () {
          try {
            return !!window.localStorage;
          } catch (t) {
            return !1;
          }
        })(),
        ag = void 0,
        lg = !0,
        cg = void 0,
        ug = !1,
        hg = [],
        dg = function t(e) {
          var n = this,
            i = e || {};
          (this.domElement = document.createElement("div")),
            (this.__ul = document.createElement("ul")),
            this.domElement.appendChild(this.__ul),
            Vm.addClass(this.domElement, "dg"),
            (this.__folders = {}),
            (this.__controllers = []),
            (this.__rememberedObjects = []),
            (this.__rememberedObjectIndecesToControllers = []),
            (this.__listening = []),
            (i = _m.defaults(i, {
              closeOnTop: !1,
              autoPlace: !0,
              width: t.DEFAULT_WIDTH,
            })),
            (i = _m.defaults(i, {
              resizable: i.autoPlace,
              hideable: i.autoPlace,
            })),
            _m.isUndefined(i.load)
              ? (i.load = { preset: og })
              : i.preset && (i.load.preset = i.preset),
            _m.isUndefined(i.parent) && i.hideable && hg.push(this),
            (i.resizable = _m.isUndefined(i.parent) && i.resizable),
            i.autoPlace && _m.isUndefined(i.scrollable) && (i.scrollable = !0);
          var r,
            o = sg && "true" === localStorage.getItem(yg(0, "isLocal")),
            s = void 0,
            a = void 0;
          if (
            (Object.defineProperties(this, {
              parent: {
                get: function () {
                  return i.parent;
                },
              },
              scrollable: {
                get: function () {
                  return i.scrollable;
                },
              },
              autoPlace: {
                get: function () {
                  return i.autoPlace;
                },
              },
              closeOnTop: {
                get: function () {
                  return i.closeOnTop;
                },
              },
              preset: {
                get: function () {
                  return n.parent ? n.getRoot().preset : i.load.preset;
                },
                set: function (t) {
                  n.parent ? (n.getRoot().preset = t) : (i.load.preset = t),
                    (function (t) {
                      for (var e = 0; e < t.__preset_select.length; e++)
                        t.__preset_select[e].value === t.preset &&
                          (t.__preset_select.selectedIndex = e);
                    })(this),
                    n.revert();
                },
              },
              width: {
                get: function () {
                  return i.width;
                },
                set: function (t) {
                  (i.width = t), Mg(n, t);
                },
              },
              name: {
                get: function () {
                  return i.name;
                },
                set: function (t) {
                  (i.name = t), a && (a.innerHTML = i.name);
                },
              },
              closed: {
                get: function () {
                  return i.closed;
                },
                set: function (e) {
                  (i.closed = e),
                    i.closed
                      ? Vm.addClass(n.__ul, t.CLASS_CLOSED)
                      : Vm.removeClass(n.__ul, t.CLASS_CLOSED),
                    this.onResize(),
                    n.__closeButton &&
                      (n.__closeButton.innerHTML = e
                        ? t.TEXT_OPEN
                        : t.TEXT_CLOSED);
                },
              },
              load: {
                get: function () {
                  return i.load;
                },
              },
              useLocalStorage: {
                get: function () {
                  return o;
                },
                set: function (t) {
                  sg &&
                    ((o = t),
                    t
                      ? Vm.bind(window, "unload", s)
                      : Vm.unbind(window, "unload", s),
                    localStorage.setItem(yg(0, "isLocal"), t));
                },
              },
            }),
            _m.isUndefined(i.parent))
          ) {
            if (
              ((this.closed = i.closed || !1),
              Vm.addClass(this.domElement, t.CLASS_MAIN),
              Vm.makeSelectable(this.domElement, !1),
              sg && o)
            ) {
              n.useLocalStorage = !0;
              var l = localStorage.getItem(yg(0, "gui"));
              l && (i.load = JSON.parse(l));
            }
            (this.__closeButton = document.createElement("div")),
              (this.__closeButton.innerHTML = t.TEXT_CLOSED),
              Vm.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON),
              i.closeOnTop
                ? (Vm.addClass(this.__closeButton, t.CLASS_CLOSE_TOP),
                  this.domElement.insertBefore(
                    this.__closeButton,
                    this.domElement.childNodes[0]
                  ))
                : (Vm.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM),
                  this.domElement.appendChild(this.__closeButton)),
              Vm.bind(this.__closeButton, "click", function () {
                n.closed = !n.closed;
              });
          } else {
            void 0 === i.closed && (i.closed = !0);
            var c = document.createTextNode(i.name);
            Vm.addClass(c, "controller-name"),
              (a = pg(n, c)),
              Vm.addClass(this.__ul, t.CLASS_CLOSED),
              Vm.addClass(a, "title"),
              Vm.bind(a, "click", function (t) {
                return t.preventDefault(), (n.closed = !n.closed), !1;
              }),
              i.closed || (this.closed = !1);
          }
          i.autoPlace &&
            (_m.isUndefined(i.parent) &&
              (lg &&
                ((cg = document.createElement("div")),
                Vm.addClass(cg, "dg"),
                Vm.addClass(cg, t.CLASS_AUTO_PLACE_CONTAINER),
                document.body.appendChild(cg),
                (lg = !1)),
              cg.appendChild(this.domElement),
              Vm.addClass(this.domElement, t.CLASS_AUTO_PLACE)),
            this.parent || Mg(n, i.width)),
            (this.__resizeHandler = function () {
              n.onResizeDebounced();
            }),
            Vm.bind(window, "resize", this.__resizeHandler),
            Vm.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
            Vm.bind(this.__ul, "transitionend", this.__resizeHandler),
            Vm.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
            this.onResize(),
            i.resizable && _g(this),
            (s = function () {
              sg &&
                "true" === localStorage.getItem(yg(0, "isLocal")) &&
                localStorage.setItem(
                  yg(0, "gui"),
                  JSON.stringify(n.getSaveObject())
                );
            }),
            (this.saveToLocalStorageIfPossible = s),
            i.parent ||
              (((r = n.getRoot()).width += 1),
              _m.defer(function () {
                r.width -= 1;
              }));
        };
      function pg(t, e, n) {
        var i = document.createElement("li");
        return (
          e && i.appendChild(e),
          n ? t.__ul.insertBefore(i, n) : t.__ul.appendChild(i),
          t.onResize(),
          i
        );
      }
      function fg(t) {
        Vm.unbind(window, "resize", t.__resizeHandler),
          t.saveToLocalStorageIfPossible &&
            Vm.unbind(window, "unload", t.saveToLocalStorageIfPossible);
      }
      function mg(t, e) {
        var n = t.__preset_select[t.__preset_select.selectedIndex];
        n.innerHTML = e ? n.value + "*" : n.value;
      }
      function gg(t, e) {
        var n = t.getRoot(),
          i = n.__rememberedObjects.indexOf(e.object);
        if (-1 !== i) {
          var r = n.__rememberedObjectIndecesToControllers[i];
          if (
            (void 0 === r &&
              ((r = {}), (n.__rememberedObjectIndecesToControllers[i] = r)),
            (r[e.property] = e),
            n.load && n.load.remembered)
          ) {
            var o = n.load.remembered,
              s = void 0;
            if (o[t.preset]) s = o[t.preset];
            else {
              if (!o.Default) return;
              s = o.Default;
            }
            if (s[i] && void 0 !== s[i][e.property]) {
              var a = s[i][e.property];
              (e.initialValue = a), e.setValue(a);
            }
          }
        }
      }
      function vg(t, e, n, i) {
        if (void 0 === e[n])
          throw new Error('Object "' + e + '" has no property "' + n + '"');
        var r = void 0;
        if (i.color) r = new Qm(e, n);
        else {
          var o = [e, n].concat(i.factoryArgs);
          r = ng.apply(t, o);
        }
        i.before instanceof Fm && (i.before = i.before.__li),
          gg(t, r),
          Vm.addClass(r.domElement, "c");
        var s = document.createElement("span");
        Vm.addClass(s, "property-name"), (s.innerHTML = r.property);
        var a = document.createElement("div");
        a.appendChild(s), a.appendChild(r.domElement);
        var l = pg(t, a, i.before);
        return (
          Vm.addClass(l, dg.CLASS_CONTROLLER_ROW),
          r instanceof Qm
            ? Vm.addClass(l, "color")
            : Vm.addClass(l, Lm(r.getValue())),
          (function (t, e, n) {
            if (
              ((n.__li = e),
              (n.__gui = t),
              _m.extend(n, {
                options: function (e) {
                  if (arguments.length > 1) {
                    var i = n.__li.nextElementSibling;
                    return (
                      n.remove(),
                      vg(t, n.object, n.property, {
                        before: i,
                        factoryArgs: [_m.toArray(arguments)],
                      })
                    );
                  }
                  if (_m.isArray(e) || _m.isObject(e)) {
                    var r = n.__li.nextElementSibling;
                    return (
                      n.remove(),
                      vg(t, n.object, n.property, {
                        before: r,
                        factoryArgs: [e],
                      })
                    );
                  }
                },
                name: function (t) {
                  return (
                    (n.__li.firstElementChild.firstElementChild.innerHTML = t),
                    n
                  );
                },
                listen: function () {
                  return n.__gui.listen(n), n;
                },
                remove: function () {
                  return n.__gui.remove(n), n;
                },
              }),
              n instanceof Jm)
            ) {
              var i = new Ym(n.object, n.property, {
                min: n.__min,
                max: n.__max,
                step: n.__step,
              });
              _m.each(
                [
                  "updateDisplay",
                  "onChange",
                  "onFinishChange",
                  "step",
                  "min",
                  "max",
                ],
                function (t) {
                  var e = n[t],
                    r = i[t];
                  n[t] = i[t] = function () {
                    var t = Array.prototype.slice.call(arguments);
                    return r.apply(i, t), e.apply(n, t);
                  };
                }
              ),
                Vm.addClass(e, "has-slider"),
                n.domElement.insertBefore(
                  i.domElement,
                  n.domElement.firstElementChild
                );
            } else if (n instanceof Ym) {
              var r = function (e) {
                if (_m.isNumber(n.__min) && _m.isNumber(n.__max)) {
                  var i = n.__li.firstElementChild.firstElementChild.innerHTML,
                    r = n.__gui.__listening.indexOf(n) > -1;
                  n.remove();
                  var o = vg(t, n.object, n.property, {
                    before: n.__li.nextElementSibling,
                    factoryArgs: [n.__min, n.__max, n.__step],
                  });
                  return o.name(i), r && o.listen(), o;
                }
                return e;
              };
              (n.min = _m.compose(r, n.min)), (n.max = _m.compose(r, n.max));
            } else
              n instanceof Gm
                ? (Vm.bind(e, "click", function () {
                    Vm.fakeEvent(n.__checkbox, "click");
                  }),
                  Vm.bind(n.__checkbox, "click", function (t) {
                    t.stopPropagation();
                  }))
                : n instanceof Km
                ? (Vm.bind(e, "click", function () {
                    Vm.fakeEvent(n.__button, "click");
                  }),
                  Vm.bind(e, "mouseover", function () {
                    Vm.addClass(n.__button, "hover");
                  }),
                  Vm.bind(e, "mouseout", function () {
                    Vm.removeClass(n.__button, "hover");
                  }))
                : n instanceof Qm &&
                  (Vm.addClass(e, "color"),
                  (n.updateDisplay = _m.compose(function (t) {
                    return (e.style.borderLeftColor = n.__color.toString()), t;
                  }, n.updateDisplay)),
                  n.updateDisplay());
            n.setValue = _m.compose(function (e) {
              return (
                t.getRoot().__preset_select &&
                  n.isModified() &&
                  mg(t.getRoot(), !0),
                e
              );
            }, n.setValue);
          })(t, l, r),
          t.__controllers.push(r),
          r
        );
      }
      function yg(t, e) {
        return document.location.href + "." + e;
      }
      function xg(t, e, n) {
        var i = document.createElement("option");
        (i.innerHTML = e),
          (i.value = e),
          t.__preset_select.appendChild(i),
          n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1);
      }
      function bg(t, e) {
        e.style.display = t.useLocalStorage ? "block" : "none";
      }
      function wg(t) {
        var e = (t.__save_row = document.createElement("li"));
        Vm.addClass(t.domElement, "has-save"),
          t.__ul.insertBefore(e, t.__ul.firstChild),
          Vm.addClass(e, "save-row");
        var n = document.createElement("span");
        (n.innerHTML = "&nbsp;"), Vm.addClass(n, "button gears");
        var i = document.createElement("span");
        (i.innerHTML = "Save"),
          Vm.addClass(i, "button"),
          Vm.addClass(i, "save");
        var r = document.createElement("span");
        (r.innerHTML = "New"),
          Vm.addClass(r, "button"),
          Vm.addClass(r, "save-as");
        var o = document.createElement("span");
        (o.innerHTML = "Revert"),
          Vm.addClass(o, "button"),
          Vm.addClass(o, "revert");
        var s = (t.__preset_select = document.createElement("select"));
        if (
          (t.load && t.load.remembered
            ? _m.each(t.load.remembered, function (e, n) {
                xg(t, n, n === t.preset);
              })
            : xg(t, og, !1),
          Vm.bind(s, "change", function () {
            for (var e = 0; e < t.__preset_select.length; e++)
              t.__preset_select[e].innerHTML = t.__preset_select[e].value;
            t.preset = this.value;
          }),
          e.appendChild(s),
          e.appendChild(n),
          e.appendChild(i),
          e.appendChild(r),
          e.appendChild(o),
          sg)
        ) {
          var a = document.getElementById("dg-local-explain"),
            l = document.getElementById("dg-local-storage");
          (document.getElementById("dg-save-locally").style.display = "block"),
            "true" === localStorage.getItem(yg(0, "isLocal")) &&
              l.setAttribute("checked", "checked"),
            bg(t, a),
            Vm.bind(l, "change", function () {
              (t.useLocalStorage = !t.useLocalStorage), bg(t, a);
            });
        }
        var c = document.getElementById("dg-new-constructor");
        Vm.bind(c, "keydown", function (t) {
          !t.metaKey || (67 !== t.which && 67 !== t.keyCode) || ag.hide();
        }),
          Vm.bind(n, "click", function () {
            (c.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2)),
              ag.show(),
              c.focus(),
              c.select();
          }),
          Vm.bind(i, "click", function () {
            t.save();
          }),
          Vm.bind(r, "click", function () {
            var e = prompt("Enter a new preset name.");
            e && t.saveAs(e);
          }),
          Vm.bind(o, "click", function () {
            t.revert();
          });
      }
      function _g(t) {
        var e = void 0;
        function n(n) {
          return (
            n.preventDefault(),
            (t.width += e - n.clientX),
            t.onResize(),
            (e = n.clientX),
            !1
          );
        }
        function i() {
          Vm.removeClass(t.__closeButton, dg.CLASS_DRAG),
            Vm.unbind(window, "mousemove", n),
            Vm.unbind(window, "mouseup", i);
        }
        function r(r) {
          return (
            r.preventDefault(),
            (e = r.clientX),
            Vm.addClass(t.__closeButton, dg.CLASS_DRAG),
            Vm.bind(window, "mousemove", n),
            Vm.bind(window, "mouseup", i),
            !1
          );
        }
        (t.__resize_handle = document.createElement("div")),
          _m.extend(t.__resize_handle.style, {
            width: "6px",
            marginLeft: "-3px",
            height: "200px",
            cursor: "ew-resize",
            position: "absolute",
          }),
          Vm.bind(t.__resize_handle, "mousedown", r),
          Vm.bind(t.__closeButton, "mousedown", r),
          t.domElement.insertBefore(
            t.__resize_handle,
            t.domElement.firstElementChild
          );
      }
      function Mg(t, e) {
        (t.domElement.style.width = e + "px"),
          t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"),
          t.__closeButton && (t.__closeButton.style.width = e + "px");
      }
      function Sg(t, e) {
        var n = {};
        return (
          _m.each(t.__rememberedObjects, function (i, r) {
            var o = {},
              s = t.__rememberedObjectIndecesToControllers[r];
            _m.each(s, function (t, n) {
              o[n] = e ? t.initialValue : t.getValue();
            }),
              (n[r] = o);
          }),
          n
        );
      }
      function Eg(t) {
        0 !== t.length &&
          ig.call(window, function () {
            Eg(t);
          }),
          _m.each(t, function (t) {
            t.updateDisplay();
          });
      }
      (dg.toggleHide = function () {
        (ug = !ug),
          _m.each(hg, function (t) {
            t.domElement.style.display = ug ? "none" : "";
          });
      }),
        (dg.CLASS_AUTO_PLACE = "a"),
        (dg.CLASS_AUTO_PLACE_CONTAINER = "ac"),
        (dg.CLASS_MAIN = "main"),
        (dg.CLASS_CONTROLLER_ROW = "cr"),
        (dg.CLASS_TOO_TALL = "taller-than-window"),
        (dg.CLASS_CLOSED = "closed"),
        (dg.CLASS_CLOSE_BUTTON = "close-button"),
        (dg.CLASS_CLOSE_TOP = "close-top"),
        (dg.CLASS_CLOSE_BOTTOM = "close-bottom"),
        (dg.CLASS_DRAG = "drag"),
        (dg.DEFAULT_WIDTH = 245),
        (dg.TEXT_CLOSED = "Close Controls"),
        (dg.TEXT_OPEN = "Open Controls"),
        (dg._keydownHandler = function (t) {
          "text" === document.activeElement.type ||
            (72 !== t.which && 72 !== t.keyCode) ||
            dg.toggleHide();
        }),
        Vm.bind(window, "keydown", dg._keydownHandler, !1),
        _m.extend(dg.prototype, {
          add: function (t, e) {
            return vg(this, t, e, {
              factoryArgs: Array.prototype.slice.call(arguments, 2),
            });
          },
          addColor: function (t, e) {
            return vg(this, t, e, { color: !0 });
          },
          remove: function (t) {
            this.__ul.removeChild(t.__li),
              this.__controllers.splice(this.__controllers.indexOf(t), 1);
            var e = this;
            _m.defer(function () {
              e.onResize();
            });
          },
          destroy: function () {
            if (this.parent)
              throw new Error(
                "Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead."
              );
            this.autoPlace && cg.removeChild(this.domElement);
            var t = this;
            _m.each(this.__folders, function (e) {
              t.removeFolder(e);
            }),
              Vm.unbind(window, "keydown", dg._keydownHandler, !1),
              fg(this);
          },
          addFolder: function (t) {
            if (void 0 !== this.__folders[t])
              throw new Error(
                'You already have a folder in this GUI by the name "' + t + '"'
              );
            var e = { name: t, parent: this };
            (e.autoPlace = this.autoPlace),
              this.load &&
                this.load.folders &&
                this.load.folders[t] &&
                ((e.closed = this.load.folders[t].closed),
                (e.load = this.load.folders[t]));
            var n = new dg(e);
            this.__folders[t] = n;
            var i = pg(this, n.domElement);
            return Vm.addClass(i, "folder"), n;
          },
          removeFolder: function (t) {
            this.__ul.removeChild(t.domElement.parentElement),
              delete this.__folders[t.name],
              this.load &&
                this.load.folders &&
                this.load.folders[t.name] &&
                delete this.load.folders[t.name],
              fg(t);
            var e = this;
            _m.each(t.__folders, function (e) {
              t.removeFolder(e);
            }),
              _m.defer(function () {
                e.onResize();
              });
          },
          open: function () {
            this.closed = !1;
          },
          close: function () {
            this.closed = !0;
          },
          hide: function () {
            this.domElement.style.display = "none";
          },
          show: function () {
            this.domElement.style.display = "";
          },
          onResize: function () {
            var t = this.getRoot();
            if (t.scrollable) {
              var e = Vm.getOffset(t.__ul).top,
                n = 0;
              _m.each(t.__ul.childNodes, function (e) {
                (t.autoPlace && e === t.__save_row) || (n += Vm.getHeight(e));
              }),
                window.innerHeight - e - 20 < n
                  ? (Vm.addClass(t.domElement, dg.CLASS_TOO_TALL),
                    (t.__ul.style.height = window.innerHeight - e - 20 + "px"))
                  : (Vm.removeClass(t.domElement, dg.CLASS_TOO_TALL),
                    (t.__ul.style.height = "auto"));
            }
            t.__resize_handle &&
              _m.defer(function () {
                t.__resize_handle.style.height = t.__ul.offsetHeight + "px";
              }),
              t.__closeButton && (t.__closeButton.style.width = t.width + "px");
          },
          onResizeDebounced: _m.debounce(function () {
            this.onResize();
          }, 50),
          remember: function () {
            if (
              (_m.isUndefined(ag) &&
                ((ag = new rg()).domElement.innerHTML = eg),
              this.parent)
            )
              throw new Error("You can only call remember on a top level GUI.");
            var t = this;
            _m.each(Array.prototype.slice.call(arguments), function (e) {
              0 === t.__rememberedObjects.length && wg(t),
                -1 === t.__rememberedObjects.indexOf(e) &&
                  t.__rememberedObjects.push(e);
            }),
              this.autoPlace && Mg(this, this.width);
          },
          getRoot: function () {
            for (var t = this; t.parent; ) t = t.parent;
            return t;
          },
          getSaveObject: function () {
            var t = this.load;
            return (
              (t.closed = this.closed),
              this.__rememberedObjects.length > 0 &&
                ((t.preset = this.preset),
                t.remembered || (t.remembered = {}),
                (t.remembered[this.preset] = Sg(this))),
              (t.folders = {}),
              _m.each(this.__folders, function (e, n) {
                t.folders[n] = e.getSaveObject();
              }),
              t
            );
          },
          save: function () {
            this.load.remembered || (this.load.remembered = {}),
              (this.load.remembered[this.preset] = Sg(this)),
              mg(this, !1),
              this.saveToLocalStorageIfPossible();
          },
          saveAs: function (t) {
            this.load.remembered ||
              ((this.load.remembered = {}),
              (this.load.remembered.Default = Sg(this, !0))),
              (this.load.remembered[t] = Sg(this)),
              (this.preset = t),
              xg(this, t, !0),
              this.saveToLocalStorageIfPossible();
          },
          revert: function (t) {
            _m.each(
              this.__controllers,
              function (e) {
                this.getRoot().load.remembered
                  ? gg(t || this.getRoot(), e)
                  : e.setValue(e.initialValue),
                  e.__onFinishChange &&
                    e.__onFinishChange.call(e, e.getValue());
              },
              this
            ),
              _m.each(this.__folders, function (t) {
                t.revert(t);
              }),
              t || mg(this.getRoot(), !1);
          },
          listen: function (t) {
            var e = 0 === this.__listening.length;
            this.__listening.push(t), e && Eg(this.__listening);
          },
          updateDisplay: function () {
            _m.each(this.__controllers, function (t) {
              t.updateDisplay();
            }),
              _m.each(this.__folders, function (t) {
                t.updateDisplay();
              });
          },
        });
      var Tg = dg;
      n(191),
        n(501),
        (function () {
          var e = new Audio("sound/orbit_jc.ogg").play();
          void 0 !== e &&
            e
              .then((t) => {
                console.log("DuccBOX.dom"), (e.loop = !0);
              })
              .catch((t) => {});
          const n = new Tg(),
            i = `Guest${Math.floor(5e3 * Math.random())}`;
          console.log("My Name is " + i);
          const r = ["font-family: px-sans;", "font-family: ms-comic;"],
            o = r[Math.floor(Math.random() * r.length)];
          "font-family: ms-comic;" == o &&
            (document.getElementById("rev").innerHTML =
              "________||DuccBOX.js REV  v2.4 M1 "),
            "font-family: px-sans;" == o &&
              (document.getElementById("rev").innerHTML =
                "______||DuccBOX.js REV  v2.4 M1 "),
            (document.getElementById("rev").style.cssText = o),
            new si();
          const s = new bd();
          let a = s.load(
            "https://DuccBOXsocket.rileythedoggo.repl.co/helvetiker_bold.typeface.json"
          );
          if (
            (s.load(
              "https://DuccBOXsocket.rileythedoggo.repl.co/helvetiker_bold.typeface.json",
              function (t) {
                a = t;
              }
            ),
            !t)
          )
            throw new Error(
              "DuccBOX.error THIS IS A FATAL THREE.JS ERROR PLEASE REPORT THIS TO @I like food#8767"
            );
          if (!Tg)
            throw new Error(
              "DuccBOX.error THIS IS A FATAL ERROR PLEASE REPORT THIS TO @I like food#8767"
            );
          new $r();
          const l = io("https://duccboxsocket.rileythedoggo.repl.co");
          var c;
          let u, h, d, p, f, m;
          l.emit("client-user-joined", i),
            ((c = document.createElement("script")).onload = function () {
              var t = new Stats();
              document.body.appendChild(t.dom),
                requestAnimationFrame(function e() {
                  t.update(), requestAnimationFrame(e);
                });
            }),
            (c.src = "js/stats.js"),
            document.head.appendChild(c),
            new XMLHttpRequest(),
            console.log(
              "%cDuccBOX is an Open world sandbox made with WebGL/Three.js ",
              "color:blue;font-family:system-ui;font-size:4rem;-webkit-text-stroke: 1px black;font-weight:bold"
            ),
            console.log(
              "%cNote: This is a Milestone 1 alpha build ",
              "color:red;font-family:system-ui;font-size:4rem;-webkit-text-stroke: 1px black;font-weight:bold"
            ),
            console.log(
              "You can find the Source code at [https://github.com/Riley-the-doggo/DuccBOXjs] "
            ),
            console.info(" v2.4 M1"),
            (d = new Ll()),
            (u = new Ao(75, window.innerWidth / window.innerHeight, 0.1, 1e3)),
            (f = new If()),
            (p = new El()),
            p.setSize(window.innerWidth, window.innerHeight),
            document.body.appendChild(p.domElement),
            new Dh(),
            f.load(
              "https://tomo0613.github.io/offroadJS/client/model/skybox.jpg"
            );
          const g = new wo(1, 1, 1),
            v = new Lr({ color: 65280 }),
            y = (new xo(g, v), Math.random(), new Uo(1e4, 1e4, 0, 0)),
            x = new xo(y, void 0);
          x.position.set(500, 0, 500),
            d.add(x),
            f.load(
              "GLtf/world.glb",
              function (t) {
                d.add(t.scene),
                  t.animations,
                  t.scene,
                  t.scenes,
                  t.cameras,
                  t.asset;
              },
              (m = new Fh().load(
                "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR7CgRkVD-wPJQUneeToWgeDWQrXrKVuG8pruN25ryy7APB99k_mWsu-H6_IGf1tQ4_XGk&usqp=CAU"
              ))
            ),
            l.on("r-u-online", () => {
              l.emit("client-online-yes");
            }),
            m || console.error("DuccBOX.THREE.error Failed to load sky-box"),
            (d.background = m);
          const b = new Fh().load(
              "https://as1.ftcdn.net/v2/jpg/02/21/47/92/500_F_221479270_5WgcQKg1sYkwsp7ba2nLh0v2A7CGVqHR.jpg"
            ),
            w = new xo(new Xu(20, 32, 20), new ih({ map: b }));
          d.add(w),
            (w.position.y = 2e3),
            l.on("io-user-joined", () => {
              const t = new wo(3, 3, 3),
                e = new Lr({ color: 65280 }),
                n = new xo(t, e);
              d.add(n), (n.position.x = 400 * Math.random());
            }),
            (function () {
              const t = new nd(16777215, 1);
              t.position.set(-100, 300, -100),
                (t.castShadow = !0),
                (t.shadow.camera.left = -2e3),
                (t.shadow.camera.right = 2e3),
                (t.shadow.camera.top = 2e3),
                (t.shadow.camera.bottom = -2e3),
                (t.shadow.camera.far = 2e3),
                (t.shadow.mapSize.width = 2048),
                (t.shadow.mapSize.height = 2048),
                d.add(t);
              const e = new id(8421504);
              d.add(e);
            })();
          const _ = new wo(3, 3, 3),
            M = new Lr({ color: 65280 }),
            S = new xo(_, M);
          d.add(S);
          let E = S.position.x;
          S.position.y,
            console.log(E),
            (S.position.y = 1),
            (u.position.y = 2),
            window.addEventListener("keydown", function (t) {
              87 == t.keyCode &&
                ((S.position.x -= 1), (u.position.y = S.position.y));
            }),
            window.addEventListener("keydown", function (t) {
              65 == t.keyCode &&
                ((S.position.z += 1),
                (u.position.y = 2),
                (u.position.z = S.position.z));
            }),
            window.addEventListener("keydown", function (t) {
              83 == t.keyCode &&
                ((S.position.x += 1),
                (u.position.y = 2),
                (u.position.x = S.position.x));
            }),
            window.addEventListener("keydown", function (t) {
              68 == t.keyCode &&
                ((S.position.z -= 1),
                (u.position.y = 2),
                (u.position.z = S.position.z));
            }),
            window.addEventListener("keydown", function (t) {
              32 == t.keyCode &&
                ((S.position.y += 2),
                setTimeout(() => {
                  S.position.y -= 2;
                }, 200));
            }),
            window.addEventListener("keydown", function (t) {
              82 == t.keyCode &&
                ((S.rotation.y += 1),
                (u.position.y = 2),
                u.lookAt(-S.rotation.y, 1, 10));
            }),
            window.addEventListener("keydown", function (t) {
              69 == t.keyCode &&
                ((S.rotation.y -= 2),
                (u.position.y = 2),
                u.lookAt(-S.rotation.y, 1, 10));
            }),
            window.addEventListener("keydown", function (t) {
              80 == t.keyCode &&
                ((S.rotation.y = 0), u.lookAt(S.rotation.y, 1, S.rotation.y));
            });
          const T = new Zu("Hello three.js!");
          d.add(T);
          const A = new Fh().load("img/2k_sun.jpg"),
            C = new xo(new Xu(20, 32, 20), new ih({ map: A }));
          let L = !1;
          (C.position.y = 800), d.add(C);
          const R = new Ju(200, 1, 16, 200),
            P = new ih({ color: 16737095 }),
            N = new xo(R, P);
          (N.position.y = 800),
            d.add(N),
            (w.position.z = 200 * Math.random()),
            (w.position.x = 200 * Math.random()),
            window.addEventListener("resize", function () {
              (u.aspect = window.innerWidth / window.innerHeight),
                u.updateProjectionMatrix(),
                p.setSize(window.innerWidth, window.innerHeight);
            });
          const I = {
              add: function () {
                d.add(new Lp(200, 50)), d.add(new _f(2e3));
              },
            },
            B = {
              add: function () {
                (L = !0), (h = new ym(u, p.domElement)), h.update();
              },
            };
          n.add(I, "add").name("helper"),
            n.add(B, "add").name("Free-cam"),
            (function t() {
              requestAnimationFrame(t),
                (document.getElementById(
                  "cords"
                ).innerHTML = `x:${S.position.x} y:${S.position.y} z:${S.position.z} look:${S.rotation.y}`),
                0 == L &&
                  ((u.position.z = S.position.z),
                  (u.position.x = S.position.x),
                  (u.position.y = S.position.y)),
                (N.rotation.x += 0.007),
                (N.rotation.y += 0.007),
                (N.rotation.z += 0.007),
                (N.position.z += 0.03),
                (C.position.z += 0.03),
                (w.position.y -= 1),
                p.render(d, u);
            })();
        })();
    })();
})();
