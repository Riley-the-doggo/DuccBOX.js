/******/ (function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/ var installedModules = {};

  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId])
      /******/ return installedModules[moduleId].exports;

    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (installedModules[moduleId] = {
      /******/ exports: {},
      /******/ id: moduleId,
      /******/ loaded: false,
      /******/
    });

    /******/ // Execute the module function
    /******/ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    );

    /******/ // Flag the module as loaded
    /******/ module.loaded = true;

    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }

  /******/ // expose the modules object (__webpack_modules__)
  /******/ __webpack_require__.m = modules;

  /******/ // expose the module cache
  /******/ __webpack_require__.c = installedModules;

  /******/ // __webpack_public_path__
  /******/ __webpack_require__.p = "";

  /******/ // Load entry module and return exports
  /******/ return __webpack_require__(0);
  /******/
})(
  /************************************************************************/
  /******/ [
    /* 0 */
    /***/ function (module, exports, __webpack_require__) {
      /*
       * index.js
       * */

      (function (global) {
        var $ = __webpack_require__(1);
        var THREE = __webpack_require__(3);
        __webpack_require__(4);

        __webpack_require__(5);

        __webpack_require__(6);
        __webpack_require__(7);
        __webpack_require__(8);
        __webpack_require__(9);
        __webpack_require__(10);

        var noise = __webpack_require__(11);

        var dat = __webpack_require__(12);
        var TWEEN = __webpack_require__(13);

        __webpack_require__(14);
        __webpack_require__(15);
        __webpack_require__(16);
        __webpack_require__(17);

        var app,
          App = function (id) {
            app = this;
            app.init(id);
          };

        App.prototype = {
          init: function (id) {
            app.scene = new THREE.Scene();

            app.camera = new THREE.PerspectiveCamera(
              75,
              window.innerWidth / window.innerHeight,
              0.05,
              1000
            );
            app.camera.position.set(14, 6, 14);

            app.renderer = new THREE.WebGLRenderer({
              alpha: true,
              antialias: true,
            });
            app.renderer.shadowMap.enabled = true;
            app.renderer.shadowMap.type = THREE.PCFShadowMap;

            app.renderer.setClearColor(0xffffff);
            app.renderer.setSize(window.innerWidth, window.innerHeight);
            $(id).append(app.renderer.domElement);

            // setup floor ----

            var noiseScale = 1.5;
            var size = 40;
            var height = 0.025;

            var floor = new THREE.Mesh(
              new THREE.ParametricGeometry(
                function (u, v) {
                  var x = u - 0.5;
                  var y = v - 0.5;
                  return new THREE.Vector3(
                    x,
                    y,
                    noise.simplex2(x * noiseScale, y * noiseScale) * height
                  );
                },
                12,
                12
              ),
              new THREE.MeshPhongMaterial({
                side: THREE.DoubleSide,
                color: 0xbbbbbb,
                shininess: 40,
                shading: THREE.FlatShading,
              })
            );

            floor.position.set(0, 0.0, 0);
            floor.scale.set(size, size, size);
            floor.rotation.set(-Math.PI * 0.5, 0, 0);
            floor.castShadow = floor.receiveShadow = true;
            app.scene.add(floor);

            // ---- setup floor

            var tree = new THREE.Tree({
              generations: 5,
              length: 4.0,
              uvLength: 20.0,
              radius: 0.2,
              radiusSegments: 8,
            });

            // var helper = new THREE.TreeHelper(tree);
            // helper.position.set(10, 0, 0);
            // helper.showLine();
            // app.scene.add(helper);

            var loader = new THREE.TextureLoader();

            loader.load("assets/textures/bark.png", function (treeMapTexture) {
              loader.load(
                "assets/textures/bark_normal.png",
                function (treeNormalMap) {
                  treeMapTexture.wrapS = treeMapTexture.wrapT =
                    THREE.RepeatWrapping;
                  treeMapTexture.repeat.set(1, 25.0);
                  treeNormalMap.wrapS = treeNormalMap.wrapT =
                    THREE.RepeatWrapping;
                  treeNormalMap.repeat.set(1, 25.0);

                  app.treeMapTexture = treeMapTexture;
                  app.treeNormalMap = treeNormalMap;

                  var mesh = new THREE.Mesh(
                    THREE.TreeGeometry.build(tree),
                    new THREE.MeshPhongMaterial({
                      shininess: 5,
                      map: app.treeMapTexture,
                      normalMap: app.treeNormalMap,
                    })
                  );
                  mesh.castShadow = mesh.receiveShadow = true;
                  app.scene.add(mesh);
                  mesh.position.set(0, 0, 0);
                }
              );
            });

            var light0 = new THREE.DirectionalLight(0xffffff, 1.0);
            light0.position.set(20, 30, 20);
            light0.castShadow = true;
            light0.shadow.camera.fov = 120;
            light0.shadow.camera.near = 0.1;
            light0.shadow.camera.far = 1000;
            light0.shadow.camera.top = light0.shadow.camera.right = 20;
            light0.shadow.camera.bottom = light0.shadow.camera.left = -20;
            light0.shadow.mapSize.width = light0.shadow.mapSize.height = 2048;
            app.scene.add(light0);

            app.light = light0;

            var light1 = new THREE.DirectionalLight(0xffffff, 0.5);
            light1.position.set(-1, 1, -1);
            app.scene.add(light1);

            var ambientLight = new THREE.AmbientLight(0x404040);
            app.scene.add(ambientLight);

            app.clock = new THREE.Clock();
            app.controls = new THREE.OrbitControls(
              app.camera,
              app.renderer.domElement
            );
            app.controls.enablePan = false;
            app.controls.enableDamping = true;
            app.controls.dampingFactor = 0.5;
            app.controls.maxPolarAngle = Math.PI * 0.45;
            app.controls.minDistance = 7.0;
            app.controls.maxDistance = 40;

            app.mouse = new THREE.Vector2(-1, -1);

            var dragged = false;

            var clearDrag = function (e) {
              dragged = false;
            };

            var drag = function (e) {
              dragged = true;
            };

            var raycaster = new THREE.Raycaster();

            var click = function (e) {
              if (dragged) return;
              if (!app.treeMapTexture || !app.treeNormalMap) return;

              app.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
              app.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
              raycaster.setFromCamera(app.mouse, app.camera);
              var intersect = raycaster.intersectObject(floor);
              if (intersect.length > 0) {
                var point = intersect[0].point;
                app.plant(new THREE.Vector3(point.x, point.y, point.z));
              }
            };

            document.addEventListener("mousedown", clearDrag);
            document.addEventListener("mousemove", drag);
            document.addEventListener("mouseup", click);

            document.addEventListener("touchstart", clearDrag);
            document.addEventListener("touchmove", drag);
            document.addEventListener("touchend", click);

            app.composer = new THREE.EffectComposer(app.renderer);

            $(window).on("resize", function () {
              app.resize();
            });

            app.composer.addPass(new THREE.RenderPass(app.scene, app.camera));

            var bloomPass = new THREE.BloomBlendPass(
              2.5,
              0.5,
              new THREE.Vector2(window.innerWidth, window.innerHeight)
            );
            app.composer.addPass(bloomPass);

            var correctionPass = new THREE.ShaderPass({
              uniforms: {
                tDiffuse: { type: "t", value: null },
                uDS: { type: "f", value: 0.52 },
              },
              vertexShader: __webpack_require__(18),
              fragmentShader: __webpack_require__(19),
            });
            correctionPass.renderToScreen = true;
            app.composer.addPass(correctionPass);

            app.composer.setSize(window.innerWidth, window.innerHeight);

            app.loop();
          },

          loop: function () {
            requestAnimationFrame(function () {
              app.loop();
            });

            TWEEN.update();

            var delta = app.clock.getDelta();
            app.controls.update(delta);

            // var t = app.clock.elapsedTime * 0.1;
            // var x = Math.cos(t) * 20;
            // var z = Math.sin(t) * 20;
            // app.light.position.set(x, 20, z);

            // app.renderer.render(app.scene, app.camera);
            app.composer.render();
          },

          resize: function () {
            var w = window.innerWidth;
            var h = window.innerHeight;
            app.camera.aspect = w / h;
            app.camera.updateProjectionMatrix();
            app.renderer.setSize(w, h);
            app.composer.setSize(w, h);
          },

          plant: function (position) {
            var tree = new THREE.Tree({
              generations: 4,
              length: 4.0,
              uvLength: 16.0,
              radius: 0.2,
              radiusSegments: 8,
            });
            var geometry = THREE.TreeGeometry.build(tree);

            var treeMat = new THREE.TreeMaterial();
            treeMat.uniforms.uGrow.value = 0.0;
            treeMat.uniforms.map.value = app.treeMapTexture;
            treeMat.uniforms.offsetRepeat.value = new THREE.Vector4(
              app.treeMapTexture.offset.x,
              app.treeMapTexture.offset.y,
              app.treeMapTexture.repeat.x,
              app.treeMapTexture.repeat.y
            );
            treeMat.uniforms.normalMap.value = app.treeNormalMap;

            var depthMat = new THREE.ShaderMaterial({
              uniforms: { uGrow: { type: "f", value: 0.0 } },
              vertexShader: __webpack_require__(20),
              fragmentShader: __webpack_require__(21),
            });

            var mesh = new THREE.Mesh(geometry, treeMat);
            mesh.customDepthMaterial = depthMat;
            mesh.castShadow = mesh.receiveShadow = true;
            mesh.position.set(position.x, position.y, position.z);
            app.scene.add(mesh);

            var duration = 1000 + Math.random() * 200;
            new TWEEN.Tween({ t: 0.0 })
              .to({ t: 1.0 }, duration)
              .easing(TWEEN.Easing.Linear.None)
              .onUpdate(function () {
                treeMat.uniforms.uGrow.value = depthMat.uniforms.uGrow.value =
                  this.t;
              })
              .start();
          },
        };

        $(function () {
          var app = new App("#viewer");
        });
      })(this);

      /***/
    },
    /* 1 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__; /*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
      !(function (a, b) {
        "object" == typeof module && "object" == typeof module.exports
          ? (module.exports = a.document
              ? b(a, !0)
              : function (a) {
                  if (!a.document)
                    throw new Error("jQuery requires a window with a document");
                  return b(a);
                })
          : b(a);
      })("undefined" != typeof window ? window : this, function (a, b) {
        var c = [],
          d = c.slice,
          e = c.concat,
          f = c.push,
          g = c.indexOf,
          h = {},
          i = h.toString,
          j = h.hasOwnProperty,
          k = {},
          l = a.document,
          m = "2.1.4",
          n = function (a, b) {
            return new n.fn.init(a, b);
          },
          o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
          p = /^-ms-/,
          q = /-([\da-z])/gi,
          r = function (a, b) {
            return b.toUpperCase();
          };
        (n.fn = n.prototype =
          {
            jquery: m,
            constructor: n,
            selector: "",
            length: 0,
            toArray: function () {
              return d.call(this);
            },
            get: function (a) {
              return null != a
                ? 0 > a
                  ? this[a + this.length]
                  : this[a]
                : d.call(this);
            },
            pushStack: function (a) {
              var b = n.merge(this.constructor(), a);
              return (b.prevObject = this), (b.context = this.context), b;
            },
            each: function (a, b) {
              return n.each(this, a, b);
            },
            map: function (a) {
              return this.pushStack(
                n.map(this, function (b, c) {
                  return a.call(b, c, b);
                })
              );
            },
            slice: function () {
              return this.pushStack(d.apply(this, arguments));
            },
            first: function () {
              return this.eq(0);
            },
            last: function () {
              return this.eq(-1);
            },
            eq: function (a) {
              var b = this.length,
                c = +a + (0 > a ? b : 0);
              return this.pushStack(c >= 0 && b > c ? [this[c]] : []);
            },
            end: function () {
              return this.prevObject || this.constructor(null);
            },
            push: f,
            sort: c.sort,
            splice: c.splice,
          }),
          (n.extend = n.fn.extend =
            function () {
              var a,
                b,
                c,
                d,
                e,
                f,
                g = arguments[0] || {},
                h = 1,
                i = arguments.length,
                j = !1;
              for (
                "boolean" == typeof g &&
                  ((j = g), (g = arguments[h] || {}), h++),
                  "object" == typeof g || n.isFunction(g) || (g = {}),
                  h === i && ((g = this), h--);
                i > h;
                h++
              )
                if (null != (a = arguments[h]))
                  for (b in a)
                    (c = g[b]),
                      (d = a[b]),
                      g !== d &&
                        (j && d && (n.isPlainObject(d) || (e = n.isArray(d)))
                          ? (e
                              ? ((e = !1), (f = c && n.isArray(c) ? c : []))
                              : (f = c && n.isPlainObject(c) ? c : {}),
                            (g[b] = n.extend(j, f, d)))
                          : void 0 !== d && (g[b] = d));
              return g;
            }),
          n.extend({
            expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function (a) {
              throw new Error(a);
            },
            noop: function () {},
            isFunction: function (a) {
              return "function" === n.type(a);
            },
            isArray: Array.isArray,
            isWindow: function (a) {
              return null != a && a === a.window;
            },
            isNumeric: function (a) {
              return !n.isArray(a) && a - parseFloat(a) + 1 >= 0;
            },
            isPlainObject: function (a) {
              return "object" !== n.type(a) || a.nodeType || n.isWindow(a)
                ? !1
                : a.constructor &&
                  !j.call(a.constructor.prototype, "isPrototypeOf")
                ? !1
                : !0;
            },
            isEmptyObject: function (a) {
              var b;
              for (b in a) return !1;
              return !0;
            },
            type: function (a) {
              return null == a
                ? a + ""
                : "object" == typeof a || "function" == typeof a
                ? h[i.call(a)] || "object"
                : typeof a;
            },
            globalEval: function (a) {
              var b,
                c = eval;
              (a = n.trim(a)),
                a &&
                  (1 === a.indexOf("use strict")
                    ? ((b = l.createElement("script")),
                      (b.text = a),
                      l.head.appendChild(b).parentNode.removeChild(b))
                    : c(a));
            },
            camelCase: function (a) {
              return a.replace(p, "ms-").replace(q, r);
            },
            nodeName: function (a, b) {
              return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
            },
            each: function (a, b, c) {
              var d,
                e = 0,
                f = a.length,
                g = s(a);
              if (c) {
                if (g) {
                  for (; f > e; e++)
                    if (((d = b.apply(a[e], c)), d === !1)) break;
                } else
                  for (e in a) if (((d = b.apply(a[e], c)), d === !1)) break;
              } else if (g) {
                for (; f > e; e++)
                  if (((d = b.call(a[e], e, a[e])), d === !1)) break;
              } else
                for (e in a) if (((d = b.call(a[e], e, a[e])), d === !1)) break;
              return a;
            },
            trim: function (a) {
              return null == a ? "" : (a + "").replace(o, "");
            },
            makeArray: function (a, b) {
              var c = b || [];
              return (
                null != a &&
                  (s(Object(a))
                    ? n.merge(c, "string" == typeof a ? [a] : a)
                    : f.call(c, a)),
                c
              );
            },
            inArray: function (a, b, c) {
              return null == b ? -1 : g.call(b, a, c);
            },
            merge: function (a, b) {
              for (var c = +b.length, d = 0, e = a.length; c > d; d++)
                a[e++] = b[d];
              return (a.length = e), a;
            },
            grep: function (a, b, c) {
              for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++)
                (d = !b(a[f], f)), d !== h && e.push(a[f]);
              return e;
            },
            map: function (a, b, c) {
              var d,
                f = 0,
                g = a.length,
                h = s(a),
                i = [];
              if (h)
                for (; g > f; f++) (d = b(a[f], f, c)), null != d && i.push(d);
              else for (f in a) (d = b(a[f], f, c)), null != d && i.push(d);
              return e.apply([], i);
            },
            guid: 1,
            proxy: function (a, b) {
              var c, e, f;
              return (
                "string" == typeof b && ((c = a[b]), (b = a), (a = c)),
                n.isFunction(a)
                  ? ((e = d.call(arguments, 2)),
                    (f = function () {
                      return a.apply(b || this, e.concat(d.call(arguments)));
                    }),
                    (f.guid = a.guid = a.guid || n.guid++),
                    f)
                  : void 0
              );
            },
            now: Date.now,
            support: k,
          }),
          n.each(
            "Boolean Number String Function Array Date RegExp Object Error".split(
              " "
            ),
            function (a, b) {
              h["[object " + b + "]"] = b.toLowerCase();
            }
          );
        function s(a) {
          var b = "length" in a && a.length,
            c = n.type(a);
          return "function" === c || n.isWindow(a)
            ? !1
            : 1 === a.nodeType && b
            ? !0
            : "array" === c ||
              0 === b ||
              ("number" == typeof b && b > 0 && b - 1 in a);
        }
        var t = (function (a) {
          var b,
            c,
            d,
            e,
            f,
            g,
            h,
            i,
            j,
            k,
            l,
            m,
            n,
            o,
            p,
            q,
            r,
            s,
            t,
            u = "sizzle" + 1 * new Date(),
            v = a.document,
            w = 0,
            x = 0,
            y = ha(),
            z = ha(),
            A = ha(),
            B = function (a, b) {
              return a === b && (l = !0), 0;
            },
            C = 1 << 31,
            D = {}.hasOwnProperty,
            E = [],
            F = E.pop,
            G = E.push,
            H = E.push,
            I = E.slice,
            J = function (a, b) {
              for (var c = 0, d = a.length; d > c; c++)
                if (a[c] === b) return c;
              return -1;
            },
            K =
              "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            L = "[\\x20\\t\\r\\n\\f]",
            M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
            N = M.replace("w", "w#"),
            O =
              "\\[" +
              L +
              "*(" +
              M +
              ")(?:" +
              L +
              "*([*^$|!~]?=)" +
              L +
              "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
              N +
              "))|)" +
              L +
              "*\\]",
            P =
              ":(" +
              M +
              ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" +
              O +
              ")*)|.*)\\)|)",
            Q = new RegExp(L + "+", "g"),
            R = new RegExp(
              "^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$",
              "g"
            ),
            S = new RegExp("^" + L + "*," + L + "*"),
            T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"),
            U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"),
            V = new RegExp(P),
            W = new RegExp("^" + N + "$"),
            X = {
              ID: new RegExp("^#(" + M + ")"),
              CLASS: new RegExp("^\\.(" + M + ")"),
              TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
              ATTR: new RegExp("^" + O),
              PSEUDO: new RegExp("^" + P),
              CHILD: new RegExp(
                "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
                  L +
                  "*(even|odd|(([+-]|)(\\d*)n|)" +
                  L +
                  "*(?:([+-]|)" +
                  L +
                  "*(\\d+)|))" +
                  L +
                  "*\\)|)",
                "i"
              ),
              bool: new RegExp("^(?:" + K + ")$", "i"),
              needsContext: new RegExp(
                "^" +
                  L +
                  "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                  L +
                  "*((?:-\\d)?\\d*)" +
                  L +
                  "*\\)|)(?=[^-]|$)",
                "i"
              ),
            },
            Y = /^(?:input|select|textarea|button)$/i,
            Z = /^h\d$/i,
            $ = /^[^{]+\{\s*\[native \w/,
            _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            aa = /[+~]/,
            ba = /'|\\/g,
            ca = new RegExp(
              "\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)",
              "ig"
            ),
            da = function (a, b, c) {
              var d = "0x" + b - 65536;
              return d !== d || c
                ? b
                : 0 > d
                ? String.fromCharCode(d + 65536)
                : String.fromCharCode((d >> 10) | 55296, (1023 & d) | 56320);
            },
            ea = function () {
              m();
            };
          try {
            H.apply((E = I.call(v.childNodes)), v.childNodes),
              E[v.childNodes.length].nodeType;
          } catch (fa) {
            H = {
              apply: E.length
                ? function (a, b) {
                    G.apply(a, I.call(b));
                  }
                : function (a, b) {
                    var c = a.length,
                      d = 0;
                    while ((a[c++] = b[d++]));
                    a.length = c - 1;
                  },
            };
          }
          function ga(a, b, d, e) {
            var f, h, j, k, l, o, r, s, w, x;
            if (
              ((b ? b.ownerDocument || b : v) !== n && m(b),
              (b = b || n),
              (d = d || []),
              (k = b.nodeType),
              "string" != typeof a || !a || (1 !== k && 9 !== k && 11 !== k))
            )
              return d;
            if (!e && p) {
              if (11 !== k && (f = _.exec(a)))
                if ((j = f[1])) {
                  if (9 === k) {
                    if (((h = b.getElementById(j)), !h || !h.parentNode))
                      return d;
                    if (h.id === j) return d.push(h), d;
                  } else if (
                    b.ownerDocument &&
                    (h = b.ownerDocument.getElementById(j)) &&
                    t(b, h) &&
                    h.id === j
                  )
                    return d.push(h), d;
                } else {
                  if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;
                  if ((j = f[3]) && c.getElementsByClassName)
                    return H.apply(d, b.getElementsByClassName(j)), d;
                }
              if (c.qsa && (!q || !q.test(a))) {
                if (
                  ((s = r = u),
                  (w = b),
                  (x = 1 !== k && a),
                  1 === k && "object" !== b.nodeName.toLowerCase())
                ) {
                  (o = g(a)),
                    (r = b.getAttribute("id"))
                      ? (s = r.replace(ba, "\\$&"))
                      : b.setAttribute("id", s),
                    (s = "[id='" + s + "'] "),
                    (l = o.length);
                  while (l--) o[l] = s + ra(o[l]);
                  (w = (aa.test(a) && pa(b.parentNode)) || b),
                    (x = o.join(","));
                }
                if (x)
                  try {
                    return H.apply(d, w.querySelectorAll(x)), d;
                  } catch (y) {
                  } finally {
                    r || b.removeAttribute("id");
                  }
              }
            }
            return i(a.replace(R, "$1"), b, d, e);
          }
          function ha() {
            var a = [];
            function b(c, e) {
              return (
                a.push(c + " ") > d.cacheLength && delete b[a.shift()],
                (b[c + " "] = e)
              );
            }
            return b;
          }
          function ia(a) {
            return (a[u] = !0), a;
          }
          function ja(a) {
            var b = n.createElement("div");
            try {
              return !!a(b);
            } catch (c) {
              return !1;
            } finally {
              b.parentNode && b.parentNode.removeChild(b), (b = null);
            }
          }
          function ka(a, b) {
            var c = a.split("|"),
              e = a.length;
            while (e--) d.attrHandle[c[e]] = b;
          }
          function la(a, b) {
            var c = b && a,
              d =
                c &&
                1 === a.nodeType &&
                1 === b.nodeType &&
                (~b.sourceIndex || C) - (~a.sourceIndex || C);
            if (d) return d;
            if (c) while ((c = c.nextSibling)) if (c === b) return -1;
            return a ? 1 : -1;
          }
          function ma(a) {
            return function (b) {
              var c = b.nodeName.toLowerCase();
              return "input" === c && b.type === a;
            };
          }
          function na(a) {
            return function (b) {
              var c = b.nodeName.toLowerCase();
              return ("input" === c || "button" === c) && b.type === a;
            };
          }
          function oa(a) {
            return ia(function (b) {
              return (
                (b = +b),
                ia(function (c, d) {
                  var e,
                    f = a([], c.length, b),
                    g = f.length;
                  while (g--) c[(e = f[g])] && (c[e] = !(d[e] = c[e]));
                })
              );
            });
          }
          function pa(a) {
            return a && "undefined" != typeof a.getElementsByTagName && a;
          }
          (c = ga.support = {}),
            (f = ga.isXML =
              function (a) {
                var b = a && (a.ownerDocument || a).documentElement;
                return b ? "HTML" !== b.nodeName : !1;
              }),
            (m = ga.setDocument =
              function (a) {
                var b,
                  e,
                  g = a ? a.ownerDocument || a : v;
                return g !== n && 9 === g.nodeType && g.documentElement
                  ? ((n = g),
                    (o = g.documentElement),
                    (e = g.defaultView),
                    e &&
                      e !== e.top &&
                      (e.addEventListener
                        ? e.addEventListener("unload", ea, !1)
                        : e.attachEvent && e.attachEvent("onunload", ea)),
                    (p = !f(g)),
                    (c.attributes = ja(function (a) {
                      return (a.className = "i"), !a.getAttribute("className");
                    })),
                    (c.getElementsByTagName = ja(function (a) {
                      return (
                        a.appendChild(g.createComment("")),
                        !a.getElementsByTagName("*").length
                      );
                    })),
                    (c.getElementsByClassName = $.test(
                      g.getElementsByClassName
                    )),
                    (c.getById = ja(function (a) {
                      return (
                        (o.appendChild(a).id = u),
                        !g.getElementsByName || !g.getElementsByName(u).length
                      );
                    })),
                    c.getById
                      ? ((d.find.ID = function (a, b) {
                          if ("undefined" != typeof b.getElementById && p) {
                            var c = b.getElementById(a);
                            return c && c.parentNode ? [c] : [];
                          }
                        }),
                        (d.filter.ID = function (a) {
                          var b = a.replace(ca, da);
                          return function (a) {
                            return a.getAttribute("id") === b;
                          };
                        }))
                      : (delete d.find.ID,
                        (d.filter.ID = function (a) {
                          var b = a.replace(ca, da);
                          return function (a) {
                            var c =
                              "undefined" != typeof a.getAttributeNode &&
                              a.getAttributeNode("id");
                            return c && c.value === b;
                          };
                        })),
                    (d.find.TAG = c.getElementsByTagName
                      ? function (a, b) {
                          return "undefined" != typeof b.getElementsByTagName
                            ? b.getElementsByTagName(a)
                            : c.qsa
                            ? b.querySelectorAll(a)
                            : void 0;
                        }
                      : function (a, b) {
                          var c,
                            d = [],
                            e = 0,
                            f = b.getElementsByTagName(a);
                          if ("*" === a) {
                            while ((c = f[e++])) 1 === c.nodeType && d.push(c);
                            return d;
                          }
                          return f;
                        }),
                    (d.find.CLASS =
                      c.getElementsByClassName &&
                      function (a, b) {
                        return p ? b.getElementsByClassName(a) : void 0;
                      }),
                    (r = []),
                    (q = []),
                    (c.qsa = $.test(g.querySelectorAll)) &&
                      (ja(function (a) {
                        (o.appendChild(a).innerHTML =
                          "<a id='" +
                          u +
                          "'></a><select id='" +
                          u +
                          "-\f]' msallowcapture=''><option selected=''></option></select>"),
                          a.querySelectorAll("[msallowcapture^='']").length &&
                            q.push("[*^$]=" + L + "*(?:''|\"\")"),
                          a.querySelectorAll("[selected]").length ||
                            q.push("\\[" + L + "*(?:value|" + K + ")"),
                          a.querySelectorAll("[id~=" + u + "-]").length ||
                            q.push("~="),
                          a.querySelectorAll(":checked").length ||
                            q.push(":checked"),
                          a.querySelectorAll("a#" + u + "+*").length ||
                            q.push(".#.+[+~]");
                      }),
                      ja(function (a) {
                        var b = g.createElement("input");
                        b.setAttribute("type", "hidden"),
                          a.appendChild(b).setAttribute("name", "D"),
                          a.querySelectorAll("[name=d]").length &&
                            q.push("name" + L + "*[*^$|!~]?="),
                          a.querySelectorAll(":enabled").length ||
                            q.push(":enabled", ":disabled"),
                          a.querySelectorAll("*,:x"),
                          q.push(",.*:");
                      })),
                    (c.matchesSelector = $.test(
                      (s =
                        o.matches ||
                        o.webkitMatchesSelector ||
                        o.mozMatchesSelector ||
                        o.oMatchesSelector ||
                        o.msMatchesSelector)
                    )) &&
                      ja(function (a) {
                        (c.disconnectedMatch = s.call(a, "div")),
                          s.call(a, "[s!='']:x"),
                          r.push("!=", P);
                      }),
                    (q = q.length && new RegExp(q.join("|"))),
                    (r = r.length && new RegExp(r.join("|"))),
                    (b = $.test(o.compareDocumentPosition)),
                    (t =
                      b || $.test(o.contains)
                        ? function (a, b) {
                            var c = 9 === a.nodeType ? a.documentElement : a,
                              d = b && b.parentNode;
                            return (
                              a === d ||
                              !(
                                !d ||
                                1 !== d.nodeType ||
                                !(c.contains
                                  ? c.contains(d)
                                  : a.compareDocumentPosition &&
                                    16 & a.compareDocumentPosition(d))
                              )
                            );
                          }
                        : function (a, b) {
                            if (b)
                              while ((b = b.parentNode)) if (b === a) return !0;
                            return !1;
                          }),
                    (B = b
                      ? function (a, b) {
                          if (a === b) return (l = !0), 0;
                          var d =
                            !a.compareDocumentPosition -
                            !b.compareDocumentPosition;
                          return d
                            ? d
                            : ((d =
                                (a.ownerDocument || a) ===
                                (b.ownerDocument || b)
                                  ? a.compareDocumentPosition(b)
                                  : 1),
                              1 & d ||
                              (!c.sortDetached &&
                                b.compareDocumentPosition(a) === d)
                                ? a === g || (a.ownerDocument === v && t(v, a))
                                  ? -1
                                  : b === g ||
                                    (b.ownerDocument === v && t(v, b))
                                  ? 1
                                  : k
                                  ? J(k, a) - J(k, b)
                                  : 0
                                : 4 & d
                                ? -1
                                : 1);
                        }
                      : function (a, b) {
                          if (a === b) return (l = !0), 0;
                          var c,
                            d = 0,
                            e = a.parentNode,
                            f = b.parentNode,
                            h = [a],
                            i = [b];
                          if (!e || !f)
                            return a === g
                              ? -1
                              : b === g
                              ? 1
                              : e
                              ? -1
                              : f
                              ? 1
                              : k
                              ? J(k, a) - J(k, b)
                              : 0;
                          if (e === f) return la(a, b);
                          c = a;
                          while ((c = c.parentNode)) h.unshift(c);
                          c = b;
                          while ((c = c.parentNode)) i.unshift(c);
                          while (h[d] === i[d]) d++;
                          return d
                            ? la(h[d], i[d])
                            : h[d] === v
                            ? -1
                            : i[d] === v
                            ? 1
                            : 0;
                        }),
                    g)
                  : n;
              }),
            (ga.matches = function (a, b) {
              return ga(a, null, null, b);
            }),
            (ga.matchesSelector = function (a, b) {
              if (
                ((a.ownerDocument || a) !== n && m(a),
                (b = b.replace(U, "='$1']")),
                !(
                  !c.matchesSelector ||
                  !p ||
                  (r && r.test(b)) ||
                  (q && q.test(b))
                ))
              )
                try {
                  var d = s.call(a, b);
                  if (
                    d ||
                    c.disconnectedMatch ||
                    (a.document && 11 !== a.document.nodeType)
                  )
                    return d;
                } catch (e) {}
              return ga(b, n, null, [a]).length > 0;
            }),
            (ga.contains = function (a, b) {
              return (a.ownerDocument || a) !== n && m(a), t(a, b);
            }),
            (ga.attr = function (a, b) {
              (a.ownerDocument || a) !== n && m(a);
              var e = d.attrHandle[b.toLowerCase()],
                f =
                  e && D.call(d.attrHandle, b.toLowerCase())
                    ? e(a, b, !p)
                    : void 0;
              return void 0 !== f
                ? f
                : c.attributes || !p
                ? a.getAttribute(b)
                : (f = a.getAttributeNode(b)) && f.specified
                ? f.value
                : null;
            }),
            (ga.error = function (a) {
              throw new Error("Syntax error, unrecognized expression: " + a);
            }),
            (ga.uniqueSort = function (a) {
              var b,
                d = [],
                e = 0,
                f = 0;
              if (
                ((l = !c.detectDuplicates),
                (k = !c.sortStable && a.slice(0)),
                a.sort(B),
                l)
              ) {
                while ((b = a[f++])) b === a[f] && (e = d.push(f));
                while (e--) a.splice(d[e], 1);
              }
              return (k = null), a;
            }),
            (e = ga.getText =
              function (a) {
                var b,
                  c = "",
                  d = 0,
                  f = a.nodeType;
                if (f) {
                  if (1 === f || 9 === f || 11 === f) {
                    if ("string" == typeof a.textContent) return a.textContent;
                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a);
                  } else if (3 === f || 4 === f) return a.nodeValue;
                } else while ((b = a[d++])) c += e(b);
                return c;
              }),
            (d = ga.selectors =
              {
                cacheLength: 50,
                createPseudo: ia,
                match: X,
                attrHandle: {},
                find: {},
                relative: {
                  ">": { dir: "parentNode", first: !0 },
                  " ": { dir: "parentNode" },
                  "+": { dir: "previousSibling", first: !0 },
                  "~": { dir: "previousSibling" },
                },
                preFilter: {
                  ATTR: function (a) {
                    return (
                      (a[1] = a[1].replace(ca, da)),
                      (a[3] = (a[3] || a[4] || a[5] || "").replace(ca, da)),
                      "~=" === a[2] && (a[3] = " " + a[3] + " "),
                      a.slice(0, 4)
                    );
                  },
                  CHILD: function (a) {
                    return (
                      (a[1] = a[1].toLowerCase()),
                      "nth" === a[1].slice(0, 3)
                        ? (a[3] || ga.error(a[0]),
                          (a[4] = +(a[4]
                            ? a[5] + (a[6] || 1)
                            : 2 * ("even" === a[3] || "odd" === a[3]))),
                          (a[5] = +(a[7] + a[8] || "odd" === a[3])))
                        : a[3] && ga.error(a[0]),
                      a
                    );
                  },
                  PSEUDO: function (a) {
                    var b,
                      c = !a[6] && a[2];
                    return X.CHILD.test(a[0])
                      ? null
                      : (a[3]
                          ? (a[2] = a[4] || a[5] || "")
                          : c &&
                            V.test(c) &&
                            (b = g(c, !0)) &&
                            (b = c.indexOf(")", c.length - b) - c.length) &&
                            ((a[0] = a[0].slice(0, b)), (a[2] = c.slice(0, b))),
                        a.slice(0, 3));
                  },
                },
                filter: {
                  TAG: function (a) {
                    var b = a.replace(ca, da).toLowerCase();
                    return "*" === a
                      ? function () {
                          return !0;
                        }
                      : function (a) {
                          return a.nodeName && a.nodeName.toLowerCase() === b;
                        };
                  },
                  CLASS: function (a) {
                    var b = y[a + " "];
                    return (
                      b ||
                      ((b = new RegExp(
                        "(^|" + L + ")" + a + "(" + L + "|$)"
                      )) &&
                        y(a, function (a) {
                          return b.test(
                            ("string" == typeof a.className && a.className) ||
                              ("undefined" != typeof a.getAttribute &&
                                a.getAttribute("class")) ||
                              ""
                          );
                        }))
                    );
                  },
                  ATTR: function (a, b, c) {
                    return function (d) {
                      var e = ga.attr(d, a);
                      return null == e
                        ? "!=" === b
                        : b
                        ? ((e += ""),
                          "=" === b
                            ? e === c
                            : "!=" === b
                            ? e !== c
                            : "^=" === b
                            ? c && 0 === e.indexOf(c)
                            : "*=" === b
                            ? c && e.indexOf(c) > -1
                            : "$=" === b
                            ? c && e.slice(-c.length) === c
                            : "~=" === b
                            ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1
                            : "|=" === b
                            ? e === c || e.slice(0, c.length + 1) === c + "-"
                            : !1)
                        : !0;
                    };
                  },
                  CHILD: function (a, b, c, d, e) {
                    var f = "nth" !== a.slice(0, 3),
                      g = "last" !== a.slice(-4),
                      h = "of-type" === b;
                    return 1 === d && 0 === e
                      ? function (a) {
                          return !!a.parentNode;
                        }
                      : function (b, c, i) {
                          var j,
                            k,
                            l,
                            m,
                            n,
                            o,
                            p = f !== g ? "nextSibling" : "previousSibling",
                            q = b.parentNode,
                            r = h && b.nodeName.toLowerCase(),
                            s = !i && !h;
                          if (q) {
                            if (f) {
                              while (p) {
                                l = b;
                                while ((l = l[p]))
                                  if (
                                    h
                                      ? l.nodeName.toLowerCase() === r
                                      : 1 === l.nodeType
                                  )
                                    return !1;
                                o = p = "only" === a && !o && "nextSibling";
                              }
                              return !0;
                            }
                            if (
                              ((o = [g ? q.firstChild : q.lastChild]), g && s)
                            ) {
                              (k = q[u] || (q[u] = {})),
                                (j = k[a] || []),
                                (n = j[0] === w && j[1]),
                                (m = j[0] === w && j[2]),
                                (l = n && q.childNodes[n]);
                              while (
                                (l =
                                  (++n && l && l[p]) || (m = n = 0) || o.pop())
                              )
                                if (1 === l.nodeType && ++m && l === b) {
                                  k[a] = [w, n, m];
                                  break;
                                }
                            } else if (
                              s &&
                              (j = (b[u] || (b[u] = {}))[a]) &&
                              j[0] === w
                            )
                              m = j[1];
                            else
                              while (
                                (l =
                                  (++n && l && l[p]) || (m = n = 0) || o.pop())
                              )
                                if (
                                  (h
                                    ? l.nodeName.toLowerCase() === r
                                    : 1 === l.nodeType) &&
                                  ++m &&
                                  (s && ((l[u] || (l[u] = {}))[a] = [w, m]),
                                  l === b)
                                )
                                  break;
                            return (
                              (m -= e), m === d || (m % d === 0 && m / d >= 0)
                            );
                          }
                        };
                  },
                  PSEUDO: function (a, b) {
                    var c,
                      e =
                        d.pseudos[a] ||
                        d.setFilters[a.toLowerCase()] ||
                        ga.error("unsupported pseudo: " + a);
                    return e[u]
                      ? e(b)
                      : e.length > 1
                      ? ((c = [a, a, "", b]),
                        d.setFilters.hasOwnProperty(a.toLowerCase())
                          ? ia(function (a, c) {
                              var d,
                                f = e(a, b),
                                g = f.length;
                              while (g--)
                                (d = J(a, f[g])), (a[d] = !(c[d] = f[g]));
                            })
                          : function (a) {
                              return e(a, 0, c);
                            })
                      : e;
                  },
                },
                pseudos: {
                  not: ia(function (a) {
                    var b = [],
                      c = [],
                      d = h(a.replace(R, "$1"));
                    return d[u]
                      ? ia(function (a, b, c, e) {
                          var f,
                            g = d(a, null, e, []),
                            h = a.length;
                          while (h--) (f = g[h]) && (a[h] = !(b[h] = f));
                        })
                      : function (a, e, f) {
                          return (
                            (b[0] = a),
                            d(b, null, f, c),
                            (b[0] = null),
                            !c.pop()
                          );
                        };
                  }),
                  has: ia(function (a) {
                    return function (b) {
                      return ga(a, b).length > 0;
                    };
                  }),
                  contains: ia(function (a) {
                    return (
                      (a = a.replace(ca, da)),
                      function (b) {
                        return (
                          (b.textContent || b.innerText || e(b)).indexOf(a) > -1
                        );
                      }
                    );
                  }),
                  lang: ia(function (a) {
                    return (
                      W.test(a || "") || ga.error("unsupported lang: " + a),
                      (a = a.replace(ca, da).toLowerCase()),
                      function (b) {
                        var c;
                        do
                          if (
                            (c = p
                              ? b.lang
                              : b.getAttribute("xml:lang") ||
                                b.getAttribute("lang"))
                          )
                            return (
                              (c = c.toLowerCase()),
                              c === a || 0 === c.indexOf(a + "-")
                            );
                        while ((b = b.parentNode) && 1 === b.nodeType);
                        return !1;
                      }
                    );
                  }),
                  target: function (b) {
                    var c = a.location && a.location.hash;
                    return c && c.slice(1) === b.id;
                  },
                  root: function (a) {
                    return a === o;
                  },
                  focus: function (a) {
                    return (
                      a === n.activeElement &&
                      (!n.hasFocus || n.hasFocus()) &&
                      !!(a.type || a.href || ~a.tabIndex)
                    );
                  },
                  enabled: function (a) {
                    return a.disabled === !1;
                  },
                  disabled: function (a) {
                    return a.disabled === !0;
                  },
                  checked: function (a) {
                    var b = a.nodeName.toLowerCase();
                    return (
                      ("input" === b && !!a.checked) ||
                      ("option" === b && !!a.selected)
                    );
                  },
                  selected: function (a) {
                    return (
                      a.parentNode && a.parentNode.selectedIndex,
                      a.selected === !0
                    );
                  },
                  empty: function (a) {
                    for (a = a.firstChild; a; a = a.nextSibling)
                      if (a.nodeType < 6) return !1;
                    return !0;
                  },
                  parent: function (a) {
                    return !d.pseudos.empty(a);
                  },
                  header: function (a) {
                    return Z.test(a.nodeName);
                  },
                  input: function (a) {
                    return Y.test(a.nodeName);
                  },
                  button: function (a) {
                    var b = a.nodeName.toLowerCase();
                    return (
                      ("input" === b && "button" === a.type) || "button" === b
                    );
                  },
                  text: function (a) {
                    var b;
                    return (
                      "input" === a.nodeName.toLowerCase() &&
                      "text" === a.type &&
                      (null == (b = a.getAttribute("type")) ||
                        "text" === b.toLowerCase())
                    );
                  },
                  first: oa(function () {
                    return [0];
                  }),
                  last: oa(function (a, b) {
                    return [b - 1];
                  }),
                  eq: oa(function (a, b, c) {
                    return [0 > c ? c + b : c];
                  }),
                  even: oa(function (a, b) {
                    for (var c = 0; b > c; c += 2) a.push(c);
                    return a;
                  }),
                  odd: oa(function (a, b) {
                    for (var c = 1; b > c; c += 2) a.push(c);
                    return a;
                  }),
                  lt: oa(function (a, b, c) {
                    for (var d = 0 > c ? c + b : c; --d >= 0; ) a.push(d);
                    return a;
                  }),
                  gt: oa(function (a, b, c) {
                    for (var d = 0 > c ? c + b : c; ++d < b; ) a.push(d);
                    return a;
                  }),
                },
              }),
            (d.pseudos.nth = d.pseudos.eq);
          for (b in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0,
          })
            d.pseudos[b] = ma(b);
          for (b in { submit: !0, reset: !0 }) d.pseudos[b] = na(b);
          function qa() {}
          (qa.prototype = d.filters = d.pseudos),
            (d.setFilters = new qa()),
            (g = ga.tokenize =
              function (a, b) {
                var c,
                  e,
                  f,
                  g,
                  h,
                  i,
                  j,
                  k = z[a + " "];
                if (k) return b ? 0 : k.slice(0);
                (h = a), (i = []), (j = d.preFilter);
                while (h) {
                  (!c || (e = S.exec(h))) &&
                    (e && (h = h.slice(e[0].length) || h), i.push((f = []))),
                    (c = !1),
                    (e = T.exec(h)) &&
                      ((c = e.shift()),
                      f.push({ value: c, type: e[0].replace(R, " ") }),
                      (h = h.slice(c.length)));
                  for (g in d.filter)
                    !(e = X[g].exec(h)) ||
                      (j[g] && !(e = j[g](e))) ||
                      ((c = e.shift()),
                      f.push({ value: c, type: g, matches: e }),
                      (h = h.slice(c.length)));
                  if (!c) break;
                }
                return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);
              });
          function ra(a) {
            for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
            return d;
          }
          function sa(a, b, c) {
            var d = b.dir,
              e = c && "parentNode" === d,
              f = x++;
            return b.first
              ? function (b, c, f) {
                  while ((b = b[d]))
                    if (1 === b.nodeType || e) return a(b, c, f);
                }
              : function (b, c, g) {
                  var h,
                    i,
                    j = [w, f];
                  if (g) {
                    while ((b = b[d]))
                      if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
                  } else
                    while ((b = b[d]))
                      if (1 === b.nodeType || e) {
                        if (
                          ((i = b[u] || (b[u] = {})),
                          (h = i[d]) && h[0] === w && h[1] === f)
                        )
                          return (j[2] = h[2]);
                        if (((i[d] = j), (j[2] = a(b, c, g)))) return !0;
                      }
                };
          }
          function ta(a) {
            return a.length > 1
              ? function (b, c, d) {
                  var e = a.length;
                  while (e--) if (!a[e](b, c, d)) return !1;
                  return !0;
                }
              : a[0];
          }
          function ua(a, b, c) {
            for (var d = 0, e = b.length; e > d; d++) ga(a, b[d], c);
            return c;
          }
          function va(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)
              (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));
            return g;
          }
          function wa(a, b, c, d, e, f) {
            return (
              d && !d[u] && (d = wa(d)),
              e && !e[u] && (e = wa(e, f)),
              ia(function (f, g, h, i) {
                var j,
                  k,
                  l,
                  m = [],
                  n = [],
                  o = g.length,
                  p = f || ua(b || "*", h.nodeType ? [h] : h, []),
                  q = !a || (!f && b) ? p : va(p, m, a, h, i),
                  r = c ? (e || (f ? a : o || d) ? [] : g) : q;
                if ((c && c(q, r, h, i), d)) {
                  (j = va(r, n)), d(j, [], h, i), (k = j.length);
                  while (k--) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
                }
                if (f) {
                  if (e || a) {
                    if (e) {
                      (j = []), (k = r.length);
                      while (k--) (l = r[k]) && j.push((q[k] = l));
                      e(null, (r = []), j, i);
                    }
                    k = r.length;
                    while (k--)
                      (l = r[k]) &&
                        (j = e ? J(f, l) : m[k]) > -1 &&
                        (f[j] = !(g[j] = l));
                  }
                } else (r = va(r === g ? r.splice(o, r.length) : r)), e ? e(null, g, r, i) : H.apply(g, r);
              })
            );
          }
          function xa(a) {
            for (
              var b,
                c,
                e,
                f = a.length,
                g = d.relative[a[0].type],
                h = g || d.relative[" "],
                i = g ? 1 : 0,
                k = sa(
                  function (a) {
                    return a === b;
                  },
                  h,
                  !0
                ),
                l = sa(
                  function (a) {
                    return J(b, a) > -1;
                  },
                  h,
                  !0
                ),
                m = [
                  function (a, c, d) {
                    var e =
                      (!g && (d || c !== j)) ||
                      ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
                    return (b = null), e;
                  },
                ];
              f > i;
              i++
            )
              if ((c = d.relative[a[i].type])) m = [sa(ta(m), c)];
              else {
                if (
                  ((c = d.filter[a[i].type].apply(null, a[i].matches)), c[u])
                ) {
                  for (e = ++i; f > e; e++) if (d.relative[a[e].type]) break;
                  return wa(
                    i > 1 && ta(m),
                    i > 1 &&
                      ra(
                        a
                          .slice(0, i - 1)
                          .concat({ value: " " === a[i - 2].type ? "*" : "" })
                      ).replace(R, "$1"),
                    c,
                    e > i && xa(a.slice(i, e)),
                    f > e && xa((a = a.slice(e))),
                    f > e && ra(a)
                  );
                }
                m.push(c);
              }
            return ta(m);
          }
          function ya(a, b) {
            var c = b.length > 0,
              e = a.length > 0,
              f = function (f, g, h, i, k) {
                var l,
                  m,
                  o,
                  p = 0,
                  q = "0",
                  r = f && [],
                  s = [],
                  t = j,
                  u = f || (e && d.find.TAG("*", k)),
                  v = (w += null == t ? 1 : Math.random() || 0.1),
                  x = u.length;
                for (
                  k && (j = g !== n && g);
                  q !== x && null != (l = u[q]);
                  q++
                ) {
                  if (e && l) {
                    m = 0;
                    while ((o = a[m++]))
                      if (o(l, g, h)) {
                        i.push(l);
                        break;
                      }
                    k && (w = v);
                  }
                  c && ((l = !o && l) && p--, f && r.push(l));
                }
                if (((p += q), c && q !== p)) {
                  m = 0;
                  while ((o = b[m++])) o(r, s, g, h);
                  if (f) {
                    if (p > 0) while (q--) r[q] || s[q] || (s[q] = F.call(i));
                    s = va(s);
                  }
                  H.apply(i, s),
                    k &&
                      !f &&
                      s.length > 0 &&
                      p + b.length > 1 &&
                      ga.uniqueSort(i);
                }
                return k && ((w = v), (j = t)), r;
              };
            return c ? ia(f) : f;
          }
          return (
            (h = ga.compile =
              function (a, b) {
                var c,
                  d = [],
                  e = [],
                  f = A[a + " "];
                if (!f) {
                  b || (b = g(a)), (c = b.length);
                  while (c--) (f = xa(b[c])), f[u] ? d.push(f) : e.push(f);
                  (f = A(a, ya(e, d))), (f.selector = a);
                }
                return f;
              }),
            (i = ga.select =
              function (a, b, e, f) {
                var i,
                  j,
                  k,
                  l,
                  m,
                  n = "function" == typeof a && a,
                  o = !f && g((a = n.selector || a));
                if (((e = e || []), 1 === o.length)) {
                  if (
                    ((j = o[0] = o[0].slice(0)),
                    j.length > 2 &&
                      "ID" === (k = j[0]).type &&
                      c.getById &&
                      9 === b.nodeType &&
                      p &&
                      d.relative[j[1].type])
                  ) {
                    if (
                      ((b = (d.find.ID(k.matches[0].replace(ca, da), b) ||
                        [])[0]),
                      !b)
                    )
                      return e;
                    n && (b = b.parentNode),
                      (a = a.slice(j.shift().value.length));
                  }
                  i = X.needsContext.test(a) ? 0 : j.length;
                  while (i--) {
                    if (((k = j[i]), d.relative[(l = k.type)])) break;
                    if (
                      (m = d.find[l]) &&
                      (f = m(
                        k.matches[0].replace(ca, da),
                        (aa.test(j[0].type) && pa(b.parentNode)) || b
                      ))
                    ) {
                      if ((j.splice(i, 1), (a = f.length && ra(j)), !a))
                        return H.apply(e, f), e;
                      break;
                    }
                  }
                }
                return (
                  (n || h(a, o))(
                    f,
                    b,
                    !p,
                    e,
                    (aa.test(a) && pa(b.parentNode)) || b
                  ),
                  e
                );
              }),
            (c.sortStable = u.split("").sort(B).join("") === u),
            (c.detectDuplicates = !!l),
            m(),
            (c.sortDetached = ja(function (a) {
              return 1 & a.compareDocumentPosition(n.createElement("div"));
            })),
            ja(function (a) {
              return (
                (a.innerHTML = "<a href='#'></a>"),
                "#" === a.firstChild.getAttribute("href")
              );
            }) ||
              ka("type|href|height|width", function (a, b, c) {
                return c
                  ? void 0
                  : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
              }),
            (c.attributes &&
              ja(function (a) {
                return (
                  (a.innerHTML = "<input/>"),
                  a.firstChild.setAttribute("value", ""),
                  "" === a.firstChild.getAttribute("value")
                );
              })) ||
              ka("value", function (a, b, c) {
                return c || "input" !== a.nodeName.toLowerCase()
                  ? void 0
                  : a.defaultValue;
              }),
            ja(function (a) {
              return null == a.getAttribute("disabled");
            }) ||
              ka(K, function (a, b, c) {
                var d;
                return c
                  ? void 0
                  : a[b] === !0
                  ? b.toLowerCase()
                  : (d = a.getAttributeNode(b)) && d.specified
                  ? d.value
                  : null;
              }),
            ga
          );
        })(a);
        (n.find = t),
          (n.expr = t.selectors),
          (n.expr[":"] = n.expr.pseudos),
          (n.unique = t.uniqueSort),
          (n.text = t.getText),
          (n.isXMLDoc = t.isXML),
          (n.contains = t.contains);
        var u = n.expr.match.needsContext,
          v = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
          w = /^.[^:#\[\.,]*$/;
        function x(a, b, c) {
          if (n.isFunction(b))
            return n.grep(a, function (a, d) {
              return !!b.call(a, d, a) !== c;
            });
          if (b.nodeType)
            return n.grep(a, function (a) {
              return (a === b) !== c;
            });
          if ("string" == typeof b) {
            if (w.test(b)) return n.filter(b, a, c);
            b = n.filter(b, a);
          }
          return n.grep(a, function (a) {
            return g.call(b, a) >= 0 !== c;
          });
        }
        (n.filter = function (a, b, c) {
          var d = b[0];
          return (
            c && (a = ":not(" + a + ")"),
            1 === b.length && 1 === d.nodeType
              ? n.find.matchesSelector(d, a)
                ? [d]
                : []
              : n.find.matches(
                  a,
                  n.grep(b, function (a) {
                    return 1 === a.nodeType;
                  })
                )
          );
        }),
          n.fn.extend({
            find: function (a) {
              var b,
                c = this.length,
                d = [],
                e = this;
              if ("string" != typeof a)
                return this.pushStack(
                  n(a).filter(function () {
                    for (b = 0; c > b; b++)
                      if (n.contains(e[b], this)) return !0;
                  })
                );
              for (b = 0; c > b; b++) n.find(a, e[b], d);
              return (
                (d = this.pushStack(c > 1 ? n.unique(d) : d)),
                (d.selector = this.selector ? this.selector + " " + a : a),
                d
              );
            },
            filter: function (a) {
              return this.pushStack(x(this, a || [], !1));
            },
            not: function (a) {
              return this.pushStack(x(this, a || [], !0));
            },
            is: function (a) {
              return !!x(
                this,
                "string" == typeof a && u.test(a) ? n(a) : a || [],
                !1
              ).length;
            },
          });
        var y,
          z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
          A = (n.fn.init = function (a, b) {
            var c, d;
            if (!a) return this;
            if ("string" == typeof a) {
              if (
                ((c =
                  "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3
                    ? [null, a, null]
                    : z.exec(a)),
                !c || (!c[1] && b))
              )
                return !b || b.jquery
                  ? (b || y).find(a)
                  : this.constructor(b).find(a);
              if (c[1]) {
                if (
                  ((b = b instanceof n ? b[0] : b),
                  n.merge(
                    this,
                    n.parseHTML(
                      c[1],
                      b && b.nodeType ? b.ownerDocument || b : l,
                      !0
                    )
                  ),
                  v.test(c[1]) && n.isPlainObject(b))
                )
                  for (c in b)
                    n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                return this;
              }
              return (
                (d = l.getElementById(c[2])),
                d && d.parentNode && ((this.length = 1), (this[0] = d)),
                (this.context = l),
                (this.selector = a),
                this
              );
            }
            return a.nodeType
              ? ((this.context = this[0] = a), (this.length = 1), this)
              : n.isFunction(a)
              ? "undefined" != typeof y.ready
                ? y.ready(a)
                : a(n)
              : (void 0 !== a.selector &&
                  ((this.selector = a.selector), (this.context = a.context)),
                n.makeArray(a, this));
          });
        (A.prototype = n.fn), (y = n(l));
        var B = /^(?:parents|prev(?:Until|All))/,
          C = { children: !0, contents: !0, next: !0, prev: !0 };
        n.extend({
          dir: function (a, b, c) {
            var d = [],
              e = void 0 !== c;
            while ((a = a[b]) && 9 !== a.nodeType)
              if (1 === a.nodeType) {
                if (e && n(a).is(c)) break;
                d.push(a);
              }
            return d;
          },
          sibling: function (a, b) {
            for (var c = []; a; a = a.nextSibling)
              1 === a.nodeType && a !== b && c.push(a);
            return c;
          },
        }),
          n.fn.extend({
            has: function (a) {
              var b = n(a, this),
                c = b.length;
              return this.filter(function () {
                for (var a = 0; c > a; a++)
                  if (n.contains(this, b[a])) return !0;
              });
            },
            closest: function (a, b) {
              for (
                var c,
                  d = 0,
                  e = this.length,
                  f = [],
                  g =
                    u.test(a) || "string" != typeof a
                      ? n(a, b || this.context)
                      : 0;
                e > d;
                d++
              )
                for (c = this[d]; c && c !== b; c = c.parentNode)
                  if (
                    c.nodeType < 11 &&
                    (g
                      ? g.index(c) > -1
                      : 1 === c.nodeType && n.find.matchesSelector(c, a))
                  ) {
                    f.push(c);
                    break;
                  }
              return this.pushStack(f.length > 1 ? n.unique(f) : f);
            },
            index: function (a) {
              return a
                ? "string" == typeof a
                  ? g.call(n(a), this[0])
                  : g.call(this, a.jquery ? a[0] : a)
                : this[0] && this[0].parentNode
                ? this.first().prevAll().length
                : -1;
            },
            add: function (a, b) {
              return this.pushStack(n.unique(n.merge(this.get(), n(a, b))));
            },
            addBack: function (a) {
              return this.add(
                null == a ? this.prevObject : this.prevObject.filter(a)
              );
            },
          });
        function D(a, b) {
          while ((a = a[b]) && 1 !== a.nodeType);
          return a;
        }
        n.each(
          {
            parent: function (a) {
              var b = a.parentNode;
              return b && 11 !== b.nodeType ? b : null;
            },
            parents: function (a) {
              return n.dir(a, "parentNode");
            },
            parentsUntil: function (a, b, c) {
              return n.dir(a, "parentNode", c);
            },
            next: function (a) {
              return D(a, "nextSibling");
            },
            prev: function (a) {
              return D(a, "previousSibling");
            },
            nextAll: function (a) {
              return n.dir(a, "nextSibling");
            },
            prevAll: function (a) {
              return n.dir(a, "previousSibling");
            },
            nextUntil: function (a, b, c) {
              return n.dir(a, "nextSibling", c);
            },
            prevUntil: function (a, b, c) {
              return n.dir(a, "previousSibling", c);
            },
            siblings: function (a) {
              return n.sibling((a.parentNode || {}).firstChild, a);
            },
            children: function (a) {
              return n.sibling(a.firstChild);
            },
            contents: function (a) {
              return a.contentDocument || n.merge([], a.childNodes);
            },
          },
          function (a, b) {
            n.fn[a] = function (c, d) {
              var e = n.map(this, b, c);
              return (
                "Until" !== a.slice(-5) && (d = c),
                d && "string" == typeof d && (e = n.filter(d, e)),
                this.length > 1 &&
                  (C[a] || n.unique(e), B.test(a) && e.reverse()),
                this.pushStack(e)
              );
            };
          }
        );
        var E = /\S+/g,
          F = {};
        function G(a) {
          var b = (F[a] = {});
          return (
            n.each(a.match(E) || [], function (a, c) {
              b[c] = !0;
            }),
            b
          );
        }
        (n.Callbacks = function (a) {
          a = "string" == typeof a ? F[a] || G(a) : n.extend({}, a);
          var b,
            c,
            d,
            e,
            f,
            g,
            h = [],
            i = !a.once && [],
            j = function (l) {
              for (
                b = a.memory && l,
                  c = !0,
                  g = e || 0,
                  e = 0,
                  f = h.length,
                  d = !0;
                h && f > g;
                g++
              )
                if (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
                  b = !1;
                  break;
                }
              (d = !1),
                h &&
                  (i ? i.length && j(i.shift()) : b ? (h = []) : k.disable());
            },
            k = {
              add: function () {
                if (h) {
                  var c = h.length;
                  !(function g(b) {
                    n.each(b, function (b, c) {
                      var d = n.type(c);
                      "function" === d
                        ? (a.unique && k.has(c)) || h.push(c)
                        : c && c.length && "string" !== d && g(c);
                    });
                  })(arguments),
                    d ? (f = h.length) : b && ((e = c), j(b));
                }
                return this;
              },
              remove: function () {
                return (
                  h &&
                    n.each(arguments, function (a, b) {
                      var c;
                      while ((c = n.inArray(b, h, c)) > -1)
                        h.splice(c, 1), d && (f >= c && f--, g >= c && g--);
                    }),
                  this
                );
              },
              has: function (a) {
                return a ? n.inArray(a, h) > -1 : !(!h || !h.length);
              },
              empty: function () {
                return (h = []), (f = 0), this;
              },
              disable: function () {
                return (h = i = b = void 0), this;
              },
              disabled: function () {
                return !h;
              },
              lock: function () {
                return (i = void 0), b || k.disable(), this;
              },
              locked: function () {
                return !i;
              },
              fireWith: function (a, b) {
                return (
                  !h ||
                    (c && !i) ||
                    ((b = b || []),
                    (b = [a, b.slice ? b.slice() : b]),
                    d ? i.push(b) : j(b)),
                  this
                );
              },
              fire: function () {
                return k.fireWith(this, arguments), this;
              },
              fired: function () {
                return !!c;
              },
            };
          return k;
        }),
          n.extend({
            Deferred: function (a) {
              var b = [
                  ["resolve", "done", n.Callbacks("once memory"), "resolved"],
                  ["reject", "fail", n.Callbacks("once memory"), "rejected"],
                  ["notify", "progress", n.Callbacks("memory")],
                ],
                c = "pending",
                d = {
                  state: function () {
                    return c;
                  },
                  always: function () {
                    return e.done(arguments).fail(arguments), this;
                  },
                  then: function () {
                    var a = arguments;
                    return n
                      .Deferred(function (c) {
                        n.each(b, function (b, f) {
                          var g = n.isFunction(a[b]) && a[b];
                          e[f[1]](function () {
                            var a = g && g.apply(this, arguments);
                            a && n.isFunction(a.promise)
                              ? a
                                  .promise()
                                  .done(c.resolve)
                                  .fail(c.reject)
                                  .progress(c.notify)
                              : c[f[0] + "With"](
                                  this === d ? c.promise() : this,
                                  g ? [a] : arguments
                                );
                          });
                        }),
                          (a = null);
                      })
                      .promise();
                  },
                  promise: function (a) {
                    return null != a ? n.extend(a, d) : d;
                  },
                },
                e = {};
              return (
                (d.pipe = d.then),
                n.each(b, function (a, f) {
                  var g = f[2],
                    h = f[3];
                  (d[f[1]] = g.add),
                    h &&
                      g.add(
                        function () {
                          c = h;
                        },
                        b[1 ^ a][2].disable,
                        b[2][2].lock
                      ),
                    (e[f[0]] = function () {
                      return (
                        e[f[0] + "With"](this === e ? d : this, arguments), this
                      );
                    }),
                    (e[f[0] + "With"] = g.fireWith);
                }),
                d.promise(e),
                a && a.call(e, e),
                e
              );
            },
            when: function (a) {
              var b = 0,
                c = d.call(arguments),
                e = c.length,
                f = 1 !== e || (a && n.isFunction(a.promise)) ? e : 0,
                g = 1 === f ? a : n.Deferred(),
                h = function (a, b, c) {
                  return function (e) {
                    (b[a] = this),
                      (c[a] = arguments.length > 1 ? d.call(arguments) : e),
                      c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
                  };
                },
                i,
                j,
                k;
              if (e > 1)
                for (
                  i = new Array(e), j = new Array(e), k = new Array(e);
                  e > b;
                  b++
                )
                  c[b] && n.isFunction(c[b].promise)
                    ? c[b]
                        .promise()
                        .done(h(b, k, c))
                        .fail(g.reject)
                        .progress(h(b, j, i))
                    : --f;
              return f || g.resolveWith(k, c), g.promise();
            },
          });
        var H;
        (n.fn.ready = function (a) {
          return n.ready.promise().done(a), this;
        }),
          n.extend({
            isReady: !1,
            readyWait: 1,
            holdReady: function (a) {
              a ? n.readyWait++ : n.ready(!0);
            },
            ready: function (a) {
              (a === !0 ? --n.readyWait : n.isReady) ||
                ((n.isReady = !0),
                (a !== !0 && --n.readyWait > 0) ||
                  (H.resolveWith(l, [n]),
                  n.fn.triggerHandler &&
                    (n(l).triggerHandler("ready"), n(l).off("ready"))));
            },
          });
        function I() {
          l.removeEventListener("DOMContentLoaded", I, !1),
            a.removeEventListener("load", I, !1),
            n.ready();
        }
        (n.ready.promise = function (b) {
          return (
            H ||
              ((H = n.Deferred()),
              "complete" === l.readyState
                ? setTimeout(n.ready)
                : (l.addEventListener("DOMContentLoaded", I, !1),
                  a.addEventListener("load", I, !1))),
            H.promise(b)
          );
        }),
          n.ready.promise();
        var J = (n.access = function (a, b, c, d, e, f, g) {
          var h = 0,
            i = a.length,
            j = null == c;
          if ("object" === n.type(c)) {
            e = !0;
            for (h in c) n.access(a, b, h, c[h], !0, f, g);
          } else if (
            void 0 !== d &&
            ((e = !0),
            n.isFunction(d) || (g = !0),
            j &&
              (g
                ? (b.call(a, d), (b = null))
                : ((j = b),
                  (b = function (a, b, c) {
                    return j.call(n(a), c);
                  }))),
            b)
          )
            for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
          return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
        });
        n.acceptData = function (a) {
          return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;
        };
        function K() {
          Object.defineProperty((this.cache = {}), 0, {
            get: function () {
              return {};
            },
          }),
            (this.expando = n.expando + K.uid++);
        }
        (K.uid = 1),
          (K.accepts = n.acceptData),
          (K.prototype = {
            key: function (a) {
              if (!K.accepts(a)) return 0;
              var b = {},
                c = a[this.expando];
              if (!c) {
                c = K.uid++;
                try {
                  (b[this.expando] = { value: c }),
                    Object.defineProperties(a, b);
                } catch (d) {
                  (b[this.expando] = c), n.extend(a, b);
                }
              }
              return this.cache[c] || (this.cache[c] = {}), c;
            },
            set: function (a, b, c) {
              var d,
                e = this.key(a),
                f = this.cache[e];
              if ("string" == typeof b) f[b] = c;
              else if (n.isEmptyObject(f)) n.extend(this.cache[e], b);
              else for (d in b) f[d] = b[d];
              return f;
            },
            get: function (a, b) {
              var c = this.cache[this.key(a)];
              return void 0 === b ? c : c[b];
            },
            access: function (a, b, c) {
              var d;
              return void 0 === b || (b && "string" == typeof b && void 0 === c)
                ? ((d = this.get(a, b)),
                  void 0 !== d ? d : this.get(a, n.camelCase(b)))
                : (this.set(a, b, c), void 0 !== c ? c : b);
            },
            remove: function (a, b) {
              var c,
                d,
                e,
                f = this.key(a),
                g = this.cache[f];
              if (void 0 === b) this.cache[f] = {};
              else {
                n.isArray(b)
                  ? (d = b.concat(b.map(n.camelCase)))
                  : ((e = n.camelCase(b)),
                    b in g
                      ? (d = [b, e])
                      : ((d = e), (d = d in g ? [d] : d.match(E) || []))),
                  (c = d.length);
                while (c--) delete g[d[c]];
              }
            },
            hasData: function (a) {
              return !n.isEmptyObject(this.cache[a[this.expando]] || {});
            },
            discard: function (a) {
              a[this.expando] && delete this.cache[a[this.expando]];
            },
          });
        var L = new K(),
          M = new K(),
          N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
          O = /([A-Z])/g;
        function P(a, b, c) {
          var d;
          if (void 0 === c && 1 === a.nodeType)
            if (
              ((d = "data-" + b.replace(O, "-$1").toLowerCase()),
              (c = a.getAttribute(d)),
              "string" == typeof c)
            ) {
              try {
                c =
                  "true" === c
                    ? !0
                    : "false" === c
                    ? !1
                    : "null" === c
                    ? null
                    : +c + "" === c
                    ? +c
                    : N.test(c)
                    ? n.parseJSON(c)
                    : c;
              } catch (e) {}
              M.set(a, b, c);
            } else c = void 0;
          return c;
        }
        n.extend({
          hasData: function (a) {
            return M.hasData(a) || L.hasData(a);
          },
          data: function (a, b, c) {
            return M.access(a, b, c);
          },
          removeData: function (a, b) {
            M.remove(a, b);
          },
          _data: function (a, b, c) {
            return L.access(a, b, c);
          },
          _removeData: function (a, b) {
            L.remove(a, b);
          },
        }),
          n.fn.extend({
            data: function (a, b) {
              var c,
                d,
                e,
                f = this[0],
                g = f && f.attributes;
              if (void 0 === a) {
                if (
                  this.length &&
                  ((e = M.get(f)),
                  1 === f.nodeType && !L.get(f, "hasDataAttrs"))
                ) {
                  c = g.length;
                  while (c--)
                    g[c] &&
                      ((d = g[c].name),
                      0 === d.indexOf("data-") &&
                        ((d = n.camelCase(d.slice(5))), P(f, d, e[d])));
                  L.set(f, "hasDataAttrs", !0);
                }
                return e;
              }
              return "object" == typeof a
                ? this.each(function () {
                    M.set(this, a);
                  })
                : J(
                    this,
                    function (b) {
                      var c,
                        d = n.camelCase(a);
                      if (f && void 0 === b) {
                        if (((c = M.get(f, a)), void 0 !== c)) return c;
                        if (((c = M.get(f, d)), void 0 !== c)) return c;
                        if (((c = P(f, d, void 0)), void 0 !== c)) return c;
                      } else
                        this.each(function () {
                          var c = M.get(this, d);
                          M.set(this, d, b),
                            -1 !== a.indexOf("-") &&
                              void 0 !== c &&
                              M.set(this, a, b);
                        });
                    },
                    null,
                    b,
                    arguments.length > 1,
                    null,
                    !0
                  );
            },
            removeData: function (a) {
              return this.each(function () {
                M.remove(this, a);
              });
            },
          }),
          n.extend({
            queue: function (a, b, c) {
              var d;
              return a
                ? ((b = (b || "fx") + "queue"),
                  (d = L.get(a, b)),
                  c &&
                    (!d || n.isArray(c)
                      ? (d = L.access(a, b, n.makeArray(c)))
                      : d.push(c)),
                  d || [])
                : void 0;
            },
            dequeue: function (a, b) {
              b = b || "fx";
              var c = n.queue(a, b),
                d = c.length,
                e = c.shift(),
                f = n._queueHooks(a, b),
                g = function () {
                  n.dequeue(a, b);
                };
              "inprogress" === e && ((e = c.shift()), d--),
                e &&
                  ("fx" === b && c.unshift("inprogress"),
                  delete f.stop,
                  e.call(a, g, f)),
                !d && f && f.empty.fire();
            },
            _queueHooks: function (a, b) {
              var c = b + "queueHooks";
              return (
                L.get(a, c) ||
                L.access(a, c, {
                  empty: n.Callbacks("once memory").add(function () {
                    L.remove(a, [b + "queue", c]);
                  }),
                })
              );
            },
          }),
          n.fn.extend({
            queue: function (a, b) {
              var c = 2;
              return (
                "string" != typeof a && ((b = a), (a = "fx"), c--),
                arguments.length < c
                  ? n.queue(this[0], a)
                  : void 0 === b
                  ? this
                  : this.each(function () {
                      var c = n.queue(this, a, b);
                      n._queueHooks(this, a),
                        "fx" === a &&
                          "inprogress" !== c[0] &&
                          n.dequeue(this, a);
                    })
              );
            },
            dequeue: function (a) {
              return this.each(function () {
                n.dequeue(this, a);
              });
            },
            clearQueue: function (a) {
              return this.queue(a || "fx", []);
            },
            promise: function (a, b) {
              var c,
                d = 1,
                e = n.Deferred(),
                f = this,
                g = this.length,
                h = function () {
                  --d || e.resolveWith(f, [f]);
                };
              "string" != typeof a && ((b = a), (a = void 0)), (a = a || "fx");
              while (g--)
                (c = L.get(f[g], a + "queueHooks")),
                  c && c.empty && (d++, c.empty.add(h));
              return h(), e.promise(b);
            },
          });
        var Q = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
          R = ["Top", "Right", "Bottom", "Left"],
          S = function (a, b) {
            return (
              (a = b || a),
              "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
            );
          },
          T = /^(?:checkbox|radio)$/i;
        !(function () {
          var a = l.createDocumentFragment(),
            b = a.appendChild(l.createElement("div")),
            c = l.createElement("input");
          c.setAttribute("type", "radio"),
            c.setAttribute("checked", "checked"),
            c.setAttribute("name", "t"),
            b.appendChild(c),
            (k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked),
            (b.innerHTML = "<textarea>x</textarea>"),
            (k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue);
        })();
        var U = "undefined";
        k.focusinBubbles = "onfocusin" in a;
        var V = /^key/,
          W = /^(?:mouse|pointer|contextmenu)|click/,
          X = /^(?:focusinfocus|focusoutblur)$/,
          Y = /^([^.]*)(?:\.(.+)|)$/;
        function Z() {
          return !0;
        }
        function $() {
          return !1;
        }
        function _() {
          try {
            return l.activeElement;
          } catch (a) {}
        }
        (n.event = {
          global: {},
          add: function (a, b, c, d, e) {
            var f,
              g,
              h,
              i,
              j,
              k,
              l,
              m,
              o,
              p,
              q,
              r = L.get(a);
            if (r) {
              c.handler && ((f = c), (c = f.handler), (e = f.selector)),
                c.guid || (c.guid = n.guid++),
                (i = r.events) || (i = r.events = {}),
                (g = r.handle) ||
                  (g = r.handle =
                    function (b) {
                      return typeof n !== U && n.event.triggered !== b.type
                        ? n.event.dispatch.apply(a, arguments)
                        : void 0;
                    }),
                (b = (b || "").match(E) || [""]),
                (j = b.length);
              while (j--)
                (h = Y.exec(b[j]) || []),
                  (o = q = h[1]),
                  (p = (h[2] || "").split(".").sort()),
                  o &&
                    ((l = n.event.special[o] || {}),
                    (o = (e ? l.delegateType : l.bindType) || o),
                    (l = n.event.special[o] || {}),
                    (k = n.extend(
                      {
                        type: o,
                        origType: q,
                        data: d,
                        handler: c,
                        guid: c.guid,
                        selector: e,
                        needsContext: e && n.expr.match.needsContext.test(e),
                        namespace: p.join("."),
                      },
                      f
                    )),
                    (m = i[o]) ||
                      ((m = i[o] = []),
                      (m.delegateCount = 0),
                      (l.setup && l.setup.call(a, d, p, g) !== !1) ||
                        (a.addEventListener && a.addEventListener(o, g, !1))),
                    l.add &&
                      (l.add.call(a, k),
                      k.handler.guid || (k.handler.guid = c.guid)),
                    e ? m.splice(m.delegateCount++, 0, k) : m.push(k),
                    (n.event.global[o] = !0));
            }
          },
          remove: function (a, b, c, d, e) {
            var f,
              g,
              h,
              i,
              j,
              k,
              l,
              m,
              o,
              p,
              q,
              r = L.hasData(a) && L.get(a);
            if (r && (i = r.events)) {
              (b = (b || "").match(E) || [""]), (j = b.length);
              while (j--)
                if (
                  ((h = Y.exec(b[j]) || []),
                  (o = q = h[1]),
                  (p = (h[2] || "").split(".").sort()),
                  o)
                ) {
                  (l = n.event.special[o] || {}),
                    (o = (d ? l.delegateType : l.bindType) || o),
                    (m = i[o] || []),
                    (h =
                      h[2] &&
                      new RegExp(
                        "(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"
                      )),
                    (g = f = m.length);
                  while (f--)
                    (k = m[f]),
                      (!e && q !== k.origType) ||
                        (c && c.guid !== k.guid) ||
                        (h && !h.test(k.namespace)) ||
                        (d &&
                          d !== k.selector &&
                          ("**" !== d || !k.selector)) ||
                        (m.splice(f, 1),
                        k.selector && m.delegateCount--,
                        l.remove && l.remove.call(a, k));
                  g &&
                    !m.length &&
                    ((l.teardown && l.teardown.call(a, p, r.handle) !== !1) ||
                      n.removeEvent(a, o, r.handle),
                    delete i[o]);
                } else for (o in i) n.event.remove(a, o + b[j], c, d, !0);
              n.isEmptyObject(i) && (delete r.handle, L.remove(a, "events"));
            }
          },
          trigger: function (b, c, d, e) {
            var f,
              g,
              h,
              i,
              k,
              m,
              o,
              p = [d || l],
              q = j.call(b, "type") ? b.type : b,
              r = j.call(b, "namespace") ? b.namespace.split(".") : [];
            if (
              ((g = h = d = d || l),
              3 !== d.nodeType &&
                8 !== d.nodeType &&
                !X.test(q + n.event.triggered) &&
                (q.indexOf(".") >= 0 &&
                  ((r = q.split(".")), (q = r.shift()), r.sort()),
                (k = q.indexOf(":") < 0 && "on" + q),
                (b = b[n.expando]
                  ? b
                  : new n.Event(q, "object" == typeof b && b)),
                (b.isTrigger = e ? 2 : 3),
                (b.namespace = r.join(".")),
                (b.namespace_re = b.namespace
                  ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)")
                  : null),
                (b.result = void 0),
                b.target || (b.target = d),
                (c = null == c ? [b] : n.makeArray(c, [b])),
                (o = n.event.special[q] || {}),
                e || !o.trigger || o.trigger.apply(d, c) !== !1))
            ) {
              if (!e && !o.noBubble && !n.isWindow(d)) {
                for (
                  i = o.delegateType || q, X.test(i + q) || (g = g.parentNode);
                  g;
                  g = g.parentNode
                )
                  p.push(g), (h = g);
                h === (d.ownerDocument || l) &&
                  p.push(h.defaultView || h.parentWindow || a);
              }
              f = 0;
              while ((g = p[f++]) && !b.isPropagationStopped())
                (b.type = f > 1 ? i : o.bindType || q),
                  (m =
                    (L.get(g, "events") || {})[b.type] && L.get(g, "handle")),
                  m && m.apply(g, c),
                  (m = k && g[k]),
                  m &&
                    m.apply &&
                    n.acceptData(g) &&
                    ((b.result = m.apply(g, c)),
                    b.result === !1 && b.preventDefault());
              return (
                (b.type = q),
                e ||
                  b.isDefaultPrevented() ||
                  (o._default && o._default.apply(p.pop(), c) !== !1) ||
                  !n.acceptData(d) ||
                  (k &&
                    n.isFunction(d[q]) &&
                    !n.isWindow(d) &&
                    ((h = d[k]),
                    h && (d[k] = null),
                    (n.event.triggered = q),
                    d[q](),
                    (n.event.triggered = void 0),
                    h && (d[k] = h))),
                b.result
              );
            }
          },
          dispatch: function (a) {
            a = n.event.fix(a);
            var b,
              c,
              e,
              f,
              g,
              h = [],
              i = d.call(arguments),
              j = (L.get(this, "events") || {})[a.type] || [],
              k = n.event.special[a.type] || {};
            if (
              ((i[0] = a),
              (a.delegateTarget = this),
              !k.preDispatch || k.preDispatch.call(this, a) !== !1)
            ) {
              (h = n.event.handlers.call(this, a, j)), (b = 0);
              while ((f = h[b++]) && !a.isPropagationStopped()) {
                (a.currentTarget = f.elem), (c = 0);
                while (
                  (g = f.handlers[c++]) &&
                  !a.isImmediatePropagationStopped()
                )
                  (!a.namespace_re || a.namespace_re.test(g.namespace)) &&
                    ((a.handleObj = g),
                    (a.data = g.data),
                    (e = (
                      (n.event.special[g.origType] || {}).handle || g.handler
                    ).apply(f.elem, i)),
                    void 0 !== e &&
                      (a.result = e) === !1 &&
                      (a.preventDefault(), a.stopPropagation()));
              }
              return k.postDispatch && k.postDispatch.call(this, a), a.result;
            }
          },
          handlers: function (a, b) {
            var c,
              d,
              e,
              f,
              g = [],
              h = b.delegateCount,
              i = a.target;
            if (h && i.nodeType && (!a.button || "click" !== a.type))
              for (; i !== this; i = i.parentNode || this)
                if (i.disabled !== !0 || "click" !== a.type) {
                  for (d = [], c = 0; h > c; c++)
                    (f = b[c]),
                      (e = f.selector + " "),
                      void 0 === d[e] &&
                        (d[e] = f.needsContext
                          ? n(e, this).index(i) >= 0
                          : n.find(e, this, null, [i]).length),
                      d[e] && d.push(f);
                  d.length && g.push({ elem: i, handlers: d });
                }
            return (
              h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g
            );
          },
          props:
            "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(
              " "
            ),
          fixHooks: {},
          keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function (a, b) {
              return (
                null == a.which &&
                  (a.which = null != b.charCode ? b.charCode : b.keyCode),
                a
              );
            },
          },
          mouseHooks: {
            props:
              "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(
                " "
              ),
            filter: function (a, b) {
              var c,
                d,
                e,
                f = b.button;
              return (
                null == a.pageX &&
                  null != b.clientX &&
                  ((c = a.target.ownerDocument || l),
                  (d = c.documentElement),
                  (e = c.body),
                  (a.pageX =
                    b.clientX +
                    ((d && d.scrollLeft) || (e && e.scrollLeft) || 0) -
                    ((d && d.clientLeft) || (e && e.clientLeft) || 0)),
                  (a.pageY =
                    b.clientY +
                    ((d && d.scrollTop) || (e && e.scrollTop) || 0) -
                    ((d && d.clientTop) || (e && e.clientTop) || 0))),
                a.which ||
                  void 0 === f ||
                  (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0),
                a
              );
            },
          },
          fix: function (a) {
            if (a[n.expando]) return a;
            var b,
              c,
              d,
              e = a.type,
              f = a,
              g = this.fixHooks[e];
            g ||
              (this.fixHooks[e] = g =
                W.test(e) ? this.mouseHooks : V.test(e) ? this.keyHooks : {}),
              (d = g.props ? this.props.concat(g.props) : this.props),
              (a = new n.Event(f)),
              (b = d.length);
            while (b--) (c = d[b]), (a[c] = f[c]);
            return (
              a.target || (a.target = l),
              3 === a.target.nodeType && (a.target = a.target.parentNode),
              g.filter ? g.filter(a, f) : a
            );
          },
          special: {
            load: { noBubble: !0 },
            focus: {
              trigger: function () {
                return this !== _() && this.focus ? (this.focus(), !1) : void 0;
              },
              delegateType: "focusin",
            },
            blur: {
              trigger: function () {
                return this === _() && this.blur ? (this.blur(), !1) : void 0;
              },
              delegateType: "focusout",
            },
            click: {
              trigger: function () {
                return "checkbox" === this.type &&
                  this.click &&
                  n.nodeName(this, "input")
                  ? (this.click(), !1)
                  : void 0;
              },
              _default: function (a) {
                return n.nodeName(a.target, "a");
              },
            },
            beforeunload: {
              postDispatch: function (a) {
                void 0 !== a.result &&
                  a.originalEvent &&
                  (a.originalEvent.returnValue = a.result);
              },
            },
          },
          simulate: function (a, b, c, d) {
            var e = n.extend(new n.Event(), c, {
              type: a,
              isSimulated: !0,
              originalEvent: {},
            });
            d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e),
              e.isDefaultPrevented() && c.preventDefault();
          },
        }),
          (n.removeEvent = function (a, b, c) {
            a.removeEventListener && a.removeEventListener(b, c, !1);
          }),
          (n.Event = function (a, b) {
            return this instanceof n.Event
              ? (a && a.type
                  ? ((this.originalEvent = a),
                    (this.type = a.type),
                    (this.isDefaultPrevented =
                      a.defaultPrevented ||
                      (void 0 === a.defaultPrevented && a.returnValue === !1)
                        ? Z
                        : $))
                  : (this.type = a),
                b && n.extend(this, b),
                (this.timeStamp = (a && a.timeStamp) || n.now()),
                void (this[n.expando] = !0))
              : new n.Event(a, b);
          }),
          (n.Event.prototype = {
            isDefaultPrevented: $,
            isPropagationStopped: $,
            isImmediatePropagationStopped: $,
            preventDefault: function () {
              var a = this.originalEvent;
              (this.isDefaultPrevented = Z),
                a && a.preventDefault && a.preventDefault();
            },
            stopPropagation: function () {
              var a = this.originalEvent;
              (this.isPropagationStopped = Z),
                a && a.stopPropagation && a.stopPropagation();
            },
            stopImmediatePropagation: function () {
              var a = this.originalEvent;
              (this.isImmediatePropagationStopped = Z),
                a && a.stopImmediatePropagation && a.stopImmediatePropagation(),
                this.stopPropagation();
            },
          }),
          n.each(
            {
              mouseenter: "mouseover",
              mouseleave: "mouseout",
              pointerenter: "pointerover",
              pointerleave: "pointerout",
            },
            function (a, b) {
              n.event.special[a] = {
                delegateType: b,
                bindType: b,
                handle: function (a) {
                  var c,
                    d = this,
                    e = a.relatedTarget,
                    f = a.handleObj;
                  return (
                    (!e || (e !== d && !n.contains(d, e))) &&
                      ((a.type = f.origType),
                      (c = f.handler.apply(this, arguments)),
                      (a.type = b)),
                    c
                  );
                },
              };
            }
          ),
          k.focusinBubbles ||
            n.each({ focus: "focusin", blur: "focusout" }, function (a, b) {
              var c = function (a) {
                n.event.simulate(b, a.target, n.event.fix(a), !0);
              };
              n.event.special[b] = {
                setup: function () {
                  var d = this.ownerDocument || this,
                    e = L.access(d, b);
                  e || d.addEventListener(a, c, !0),
                    L.access(d, b, (e || 0) + 1);
                },
                teardown: function () {
                  var d = this.ownerDocument || this,
                    e = L.access(d, b) - 1;
                  e
                    ? L.access(d, b, e)
                    : (d.removeEventListener(a, c, !0), L.remove(d, b));
                },
              };
            }),
          n.fn.extend({
            on: function (a, b, c, d, e) {
              var f, g;
              if ("object" == typeof a) {
                "string" != typeof b && ((c = c || b), (b = void 0));
                for (g in a) this.on(g, b, c, a[g], e);
                return this;
              }
              if (
                (null == c && null == d
                  ? ((d = b), (c = b = void 0))
                  : null == d &&
                    ("string" == typeof b
                      ? ((d = c), (c = void 0))
                      : ((d = c), (c = b), (b = void 0))),
                d === !1)
              )
                d = $;
              else if (!d) return this;
              return (
                1 === e &&
                  ((f = d),
                  (d = function (a) {
                    return n().off(a), f.apply(this, arguments);
                  }),
                  (d.guid = f.guid || (f.guid = n.guid++))),
                this.each(function () {
                  n.event.add(this, a, d, c, b);
                })
              );
            },
            one: function (a, b, c, d) {
              return this.on(a, b, c, d, 1);
            },
            off: function (a, b, c) {
              var d, e;
              if (a && a.preventDefault && a.handleObj)
                return (
                  (d = a.handleObj),
                  n(a.delegateTarget).off(
                    d.namespace ? d.origType + "." + d.namespace : d.origType,
                    d.selector,
                    d.handler
                  ),
                  this
                );
              if ("object" == typeof a) {
                for (e in a) this.off(e, b, a[e]);
                return this;
              }
              return (
                (b === !1 || "function" == typeof b) && ((c = b), (b = void 0)),
                c === !1 && (c = $),
                this.each(function () {
                  n.event.remove(this, a, c, b);
                })
              );
            },
            trigger: function (a, b) {
              return this.each(function () {
                n.event.trigger(a, b, this);
              });
            },
            triggerHandler: function (a, b) {
              var c = this[0];
              return c ? n.event.trigger(a, b, c, !0) : void 0;
            },
          });
        var aa =
            /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
          ba = /<([\w:]+)/,
          ca = /<|&#?\w+;/,
          da = /<(?:script|style|link)/i,
          ea = /checked\s*(?:[^=]|=\s*.checked.)/i,
          fa = /^$|\/(?:java|ecma)script/i,
          ga = /^true\/(.*)/,
          ha = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
          ia = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""],
          };
        (ia.optgroup = ia.option),
          (ia.tbody = ia.tfoot = ia.colgroup = ia.caption = ia.thead),
          (ia.th = ia.td);
        function ja(a, b) {
          return n.nodeName(a, "table") &&
            n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr")
            ? a.getElementsByTagName("tbody")[0] ||
                a.appendChild(a.ownerDocument.createElement("tbody"))
            : a;
        }
        function ka(a) {
          return (a.type = (null !== a.getAttribute("type")) + "/" + a.type), a;
        }
        function la(a) {
          var b = ga.exec(a.type);
          return b ? (a.type = b[1]) : a.removeAttribute("type"), a;
        }
        function ma(a, b) {
          for (var c = 0, d = a.length; d > c; c++)
            L.set(a[c], "globalEval", !b || L.get(b[c], "globalEval"));
        }
        function na(a, b) {
          var c, d, e, f, g, h, i, j;
          if (1 === b.nodeType) {
            if (
              L.hasData(a) &&
              ((f = L.access(a)), (g = L.set(b, f)), (j = f.events))
            ) {
              delete g.handle, (g.events = {});
              for (e in j)
                for (c = 0, d = j[e].length; d > c; c++)
                  n.event.add(b, e, j[e][c]);
            }
            M.hasData(a) &&
              ((h = M.access(a)), (i = n.extend({}, h)), M.set(b, i));
          }
        }
        function oa(a, b) {
          var c = a.getElementsByTagName
            ? a.getElementsByTagName(b || "*")
            : a.querySelectorAll
            ? a.querySelectorAll(b || "*")
            : [];
          return void 0 === b || (b && n.nodeName(a, b)) ? n.merge([a], c) : c;
        }
        function pa(a, b) {
          var c = b.nodeName.toLowerCase();
          "input" === c && T.test(a.type)
            ? (b.checked = a.checked)
            : ("input" === c || "textarea" === c) &&
              (b.defaultValue = a.defaultValue);
        }
        n.extend({
          clone: function (a, b, c) {
            var d,
              e,
              f,
              g,
              h = a.cloneNode(!0),
              i = n.contains(a.ownerDocument, a);
            if (
              !(
                k.noCloneChecked ||
                (1 !== a.nodeType && 11 !== a.nodeType) ||
                n.isXMLDoc(a)
              )
            )
              for (g = oa(h), f = oa(a), d = 0, e = f.length; e > d; d++)
                pa(f[d], g[d]);
            if (b)
              if (c)
                for (
                  f = f || oa(a), g = g || oa(h), d = 0, e = f.length;
                  e > d;
                  d++
                )
                  na(f[d], g[d]);
              else na(a, h);
            return (
              (g = oa(h, "script")),
              g.length > 0 && ma(g, !i && oa(a, "script")),
              h
            );
          },
          buildFragment: function (a, b, c, d) {
            for (
              var e,
                f,
                g,
                h,
                i,
                j,
                k = b.createDocumentFragment(),
                l = [],
                m = 0,
                o = a.length;
              o > m;
              m++
            )
              if (((e = a[m]), e || 0 === e))
                if ("object" === n.type(e)) n.merge(l, e.nodeType ? [e] : e);
                else if (ca.test(e)) {
                  (f = f || k.appendChild(b.createElement("div"))),
                    (g = (ba.exec(e) || ["", ""])[1].toLowerCase()),
                    (h = ia[g] || ia._default),
                    (f.innerHTML = h[1] + e.replace(aa, "<$1></$2>") + h[2]),
                    (j = h[0]);
                  while (j--) f = f.lastChild;
                  n.merge(l, f.childNodes),
                    (f = k.firstChild),
                    (f.textContent = "");
                } else l.push(b.createTextNode(e));
            (k.textContent = ""), (m = 0);
            while ((e = l[m++]))
              if (
                (!d || -1 === n.inArray(e, d)) &&
                ((i = n.contains(e.ownerDocument, e)),
                (f = oa(k.appendChild(e), "script")),
                i && ma(f),
                c)
              ) {
                j = 0;
                while ((e = f[j++])) fa.test(e.type || "") && c.push(e);
              }
            return k;
          },
          cleanData: function (a) {
            for (
              var b, c, d, e, f = n.event.special, g = 0;
              void 0 !== (c = a[g]);
              g++
            ) {
              if (
                n.acceptData(c) &&
                ((e = c[L.expando]), e && (b = L.cache[e]))
              ) {
                if (b.events)
                  for (d in b.events)
                    f[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);
                L.cache[e] && delete L.cache[e];
              }
              delete M.cache[c[M.expando]];
            }
          },
        }),
          n.fn.extend({
            text: function (a) {
              return J(
                this,
                function (a) {
                  return void 0 === a
                    ? n.text(this)
                    : this.empty().each(function () {
                        (1 === this.nodeType ||
                          11 === this.nodeType ||
                          9 === this.nodeType) &&
                          (this.textContent = a);
                      });
                },
                null,
                a,
                arguments.length
              );
            },
            append: function () {
              return this.domManip(arguments, function (a) {
                if (
                  1 === this.nodeType ||
                  11 === this.nodeType ||
                  9 === this.nodeType
                ) {
                  var b = ja(this, a);
                  b.appendChild(a);
                }
              });
            },
            prepend: function () {
              return this.domManip(arguments, function (a) {
                if (
                  1 === this.nodeType ||
                  11 === this.nodeType ||
                  9 === this.nodeType
                ) {
                  var b = ja(this, a);
                  b.insertBefore(a, b.firstChild);
                }
              });
            },
            before: function () {
              return this.domManip(arguments, function (a) {
                this.parentNode && this.parentNode.insertBefore(a, this);
              });
            },
            after: function () {
              return this.domManip(arguments, function (a) {
                this.parentNode &&
                  this.parentNode.insertBefore(a, this.nextSibling);
              });
            },
            remove: function (a, b) {
              for (
                var c, d = a ? n.filter(a, this) : this, e = 0;
                null != (c = d[e]);
                e++
              )
                b || 1 !== c.nodeType || n.cleanData(oa(c)),
                  c.parentNode &&
                    (b && n.contains(c.ownerDocument, c) && ma(oa(c, "script")),
                    c.parentNode.removeChild(c));
              return this;
            },
            empty: function () {
              for (var a, b = 0; null != (a = this[b]); b++)
                1 === a.nodeType &&
                  (n.cleanData(oa(a, !1)), (a.textContent = ""));
              return this;
            },
            clone: function (a, b) {
              return (
                (a = null == a ? !1 : a),
                (b = null == b ? a : b),
                this.map(function () {
                  return n.clone(this, a, b);
                })
              );
            },
            html: function (a) {
              return J(
                this,
                function (a) {
                  var b = this[0] || {},
                    c = 0,
                    d = this.length;
                  if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
                  if (
                    "string" == typeof a &&
                    !da.test(a) &&
                    !ia[(ba.exec(a) || ["", ""])[1].toLowerCase()]
                  ) {
                    a = a.replace(aa, "<$1></$2>");
                    try {
                      for (; d > c; c++)
                        (b = this[c] || {}),
                          1 === b.nodeType &&
                            (n.cleanData(oa(b, !1)), (b.innerHTML = a));
                      b = 0;
                    } catch (e) {}
                  }
                  b && this.empty().append(a);
                },
                null,
                a,
                arguments.length
              );
            },
            replaceWith: function () {
              var a = arguments[0];
              return (
                this.domManip(arguments, function (b) {
                  (a = this.parentNode),
                    n.cleanData(oa(this)),
                    a && a.replaceChild(b, this);
                }),
                a && (a.length || a.nodeType) ? this : this.remove()
              );
            },
            detach: function (a) {
              return this.remove(a, !0);
            },
            domManip: function (a, b) {
              a = e.apply([], a);
              var c,
                d,
                f,
                g,
                h,
                i,
                j = 0,
                l = this.length,
                m = this,
                o = l - 1,
                p = a[0],
                q = n.isFunction(p);
              if (
                q ||
                (l > 1 && "string" == typeof p && !k.checkClone && ea.test(p))
              )
                return this.each(function (c) {
                  var d = m.eq(c);
                  q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
                });
              if (
                l &&
                ((c = n.buildFragment(a, this[0].ownerDocument, !1, this)),
                (d = c.firstChild),
                1 === c.childNodes.length && (c = d),
                d)
              ) {
                for (f = n.map(oa(c, "script"), ka), g = f.length; l > j; j++)
                  (h = c),
                    j !== o &&
                      ((h = n.clone(h, !0, !0)),
                      g && n.merge(f, oa(h, "script"))),
                    b.call(this[j], h, j);
                if (g)
                  for (
                    i = f[f.length - 1].ownerDocument, n.map(f, la), j = 0;
                    g > j;
                    j++
                  )
                    (h = f[j]),
                      fa.test(h.type || "") &&
                        !L.access(h, "globalEval") &&
                        n.contains(i, h) &&
                        (h.src
                          ? n._evalUrl && n._evalUrl(h.src)
                          : n.globalEval(h.textContent.replace(ha, "")));
              }
              return this;
            },
          }),
          n.each(
            {
              appendTo: "append",
              prependTo: "prepend",
              insertBefore: "before",
              insertAfter: "after",
              replaceAll: "replaceWith",
            },
            function (a, b) {
              n.fn[a] = function (a) {
                for (
                  var c, d = [], e = n(a), g = e.length - 1, h = 0;
                  g >= h;
                  h++
                )
                  (c = h === g ? this : this.clone(!0)),
                    n(e[h])[b](c),
                    f.apply(d, c.get());
                return this.pushStack(d);
              };
            }
          );
        var qa,
          ra = {};
        function sa(b, c) {
          var d,
            e = n(c.createElement(b)).appendTo(c.body),
            f =
              a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0]))
                ? d.display
                : n.css(e[0], "display");
          return e.detach(), f;
        }
        function ta(a) {
          var b = l,
            c = ra[a];
          return (
            c ||
              ((c = sa(a, b)),
              ("none" !== c && c) ||
                ((qa = (
                  qa || n("<iframe frameborder='0' width='0' height='0'/>")
                ).appendTo(b.documentElement)),
                (b = qa[0].contentDocument),
                b.write(),
                b.close(),
                (c = sa(a, b)),
                qa.detach()),
              (ra[a] = c)),
            c
          );
        }
        var ua = /^margin/,
          va = new RegExp("^(" + Q + ")(?!px)[a-z%]+$", "i"),
          wa = function (b) {
            return b.ownerDocument.defaultView.opener
              ? b.ownerDocument.defaultView.getComputedStyle(b, null)
              : a.getComputedStyle(b, null);
          };
        function xa(a, b, c) {
          var d,
            e,
            f,
            g,
            h = a.style;
          return (
            (c = c || wa(a)),
            c && (g = c.getPropertyValue(b) || c[b]),
            c &&
              ("" !== g ||
                n.contains(a.ownerDocument, a) ||
                (g = n.style(a, b)),
              va.test(g) &&
                ua.test(b) &&
                ((d = h.width),
                (e = h.minWidth),
                (f = h.maxWidth),
                (h.minWidth = h.maxWidth = h.width = g),
                (g = c.width),
                (h.width = d),
                (h.minWidth = e),
                (h.maxWidth = f))),
            void 0 !== g ? g + "" : g
          );
        }
        function ya(a, b) {
          return {
            get: function () {
              return a()
                ? void delete this.get
                : (this.get = b).apply(this, arguments);
            },
          };
        }
        !(function () {
          var b,
            c,
            d = l.documentElement,
            e = l.createElement("div"),
            f = l.createElement("div");
          if (f.style) {
            (f.style.backgroundClip = "content-box"),
              (f.cloneNode(!0).style.backgroundClip = ""),
              (k.clearCloneStyle = "content-box" === f.style.backgroundClip),
              (e.style.cssText =
                "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute"),
              e.appendChild(f);
            function g() {
              (f.style.cssText =
                "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute"),
                (f.innerHTML = ""),
                d.appendChild(e);
              var g = a.getComputedStyle(f, null);
              (b = "1%" !== g.top), (c = "4px" === g.width), d.removeChild(e);
            }
            a.getComputedStyle &&
              n.extend(k, {
                pixelPosition: function () {
                  return g(), b;
                },
                boxSizingReliable: function () {
                  return null == c && g(), c;
                },
                reliableMarginRight: function () {
                  var b,
                    c = f.appendChild(l.createElement("div"));
                  return (
                    (c.style.cssText = f.style.cssText =
                      "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0"),
                    (c.style.marginRight = c.style.width = "0"),
                    (f.style.width = "1px"),
                    d.appendChild(e),
                    (b = !parseFloat(a.getComputedStyle(c, null).marginRight)),
                    d.removeChild(e),
                    f.removeChild(c),
                    b
                  );
                },
              });
          }
        })(),
          (n.swap = function (a, b, c, d) {
            var e,
              f,
              g = {};
            for (f in b) (g[f] = a.style[f]), (a.style[f] = b[f]);
            e = c.apply(a, d || []);
            for (f in b) a.style[f] = g[f];
            return e;
          });
        var za = /^(none|table(?!-c[ea]).+)/,
          Aa = new RegExp("^(" + Q + ")(.*)$", "i"),
          Ba = new RegExp("^([+-])=(" + Q + ")", "i"),
          Ca = { position: "absolute", visibility: "hidden", display: "block" },
          Da = { letterSpacing: "0", fontWeight: "400" },
          Ea = ["Webkit", "O", "Moz", "ms"];
        function Fa(a, b) {
          if (b in a) return b;
          var c = b[0].toUpperCase() + b.slice(1),
            d = b,
            e = Ea.length;
          while (e--) if (((b = Ea[e] + c), b in a)) return b;
          return d;
        }
        function Ga(a, b, c) {
          var d = Aa.exec(b);
          return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
        }
        function Ha(a, b, c, d, e) {
          for (
            var f =
                c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0,
              g = 0;
            4 > f;
            f += 2
          )
            "margin" === c && (g += n.css(a, c + R[f], !0, e)),
              d
                ? ("content" === c && (g -= n.css(a, "padding" + R[f], !0, e)),
                  "margin" !== c &&
                    (g -= n.css(a, "border" + R[f] + "Width", !0, e)))
                : ((g += n.css(a, "padding" + R[f], !0, e)),
                  "padding" !== c &&
                    (g += n.css(a, "border" + R[f] + "Width", !0, e)));
          return g;
        }
        function Ia(a, b, c) {
          var d = !0,
            e = "width" === b ? a.offsetWidth : a.offsetHeight,
            f = wa(a),
            g = "border-box" === n.css(a, "boxSizing", !1, f);
          if (0 >= e || null == e) {
            if (
              ((e = xa(a, b, f)),
              (0 > e || null == e) && (e = a.style[b]),
              va.test(e))
            )
              return e;
            (d = g && (k.boxSizingReliable() || e === a.style[b])),
              (e = parseFloat(e) || 0);
          }
          return e + Ha(a, b, c || (g ? "border" : "content"), d, f) + "px";
        }
        function Ja(a, b) {
          for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++)
            (d = a[g]),
              d.style &&
                ((f[g] = L.get(d, "olddisplay")),
                (c = d.style.display),
                b
                  ? (f[g] || "none" !== c || (d.style.display = ""),
                    "" === d.style.display &&
                      S(d) &&
                      (f[g] = L.access(d, "olddisplay", ta(d.nodeName))))
                  : ((e = S(d)),
                    ("none" === c && e) ||
                      L.set(d, "olddisplay", e ? c : n.css(d, "display"))));
          for (g = 0; h > g; g++)
            (d = a[g]),
              d.style &&
                ((b && "none" !== d.style.display && "" !== d.style.display) ||
                  (d.style.display = b ? f[g] || "" : "none"));
          return a;
        }
        n.extend({
          cssHooks: {
            opacity: {
              get: function (a, b) {
                if (b) {
                  var c = xa(a, "opacity");
                  return "" === c ? "1" : c;
                }
              },
            },
          },
          cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
          },
          cssProps: { float: "cssFloat" },
          style: function (a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
              var e,
                f,
                g,
                h = n.camelCase(b),
                i = a.style;
              return (
                (b = n.cssProps[h] || (n.cssProps[h] = Fa(i, h))),
                (g = n.cssHooks[b] || n.cssHooks[h]),
                void 0 === c
                  ? g && "get" in g && void 0 !== (e = g.get(a, !1, d))
                    ? e
                    : i[b]
                  : ((f = typeof c),
                    "string" === f &&
                      (e = Ba.exec(c)) &&
                      ((c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b))),
                      (f = "number")),
                    null != c &&
                      c === c &&
                      ("number" !== f || n.cssNumber[h] || (c += "px"),
                      k.clearCloneStyle ||
                        "" !== c ||
                        0 !== b.indexOf("background") ||
                        (i[b] = "inherit"),
                      (g && "set" in g && void 0 === (c = g.set(a, c, d))) ||
                        (i[b] = c)),
                    void 0)
              );
            }
          },
          css: function (a, b, c, d) {
            var e,
              f,
              g,
              h = n.camelCase(b);
            return (
              (b = n.cssProps[h] || (n.cssProps[h] = Fa(a.style, h))),
              (g = n.cssHooks[b] || n.cssHooks[h]),
              g && "get" in g && (e = g.get(a, !0, c)),
              void 0 === e && (e = xa(a, b, d)),
              "normal" === e && b in Da && (e = Da[b]),
              "" === c || c
                ? ((f = parseFloat(e)), c === !0 || n.isNumeric(f) ? f || 0 : e)
                : e
            );
          },
        }),
          n.each(["height", "width"], function (a, b) {
            n.cssHooks[b] = {
              get: function (a, c, d) {
                return c
                  ? za.test(n.css(a, "display")) && 0 === a.offsetWidth
                    ? n.swap(a, Ca, function () {
                        return Ia(a, b, d);
                      })
                    : Ia(a, b, d)
                  : void 0;
              },
              set: function (a, c, d) {
                var e = d && wa(a);
                return Ga(
                  a,
                  c,
                  d
                    ? Ha(
                        a,
                        b,
                        d,
                        "border-box" === n.css(a, "boxSizing", !1, e),
                        e
                      )
                    : 0
                );
              },
            };
          }),
          (n.cssHooks.marginRight = ya(k.reliableMarginRight, function (a, b) {
            return b
              ? n.swap(a, { display: "inline-block" }, xa, [a, "marginRight"])
              : void 0;
          })),
          n.each({ margin: "", padding: "", border: "Width" }, function (a, b) {
            (n.cssHooks[a + b] = {
              expand: function (c) {
                for (
                  var d = 0,
                    e = {},
                    f = "string" == typeof c ? c.split(" ") : [c];
                  4 > d;
                  d++
                )
                  e[a + R[d] + b] = f[d] || f[d - 2] || f[0];
                return e;
              },
            }),
              ua.test(a) || (n.cssHooks[a + b].set = Ga);
          }),
          n.fn.extend({
            css: function (a, b) {
              return J(
                this,
                function (a, b, c) {
                  var d,
                    e,
                    f = {},
                    g = 0;
                  if (n.isArray(b)) {
                    for (d = wa(a), e = b.length; e > g; g++)
                      f[b[g]] = n.css(a, b[g], !1, d);
                    return f;
                  }
                  return void 0 !== c ? n.style(a, b, c) : n.css(a, b);
                },
                a,
                b,
                arguments.length > 1
              );
            },
            show: function () {
              return Ja(this, !0);
            },
            hide: function () {
              return Ja(this);
            },
            toggle: function (a) {
              return "boolean" == typeof a
                ? a
                  ? this.show()
                  : this.hide()
                : this.each(function () {
                    S(this) ? n(this).show() : n(this).hide();
                  });
            },
          });
        function Ka(a, b, c, d, e) {
          return new Ka.prototype.init(a, b, c, d, e);
        }
        (n.Tween = Ka),
          (Ka.prototype = {
            constructor: Ka,
            init: function (a, b, c, d, e, f) {
              (this.elem = a),
                (this.prop = c),
                (this.easing = e || "swing"),
                (this.options = b),
                (this.start = this.now = this.cur()),
                (this.end = d),
                (this.unit = f || (n.cssNumber[c] ? "" : "px"));
            },
            cur: function () {
              var a = Ka.propHooks[this.prop];
              return a && a.get ? a.get(this) : Ka.propHooks._default.get(this);
            },
            run: function (a) {
              var b,
                c = Ka.propHooks[this.prop];
              return (
                this.options.duration
                  ? (this.pos = b =
                      n.easing[this.easing](
                        a,
                        this.options.duration * a,
                        0,
                        1,
                        this.options.duration
                      ))
                  : (this.pos = b = a),
                (this.now = (this.end - this.start) * b + this.start),
                this.options.step &&
                  this.options.step.call(this.elem, this.now, this),
                c && c.set ? c.set(this) : Ka.propHooks._default.set(this),
                this
              );
            },
          }),
          (Ka.prototype.init.prototype = Ka.prototype),
          (Ka.propHooks = {
            _default: {
              get: function (a) {
                var b;
                return null == a.elem[a.prop] ||
                  (a.elem.style && null != a.elem.style[a.prop])
                  ? ((b = n.css(a.elem, a.prop, "")), b && "auto" !== b ? b : 0)
                  : a.elem[a.prop];
              },
              set: function (a) {
                n.fx.step[a.prop]
                  ? n.fx.step[a.prop](a)
                  : a.elem.style &&
                    (null != a.elem.style[n.cssProps[a.prop]] ||
                      n.cssHooks[a.prop])
                  ? n.style(a.elem, a.prop, a.now + a.unit)
                  : (a.elem[a.prop] = a.now);
              },
            },
          }),
          (Ka.propHooks.scrollTop = Ka.propHooks.scrollLeft =
            {
              set: function (a) {
                a.elem.nodeType &&
                  a.elem.parentNode &&
                  (a.elem[a.prop] = a.now);
              },
            }),
          (n.easing = {
            linear: function (a) {
              return a;
            },
            swing: function (a) {
              return 0.5 - Math.cos(a * Math.PI) / 2;
            },
          }),
          (n.fx = Ka.prototype.init),
          (n.fx.step = {});
        var La,
          Ma,
          Na = /^(?:toggle|show|hide)$/,
          Oa = new RegExp("^(?:([+-])=|)(" + Q + ")([a-z%]*)$", "i"),
          Pa = /queueHooks$/,
          Qa = [Va],
          Ra = {
            "*": [
              function (a, b) {
                var c = this.createTween(a, b),
                  d = c.cur(),
                  e = Oa.exec(b),
                  f = (e && e[3]) || (n.cssNumber[a] ? "" : "px"),
                  g =
                    (n.cssNumber[a] || ("px" !== f && +d)) &&
                    Oa.exec(n.css(c.elem, a)),
                  h = 1,
                  i = 20;
                if (g && g[3] !== f) {
                  (f = f || g[3]), (e = e || []), (g = +d || 1);
                  do (h = h || ".5"), (g /= h), n.style(c.elem, a, g + f);
                  while (h !== (h = c.cur() / d) && 1 !== h && --i);
                }
                return (
                  e &&
                    ((g = c.start = +g || +d || 0),
                    (c.unit = f),
                    (c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2])),
                  c
                );
              },
            ],
          };
        function Sa() {
          return (
            setTimeout(function () {
              La = void 0;
            }),
            (La = n.now())
          );
        }
        function Ta(a, b) {
          var c,
            d = 0,
            e = { height: a };
          for (b = b ? 1 : 0; 4 > d; d += 2 - b)
            (c = R[d]), (e["margin" + c] = e["padding" + c] = a);
          return b && (e.opacity = e.width = a), e;
        }
        function Ua(a, b, c) {
          for (
            var d, e = (Ra[b] || []).concat(Ra["*"]), f = 0, g = e.length;
            g > f;
            f++
          )
            if ((d = e[f].call(c, b, a))) return d;
        }
        function Va(a, b, c) {
          var d,
            e,
            f,
            g,
            h,
            i,
            j,
            k,
            l = this,
            m = {},
            o = a.style,
            p = a.nodeType && S(a),
            q = L.get(a, "fxshow");
          c.queue ||
            ((h = n._queueHooks(a, "fx")),
            null == h.unqueued &&
              ((h.unqueued = 0),
              (i = h.empty.fire),
              (h.empty.fire = function () {
                h.unqueued || i();
              })),
            h.unqueued++,
            l.always(function () {
              l.always(function () {
                h.unqueued--, n.queue(a, "fx").length || h.empty.fire();
              });
            })),
            1 === a.nodeType &&
              ("height" in b || "width" in b) &&
              ((c.overflow = [o.overflow, o.overflowX, o.overflowY]),
              (j = n.css(a, "display")),
              (k = "none" === j ? L.get(a, "olddisplay") || ta(a.nodeName) : j),
              "inline" === k &&
                "none" === n.css(a, "float") &&
                (o.display = "inline-block")),
            c.overflow &&
              ((o.overflow = "hidden"),
              l.always(function () {
                (o.overflow = c.overflow[0]),
                  (o.overflowX = c.overflow[1]),
                  (o.overflowY = c.overflow[2]);
              }));
          for (d in b)
            if (((e = b[d]), Na.exec(e))) {
              if (
                (delete b[d],
                (f = f || "toggle" === e),
                e === (p ? "hide" : "show"))
              ) {
                if ("show" !== e || !q || void 0 === q[d]) continue;
                p = !0;
              }
              m[d] = (q && q[d]) || n.style(a, d);
            } else j = void 0;
          if (n.isEmptyObject(m))
            "inline" === ("none" === j ? ta(a.nodeName) : j) && (o.display = j);
          else {
            q
              ? "hidden" in q && (p = q.hidden)
              : (q = L.access(a, "fxshow", {})),
              f && (q.hidden = !p),
              p
                ? n(a).show()
                : l.done(function () {
                    n(a).hide();
                  }),
              l.done(function () {
                var b;
                L.remove(a, "fxshow");
                for (b in m) n.style(a, b, m[b]);
              });
            for (d in m)
              (g = Ua(p ? q[d] : 0, d, l)),
                d in q ||
                  ((q[d] = g.start),
                  p &&
                    ((g.end = g.start),
                    (g.start = "width" === d || "height" === d ? 1 : 0)));
          }
        }
        function Wa(a, b) {
          var c, d, e, f, g;
          for (c in a)
            if (
              ((d = n.camelCase(c)),
              (e = b[d]),
              (f = a[c]),
              n.isArray(f) && ((e = f[1]), (f = a[c] = f[0])),
              c !== d && ((a[d] = f), delete a[c]),
              (g = n.cssHooks[d]),
              g && "expand" in g)
            ) {
              (f = g.expand(f)), delete a[d];
              for (c in f) c in a || ((a[c] = f[c]), (b[c] = e));
            } else b[d] = e;
        }
        function Xa(a, b, c) {
          var d,
            e,
            f = 0,
            g = Qa.length,
            h = n.Deferred().always(function () {
              delete i.elem;
            }),
            i = function () {
              if (e) return !1;
              for (
                var b = La || Sa(),
                  c = Math.max(0, j.startTime + j.duration - b),
                  d = c / j.duration || 0,
                  f = 1 - d,
                  g = 0,
                  i = j.tweens.length;
                i > g;
                g++
              )
                j.tweens[g].run(f);
              return (
                h.notifyWith(a, [j, f, c]),
                1 > f && i ? c : (h.resolveWith(a, [j]), !1)
              );
            },
            j = h.promise({
              elem: a,
              props: n.extend({}, b),
              opts: n.extend(!0, { specialEasing: {} }, c),
              originalProperties: b,
              originalOptions: c,
              startTime: La || Sa(),
              duration: c.duration,
              tweens: [],
              createTween: function (b, c) {
                var d = n.Tween(
                  a,
                  j.opts,
                  b,
                  c,
                  j.opts.specialEasing[b] || j.opts.easing
                );
                return j.tweens.push(d), d;
              },
              stop: function (b) {
                var c = 0,
                  d = b ? j.tweens.length : 0;
                if (e) return this;
                for (e = !0; d > c; c++) j.tweens[c].run(1);
                return (
                  b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this
                );
              },
            }),
            k = j.props;
          for (Wa(k, j.opts.specialEasing); g > f; f++)
            if ((d = Qa[f].call(j, a, k, j.opts))) return d;
          return (
            n.map(k, Ua, j),
            n.isFunction(j.opts.start) && j.opts.start.call(a, j),
            n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })),
            j
              .progress(j.opts.progress)
              .done(j.opts.done, j.opts.complete)
              .fail(j.opts.fail)
              .always(j.opts.always)
          );
        }
        (n.Animation = n.extend(Xa, {
          tweener: function (a, b) {
            n.isFunction(a) ? ((b = a), (a = ["*"])) : (a = a.split(" "));
            for (var c, d = 0, e = a.length; e > d; d++)
              (c = a[d]), (Ra[c] = Ra[c] || []), Ra[c].unshift(b);
          },
          prefilter: function (a, b) {
            b ? Qa.unshift(a) : Qa.push(a);
          },
        })),
          (n.speed = function (a, b, c) {
            var d =
              a && "object" == typeof a
                ? n.extend({}, a)
                : {
                    complete: c || (!c && b) || (n.isFunction(a) && a),
                    duration: a,
                    easing: (c && b) || (b && !n.isFunction(b) && b),
                  };
            return (
              (d.duration = n.fx.off
                ? 0
                : "number" == typeof d.duration
                ? d.duration
                : d.duration in n.fx.speeds
                ? n.fx.speeds[d.duration]
                : n.fx.speeds._default),
              (null == d.queue || d.queue === !0) && (d.queue = "fx"),
              (d.old = d.complete),
              (d.complete = function () {
                n.isFunction(d.old) && d.old.call(this),
                  d.queue && n.dequeue(this, d.queue);
              }),
              d
            );
          }),
          n.fn.extend({
            fadeTo: function (a, b, c, d) {
              return this.filter(S)
                .css("opacity", 0)
                .show()
                .end()
                .animate({ opacity: b }, a, c, d);
            },
            animate: function (a, b, c, d) {
              var e = n.isEmptyObject(a),
                f = n.speed(b, c, d),
                g = function () {
                  var b = Xa(this, n.extend({}, a), f);
                  (e || L.get(this, "finish")) && b.stop(!0);
                };
              return (
                (g.finish = g),
                e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
              );
            },
            stop: function (a, b, c) {
              var d = function (a) {
                var b = a.stop;
                delete a.stop, b(c);
              };
              return (
                "string" != typeof a && ((c = b), (b = a), (a = void 0)),
                b && a !== !1 && this.queue(a || "fx", []),
                this.each(function () {
                  var b = !0,
                    e = null != a && a + "queueHooks",
                    f = n.timers,
                    g = L.get(this);
                  if (e) g[e] && g[e].stop && d(g[e]);
                  else for (e in g) g[e] && g[e].stop && Pa.test(e) && d(g[e]);
                  for (e = f.length; e--; )
                    f[e].elem !== this ||
                      (null != a && f[e].queue !== a) ||
                      (f[e].anim.stop(c), (b = !1), f.splice(e, 1));
                  (b || !c) && n.dequeue(this, a);
                })
              );
            },
            finish: function (a) {
              return (
                a !== !1 && (a = a || "fx"),
                this.each(function () {
                  var b,
                    c = L.get(this),
                    d = c[a + "queue"],
                    e = c[a + "queueHooks"],
                    f = n.timers,
                    g = d ? d.length : 0;
                  for (
                    c.finish = !0,
                      n.queue(this, a, []),
                      e && e.stop && e.stop.call(this, !0),
                      b = f.length;
                    b--;

                  )
                    f[b].elem === this &&
                      f[b].queue === a &&
                      (f[b].anim.stop(!0), f.splice(b, 1));
                  for (b = 0; g > b; b++)
                    d[b] && d[b].finish && d[b].finish.call(this);
                  delete c.finish;
                })
              );
            },
          }),
          n.each(["toggle", "show", "hide"], function (a, b) {
            var c = n.fn[b];
            n.fn[b] = function (a, d, e) {
              return null == a || "boolean" == typeof a
                ? c.apply(this, arguments)
                : this.animate(Ta(b, !0), a, d, e);
            };
          }),
          n.each(
            {
              slideDown: Ta("show"),
              slideUp: Ta("hide"),
              slideToggle: Ta("toggle"),
              fadeIn: { opacity: "show" },
              fadeOut: { opacity: "hide" },
              fadeToggle: { opacity: "toggle" },
            },
            function (a, b) {
              n.fn[a] = function (a, c, d) {
                return this.animate(b, a, c, d);
              };
            }
          ),
          (n.timers = []),
          (n.fx.tick = function () {
            var a,
              b = 0,
              c = n.timers;
            for (La = n.now(); b < c.length; b++)
              (a = c[b]), a() || c[b] !== a || c.splice(b--, 1);
            c.length || n.fx.stop(), (La = void 0);
          }),
          (n.fx.timer = function (a) {
            n.timers.push(a), a() ? n.fx.start() : n.timers.pop();
          }),
          (n.fx.interval = 13),
          (n.fx.start = function () {
            Ma || (Ma = setInterval(n.fx.tick, n.fx.interval));
          }),
          (n.fx.stop = function () {
            clearInterval(Ma), (Ma = null);
          }),
          (n.fx.speeds = { slow: 600, fast: 200, _default: 400 }),
          (n.fn.delay = function (a, b) {
            return (
              (a = n.fx ? n.fx.speeds[a] || a : a),
              (b = b || "fx"),
              this.queue(b, function (b, c) {
                var d = setTimeout(b, a);
                c.stop = function () {
                  clearTimeout(d);
                };
              })
            );
          }),
          (function () {
            var a = l.createElement("input"),
              b = l.createElement("select"),
              c = b.appendChild(l.createElement("option"));
            (a.type = "checkbox"),
              (k.checkOn = "" !== a.value),
              (k.optSelected = c.selected),
              (b.disabled = !0),
              (k.optDisabled = !c.disabled),
              (a = l.createElement("input")),
              (a.value = "t"),
              (a.type = "radio"),
              (k.radioValue = "t" === a.value);
          })();
        var Ya,
          Za,
          $a = n.expr.attrHandle;
        n.fn.extend({
          attr: function (a, b) {
            return J(this, n.attr, a, b, arguments.length > 1);
          },
          removeAttr: function (a) {
            return this.each(function () {
              n.removeAttr(this, a);
            });
          },
        }),
          n.extend({
            attr: function (a, b, c) {
              var d,
                e,
                f = a.nodeType;
              if (a && 3 !== f && 8 !== f && 2 !== f)
                return typeof a.getAttribute === U
                  ? n.prop(a, b, c)
                  : ((1 === f && n.isXMLDoc(a)) ||
                      ((b = b.toLowerCase()),
                      (d =
                        n.attrHooks[b] ||
                        (n.expr.match.bool.test(b) ? Za : Ya))),
                    void 0 === c
                      ? d && "get" in d && null !== (e = d.get(a, b))
                        ? e
                        : ((e = n.find.attr(a, b)), null == e ? void 0 : e)
                      : null !== c
                      ? d && "set" in d && void 0 !== (e = d.set(a, c, b))
                        ? e
                        : (a.setAttribute(b, c + ""), c)
                      : void n.removeAttr(a, b));
            },
            removeAttr: function (a, b) {
              var c,
                d,
                e = 0,
                f = b && b.match(E);
              if (f && 1 === a.nodeType)
                while ((c = f[e++]))
                  (d = n.propFix[c] || c),
                    n.expr.match.bool.test(c) && (a[d] = !1),
                    a.removeAttribute(c);
            },
            attrHooks: {
              type: {
                set: function (a, b) {
                  if (
                    !k.radioValue &&
                    "radio" === b &&
                    n.nodeName(a, "input")
                  ) {
                    var c = a.value;
                    return a.setAttribute("type", b), c && (a.value = c), b;
                  }
                },
              },
            },
          }),
          (Za = {
            set: function (a, b, c) {
              return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;
            },
          }),
          n.each(n.expr.match.bool.source.match(/\w+/g), function (a, b) {
            var c = $a[b] || n.find.attr;
            $a[b] = function (a, b, d) {
              var e, f;
              return (
                d ||
                  ((f = $a[b]),
                  ($a[b] = e),
                  (e = null != c(a, b, d) ? b.toLowerCase() : null),
                  ($a[b] = f)),
                e
              );
            };
          });
        var _a = /^(?:input|select|textarea|button)$/i;
        n.fn.extend({
          prop: function (a, b) {
            return J(this, n.prop, a, b, arguments.length > 1);
          },
          removeProp: function (a) {
            return this.each(function () {
              delete this[n.propFix[a] || a];
            });
          },
        }),
          n.extend({
            propFix: { for: "htmlFor", class: "className" },
            prop: function (a, b, c) {
              var d,
                e,
                f,
                g = a.nodeType;
              if (a && 3 !== g && 8 !== g && 2 !== g)
                return (
                  (f = 1 !== g || !n.isXMLDoc(a)),
                  f && ((b = n.propFix[b] || b), (e = n.propHooks[b])),
                  void 0 !== c
                    ? e && "set" in e && void 0 !== (d = e.set(a, c, b))
                      ? d
                      : (a[b] = c)
                    : e && "get" in e && null !== (d = e.get(a, b))
                    ? d
                    : a[b]
                );
            },
            propHooks: {
              tabIndex: {
                get: function (a) {
                  return a.hasAttribute("tabindex") ||
                    _a.test(a.nodeName) ||
                    a.href
                    ? a.tabIndex
                    : -1;
                },
              },
            },
          }),
          k.optSelected ||
            (n.propHooks.selected = {
              get: function (a) {
                var b = a.parentNode;
                return b && b.parentNode && b.parentNode.selectedIndex, null;
              },
            }),
          n.each(
            [
              "tabIndex",
              "readOnly",
              "maxLength",
              "cellSpacing",
              "cellPadding",
              "rowSpan",
              "colSpan",
              "useMap",
              "frameBorder",
              "contentEditable",
            ],
            function () {
              n.propFix[this.toLowerCase()] = this;
            }
          );
        var ab = /[\t\r\n\f]/g;
        n.fn.extend({
          addClass: function (a) {
            var b,
              c,
              d,
              e,
              f,
              g,
              h = "string" == typeof a && a,
              i = 0,
              j = this.length;
            if (n.isFunction(a))
              return this.each(function (b) {
                n(this).addClass(a.call(this, b, this.className));
              });
            if (h)
              for (b = (a || "").match(E) || []; j > i; i++)
                if (
                  ((c = this[i]),
                  (d =
                    1 === c.nodeType &&
                    (c.className
                      ? (" " + c.className + " ").replace(ab, " ")
                      : " ")))
                ) {
                  f = 0;
                  while ((e = b[f++]))
                    d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                  (g = n.trim(d)), c.className !== g && (c.className = g);
                }
            return this;
          },
          removeClass: function (a) {
            var b,
              c,
              d,
              e,
              f,
              g,
              h = 0 === arguments.length || ("string" == typeof a && a),
              i = 0,
              j = this.length;
            if (n.isFunction(a))
              return this.each(function (b) {
                n(this).removeClass(a.call(this, b, this.className));
              });
            if (h)
              for (b = (a || "").match(E) || []; j > i; i++)
                if (
                  ((c = this[i]),
                  (d =
                    1 === c.nodeType &&
                    (c.className
                      ? (" " + c.className + " ").replace(ab, " ")
                      : "")))
                ) {
                  f = 0;
                  while ((e = b[f++]))
                    while (d.indexOf(" " + e + " ") >= 0)
                      d = d.replace(" " + e + " ", " ");
                  (g = a ? n.trim(d) : ""),
                    c.className !== g && (c.className = g);
                }
            return this;
          },
          toggleClass: function (a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" === c
              ? b
                ? this.addClass(a)
                : this.removeClass(a)
              : this.each(
                  n.isFunction(a)
                    ? function (c) {
                        n(this).toggleClass(
                          a.call(this, c, this.className, b),
                          b
                        );
                      }
                    : function () {
                        if ("string" === c) {
                          var b,
                            d = 0,
                            e = n(this),
                            f = a.match(E) || [];
                          while ((b = f[d++]))
                            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
                        } else
                          (c === U || "boolean" === c) &&
                            (this.className &&
                              L.set(this, "__className__", this.className),
                            (this.className =
                              this.className || a === !1
                                ? ""
                                : L.get(this, "__className__") || ""));
                      }
                );
          },
          hasClass: function (a) {
            for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++)
              if (
                1 === this[c].nodeType &&
                (" " + this[c].className + " ").replace(ab, " ").indexOf(b) >= 0
              )
                return !0;
            return !1;
          },
        });
        var bb = /\r/g;
        n.fn.extend({
          val: function (a) {
            var b,
              c,
              d,
              e = this[0];
            {
              if (arguments.length)
                return (
                  (d = n.isFunction(a)),
                  this.each(function (c) {
                    var e;
                    1 === this.nodeType &&
                      ((e = d ? a.call(this, c, n(this).val()) : a),
                      null == e
                        ? (e = "")
                        : "number" == typeof e
                        ? (e += "")
                        : n.isArray(e) &&
                          (e = n.map(e, function (a) {
                            return null == a ? "" : a + "";
                          })),
                      (b =
                        n.valHooks[this.type] ||
                        n.valHooks[this.nodeName.toLowerCase()]),
                      (b && "set" in b && void 0 !== b.set(this, e, "value")) ||
                        (this.value = e));
                  })
                );
              if (e)
                return (
                  (b =
                    n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()]),
                  b && "get" in b && void 0 !== (c = b.get(e, "value"))
                    ? c
                    : ((c = e.value),
                      "string" == typeof c
                        ? c.replace(bb, "")
                        : null == c
                        ? ""
                        : c)
                );
            }
          },
        }),
          n.extend({
            valHooks: {
              option: {
                get: function (a) {
                  var b = n.find.attr(a, "value");
                  return null != b ? b : n.trim(n.text(a));
                },
              },
              select: {
                get: function (a) {
                  for (
                    var b,
                      c,
                      d = a.options,
                      e = a.selectedIndex,
                      f = "select-one" === a.type || 0 > e,
                      g = f ? null : [],
                      h = f ? e + 1 : d.length,
                      i = 0 > e ? h : f ? e : 0;
                    h > i;
                    i++
                  )
                    if (
                      ((c = d[i]),
                      !(
                        (!c.selected && i !== e) ||
                        (k.optDisabled
                          ? c.disabled
                          : null !== c.getAttribute("disabled")) ||
                        (c.parentNode.disabled &&
                          n.nodeName(c.parentNode, "optgroup"))
                      ))
                    ) {
                      if (((b = n(c).val()), f)) return b;
                      g.push(b);
                    }
                  return g;
                },
                set: function (a, b) {
                  var c,
                    d,
                    e = a.options,
                    f = n.makeArray(b),
                    g = e.length;
                  while (g--)
                    (d = e[g]),
                      (d.selected = n.inArray(d.value, f) >= 0) && (c = !0);
                  return c || (a.selectedIndex = -1), f;
                },
              },
            },
          }),
          n.each(["radio", "checkbox"], function () {
            (n.valHooks[this] = {
              set: function (a, b) {
                return n.isArray(b)
                  ? (a.checked = n.inArray(n(a).val(), b) >= 0)
                  : void 0;
              },
            }),
              k.checkOn ||
                (n.valHooks[this].get = function (a) {
                  return null === a.getAttribute("value") ? "on" : a.value;
                });
          }),
          n.each(
            "blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(
              " "
            ),
            function (a, b) {
              n.fn[b] = function (a, c) {
                return arguments.length > 0
                  ? this.on(b, null, a, c)
                  : this.trigger(b);
              };
            }
          ),
          n.fn.extend({
            hover: function (a, b) {
              return this.mouseenter(a).mouseleave(b || a);
            },
            bind: function (a, b, c) {
              return this.on(a, null, b, c);
            },
            unbind: function (a, b) {
              return this.off(a, null, b);
            },
            delegate: function (a, b, c, d) {
              return this.on(b, a, c, d);
            },
            undelegate: function (a, b, c) {
              return 1 === arguments.length
                ? this.off(a, "**")
                : this.off(b, a || "**", c);
            },
          });
        var cb = n.now(),
          db = /\?/;
        (n.parseJSON = function (a) {
          return JSON.parse(a + "");
        }),
          (n.parseXML = function (a) {
            var b, c;
            if (!a || "string" != typeof a) return null;
            try {
              (c = new DOMParser()), (b = c.parseFromString(a, "text/xml"));
            } catch (d) {
              b = void 0;
            }
            return (
              (!b || b.getElementsByTagName("parsererror").length) &&
                n.error("Invalid XML: " + a),
              b
            );
          });
        var eb = /#.*$/,
          fb = /([?&])_=[^&]*/,
          gb = /^(.*?):[ \t]*([^\r\n]*)$/gm,
          hb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
          ib = /^(?:GET|HEAD)$/,
          jb = /^\/\//,
          kb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
          lb = {},
          mb = {},
          nb = "*/".concat("*"),
          ob = a.location.href,
          pb = kb.exec(ob.toLowerCase()) || [];
        function qb(a) {
          return function (b, c) {
            "string" != typeof b && ((c = b), (b = "*"));
            var d,
              e = 0,
              f = b.toLowerCase().match(E) || [];
            if (n.isFunction(c))
              while ((d = f[e++]))
                "+" === d[0]
                  ? ((d = d.slice(1) || "*"), (a[d] = a[d] || []).unshift(c))
                  : (a[d] = a[d] || []).push(c);
          };
        }
        function rb(a, b, c, d) {
          var e = {},
            f = a === mb;
          function g(h) {
            var i;
            return (
              (e[h] = !0),
              n.each(a[h] || [], function (a, h) {
                var j = h(b, c, d);
                return "string" != typeof j || f || e[j]
                  ? f
                    ? !(i = j)
                    : void 0
                  : (b.dataTypes.unshift(j), g(j), !1);
              }),
              i
            );
          }
          return g(b.dataTypes[0]) || (!e["*"] && g("*"));
        }
        function sb(a, b) {
          var c,
            d,
            e = n.ajaxSettings.flatOptions || {};
          for (c in b)
            void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
          return d && n.extend(!0, a, d), a;
        }
        function tb(a, b, c) {
          var d,
            e,
            f,
            g,
            h = a.contents,
            i = a.dataTypes;
          while ("*" === i[0])
            i.shift(),
              void 0 === d &&
                (d = a.mimeType || b.getResponseHeader("Content-Type"));
          if (d)
            for (e in h)
              if (h[e] && h[e].test(d)) {
                i.unshift(e);
                break;
              }
          if (i[0] in c) f = i[0];
          else {
            for (e in c) {
              if (!i[0] || a.converters[e + " " + i[0]]) {
                f = e;
                break;
              }
              g || (g = e);
            }
            f = f || g;
          }
          return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
        }
        function ub(a, b, c, d) {
          var e,
            f,
            g,
            h,
            i,
            j = {},
            k = a.dataTypes.slice();
          if (k[1])
            for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
          f = k.shift();
          while (f)
            if (
              (a.responseFields[f] && (c[a.responseFields[f]] = b),
              !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)),
              (i = f),
              (f = k.shift()))
            )
              if ("*" === f) f = i;
              else if ("*" !== i && i !== f) {
                if (((g = j[i + " " + f] || j["* " + f]), !g))
                  for (e in j)
                    if (
                      ((h = e.split(" ")),
                      h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]]))
                    ) {
                      g === !0
                        ? (g = j[e])
                        : j[e] !== !0 && ((f = h[0]), k.unshift(h[1]));
                      break;
                    }
                if (g !== !0)
                  if (g && a["throws"]) b = g(b);
                  else
                    try {
                      b = g(b);
                    } catch (l) {
                      return {
                        state: "parsererror",
                        error: g ? l : "No conversion from " + i + " to " + f,
                      };
                    }
              }
          return { state: "success", data: b };
        }
        n.extend({
          active: 0,
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: ob,
            type: "GET",
            isLocal: hb.test(pb[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
              "*": nb,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript",
            },
            contents: { xml: /xml/, html: /html/, json: /json/ },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON",
            },
            converters: {
              "* text": String,
              "text html": !0,
              "text json": n.parseJSON,
              "text xml": n.parseXML,
            },
            flatOptions: { url: !0, context: !0 },
          },
          ajaxSetup: function (a, b) {
            return b ? sb(sb(a, n.ajaxSettings), b) : sb(n.ajaxSettings, a);
          },
          ajaxPrefilter: qb(lb),
          ajaxTransport: qb(mb),
          ajax: function (a, b) {
            "object" == typeof a && ((b = a), (a = void 0)), (b = b || {});
            var c,
              d,
              e,
              f,
              g,
              h,
              i,
              j,
              k = n.ajaxSetup({}, b),
              l = k.context || k,
              m = k.context && (l.nodeType || l.jquery) ? n(l) : n.event,
              o = n.Deferred(),
              p = n.Callbacks("once memory"),
              q = k.statusCode || {},
              r = {},
              s = {},
              t = 0,
              u = "canceled",
              v = {
                readyState: 0,
                getResponseHeader: function (a) {
                  var b;
                  if (2 === t) {
                    if (!f) {
                      f = {};
                      while ((b = gb.exec(e))) f[b[1].toLowerCase()] = b[2];
                    }
                    b = f[a.toLowerCase()];
                  }
                  return null == b ? null : b;
                },
                getAllResponseHeaders: function () {
                  return 2 === t ? e : null;
                },
                setRequestHeader: function (a, b) {
                  var c = a.toLowerCase();
                  return t || ((a = s[c] = s[c] || a), (r[a] = b)), this;
                },
                overrideMimeType: function (a) {
                  return t || (k.mimeType = a), this;
                },
                statusCode: function (a) {
                  var b;
                  if (a)
                    if (2 > t) for (b in a) q[b] = [q[b], a[b]];
                    else v.always(a[v.status]);
                  return this;
                },
                abort: function (a) {
                  var b = a || u;
                  return c && c.abort(b), x(0, b), this;
                },
              };
            if (
              ((o.promise(v).complete = p.add),
              (v.success = v.done),
              (v.error = v.fail),
              (k.url = ((a || k.url || ob) + "")
                .replace(eb, "")
                .replace(jb, pb[1] + "//")),
              (k.type = b.method || b.type || k.method || k.type),
              (k.dataTypes = n
                .trim(k.dataType || "*")
                .toLowerCase()
                .match(E) || [""]),
              null == k.crossDomain &&
                ((h = kb.exec(k.url.toLowerCase())),
                (k.crossDomain = !(
                  !h ||
                  (h[1] === pb[1] &&
                    h[2] === pb[2] &&
                    (h[3] || ("http:" === h[1] ? "80" : "443")) ===
                      (pb[3] || ("http:" === pb[1] ? "80" : "443")))
                ))),
              k.data &&
                k.processData &&
                "string" != typeof k.data &&
                (k.data = n.param(k.data, k.traditional)),
              rb(lb, k, b, v),
              2 === t)
            )
              return v;
            (i = n.event && k.global),
              i && 0 === n.active++ && n.event.trigger("ajaxStart"),
              (k.type = k.type.toUpperCase()),
              (k.hasContent = !ib.test(k.type)),
              (d = k.url),
              k.hasContent ||
                (k.data &&
                  ((d = k.url += (db.test(d) ? "&" : "?") + k.data),
                  delete k.data),
                k.cache === !1 &&
                  (k.url = fb.test(d)
                    ? d.replace(fb, "$1_=" + cb++)
                    : d + (db.test(d) ? "&" : "?") + "_=" + cb++)),
              k.ifModified &&
                (n.lastModified[d] &&
                  v.setRequestHeader("If-Modified-Since", n.lastModified[d]),
                n.etag[d] && v.setRequestHeader("If-None-Match", n.etag[d])),
              ((k.data && k.hasContent && k.contentType !== !1) ||
                b.contentType) &&
                v.setRequestHeader("Content-Type", k.contentType),
              v.setRequestHeader(
                "Accept",
                k.dataTypes[0] && k.accepts[k.dataTypes[0]]
                  ? k.accepts[k.dataTypes[0]] +
                      ("*" !== k.dataTypes[0] ? ", " + nb + "; q=0.01" : "")
                  : k.accepts["*"]
              );
            for (j in k.headers) v.setRequestHeader(j, k.headers[j]);
            if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t))
              return v.abort();
            u = "abort";
            for (j in { success: 1, error: 1, complete: 1 }) v[j](k[j]);
            if ((c = rb(mb, k, b, v))) {
              (v.readyState = 1),
                i && m.trigger("ajaxSend", [v, k]),
                k.async &&
                  k.timeout > 0 &&
                  (g = setTimeout(function () {
                    v.abort("timeout");
                  }, k.timeout));
              try {
                (t = 1), c.send(r, x);
              } catch (w) {
                if (!(2 > t)) throw w;
                x(-1, w);
              }
            } else x(-1, "No Transport");
            function x(a, b, f, h) {
              var j,
                r,
                s,
                u,
                w,
                x = b;
              2 !== t &&
                ((t = 2),
                g && clearTimeout(g),
                (c = void 0),
                (e = h || ""),
                (v.readyState = a > 0 ? 4 : 0),
                (j = (a >= 200 && 300 > a) || 304 === a),
                f && (u = tb(k, v, f)),
                (u = ub(k, u, v, j)),
                j
                  ? (k.ifModified &&
                      ((w = v.getResponseHeader("Last-Modified")),
                      w && (n.lastModified[d] = w),
                      (w = v.getResponseHeader("etag")),
                      w && (n.etag[d] = w)),
                    204 === a || "HEAD" === k.type
                      ? (x = "nocontent")
                      : 304 === a
                      ? (x = "notmodified")
                      : ((x = u.state), (r = u.data), (s = u.error), (j = !s)))
                  : ((s = x), (a || !x) && ((x = "error"), 0 > a && (a = 0))),
                (v.status = a),
                (v.statusText = (b || x) + ""),
                j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]),
                v.statusCode(q),
                (q = void 0),
                i &&
                  m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]),
                p.fireWith(l, [v, x]),
                i &&
                  (m.trigger("ajaxComplete", [v, k]),
                  --n.active || n.event.trigger("ajaxStop")));
            }
            return v;
          },
          getJSON: function (a, b, c) {
            return n.get(a, b, c, "json");
          },
          getScript: function (a, b) {
            return n.get(a, void 0, b, "script");
          },
        }),
          n.each(["get", "post"], function (a, b) {
            n[b] = function (a, c, d, e) {
              return (
                n.isFunction(c) && ((e = e || d), (d = c), (c = void 0)),
                n.ajax({ url: a, type: b, dataType: e, data: c, success: d })
              );
            };
          }),
          (n._evalUrl = function (a) {
            return n.ajax({
              url: a,
              type: "GET",
              dataType: "script",
              async: !1,
              global: !1,
              throws: !0,
            });
          }),
          n.fn.extend({
            wrapAll: function (a) {
              var b;
              return n.isFunction(a)
                ? this.each(function (b) {
                    n(this).wrapAll(a.call(this, b));
                  })
                : (this[0] &&
                    ((b = n(a, this[0].ownerDocument).eq(0).clone(!0)),
                    this[0].parentNode && b.insertBefore(this[0]),
                    b
                      .map(function () {
                        var a = this;
                        while (a.firstElementChild) a = a.firstElementChild;
                        return a;
                      })
                      .append(this)),
                  this);
            },
            wrapInner: function (a) {
              return this.each(
                n.isFunction(a)
                  ? function (b) {
                      n(this).wrapInner(a.call(this, b));
                    }
                  : function () {
                      var b = n(this),
                        c = b.contents();
                      c.length ? c.wrapAll(a) : b.append(a);
                    }
              );
            },
            wrap: function (a) {
              var b = n.isFunction(a);
              return this.each(function (c) {
                n(this).wrapAll(b ? a.call(this, c) : a);
              });
            },
            unwrap: function () {
              return this.parent()
                .each(function () {
                  n.nodeName(this, "body") ||
                    n(this).replaceWith(this.childNodes);
                })
                .end();
            },
          }),
          (n.expr.filters.hidden = function (a) {
            return a.offsetWidth <= 0 && a.offsetHeight <= 0;
          }),
          (n.expr.filters.visible = function (a) {
            return !n.expr.filters.hidden(a);
          });
        var vb = /%20/g,
          wb = /\[\]$/,
          xb = /\r?\n/g,
          yb = /^(?:submit|button|image|reset|file)$/i,
          zb = /^(?:input|select|textarea|keygen)/i;
        function Ab(a, b, c, d) {
          var e;
          if (n.isArray(b))
            n.each(b, function (b, e) {
              c || wb.test(a)
                ? d(a, e)
                : Ab(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
            });
          else if (c || "object" !== n.type(b)) d(a, b);
          else for (e in b) Ab(a + "[" + e + "]", b[e], c, d);
        }
        (n.param = function (a, b) {
          var c,
            d = [],
            e = function (a, b) {
              (b = n.isFunction(b) ? b() : null == b ? "" : b),
                (d[d.length] =
                  encodeURIComponent(a) + "=" + encodeURIComponent(b));
            };
          if (
            (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional),
            n.isArray(a) || (a.jquery && !n.isPlainObject(a)))
          )
            n.each(a, function () {
              e(this.name, this.value);
            });
          else for (c in a) Ab(c, a[c], b, e);
          return d.join("&").replace(vb, "+");
        }),
          n.fn.extend({
            serialize: function () {
              return n.param(this.serializeArray());
            },
            serializeArray: function () {
              return this.map(function () {
                var a = n.prop(this, "elements");
                return a ? n.makeArray(a) : this;
              })
                .filter(function () {
                  var a = this.type;
                  return (
                    this.name &&
                    !n(this).is(":disabled") &&
                    zb.test(this.nodeName) &&
                    !yb.test(a) &&
                    (this.checked || !T.test(a))
                  );
                })
                .map(function (a, b) {
                  var c = n(this).val();
                  return null == c
                    ? null
                    : n.isArray(c)
                    ? n.map(c, function (a) {
                        return { name: b.name, value: a.replace(xb, "\r\n") };
                      })
                    : { name: b.name, value: c.replace(xb, "\r\n") };
                })
                .get();
            },
          }),
          (n.ajaxSettings.xhr = function () {
            try {
              return new XMLHttpRequest();
            } catch (a) {}
          });
        var Bb = 0,
          Cb = {},
          Db = { 0: 200, 1223: 204 },
          Eb = n.ajaxSettings.xhr();
        a.attachEvent &&
          a.attachEvent("onunload", function () {
            for (var a in Cb) Cb[a]();
          }),
          (k.cors = !!Eb && "withCredentials" in Eb),
          (k.ajax = Eb = !!Eb),
          n.ajaxTransport(function (a) {
            var b;
            return k.cors || (Eb && !a.crossDomain)
              ? {
                  send: function (c, d) {
                    var e,
                      f = a.xhr(),
                      g = ++Bb;
                    if (
                      (f.open(a.type, a.url, a.async, a.username, a.password),
                      a.xhrFields)
                    )
                      for (e in a.xhrFields) f[e] = a.xhrFields[e];
                    a.mimeType &&
                      f.overrideMimeType &&
                      f.overrideMimeType(a.mimeType),
                      a.crossDomain ||
                        c["X-Requested-With"] ||
                        (c["X-Requested-With"] = "XMLHttpRequest");
                    for (e in c) f.setRequestHeader(e, c[e]);
                    (b = function (a) {
                      return function () {
                        b &&
                          (delete Cb[g],
                          (b = f.onload = f.onerror = null),
                          "abort" === a
                            ? f.abort()
                            : "error" === a
                            ? d(f.status, f.statusText)
                            : d(
                                Db[f.status] || f.status,
                                f.statusText,
                                "string" == typeof f.responseText
                                  ? { text: f.responseText }
                                  : void 0,
                                f.getAllResponseHeaders()
                              ));
                      };
                    }),
                      (f.onload = b()),
                      (f.onerror = b("error")),
                      (b = Cb[g] = b("abort"));
                    try {
                      f.send((a.hasContent && a.data) || null);
                    } catch (h) {
                      if (b) throw h;
                    }
                  },
                  abort: function () {
                    b && b();
                  },
                }
              : void 0;
          }),
          n.ajaxSetup({
            accepts: {
              script:
                "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript",
            },
            contents: { script: /(?:java|ecma)script/ },
            converters: {
              "text script": function (a) {
                return n.globalEval(a), a;
              },
            },
          }),
          n.ajaxPrefilter("script", function (a) {
            void 0 === a.cache && (a.cache = !1),
              a.crossDomain && (a.type = "GET");
          }),
          n.ajaxTransport("script", function (a) {
            if (a.crossDomain) {
              var b, c;
              return {
                send: function (d, e) {
                  (b = n("<script>")
                    .prop({ async: !0, charset: a.scriptCharset, src: a.url })
                    .on(
                      "load error",
                      (c = function (a) {
                        b.remove(),
                          (c = null),
                          a && e("error" === a.type ? 404 : 200, a.type);
                      })
                    )),
                    l.head.appendChild(b[0]);
                },
                abort: function () {
                  c && c();
                },
              };
            }
          });
        var Fb = [],
          Gb = /(=)\?(?=&|$)|\?\?/;
        n.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function () {
            var a = Fb.pop() || n.expando + "_" + cb++;
            return (this[a] = !0), a;
          },
        }),
          n.ajaxPrefilter("json jsonp", function (b, c, d) {
            var e,
              f,
              g,
              h =
                b.jsonp !== !1 &&
                (Gb.test(b.url)
                  ? "url"
                  : "string" == typeof b.data &&
                    !(b.contentType || "").indexOf(
                      "application/x-www-form-urlencoded"
                    ) &&
                    Gb.test(b.data) &&
                    "data");
            return h || "jsonp" === b.dataTypes[0]
              ? ((e = b.jsonpCallback =
                  n.isFunction(b.jsonpCallback)
                    ? b.jsonpCallback()
                    : b.jsonpCallback),
                h
                  ? (b[h] = b[h].replace(Gb, "$1" + e))
                  : b.jsonp !== !1 &&
                    (b.url += (db.test(b.url) ? "&" : "?") + b.jsonp + "=" + e),
                (b.converters["script json"] = function () {
                  return g || n.error(e + " was not called"), g[0];
                }),
                (b.dataTypes[0] = "json"),
                (f = a[e]),
                (a[e] = function () {
                  g = arguments;
                }),
                d.always(function () {
                  (a[e] = f),
                    b[e] && ((b.jsonpCallback = c.jsonpCallback), Fb.push(e)),
                    g && n.isFunction(f) && f(g[0]),
                    (g = f = void 0);
                }),
                "script")
              : void 0;
          }),
          (n.parseHTML = function (a, b, c) {
            if (!a || "string" != typeof a) return null;
            "boolean" == typeof b && ((c = b), (b = !1)), (b = b || l);
            var d = v.exec(a),
              e = !c && [];
            return d
              ? [b.createElement(d[1])]
              : ((d = n.buildFragment([a], b, e)),
                e && e.length && n(e).remove(),
                n.merge([], d.childNodes));
          });
        var Hb = n.fn.load;
        (n.fn.load = function (a, b, c) {
          if ("string" != typeof a && Hb) return Hb.apply(this, arguments);
          var d,
            e,
            f,
            g = this,
            h = a.indexOf(" ");
          return (
            h >= 0 && ((d = n.trim(a.slice(h))), (a = a.slice(0, h))),
            n.isFunction(b)
              ? ((c = b), (b = void 0))
              : b && "object" == typeof b && (e = "POST"),
            g.length > 0 &&
              n
                .ajax({ url: a, type: e, dataType: "html", data: b })
                .done(function (a) {
                  (f = arguments),
                    g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a);
                })
                .complete(
                  c &&
                    function (a, b) {
                      g.each(c, f || [a.responseText, b, a]);
                    }
                ),
            this
          );
        }),
          n.each(
            [
              "ajaxStart",
              "ajaxStop",
              "ajaxComplete",
              "ajaxError",
              "ajaxSuccess",
              "ajaxSend",
            ],
            function (a, b) {
              n.fn[b] = function (a) {
                return this.on(b, a);
              };
            }
          ),
          (n.expr.filters.animated = function (a) {
            return n.grep(n.timers, function (b) {
              return a === b.elem;
            }).length;
          });
        var Ib = a.document.documentElement;
        function Jb(a) {
          return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;
        }
        (n.offset = {
          setOffset: function (a, b, c) {
            var d,
              e,
              f,
              g,
              h,
              i,
              j,
              k = n.css(a, "position"),
              l = n(a),
              m = {};
            "static" === k && (a.style.position = "relative"),
              (h = l.offset()),
              (f = n.css(a, "top")),
              (i = n.css(a, "left")),
              (j =
                ("absolute" === k || "fixed" === k) &&
                (f + i).indexOf("auto") > -1),
              j
                ? ((d = l.position()), (g = d.top), (e = d.left))
                : ((g = parseFloat(f) || 0), (e = parseFloat(i) || 0)),
              n.isFunction(b) && (b = b.call(a, c, h)),
              null != b.top && (m.top = b.top - h.top + g),
              null != b.left && (m.left = b.left - h.left + e),
              "using" in b ? b.using.call(a, m) : l.css(m);
          },
        }),
          n.fn.extend({
            offset: function (a) {
              if (arguments.length)
                return void 0 === a
                  ? this
                  : this.each(function (b) {
                      n.offset.setOffset(this, a, b);
                    });
              var b,
                c,
                d = this[0],
                e = { top: 0, left: 0 },
                f = d && d.ownerDocument;
              if (f)
                return (
                  (b = f.documentElement),
                  n.contains(b, d)
                    ? (typeof d.getBoundingClientRect !== U &&
                        (e = d.getBoundingClientRect()),
                      (c = Jb(f)),
                      {
                        top: e.top + c.pageYOffset - b.clientTop,
                        left: e.left + c.pageXOffset - b.clientLeft,
                      })
                    : e
                );
            },
            position: function () {
              if (this[0]) {
                var a,
                  b,
                  c = this[0],
                  d = { top: 0, left: 0 };
                return (
                  "fixed" === n.css(c, "position")
                    ? (b = c.getBoundingClientRect())
                    : ((a = this.offsetParent()),
                      (b = this.offset()),
                      n.nodeName(a[0], "html") || (d = a.offset()),
                      (d.top += n.css(a[0], "borderTopWidth", !0)),
                      (d.left += n.css(a[0], "borderLeftWidth", !0))),
                  {
                    top: b.top - d.top - n.css(c, "marginTop", !0),
                    left: b.left - d.left - n.css(c, "marginLeft", !0),
                  }
                );
              }
            },
            offsetParent: function () {
              return this.map(function () {
                var a = this.offsetParent || Ib;
                while (
                  a &&
                  !n.nodeName(a, "html") &&
                  "static" === n.css(a, "position")
                )
                  a = a.offsetParent;
                return a || Ib;
              });
            },
          }),
          n.each(
            { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
            function (b, c) {
              var d = "pageYOffset" === c;
              n.fn[b] = function (e) {
                return J(
                  this,
                  function (b, e, f) {
                    var g = Jb(b);
                    return void 0 === f
                      ? g
                        ? g[c]
                        : b[e]
                      : void (g
                          ? g.scrollTo(
                              d ? a.pageXOffset : f,
                              d ? f : a.pageYOffset
                            )
                          : (b[e] = f));
                  },
                  b,
                  e,
                  arguments.length,
                  null
                );
              };
            }
          ),
          n.each(["top", "left"], function (a, b) {
            n.cssHooks[b] = ya(k.pixelPosition, function (a, c) {
              return c
                ? ((c = xa(a, b)), va.test(c) ? n(a).position()[b] + "px" : c)
                : void 0;
            });
          }),
          n.each({ Height: "height", Width: "width" }, function (a, b) {
            n.each(
              { padding: "inner" + a, content: b, "": "outer" + a },
              function (c, d) {
                n.fn[d] = function (d, e) {
                  var f = arguments.length && (c || "boolean" != typeof d),
                    g = c || (d === !0 || e === !0 ? "margin" : "border");
                  return J(
                    this,
                    function (b, c, d) {
                      var e;
                      return n.isWindow(b)
                        ? b.document.documentElement["client" + a]
                        : 9 === b.nodeType
                        ? ((e = b.documentElement),
                          Math.max(
                            b.body["scroll" + a],
                            e["scroll" + a],
                            b.body["offset" + a],
                            e["offset" + a],
                            e["client" + a]
                          ))
                        : void 0 === d
                        ? n.css(b, c, g)
                        : n.style(b, c, d, g);
                    },
                    b,
                    f ? d : void 0,
                    f,
                    null
                  );
                };
              }
            );
          }),
          (n.fn.size = function () {
            return this.length;
          }),
          (n.fn.andSelf = n.fn.addBack),
          "function" == "function" &&
            __webpack_require__(2) &&
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
              return n;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        var Kb = a.jQuery,
          Lb = a.$;
        return (
          (n.noConflict = function (b) {
            return (
              a.$ === n && (a.$ = Lb), b && a.jQuery === n && (a.jQuery = Kb), n
            );
          }),
          typeof b === U && (a.jQuery = a.$ = n),
          n
        );
      });
      //# sourceMappingURL=jquery.min.map

      /***/
    },
    /* 2 */
    /***/ function (module, exports) {
      /* WEBPACK VAR INJECTION */ (function (__webpack_amd_options__) {
        module.exports = __webpack_amd_options__;

        /* WEBPACK VAR INJECTION */
      }.call(exports, {}));

      /***/
    },
    /* 3 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__; // threejs.org/license
      ("use strict");
      var THREE = { REVISION: "74" };
      true
        ? !((__WEBPACK_AMD_DEFINE_FACTORY__ = THREE),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
              ? __WEBPACK_AMD_DEFINE_FACTORY__.call(
                  exports,
                  __webpack_require__,
                  exports,
                  module
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        : "undefined" !== typeof exports &&
          "undefined" !== typeof module &&
          (module.exports = THREE);
      void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
      void 0 === Math.sign &&
        (Math.sign = function (a) {
          return 0 > a ? -1 : 0 < a ? 1 : +a;
        });
      void 0 === Function.prototype.name &&
        void 0 !== Object.defineProperty &&
        Object.defineProperty(Function.prototype, "name", {
          get: function () {
            return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
          },
        });
      void 0 === Object.assign &&
        Object.defineProperty(Object, "assign", {
          writable: !0,
          configurable: !0,
          value: function (a) {
            if (void 0 === a || null === a)
              throw new TypeError("Cannot convert first argument to object");
            for (var b = Object(a), c = 1, d = arguments.length; c !== d; ++c) {
              var e = arguments[c];
              if (void 0 !== e && null !== e)
                for (
                  var e = Object(e), f = Object.keys(e), g = 0, h = f.length;
                  g !== h;
                  ++g
                ) {
                  var k = f[g],
                    l = Object.getOwnPropertyDescriptor(e, k);
                  void 0 !== l && l.enumerable && (b[k] = e[k]);
                }
            }
            return b;
          },
        });
      THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
      THREE.CullFaceNone = 0;
      THREE.CullFaceBack = 1;
      THREE.CullFaceFront = 2;
      THREE.CullFaceFrontBack = 3;
      THREE.FrontFaceDirectionCW = 0;
      THREE.FrontFaceDirectionCCW = 1;
      THREE.BasicShadowMap = 0;
      THREE.PCFShadowMap = 1;
      THREE.PCFSoftShadowMap = 2;
      THREE.FrontSide = 0;
      THREE.BackSide = 1;
      THREE.DoubleSide = 2;
      THREE.FlatShading = 1;
      THREE.SmoothShading = 2;
      THREE.NoColors = 0;
      THREE.FaceColors = 1;
      THREE.VertexColors = 2;
      THREE.NoBlending = 0;
      THREE.NormalBlending = 1;
      THREE.AdditiveBlending = 2;
      THREE.SubtractiveBlending = 3;
      THREE.MultiplyBlending = 4;
      THREE.CustomBlending = 5;
      THREE.AddEquation = 100;
      THREE.SubtractEquation = 101;
      THREE.ReverseSubtractEquation = 102;
      THREE.MinEquation = 103;
      THREE.MaxEquation = 104;
      THREE.ZeroFactor = 200;
      THREE.OneFactor = 201;
      THREE.SrcColorFactor = 202;
      THREE.OneMinusSrcColorFactor = 203;
      THREE.SrcAlphaFactor = 204;
      THREE.OneMinusSrcAlphaFactor = 205;
      THREE.DstAlphaFactor = 206;
      THREE.OneMinusDstAlphaFactor = 207;
      THREE.DstColorFactor = 208;
      THREE.OneMinusDstColorFactor = 209;
      THREE.SrcAlphaSaturateFactor = 210;
      THREE.NeverDepth = 0;
      THREE.AlwaysDepth = 1;
      THREE.LessDepth = 2;
      THREE.LessEqualDepth = 3;
      THREE.EqualDepth = 4;
      THREE.GreaterEqualDepth = 5;
      THREE.GreaterDepth = 6;
      THREE.NotEqualDepth = 7;
      THREE.MultiplyOperation = 0;
      THREE.MixOperation = 1;
      THREE.AddOperation = 2;
      THREE.UVMapping = 300;
      THREE.CubeReflectionMapping = 301;
      THREE.CubeRefractionMapping = 302;
      THREE.EquirectangularReflectionMapping = 303;
      THREE.EquirectangularRefractionMapping = 304;
      THREE.SphericalReflectionMapping = 305;
      THREE.RepeatWrapping = 1e3;
      THREE.ClampToEdgeWrapping = 1001;
      THREE.MirroredRepeatWrapping = 1002;
      THREE.NearestFilter = 1003;
      THREE.NearestMipMapNearestFilter = 1004;
      THREE.NearestMipMapLinearFilter = 1005;
      THREE.LinearFilter = 1006;
      THREE.LinearMipMapNearestFilter = 1007;
      THREE.LinearMipMapLinearFilter = 1008;
      THREE.UnsignedByteType = 1009;
      THREE.ByteType = 1010;
      THREE.ShortType = 1011;
      THREE.UnsignedShortType = 1012;
      THREE.IntType = 1013;
      THREE.UnsignedIntType = 1014;
      THREE.FloatType = 1015;
      THREE.HalfFloatType = 1025;
      THREE.UnsignedShort4444Type = 1016;
      THREE.UnsignedShort5551Type = 1017;
      THREE.UnsignedShort565Type = 1018;
      THREE.AlphaFormat = 1019;
      THREE.RGBFormat = 1020;
      THREE.RGBAFormat = 1021;
      THREE.LuminanceFormat = 1022;
      THREE.LuminanceAlphaFormat = 1023;
      THREE.RGBEFormat = THREE.RGBAFormat;
      THREE.RGB_S3TC_DXT1_Format = 2001;
      THREE.RGBA_S3TC_DXT1_Format = 2002;
      THREE.RGBA_S3TC_DXT3_Format = 2003;
      THREE.RGBA_S3TC_DXT5_Format = 2004;
      THREE.RGB_PVRTC_4BPPV1_Format = 2100;
      THREE.RGB_PVRTC_2BPPV1_Format = 2101;
      THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
      THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
      THREE.RGB_ETC1_Format = 2151;
      THREE.LoopOnce = 2200;
      THREE.LoopRepeat = 2201;
      THREE.LoopPingPong = 2202;
      THREE.InterpolateDiscrete = 2300;
      THREE.InterpolateLinear = 2301;
      THREE.InterpolateSmooth = 2302;
      THREE.ZeroCurvatureEnding = 2400;
      THREE.ZeroSlopeEnding = 2401;
      THREE.WrapAroundEnding = 2402;
      THREE.TrianglesDrawMode = 0;
      THREE.TriangleStripDrawMode = 1;
      THREE.TriangleFanDrawMode = 2;
      THREE.Color = function (a) {
        return 3 === arguments.length ? this.fromArray(arguments) : this.set(a);
      };
      THREE.Color.prototype = {
        constructor: THREE.Color,
        r: 1,
        g: 1,
        b: 1,
        set: function (a) {
          a instanceof THREE.Color
            ? this.copy(a)
            : "number" === typeof a
            ? this.setHex(a)
            : "string" === typeof a && this.setStyle(a);
          return this;
        },
        setScalar: function (a) {
          this.b = this.g = this.r = a;
        },
        setHex: function (a) {
          a = Math.floor(a);
          this.r = ((a >> 16) & 255) / 255;
          this.g = ((a >> 8) & 255) / 255;
          this.b = (a & 255) / 255;
          return this;
        },
        setRGB: function (a, b, c) {
          this.r = a;
          this.g = b;
          this.b = c;
          return this;
        },
        setHSL: (function () {
          function a(a, c, d) {
            0 > d && (d += 1);
            1 < d && (d -= 1);
            return d < 1 / 6
              ? a + 6 * (c - a) * d
              : 0.5 > d
              ? c
              : d < 2 / 3
              ? a + 6 * (c - a) * (2 / 3 - d)
              : a;
          }
          return function (b, c, d) {
            b = THREE.Math.euclideanModulo(b, 1);
            c = THREE.Math.clamp(c, 0, 1);
            d = THREE.Math.clamp(d, 0, 1);
            0 === c
              ? (this.r = this.g = this.b = d)
              : ((c = 0.5 >= d ? d * (1 + c) : d + c - d * c),
                (d = 2 * d - c),
                (this.r = a(d, c, b + 1 / 3)),
                (this.g = a(d, c, b)),
                (this.b = a(d, c, b - 1 / 3)));
            return this;
          };
        })(),
        setStyle: function (a) {
          function b(b) {
            void 0 !== b &&
              1 > parseFloat(b) &&
              console.warn(
                "THREE.Color: Alpha component of " + a + " will be ignored."
              );
          }
          var c;
          if ((c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a))) {
            var d = c[2];
            switch (c[1]) {
              case "rgb":
              case "rgba":
                if (
                  (c =
                    /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      d
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(c[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(c[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(c[3], 10)) / 255),
                    b(c[5]),
                    this
                  );
                if (
                  (c =
                    /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      d
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(c[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(c[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(c[3], 10)) / 100),
                    b(c[5]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (c =
                    /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                      d
                    ))
                ) {
                  var d = parseFloat(c[1]) / 360,
                    e = parseInt(c[2], 10) / 100,
                    f = parseInt(c[3], 10) / 100;
                  b(c[5]);
                  return this.setHSL(d, e, f);
                }
            }
          } else if ((c = /^\#([A-Fa-f0-9]+)$/.exec(a))) {
            c = c[1];
            d = c.length;
            if (3 === d)
              return (
                (this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255),
                (this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255),
                (this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255),
                this
              );
            if (6 === d)
              return (
                (this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255),
                (this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255),
                (this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255),
                this
              );
          }
          a &&
            0 < a.length &&
            ((c = THREE.ColorKeywords[a]),
            void 0 !== c
              ? this.setHex(c)
              : console.warn("THREE.Color: Unknown color " + a));
          return this;
        },
        clone: function () {
          return new this.constructor(this.r, this.g, this.b);
        },
        copy: function (a) {
          this.r = a.r;
          this.g = a.g;
          this.b = a.b;
          return this;
        },
        copyGammaToLinear: function (a, b) {
          void 0 === b && (b = 2);
          this.r = Math.pow(a.r, b);
          this.g = Math.pow(a.g, b);
          this.b = Math.pow(a.b, b);
          return this;
        },
        copyLinearToGamma: function (a, b) {
          void 0 === b && (b = 2);
          var c = 0 < b ? 1 / b : 1;
          this.r = Math.pow(a.r, c);
          this.g = Math.pow(a.g, c);
          this.b = Math.pow(a.b, c);
          return this;
        },
        convertGammaToLinear: function () {
          var a = this.r,
            b = this.g,
            c = this.b;
          this.r = a * a;
          this.g = b * b;
          this.b = c * c;
          return this;
        },
        convertLinearToGamma: function () {
          this.r = Math.sqrt(this.r);
          this.g = Math.sqrt(this.g);
          this.b = Math.sqrt(this.b);
          return this;
        },
        getHex: function () {
          return (
            ((255 * this.r) << 16) ^
            ((255 * this.g) << 8) ^
            ((255 * this.b) << 0)
          );
        },
        getHexString: function () {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function (a) {
          a = a || { h: 0, s: 0, l: 0 };
          var b = this.r,
            c = this.g,
            d = this.b,
            e = Math.max(b, c, d),
            f = Math.min(b, c, d),
            g,
            h = (f + e) / 2;
          if (f === e) f = g = 0;
          else {
            var k = e - f,
              f = 0.5 >= h ? k / (e + f) : k / (2 - e - f);
            switch (e) {
              case b:
                g = (c - d) / k + (c < d ? 6 : 0);
                break;
              case c:
                g = (d - b) / k + 2;
                break;
              case d:
                g = (b - c) / k + 4;
            }
            g /= 6;
          }
          a.h = g;
          a.s = f;
          a.l = h;
          return a;
        },
        getStyle: function () {
          return (
            "rgb(" +
            ((255 * this.r) | 0) +
            "," +
            ((255 * this.g) | 0) +
            "," +
            ((255 * this.b) | 0) +
            ")"
          );
        },
        offsetHSL: function (a, b, c) {
          var d = this.getHSL();
          d.h += a;
          d.s += b;
          d.l += c;
          this.setHSL(d.h, d.s, d.l);
          return this;
        },
        add: function (a) {
          this.r += a.r;
          this.g += a.g;
          this.b += a.b;
          return this;
        },
        addColors: function (a, b) {
          this.r = a.r + b.r;
          this.g = a.g + b.g;
          this.b = a.b + b.b;
          return this;
        },
        addScalar: function (a) {
          this.r += a;
          this.g += a;
          this.b += a;
          return this;
        },
        multiply: function (a) {
          this.r *= a.r;
          this.g *= a.g;
          this.b *= a.b;
          return this;
        },
        multiplyScalar: function (a) {
          this.r *= a;
          this.g *= a;
          this.b *= a;
          return this;
        },
        lerp: function (a, b) {
          this.r += (a.r - this.r) * b;
          this.g += (a.g - this.g) * b;
          this.b += (a.b - this.b) * b;
          return this;
        },
        equals: function (a) {
          return a.r === this.r && a.g === this.g && a.b === this.b;
        },
        fromArray: function (a, b) {
          void 0 === b && (b = 0);
          this.r = a[b];
          this.g = a[b + 1];
          this.b = a[b + 2];
          return this;
        },
        toArray: function (a, b) {
          void 0 === a && (a = []);
          void 0 === b && (b = 0);
          a[b] = this.r;
          a[b + 1] = this.g;
          a[b + 2] = this.b;
          return a;
        },
      };
      THREE.ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      };
      THREE.Quaternion = function (a, b, c, d) {
        this._x = a || 0;
        this._y = b || 0;
        this._z = c || 0;
        this._w = void 0 !== d ? d : 1;
      };
      THREE.Quaternion.prototype = {
        constructor: THREE.Quaternion,
        get x() {
          return this._x;
        },
        set x(a) {
          this._x = a;
          this.onChangeCallback();
        },
        get y() {
          return this._y;
        },
        set y(a) {
          this._y = a;
          this.onChangeCallback();
        },
        get z() {
          return this._z;
        },
        set z(a) {
          this._z = a;
          this.onChangeCallback();
        },
        get w() {
          return this._w;
        },
        set w(a) {
          this._w = a;
          this.onChangeCallback();
        },
        set: function (a, b, c, d) {
          this._x = a;
          this._y = b;
          this._z = c;
          this._w = d;
          this.onChangeCallback();
          return this;
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function (a) {
          this._x = a.x;
          this._y = a.y;
          this._z = a.z;
          this._w = a.w;
          this.onChangeCallback();
          return this;
        },
        setFromEuler: function (a, b) {
          if (!1 === a instanceof THREE.Euler)
            throw Error(
              "THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          var c = Math.cos(a._x / 2),
            d = Math.cos(a._y / 2),
            e = Math.cos(a._z / 2),
            f = Math.sin(a._x / 2),
            g = Math.sin(a._y / 2),
            h = Math.sin(a._z / 2),
            k = a.order;
          "XYZ" === k
            ? ((this._x = f * d * e + c * g * h),
              (this._y = c * g * e - f * d * h),
              (this._z = c * d * h + f * g * e),
              (this._w = c * d * e - f * g * h))
            : "YXZ" === k
            ? ((this._x = f * d * e + c * g * h),
              (this._y = c * g * e - f * d * h),
              (this._z = c * d * h - f * g * e),
              (this._w = c * d * e + f * g * h))
            : "ZXY" === k
            ? ((this._x = f * d * e - c * g * h),
              (this._y = c * g * e + f * d * h),
              (this._z = c * d * h + f * g * e),
              (this._w = c * d * e - f * g * h))
            : "ZYX" === k
            ? ((this._x = f * d * e - c * g * h),
              (this._y = c * g * e + f * d * h),
              (this._z = c * d * h - f * g * e),
              (this._w = c * d * e + f * g * h))
            : "YZX" === k
            ? ((this._x = f * d * e + c * g * h),
              (this._y = c * g * e + f * d * h),
              (this._z = c * d * h - f * g * e),
              (this._w = c * d * e - f * g * h))
            : "XZY" === k &&
              ((this._x = f * d * e - c * g * h),
              (this._y = c * g * e - f * d * h),
              (this._z = c * d * h + f * g * e),
              (this._w = c * d * e + f * g * h));
          if (!1 !== b) this.onChangeCallback();
          return this;
        },
        setFromAxisAngle: function (a, b) {
          var c = b / 2,
            d = Math.sin(c);
          this._x = a.x * d;
          this._y = a.y * d;
          this._z = a.z * d;
          this._w = Math.cos(c);
          this.onChangeCallback();
          return this;
        },
        setFromRotationMatrix: function (a) {
          var b = a.elements,
            c = b[0];
          a = b[4];
          var d = b[8],
            e = b[1],
            f = b[5],
            g = b[9],
            h = b[2],
            k = b[6],
            b = b[10],
            l = c + f + b;
          0 < l
            ? ((c = 0.5 / Math.sqrt(l + 1)),
              (this._w = 0.25 / c),
              (this._x = (k - g) * c),
              (this._y = (d - h) * c),
              (this._z = (e - a) * c))
            : c > f && c > b
            ? ((c = 2 * Math.sqrt(1 + c - f - b)),
              (this._w = (k - g) / c),
              (this._x = 0.25 * c),
              (this._y = (a + e) / c),
              (this._z = (d + h) / c))
            : f > b
            ? ((c = 2 * Math.sqrt(1 + f - c - b)),
              (this._w = (d - h) / c),
              (this._x = (a + e) / c),
              (this._y = 0.25 * c),
              (this._z = (g + k) / c))
            : ((c = 2 * Math.sqrt(1 + b - c - f)),
              (this._w = (e - a) / c),
              (this._x = (d + h) / c),
              (this._y = (g + k) / c),
              (this._z = 0.25 * c));
          this.onChangeCallback();
          return this;
        },
        setFromUnitVectors: (function () {
          var a, b;
          return function (c, d) {
            void 0 === a && (a = new THREE.Vector3());
            b = c.dot(d) + 1;
            1e-6 > b
              ? ((b = 0),
                Math.abs(c.x) > Math.abs(c.z)
                  ? a.set(-c.y, c.x, 0)
                  : a.set(0, -c.z, c.y))
              : a.crossVectors(c, d);
            this._x = a.x;
            this._y = a.y;
            this._z = a.z;
            this._w = b;
            this.normalize();
            return this;
          };
        })(),
        inverse: function () {
          this.conjugate().normalize();
          return this;
        },
        conjugate: function () {
          this._x *= -1;
          this._y *= -1;
          this._z *= -1;
          this.onChangeCallback();
          return this;
        },
        dot: function (a) {
          return (
            this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
          );
        },
        lengthSq: function () {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        },
        length: function () {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        },
        normalize: function () {
          var a = this.length();
          0 === a
            ? ((this._z = this._y = this._x = 0), (this._w = 1))
            : ((a = 1 / a),
              (this._x *= a),
              (this._y *= a),
              (this._z *= a),
              (this._w *= a));
          this.onChangeCallback();
          return this;
        },
        multiply: function (a, b) {
          return void 0 !== b
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(a, b))
            : this.multiplyQuaternions(this, a);
        },
        multiplyQuaternions: function (a, b) {
          var c = a._x,
            d = a._y,
            e = a._z,
            f = a._w,
            g = b._x,
            h = b._y,
            k = b._z,
            l = b._w;
          this._x = c * l + f * g + d * k - e * h;
          this._y = d * l + f * h + e * g - c * k;
          this._z = e * l + f * k + c * h - d * g;
          this._w = f * l - c * g - d * h - e * k;
          this.onChangeCallback();
          return this;
        },
        slerp: function (a, b) {
          if (0 === b) return this;
          if (1 === b) return this.copy(a);
          var c = this._x,
            d = this._y,
            e = this._z,
            f = this._w,
            g = f * a._w + c * a._x + d * a._y + e * a._z;
          0 > g
            ? ((this._w = -a._w),
              (this._x = -a._x),
              (this._y = -a._y),
              (this._z = -a._z),
              (g = -g))
            : this.copy(a);
          if (1 <= g)
            return (
              (this._w = f), (this._x = c), (this._y = d), (this._z = e), this
            );
          var h = Math.sqrt(1 - g * g);
          if (0.001 > Math.abs(h))
            return (
              (this._w = 0.5 * (f + this._w)),
              (this._x = 0.5 * (c + this._x)),
              (this._y = 0.5 * (d + this._y)),
              (this._z = 0.5 * (e + this._z)),
              this
            );
          var k = Math.atan2(h, g),
            g = Math.sin((1 - b) * k) / h,
            h = Math.sin(b * k) / h;
          this._w = f * g + this._w * h;
          this._x = c * g + this._x * h;
          this._y = d * g + this._y * h;
          this._z = e * g + this._z * h;
          this.onChangeCallback();
          return this;
        },
        equals: function (a) {
          return (
            a._x === this._x &&
            a._y === this._y &&
            a._z === this._z &&
            a._w === this._w
          );
        },
        fromArray: function (a, b) {
          void 0 === b && (b = 0);
          this._x = a[b];
          this._y = a[b + 1];
          this._z = a[b + 2];
          this._w = a[b + 3];
          this.onChangeCallback();
          return this;
        },
        toArray: function (a, b) {
          void 0 === a && (a = []);
          void 0 === b && (b = 0);
          a[b] = this._x;
          a[b + 1] = this._y;
          a[b + 2] = this._z;
          a[b + 3] = this._w;
          return a;
        },
        onChange: function (a) {
          this.onChangeCallback = a;
          return this;
        },
        onChangeCallback: function () {},
      };
      Object.assign(THREE.Quaternion, {
        slerp: function (a, b, c, d) {
          return c.copy(a).slerp(b, d);
        },
        slerpFlat: function (a, b, c, d, e, f, g) {
          var h = c[d + 0],
            k = c[d + 1],
            l = c[d + 2];
          c = c[d + 3];
          d = e[f + 0];
          var n = e[f + 1],
            p = e[f + 2];
          e = e[f + 3];
          if (c !== e || h !== d || k !== n || l !== p) {
            f = 1 - g;
            var m = h * d + k * n + l * p + c * e,
              q = 0 <= m ? 1 : -1,
              s = 1 - m * m;
            s > Number.EPSILON &&
              ((s = Math.sqrt(s)),
              (m = Math.atan2(s, m * q)),
              (f = Math.sin(f * m) / s),
              (g = Math.sin(g * m) / s));
            q *= g;
            h = h * f + d * q;
            k = k * f + n * q;
            l = l * f + p * q;
            c = c * f + e * q;
            f === 1 - g &&
              ((g = 1 / Math.sqrt(h * h + k * k + l * l + c * c)),
              (h *= g),
              (k *= g),
              (l *= g),
              (c *= g));
          }
          a[b] = h;
          a[b + 1] = k;
          a[b + 2] = l;
          a[b + 3] = c;
        },
      });
      THREE.Vector2 = function (a, b) {
        this.x = a || 0;
        this.y = b || 0;
      };
      THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        get width() {
          return this.x;
        },
        set width(a) {
          this.x = a;
        },
        get height() {
          return this.y;
        },
        set height(a) {
          this.y = a;
        },
        set: function (a, b) {
          this.x = a;
          this.y = b;
          return this;
        },
        setScalar: function (a) {
          this.y = this.x = a;
          return this;
        },
        setX: function (a) {
          this.x = a;
          return this;
        },
        setY: function (a) {
          this.y = a;
          return this;
        },
        setComponent: function (a, b) {
          switch (a) {
            case 0:
              this.x = b;
              break;
            case 1:
              this.y = b;
              break;
            default:
              throw Error("index is out of range: " + a);
          }
        },
        getComponent: function (a) {
          switch (a) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw Error("index is out of range: " + a);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y);
        },
        copy: function (a) {
          this.x = a.x;
          this.y = a.y;
          return this;
        },
        add: function (a, b) {
          if (void 0 !== b)
            return (
              console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(a, b)
            );
          this.x += a.x;
          this.y += a.y;
          return this;
        },
        addScalar: function (a) {
          this.x += a;
          this.y += a;
          return this;
        },
        addVectors: function (a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          return this;
        },
        addScaledVector: function (a, b) {
          this.x += a.x * b;
          this.y += a.y * b;
          return this;
        },
        sub: function (a, b) {
          if (void 0 !== b)
            return (
              console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(a, b)
            );
          this.x -= a.x;
          this.y -= a.y;
          return this;
        },
        subScalar: function (a) {
          this.x -= a;
          this.y -= a;
          return this;
        },
        subVectors: function (a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          return this;
        },
        multiply: function (a) {
          this.x *= a.x;
          this.y *= a.y;
          return this;
        },
        multiplyScalar: function (a) {
          isFinite(a) ? ((this.x *= a), (this.y *= a)) : (this.y = this.x = 0);
          return this;
        },
        divide: function (a) {
          this.x /= a.x;
          this.y /= a.y;
          return this;
        },
        divideScalar: function (a) {
          return this.multiplyScalar(1 / a);
        },
        min: function (a) {
          this.x = Math.min(this.x, a.x);
          this.y = Math.min(this.y, a.y);
          return this;
        },
        max: function (a) {
          this.x = Math.max(this.x, a.x);
          this.y = Math.max(this.y, a.y);
          return this;
        },
        clamp: function (a, b) {
          this.x = Math.max(a.x, Math.min(b.x, this.x));
          this.y = Math.max(a.y, Math.min(b.y, this.y));
          return this;
        },
        clampScalar: (function () {
          var a, b;
          return function (c, d) {
            void 0 === a &&
              ((a = new THREE.Vector2()), (b = new THREE.Vector2()));
            a.set(c, c);
            b.set(d, d);
            return this.clamp(a, b);
          };
        })(),
        clampLength: function (a, b) {
          var c = this.length();
          this.multiplyScalar(Math.max(a, Math.min(b, c)) / c);
          return this;
        },
        floor: function () {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        },
        ceil: function () {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        },
        round: function () {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        roundToZero: function () {
          this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
          return this;
        },
        negate: function () {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        },
        dot: function (a) {
          return this.x * a.x + this.y * a.y;
        },
        lengthSq: function () {
          return this.x * this.x + this.y * this.y;
        },
        length: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        lengthManhattan: function () {
          return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function () {
          return this.divideScalar(this.length());
        },
        angle: function () {
          var a = Math.atan2(this.y, this.x);
          0 > a && (a += 2 * Math.PI);
          return a;
        },
        distanceTo: function (a) {
          return Math.sqrt(this.distanceToSquared(a));
        },
        distanceToSquared: function (a) {
          var b = this.x - a.x;
          a = this.y - a.y;
          return b * b + a * a;
        },
        setLength: function (a) {
          return this.multiplyScalar(a / this.length());
        },
        lerp: function (a, b) {
          this.x += (a.x - this.x) * b;
          this.y += (a.y - this.y) * b;
          return this;
        },
        lerpVectors: function (a, b, c) {
          this.subVectors(b, a).multiplyScalar(c).add(a);
          return this;
        },
        equals: function (a) {
          return a.x === this.x && a.y === this.y;
        },
        fromArray: function (a, b) {
          void 0 === b && (b = 0);
          this.x = a[b];
          this.y = a[b + 1];
          return this;
        },
        toArray: function (a, b) {
          void 0 === a && (a = []);
          void 0 === b && (b = 0);
          a[b] = this.x;
          a[b + 1] = this.y;
          return a;
        },
        fromAttribute: function (a, b, c) {
          void 0 === c && (c = 0);
          b = b * a.itemSize + c;
          this.x = a.array[b];
          this.y = a.array[b + 1];
          return this;
        },
        rotateAround: function (a, b) {
          var c = Math.cos(b),
            d = Math.sin(b),
            e = this.x - a.x,
            f = this.y - a.y;
          this.x = e * c - f * d + a.x;
          this.y = e * d + f * c + a.y;
          return this;
        },
      };
      THREE.Vector3 = function (a, b, c) {
        this.x = a || 0;
        this.y = b || 0;
        this.z = c || 0;
      };
      THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        set: function (a, b, c) {
          this.x = a;
          this.y = b;
          this.z = c;
          return this;
        },
        setScalar: function (a) {
          this.z = this.y = this.x = a;
          return this;
        },
        setX: function (a) {
          this.x = a;
          return this;
        },
        setY: function (a) {
          this.y = a;
          return this;
        },
        setZ: function (a) {
          this.z = a;
          return this;
        },
        setComponent: function (a, b) {
          switch (a) {
            case 0:
              this.x = b;
              break;
            case 1:
              this.y = b;
              break;
            case 2:
              this.z = b;
              break;
            default:
              throw Error("index is out of range: " + a);
          }
        },
        getComponent: function (a) {
          switch (a) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw Error("index is out of range: " + a);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y, this.z);
        },
        copy: function (a) {
          this.x = a.x;
          this.y = a.y;
          this.z = a.z;
          return this;
        },
        add: function (a, b) {
          if (void 0 !== b)
            return (
              console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(a, b)
            );
          this.x += a.x;
          this.y += a.y;
          this.z += a.z;
          return this;
        },
        addScalar: function (a) {
          this.x += a;
          this.y += a;
          this.z += a;
          return this;
        },
        addVectors: function (a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          return this;
        },
        addScaledVector: function (a, b) {
          this.x += a.x * b;
          this.y += a.y * b;
          this.z += a.z * b;
          return this;
        },
        sub: function (a, b) {
          if (void 0 !== b)
            return (
              console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(a, b)
            );
          this.x -= a.x;
          this.y -= a.y;
          this.z -= a.z;
          return this;
        },
        subScalar: function (a) {
          this.x -= a;
          this.y -= a;
          this.z -= a;
          return this;
        },
        subVectors: function (a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          return this;
        },
        multiply: function (a, b) {
          if (void 0 !== b)
            return (
              console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(a, b)
            );
          this.x *= a.x;
          this.y *= a.y;
          this.z *= a.z;
          return this;
        },
        multiplyScalar: function (a) {
          isFinite(a)
            ? ((this.x *= a), (this.y *= a), (this.z *= a))
            : (this.z = this.y = this.x = 0);
          return this;
        },
        multiplyVectors: function (a, b) {
          this.x = a.x * b.x;
          this.y = a.y * b.y;
          this.z = a.z * b.z;
          return this;
        },
        applyEuler: (function () {
          var a;
          return function (b) {
            !1 === b instanceof THREE.Euler &&
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              );
            void 0 === a && (a = new THREE.Quaternion());
            this.applyQuaternion(a.setFromEuler(b));
            return this;
          };
        })(),
        applyAxisAngle: (function () {
          var a;
          return function (b, c) {
            void 0 === a && (a = new THREE.Quaternion());
            this.applyQuaternion(a.setFromAxisAngle(b, c));
            return this;
          };
        })(),
        applyMatrix3: function (a) {
          var b = this.x,
            c = this.y,
            d = this.z;
          a = a.elements;
          this.x = a[0] * b + a[3] * c + a[6] * d;
          this.y = a[1] * b + a[4] * c + a[7] * d;
          this.z = a[2] * b + a[5] * c + a[8] * d;
          return this;
        },
        applyMatrix4: function (a) {
          var b = this.x,
            c = this.y,
            d = this.z;
          a = a.elements;
          this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
          this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
          this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
          return this;
        },
        applyProjection: function (a) {
          var b = this.x,
            c = this.y,
            d = this.z;
          a = a.elements;
          var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
          this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
          this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
          this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
          return this;
        },
        applyQuaternion: function (a) {
          var b = this.x,
            c = this.y,
            d = this.z,
            e = a.x,
            f = a.y,
            g = a.z;
          a = a.w;
          var h = a * b + f * d - g * c,
            k = a * c + g * b - e * d,
            l = a * d + e * c - f * b,
            b = -e * b - f * c - g * d;
          this.x = h * a + b * -e + k * -g - l * -f;
          this.y = k * a + b * -f + l * -e - h * -g;
          this.z = l * a + b * -g + h * -f - k * -e;
          return this;
        },
        project: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Matrix4());
            a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld));
            return this.applyProjection(a);
          };
        })(),
        unproject: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Matrix4());
            a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix));
            return this.applyProjection(a);
          };
        })(),
        transformDirection: function (a) {
          var b = this.x,
            c = this.y,
            d = this.z;
          a = a.elements;
          this.x = a[0] * b + a[4] * c + a[8] * d;
          this.y = a[1] * b + a[5] * c + a[9] * d;
          this.z = a[2] * b + a[6] * c + a[10] * d;
          this.normalize();
          return this;
        },
        divide: function (a) {
          this.x /= a.x;
          this.y /= a.y;
          this.z /= a.z;
          return this;
        },
        divideScalar: function (a) {
          return this.multiplyScalar(1 / a);
        },
        min: function (a) {
          this.x = Math.min(this.x, a.x);
          this.y = Math.min(this.y, a.y);
          this.z = Math.min(this.z, a.z);
          return this;
        },
        max: function (a) {
          this.x = Math.max(this.x, a.x);
          this.y = Math.max(this.y, a.y);
          this.z = Math.max(this.z, a.z);
          return this;
        },
        clamp: function (a, b) {
          this.x = Math.max(a.x, Math.min(b.x, this.x));
          this.y = Math.max(a.y, Math.min(b.y, this.y));
          this.z = Math.max(a.z, Math.min(b.z, this.z));
          return this;
        },
        clampScalar: (function () {
          var a, b;
          return function (c, d) {
            void 0 === a &&
              ((a = new THREE.Vector3()), (b = new THREE.Vector3()));
            a.set(c, c, c);
            b.set(d, d, d);
            return this.clamp(a, b);
          };
        })(),
        clampLength: function (a, b) {
          var c = this.length();
          this.multiplyScalar(Math.max(a, Math.min(b, c)) / c);
          return this;
        },
        floor: function () {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          return this;
        },
        ceil: function () {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          return this;
        },
        round: function () {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          return this;
        },
        roundToZero: function () {
          this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
          return this;
        },
        negate: function () {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        },
        dot: function (a) {
          return this.x * a.x + this.y * a.y + this.z * a.z;
        },
        lengthSq: function () {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        lengthManhattan: function () {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function () {
          return this.divideScalar(this.length());
        },
        setLength: function (a) {
          return this.multiplyScalar(a / this.length());
        },
        lerp: function (a, b) {
          this.x += (a.x - this.x) * b;
          this.y += (a.y - this.y) * b;
          this.z += (a.z - this.z) * b;
          return this;
        },
        lerpVectors: function (a, b, c) {
          this.subVectors(b, a).multiplyScalar(c).add(a);
          return this;
        },
        cross: function (a, b) {
          if (void 0 !== b)
            return (
              console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(a, b)
            );
          var c = this.x,
            d = this.y,
            e = this.z;
          this.x = d * a.z - e * a.y;
          this.y = e * a.x - c * a.z;
          this.z = c * a.y - d * a.x;
          return this;
        },
        crossVectors: function (a, b) {
          var c = a.x,
            d = a.y,
            e = a.z,
            f = b.x,
            g = b.y,
            h = b.z;
          this.x = d * h - e * g;
          this.y = e * f - c * h;
          this.z = c * g - d * f;
          return this;
        },
        projectOnVector: (function () {
          var a, b;
          return function (c) {
            void 0 === a && (a = new THREE.Vector3());
            a.copy(c).normalize();
            b = this.dot(a);
            return this.copy(a).multiplyScalar(b);
          };
        })(),
        projectOnPlane: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Vector3());
            a.copy(this).projectOnVector(b);
            return this.sub(a);
          };
        })(),
        reflect: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Vector3());
            return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));
          };
        })(),
        angleTo: function (a) {
          a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());
          return Math.acos(THREE.Math.clamp(a, -1, 1));
        },
        distanceTo: function (a) {
          return Math.sqrt(this.distanceToSquared(a));
        },
        distanceToSquared: function (a) {
          var b = this.x - a.x,
            c = this.y - a.y;
          a = this.z - a.z;
          return b * b + c * c + a * a;
        },
        setFromMatrixPosition: function (a) {
          this.x = a.elements[12];
          this.y = a.elements[13];
          this.z = a.elements[14];
          return this;
        },
        setFromMatrixScale: function (a) {
          var b = this.set(
              a.elements[0],
              a.elements[1],
              a.elements[2]
            ).length(),
            c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
          a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
          this.x = b;
          this.y = c;
          this.z = a;
          return this;
        },
        setFromMatrixColumn: function (a, b) {
          var c = 4 * a,
            d = b.elements;
          this.x = d[c];
          this.y = d[c + 1];
          this.z = d[c + 2];
          return this;
        },
        equals: function (a) {
          return a.x === this.x && a.y === this.y && a.z === this.z;
        },
        fromArray: function (a, b) {
          void 0 === b && (b = 0);
          this.x = a[b];
          this.y = a[b + 1];
          this.z = a[b + 2];
          return this;
        },
        toArray: function (a, b) {
          void 0 === a && (a = []);
          void 0 === b && (b = 0);
          a[b] = this.x;
          a[b + 1] = this.y;
          a[b + 2] = this.z;
          return a;
        },
        fromAttribute: function (a, b, c) {
          void 0 === c && (c = 0);
          b = b * a.itemSize + c;
          this.x = a.array[b];
          this.y = a.array[b + 1];
          this.z = a.array[b + 2];
          return this;
        },
      };
      THREE.Vector4 = function (a, b, c, d) {
        this.x = a || 0;
        this.y = b || 0;
        this.z = c || 0;
        this.w = void 0 !== d ? d : 1;
      };
      THREE.Vector4.prototype = {
        constructor: THREE.Vector4,
        set: function (a, b, c, d) {
          this.x = a;
          this.y = b;
          this.z = c;
          this.w = d;
          return this;
        },
        setScalar: function (a) {
          this.w = this.z = this.y = this.x = a;
          return this;
        },
        setX: function (a) {
          this.x = a;
          return this;
        },
        setY: function (a) {
          this.y = a;
          return this;
        },
        setZ: function (a) {
          this.z = a;
          return this;
        },
        setW: function (a) {
          this.w = a;
          return this;
        },
        setComponent: function (a, b) {
          switch (a) {
            case 0:
              this.x = b;
              break;
            case 1:
              this.y = b;
              break;
            case 2:
              this.z = b;
              break;
            case 3:
              this.w = b;
              break;
            default:
              throw Error("index is out of range: " + a);
          }
        },
        getComponent: function (a) {
          switch (a) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw Error("index is out of range: " + a);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function (a) {
          this.x = a.x;
          this.y = a.y;
          this.z = a.z;
          this.w = void 0 !== a.w ? a.w : 1;
          return this;
        },
        add: function (a, b) {
          if (void 0 !== b)
            return (
              console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(a, b)
            );
          this.x += a.x;
          this.y += a.y;
          this.z += a.z;
          this.w += a.w;
          return this;
        },
        addScalar: function (a) {
          this.x += a;
          this.y += a;
          this.z += a;
          this.w += a;
          return this;
        },
        addVectors: function (a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          this.w = a.w + b.w;
          return this;
        },
        addScaledVector: function (a, b) {
          this.x += a.x * b;
          this.y += a.y * b;
          this.z += a.z * b;
          this.w += a.w * b;
          return this;
        },
        sub: function (a, b) {
          if (void 0 !== b)
            return (
              console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(a, b)
            );
          this.x -= a.x;
          this.y -= a.y;
          this.z -= a.z;
          this.w -= a.w;
          return this;
        },
        subScalar: function (a) {
          this.x -= a;
          this.y -= a;
          this.z -= a;
          this.w -= a;
          return this;
        },
        subVectors: function (a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          this.w = a.w - b.w;
          return this;
        },
        multiplyScalar: function (a) {
          isFinite(a)
            ? ((this.x *= a), (this.y *= a), (this.z *= a), (this.w *= a))
            : (this.w = this.z = this.y = this.x = 0);
          return this;
        },
        applyMatrix4: function (a) {
          var b = this.x,
            c = this.y,
            d = this.z,
            e = this.w;
          a = a.elements;
          this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
          this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
          this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
          this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
          return this;
        },
        divideScalar: function (a) {
          return this.multiplyScalar(1 / a);
        },
        setAxisAngleFromQuaternion: function (a) {
          this.w = 2 * Math.acos(a.w);
          var b = Math.sqrt(1 - a.w * a.w);
          1e-4 > b
            ? ((this.x = 1), (this.z = this.y = 0))
            : ((this.x = a.x / b), (this.y = a.y / b), (this.z = a.z / b));
          return this;
        },
        setAxisAngleFromRotationMatrix: function (a) {
          var b, c, d;
          a = a.elements;
          var e = a[0];
          d = a[4];
          var f = a[8],
            g = a[1],
            h = a[5],
            k = a[9];
          c = a[2];
          b = a[6];
          var l = a[10];
          if (
            0.01 > Math.abs(d - g) &&
            0.01 > Math.abs(f - c) &&
            0.01 > Math.abs(k - b)
          ) {
            if (
              0.1 > Math.abs(d + g) &&
              0.1 > Math.abs(f + c) &&
              0.1 > Math.abs(k + b) &&
              0.1 > Math.abs(e + h + l - 3)
            )
              return this.set(1, 0, 0, 0), this;
            a = Math.PI;
            e = (e + 1) / 2;
            h = (h + 1) / 2;
            l = (l + 1) / 2;
            d = (d + g) / 4;
            f = (f + c) / 4;
            k = (k + b) / 4;
            e > h && e > l
              ? 0.01 > e
                ? ((b = 0), (d = c = 0.707106781))
                : ((b = Math.sqrt(e)), (c = d / b), (d = f / b))
              : h > l
              ? 0.01 > h
                ? ((b = 0.707106781), (c = 0), (d = 0.707106781))
                : ((c = Math.sqrt(h)), (b = d / c), (d = k / c))
              : 0.01 > l
              ? ((c = b = 0.707106781), (d = 0))
              : ((d = Math.sqrt(l)), (b = f / d), (c = k / d));
            this.set(b, c, d, a);
            return this;
          }
          a = Math.sqrt(
            (b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d)
          );
          0.001 > Math.abs(a) && (a = 1);
          this.x = (b - k) / a;
          this.y = (f - c) / a;
          this.z = (g - d) / a;
          this.w = Math.acos((e + h + l - 1) / 2);
          return this;
        },
        min: function (a) {
          this.x = Math.min(this.x, a.x);
          this.y = Math.min(this.y, a.y);
          this.z = Math.min(this.z, a.z);
          this.w = Math.min(this.w, a.w);
          return this;
        },
        max: function (a) {
          this.x = Math.max(this.x, a.x);
          this.y = Math.max(this.y, a.y);
          this.z = Math.max(this.z, a.z);
          this.w = Math.max(this.w, a.w);
          return this;
        },
        clamp: function (a, b) {
          this.x = Math.max(a.x, Math.min(b.x, this.x));
          this.y = Math.max(a.y, Math.min(b.y, this.y));
          this.z = Math.max(a.z, Math.min(b.z, this.z));
          this.w = Math.max(a.w, Math.min(b.w, this.w));
          return this;
        },
        clampScalar: (function () {
          var a, b;
          return function (c, d) {
            void 0 === a &&
              ((a = new THREE.Vector4()), (b = new THREE.Vector4()));
            a.set(c, c, c, c);
            b.set(d, d, d, d);
            return this.clamp(a, b);
          };
        })(),
        floor: function () {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);
          return this;
        },
        ceil: function () {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);
          return this;
        },
        round: function () {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);
          return this;
        },
        roundToZero: function () {
          this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
          this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
          return this;
        },
        negate: function () {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        },
        dot: function (a) {
          return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
        },
        lengthSq: function () {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        },
        length: function () {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        },
        lengthManhattan: function () {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        },
        normalize: function () {
          return this.divideScalar(this.length());
        },
        setLength: function (a) {
          return this.multiplyScalar(a / this.length());
        },
        lerp: function (a, b) {
          this.x += (a.x - this.x) * b;
          this.y += (a.y - this.y) * b;
          this.z += (a.z - this.z) * b;
          this.w += (a.w - this.w) * b;
          return this;
        },
        lerpVectors: function (a, b, c) {
          this.subVectors(b, a).multiplyScalar(c).add(a);
          return this;
        },
        equals: function (a) {
          return (
            a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
          );
        },
        fromArray: function (a, b) {
          void 0 === b && (b = 0);
          this.x = a[b];
          this.y = a[b + 1];
          this.z = a[b + 2];
          this.w = a[b + 3];
          return this;
        },
        toArray: function (a, b) {
          void 0 === a && (a = []);
          void 0 === b && (b = 0);
          a[b] = this.x;
          a[b + 1] = this.y;
          a[b + 2] = this.z;
          a[b + 3] = this.w;
          return a;
        },
        fromAttribute: function (a, b, c) {
          void 0 === c && (c = 0);
          b = b * a.itemSize + c;
          this.x = a.array[b];
          this.y = a.array[b + 1];
          this.z = a.array[b + 2];
          this.w = a.array[b + 3];
          return this;
        },
      };
      THREE.Euler = function (a, b, c, d) {
        this._x = a || 0;
        this._y = b || 0;
        this._z = c || 0;
        this._order = d || THREE.Euler.DefaultOrder;
      };
      THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
      THREE.Euler.DefaultOrder = "XYZ";
      THREE.Euler.prototype = {
        constructor: THREE.Euler,
        get x() {
          return this._x;
        },
        set x(a) {
          this._x = a;
          this.onChangeCallback();
        },
        get y() {
          return this._y;
        },
        set y(a) {
          this._y = a;
          this.onChangeCallback();
        },
        get z() {
          return this._z;
        },
        set z(a) {
          this._z = a;
          this.onChangeCallback();
        },
        get order() {
          return this._order;
        },
        set order(a) {
          this._order = a;
          this.onChangeCallback();
        },
        set: function (a, b, c, d) {
          this._x = a;
          this._y = b;
          this._z = c;
          this._order = d || this._order;
          this.onChangeCallback();
          return this;
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function (a) {
          this._x = a._x;
          this._y = a._y;
          this._z = a._z;
          this._order = a._order;
          this.onChangeCallback();
          return this;
        },
        setFromRotationMatrix: function (a, b, c) {
          var d = THREE.Math.clamp,
            e = a.elements;
          a = e[0];
          var f = e[4],
            g = e[8],
            h = e[1],
            k = e[5],
            l = e[9],
            n = e[2],
            p = e[6],
            e = e[10];
          b = b || this._order;
          "XYZ" === b
            ? ((this._y = Math.asin(d(g, -1, 1))),
              0.99999 > Math.abs(g)
                ? ((this._x = Math.atan2(-l, e)), (this._z = Math.atan2(-f, a)))
                : ((this._x = Math.atan2(p, k)), (this._z = 0)))
            : "YXZ" === b
            ? ((this._x = Math.asin(-d(l, -1, 1))),
              0.99999 > Math.abs(l)
                ? ((this._y = Math.atan2(g, e)), (this._z = Math.atan2(h, k)))
                : ((this._y = Math.atan2(-n, a)), (this._z = 0)))
            : "ZXY" === b
            ? ((this._x = Math.asin(d(p, -1, 1))),
              0.99999 > Math.abs(p)
                ? ((this._y = Math.atan2(-n, e)), (this._z = Math.atan2(-f, k)))
                : ((this._y = 0), (this._z = Math.atan2(h, a))))
            : "ZYX" === b
            ? ((this._y = Math.asin(-d(n, -1, 1))),
              0.99999 > Math.abs(n)
                ? ((this._x = Math.atan2(p, e)), (this._z = Math.atan2(h, a)))
                : ((this._x = 0), (this._z = Math.atan2(-f, k))))
            : "YZX" === b
            ? ((this._z = Math.asin(d(h, -1, 1))),
              0.99999 > Math.abs(h)
                ? ((this._x = Math.atan2(-l, k)), (this._y = Math.atan2(-n, a)))
                : ((this._x = 0), (this._y = Math.atan2(g, e))))
            : "XZY" === b
            ? ((this._z = Math.asin(-d(f, -1, 1))),
              0.99999 > Math.abs(f)
                ? ((this._x = Math.atan2(p, k)), (this._y = Math.atan2(g, a)))
                : ((this._x = Math.atan2(-l, e)), (this._y = 0)))
            : console.warn(
                "THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
                  b
              );
          this._order = b;
          if (!1 !== c) this.onChangeCallback();
          return this;
        },
        setFromQuaternion: (function () {
          var a;
          return function (b, c, d) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeRotationFromQuaternion(b);
            this.setFromRotationMatrix(a, c, d);
            return this;
          };
        })(),
        setFromVector3: function (a, b) {
          return this.set(a.x, a.y, a.z, b || this._order);
        },
        reorder: (function () {
          var a = new THREE.Quaternion();
          return function (b) {
            a.setFromEuler(this);
            this.setFromQuaternion(a, b);
          };
        })(),
        equals: function (a) {
          return (
            a._x === this._x &&
            a._y === this._y &&
            a._z === this._z &&
            a._order === this._order
          );
        },
        fromArray: function (a) {
          this._x = a[0];
          this._y = a[1];
          this._z = a[2];
          void 0 !== a[3] && (this._order = a[3]);
          this.onChangeCallback();
          return this;
        },
        toArray: function (a, b) {
          void 0 === a && (a = []);
          void 0 === b && (b = 0);
          a[b] = this._x;
          a[b + 1] = this._y;
          a[b + 2] = this._z;
          a[b + 3] = this._order;
          return a;
        },
        toVector3: function (a) {
          return a
            ? a.set(this._x, this._y, this._z)
            : new THREE.Vector3(this._x, this._y, this._z);
        },
        onChange: function (a) {
          this.onChangeCallback = a;
          return this;
        },
        onChangeCallback: function () {},
      };
      THREE.Line3 = function (a, b) {
        this.start = void 0 !== a ? a : new THREE.Vector3();
        this.end = void 0 !== b ? b : new THREE.Vector3();
      };
      THREE.Line3.prototype = {
        constructor: THREE.Line3,
        set: function (a, b) {
          this.start.copy(a);
          this.end.copy(b);
          return this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.start.copy(a.start);
          this.end.copy(a.end);
          return this;
        },
        center: function (a) {
          return (a || new THREE.Vector3())
            .addVectors(this.start, this.end)
            .multiplyScalar(0.5);
        },
        delta: function (a) {
          return (a || new THREE.Vector3()).subVectors(this.end, this.start);
        },
        distanceSq: function () {
          return this.start.distanceToSquared(this.end);
        },
        distance: function () {
          return this.start.distanceTo(this.end);
        },
        at: function (a, b) {
          var c = b || new THREE.Vector3();
          return this.delta(c).multiplyScalar(a).add(this.start);
        },
        closestPointToPointParameter: (function () {
          var a = new THREE.Vector3(),
            b = new THREE.Vector3();
          return function (c, d) {
            a.subVectors(c, this.start);
            b.subVectors(this.end, this.start);
            var e = b.dot(b),
              e = b.dot(a) / e;
            d && (e = THREE.Math.clamp(e, 0, 1));
            return e;
          };
        })(),
        closestPointToPoint: function (a, b, c) {
          a = this.closestPointToPointParameter(a, b);
          c = c || new THREE.Vector3();
          return this.delta(c).multiplyScalar(a).add(this.start);
        },
        applyMatrix4: function (a) {
          this.start.applyMatrix4(a);
          this.end.applyMatrix4(a);
          return this;
        },
        equals: function (a) {
          return a.start.equals(this.start) && a.end.equals(this.end);
        },
      };
      THREE.Box2 = function (a, b) {
        this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
        this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity);
      };
      THREE.Box2.prototype = {
        constructor: THREE.Box2,
        set: function (a, b) {
          this.min.copy(a);
          this.max.copy(b);
          return this;
        },
        setFromPoints: function (a) {
          this.makeEmpty();
          for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
          return this;
        },
        setFromCenterAndSize: (function () {
          var a = new THREE.Vector2();
          return function (b, c) {
            var d = a.copy(c).multiplyScalar(0.5);
            this.min.copy(b).sub(d);
            this.max.copy(b).add(d);
            return this;
          };
        })(),
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.min.copy(a.min);
          this.max.copy(a.max);
          return this;
        },
        makeEmpty: function () {
          this.min.x = this.min.y = Infinity;
          this.max.x = this.max.y = -Infinity;
          return this;
        },
        isEmpty: function () {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        },
        center: function (a) {
          return (a || new THREE.Vector2())
            .addVectors(this.min, this.max)
            .multiplyScalar(0.5);
        },
        size: function (a) {
          return (a || new THREE.Vector2()).subVectors(this.max, this.min);
        },
        expandByPoint: function (a) {
          this.min.min(a);
          this.max.max(a);
          return this;
        },
        expandByVector: function (a) {
          this.min.sub(a);
          this.max.add(a);
          return this;
        },
        expandByScalar: function (a) {
          this.min.addScalar(-a);
          this.max.addScalar(a);
          return this;
        },
        containsPoint: function (a) {
          return a.x < this.min.x ||
            a.x > this.max.x ||
            a.y < this.min.y ||
            a.y > this.max.y
            ? !1
            : !0;
        },
        containsBox: function (a) {
          return this.min.x <= a.min.x &&
            a.max.x <= this.max.x &&
            this.min.y <= a.min.y &&
            a.max.y <= this.max.y
            ? !0
            : !1;
        },
        getParameter: function (a, b) {
          return (b || new THREE.Vector2()).set(
            (a.x - this.min.x) / (this.max.x - this.min.x),
            (a.y - this.min.y) / (this.max.y - this.min.y)
          );
        },
        intersectsBox: function (a) {
          return a.max.x < this.min.x ||
            a.min.x > this.max.x ||
            a.max.y < this.min.y ||
            a.min.y > this.max.y
            ? !1
            : !0;
        },
        clampPoint: function (a, b) {
          return (b || new THREE.Vector2()).copy(a).clamp(this.min, this.max);
        },
        distanceToPoint: (function () {
          var a = new THREE.Vector2();
          return function (b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length();
          };
        })(),
        intersect: function (a) {
          this.min.max(a.min);
          this.max.min(a.max);
          return this;
        },
        union: function (a) {
          this.min.min(a.min);
          this.max.max(a.max);
          return this;
        },
        translate: function (a) {
          this.min.add(a);
          this.max.add(a);
          return this;
        },
        equals: function (a) {
          return a.min.equals(this.min) && a.max.equals(this.max);
        },
      };
      THREE.Box3 = function (a, b) {
        this.min =
          void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
        this.max =
          void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
      };
      THREE.Box3.prototype = {
        constructor: THREE.Box3,
        set: function (a, b) {
          this.min.copy(a);
          this.max.copy(b);
          return this;
        },
        setFromArray: function (a) {
          this.makeEmpty();
          for (
            var b = Infinity,
              c = Infinity,
              d = Infinity,
              e = -Infinity,
              f = -Infinity,
              g = -Infinity,
              h = 0,
              k = a.length;
            h < k;
            h += 3
          ) {
            var l = a[h],
              n = a[h + 1],
              p = a[h + 2];
            l < b && (b = l);
            n < c && (c = n);
            p < d && (d = p);
            l > e && (e = l);
            n > f && (f = n);
            p > g && (g = p);
          }
          this.min.set(b, c, d);
          this.max.set(e, f, g);
        },
        setFromPoints: function (a) {
          this.makeEmpty();
          for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
          return this;
        },
        setFromCenterAndSize: (function () {
          var a = new THREE.Vector3();
          return function (b, c) {
            var d = a.copy(c).multiplyScalar(0.5);
            this.min.copy(b).sub(d);
            this.max.copy(b).add(d);
            return this;
          };
        })(),
        setFromObject: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Box3());
            var c = this;
            this.makeEmpty();
            b.updateMatrixWorld(!0);
            b.traverse(function (b) {
              var e = b.geometry;
              void 0 !== e &&
                (null === e.boundingBox && e.computeBoundingBox(),
                a.copy(e.boundingBox),
                a.applyMatrix4(b.matrixWorld),
                c.union(a));
            });
            return this;
          };
        })(),
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.min.copy(a.min);
          this.max.copy(a.max);
          return this;
        },
        makeEmpty: function () {
          this.min.x = this.min.y = this.min.z = Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;
          return this;
        },
        isEmpty: function () {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        },
        center: function (a) {
          return (a || new THREE.Vector3())
            .addVectors(this.min, this.max)
            .multiplyScalar(0.5);
        },
        size: function (a) {
          return (a || new THREE.Vector3()).subVectors(this.max, this.min);
        },
        expandByPoint: function (a) {
          this.min.min(a);
          this.max.max(a);
          return this;
        },
        expandByVector: function (a) {
          this.min.sub(a);
          this.max.add(a);
          return this;
        },
        expandByScalar: function (a) {
          this.min.addScalar(-a);
          this.max.addScalar(a);
          return this;
        },
        containsPoint: function (a) {
          return a.x < this.min.x ||
            a.x > this.max.x ||
            a.y < this.min.y ||
            a.y > this.max.y ||
            a.z < this.min.z ||
            a.z > this.max.z
            ? !1
            : !0;
        },
        containsBox: function (a) {
          return this.min.x <= a.min.x &&
            a.max.x <= this.max.x &&
            this.min.y <= a.min.y &&
            a.max.y <= this.max.y &&
            this.min.z <= a.min.z &&
            a.max.z <= this.max.z
            ? !0
            : !1;
        },
        getParameter: function (a, b) {
          return (b || new THREE.Vector3()).set(
            (a.x - this.min.x) / (this.max.x - this.min.x),
            (a.y - this.min.y) / (this.max.y - this.min.y),
            (a.z - this.min.z) / (this.max.z - this.min.z)
          );
        },
        intersectsBox: function (a) {
          return a.max.x < this.min.x ||
            a.min.x > this.max.x ||
            a.max.y < this.min.y ||
            a.min.y > this.max.y ||
            a.max.z < this.min.z ||
            a.min.z > this.max.z
            ? !1
            : !0;
        },
        intersectsSphere: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Vector3());
            this.clampPoint(b.center, a);
            return a.distanceToSquared(b.center) <= b.radius * b.radius;
          };
        })(),
        intersectsPlane: function (a) {
          var b, c;
          0 < a.normal.x
            ? ((b = a.normal.x * this.min.x), (c = a.normal.x * this.max.x))
            : ((b = a.normal.x * this.max.x), (c = a.normal.x * this.min.x));
          0 < a.normal.y
            ? ((b += a.normal.y * this.min.y), (c += a.normal.y * this.max.y))
            : ((b += a.normal.y * this.max.y), (c += a.normal.y * this.min.y));
          0 < a.normal.z
            ? ((b += a.normal.z * this.min.z), (c += a.normal.z * this.max.z))
            : ((b += a.normal.z * this.max.z), (c += a.normal.z * this.min.z));
          return b <= a.constant && c >= a.constant;
        },
        clampPoint: function (a, b) {
          return (b || new THREE.Vector3()).copy(a).clamp(this.min, this.max);
        },
        distanceToPoint: (function () {
          var a = new THREE.Vector3();
          return function (b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length();
          };
        })(),
        getBoundingSphere: (function () {
          var a = new THREE.Vector3();
          return function (b) {
            b = b || new THREE.Sphere();
            b.center = this.center();
            b.radius = 0.5 * this.size(a).length();
            return b;
          };
        })(),
        intersect: function (a) {
          this.min.max(a.min);
          this.max.min(a.max);
          return this;
        },
        union: function (a) {
          this.min.min(a.min);
          this.max.max(a.max);
          return this;
        },
        applyMatrix4: (function () {
          var a = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
          ];
          return function (b) {
            a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
            a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
            a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
            a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
            a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
            a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
            a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
            a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
            this.makeEmpty();
            this.setFromPoints(a);
            return this;
          };
        })(),
        translate: function (a) {
          this.min.add(a);
          this.max.add(a);
          return this;
        },
        equals: function (a) {
          return a.min.equals(this.min) && a.max.equals(this.max);
        },
      };
      THREE.Matrix3 = function () {
        this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        0 < arguments.length &&
          console.error(
            "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
          );
      };
      THREE.Matrix3.prototype = {
        constructor: THREE.Matrix3,
        set: function (a, b, c, d, e, f, g, h, k) {
          var l = this.elements;
          l[0] = a;
          l[3] = b;
          l[6] = c;
          l[1] = d;
          l[4] = e;
          l[7] = f;
          l[2] = g;
          l[5] = h;
          l[8] = k;
          return this;
        },
        identity: function () {
          this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
          return this;
        },
        clone: function () {
          return new this.constructor().fromArray(this.elements);
        },
        copy: function (a) {
          a = a.elements;
          this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
          return this;
        },
        applyToVector3Array: (function () {
          var a;
          return function (b, c, d) {
            void 0 === a && (a = new THREE.Vector3());
            void 0 === c && (c = 0);
            void 0 === d && (d = b.length);
            for (var e = 0; e < d; e += 3, c += 3)
              a.fromArray(b, c), a.applyMatrix3(this), a.toArray(b, c);
            return b;
          };
        })(),
        applyToBuffer: (function () {
          var a;
          return function (b, c, d) {
            void 0 === a && (a = new THREE.Vector3());
            void 0 === c && (c = 0);
            void 0 === d && (d = b.length / b.itemSize);
            for (var e = 0; e < d; e++, c++)
              (a.x = b.getX(c)),
                (a.y = b.getY(c)),
                (a.z = b.getZ(c)),
                a.applyMatrix3(this),
                b.setXYZ(a.x, a.y, a.z);
            return b;
          };
        })(),
        multiplyScalar: function (a) {
          var b = this.elements;
          b[0] *= a;
          b[3] *= a;
          b[6] *= a;
          b[1] *= a;
          b[4] *= a;
          b[7] *= a;
          b[2] *= a;
          b[5] *= a;
          b[8] *= a;
          return this;
        },
        determinant: function () {
          var a = this.elements,
            b = a[0],
            c = a[1],
            d = a[2],
            e = a[3],
            f = a[4],
            g = a[5],
            h = a[6],
            k = a[7],
            a = a[8];
          return (
            b * f * a -
            b * g * k -
            c * e * a +
            c * g * h +
            d * e * k -
            d * f * h
          );
        },
        getInverse: function (a, b) {
          var c = a.elements,
            d = this.elements;
          d[0] = c[10] * c[5] - c[6] * c[9];
          d[1] = -c[10] * c[1] + c[2] * c[9];
          d[2] = c[6] * c[1] - c[2] * c[5];
          d[3] = -c[10] * c[4] + c[6] * c[8];
          d[4] = c[10] * c[0] - c[2] * c[8];
          d[5] = -c[6] * c[0] + c[2] * c[4];
          d[6] = c[9] * c[4] - c[5] * c[8];
          d[7] = -c[9] * c[0] + c[1] * c[8];
          d[8] = c[5] * c[0] - c[1] * c[4];
          c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
          if (0 === c) {
            if (b)
              throw Error(
                "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"
              );
            console.warn(
              "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"
            );
            this.identity();
            return this;
          }
          this.multiplyScalar(1 / c);
          return this;
        },
        transpose: function () {
          var a,
            b = this.elements;
          a = b[1];
          b[1] = b[3];
          b[3] = a;
          a = b[2];
          b[2] = b[6];
          b[6] = a;
          a = b[5];
          b[5] = b[7];
          b[7] = a;
          return this;
        },
        flattenToArrayOffset: function (a, b) {
          var c = this.elements;
          a[b] = c[0];
          a[b + 1] = c[1];
          a[b + 2] = c[2];
          a[b + 3] = c[3];
          a[b + 4] = c[4];
          a[b + 5] = c[5];
          a[b + 6] = c[6];
          a[b + 7] = c[7];
          a[b + 8] = c[8];
          return a;
        },
        getNormalMatrix: function (a) {
          this.getInverse(a).transpose();
          return this;
        },
        transposeIntoArray: function (a) {
          var b = this.elements;
          a[0] = b[0];
          a[1] = b[3];
          a[2] = b[6];
          a[3] = b[1];
          a[4] = b[4];
          a[5] = b[7];
          a[6] = b[2];
          a[7] = b[5];
          a[8] = b[8];
          return this;
        },
        fromArray: function (a) {
          this.elements.set(a);
          return this;
        },
        toArray: function () {
          var a = this.elements;
          return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]];
        },
      };
      THREE.Matrix4 = function () {
        this.elements = new Float32Array([
          1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        ]);
        0 < arguments.length &&
          console.error(
            "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
          );
      };
      THREE.Matrix4.prototype = {
        constructor: THREE.Matrix4,
        set: function (a, b, c, d, e, f, g, h, k, l, n, p, m, q, s, u) {
          var t = this.elements;
          t[0] = a;
          t[4] = b;
          t[8] = c;
          t[12] = d;
          t[1] = e;
          t[5] = f;
          t[9] = g;
          t[13] = h;
          t[2] = k;
          t[6] = l;
          t[10] = n;
          t[14] = p;
          t[3] = m;
          t[7] = q;
          t[11] = s;
          t[15] = u;
          return this;
        },
        identity: function () {
          this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        },
        clone: function () {
          return new THREE.Matrix4().fromArray(this.elements);
        },
        copy: function (a) {
          this.elements.set(a.elements);
          return this;
        },
        copyPosition: function (a) {
          var b = this.elements;
          a = a.elements;
          b[12] = a[12];
          b[13] = a[13];
          b[14] = a[14];
          return this;
        },
        extractBasis: function (a, b, c) {
          var d = this.elements;
          a.set(d[0], d[1], d[2]);
          b.set(d[4], d[5], d[6]);
          c.set(d[8], d[9], d[10]);
          return this;
        },
        makeBasis: function (a, b, c) {
          this.set(
            a.x,
            b.x,
            c.x,
            0,
            a.y,
            b.y,
            c.y,
            0,
            a.z,
            b.z,
            c.z,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        },
        extractRotation: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Vector3());
            var c = this.elements;
            b = b.elements;
            var d = 1 / a.set(b[0], b[1], b[2]).length(),
              e = 1 / a.set(b[4], b[5], b[6]).length(),
              f = 1 / a.set(b[8], b[9], b[10]).length();
            c[0] = b[0] * d;
            c[1] = b[1] * d;
            c[2] = b[2] * d;
            c[4] = b[4] * e;
            c[5] = b[5] * e;
            c[6] = b[6] * e;
            c[8] = b[8] * f;
            c[9] = b[9] * f;
            c[10] = b[10] * f;
            return this;
          };
        })(),
        makeRotationFromEuler: function (a) {
          !1 === a instanceof THREE.Euler &&
            console.error(
              "THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z,
            f = Math.cos(c),
            c = Math.sin(c),
            g = Math.cos(d),
            d = Math.sin(d),
            h = Math.cos(e),
            e = Math.sin(e);
          if ("XYZ" === a.order) {
            a = f * h;
            var k = f * e,
              l = c * h,
              n = c * e;
            b[0] = g * h;
            b[4] = -g * e;
            b[8] = d;
            b[1] = k + l * d;
            b[5] = a - n * d;
            b[9] = -c * g;
            b[2] = n - a * d;
            b[6] = l + k * d;
            b[10] = f * g;
          } else
            "YXZ" === a.order
              ? ((a = g * h),
                (k = g * e),
                (l = d * h),
                (n = d * e),
                (b[0] = a + n * c),
                (b[4] = l * c - k),
                (b[8] = f * d),
                (b[1] = f * e),
                (b[5] = f * h),
                (b[9] = -c),
                (b[2] = k * c - l),
                (b[6] = n + a * c),
                (b[10] = f * g))
              : "ZXY" === a.order
              ? ((a = g * h),
                (k = g * e),
                (l = d * h),
                (n = d * e),
                (b[0] = a - n * c),
                (b[4] = -f * e),
                (b[8] = l + k * c),
                (b[1] = k + l * c),
                (b[5] = f * h),
                (b[9] = n - a * c),
                (b[2] = -f * d),
                (b[6] = c),
                (b[10] = f * g))
              : "ZYX" === a.order
              ? ((a = f * h),
                (k = f * e),
                (l = c * h),
                (n = c * e),
                (b[0] = g * h),
                (b[4] = l * d - k),
                (b[8] = a * d + n),
                (b[1] = g * e),
                (b[5] = n * d + a),
                (b[9] = k * d - l),
                (b[2] = -d),
                (b[6] = c * g),
                (b[10] = f * g))
              : "YZX" === a.order
              ? ((a = f * g),
                (k = f * d),
                (l = c * g),
                (n = c * d),
                (b[0] = g * h),
                (b[4] = n - a * e),
                (b[8] = l * e + k),
                (b[1] = e),
                (b[5] = f * h),
                (b[9] = -c * h),
                (b[2] = -d * h),
                (b[6] = k * e + l),
                (b[10] = a - n * e))
              : "XZY" === a.order &&
                ((a = f * g),
                (k = f * d),
                (l = c * g),
                (n = c * d),
                (b[0] = g * h),
                (b[4] = -e),
                (b[8] = d * h),
                (b[1] = a * e + n),
                (b[5] = f * h),
                (b[9] = k * e - l),
                (b[2] = l * e - k),
                (b[6] = c * h),
                (b[10] = n * e + a));
          b[3] = 0;
          b[7] = 0;
          b[11] = 0;
          b[12] = 0;
          b[13] = 0;
          b[14] = 0;
          b[15] = 1;
          return this;
        },
        makeRotationFromQuaternion: function (a) {
          var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z,
            f = a.w,
            g = c + c,
            h = d + d,
            k = e + e;
          a = c * g;
          var l = c * h,
            c = c * k,
            n = d * h,
            d = d * k,
            e = e * k,
            g = f * g,
            h = f * h,
            f = f * k;
          b[0] = 1 - (n + e);
          b[4] = l - f;
          b[8] = c + h;
          b[1] = l + f;
          b[5] = 1 - (a + e);
          b[9] = d - g;
          b[2] = c - h;
          b[6] = d + g;
          b[10] = 1 - (a + n);
          b[3] = 0;
          b[7] = 0;
          b[11] = 0;
          b[12] = 0;
          b[13] = 0;
          b[14] = 0;
          b[15] = 1;
          return this;
        },
        lookAt: (function () {
          var a, b, c;
          return function (d, e, f) {
            void 0 === a && (a = new THREE.Vector3());
            void 0 === b && (b = new THREE.Vector3());
            void 0 === c && (c = new THREE.Vector3());
            var g = this.elements;
            c.subVectors(d, e).normalize();
            0 === c.lengthSq() && (c.z = 1);
            a.crossVectors(f, c).normalize();
            0 === a.lengthSq() &&
              ((c.x += 1e-4), a.crossVectors(f, c).normalize());
            b.crossVectors(c, a);
            g[0] = a.x;
            g[4] = b.x;
            g[8] = c.x;
            g[1] = a.y;
            g[5] = b.y;
            g[9] = c.y;
            g[2] = a.z;
            g[6] = b.z;
            g[10] = c.z;
            return this;
          };
        })(),
        multiply: function (a, b) {
          return void 0 !== b
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(a, b))
            : this.multiplyMatrices(this, a);
        },
        multiplyMatrices: function (a, b) {
          var c = a.elements,
            d = b.elements,
            e = this.elements,
            f = c[0],
            g = c[4],
            h = c[8],
            k = c[12],
            l = c[1],
            n = c[5],
            p = c[9],
            m = c[13],
            q = c[2],
            s = c[6],
            u = c[10],
            t = c[14],
            x = c[3],
            v = c[7],
            C = c[11],
            c = c[15],
            w = d[0],
            D = d[4],
            z = d[8],
            y = d[12],
            A = d[1],
            H = d[5],
            G = d[9],
            E = d[13],
            K = d[2],
            P = d[6],
            N = d[10],
            L = d[14],
            B = d[3],
            M = d[7],
            Q = d[11],
            d = d[15];
          e[0] = f * w + g * A + h * K + k * B;
          e[4] = f * D + g * H + h * P + k * M;
          e[8] = f * z + g * G + h * N + k * Q;
          e[12] = f * y + g * E + h * L + k * d;
          e[1] = l * w + n * A + p * K + m * B;
          e[5] = l * D + n * H + p * P + m * M;
          e[9] = l * z + n * G + p * N + m * Q;
          e[13] = l * y + n * E + p * L + m * d;
          e[2] = q * w + s * A + u * K + t * B;
          e[6] = q * D + s * H + u * P + t * M;
          e[10] = q * z + s * G + u * N + t * Q;
          e[14] = q * y + s * E + u * L + t * d;
          e[3] = x * w + v * A + C * K + c * B;
          e[7] = x * D + v * H + C * P + c * M;
          e[11] = x * z + v * G + C * N + c * Q;
          e[15] = x * y + v * E + C * L + c * d;
          return this;
        },
        multiplyToArray: function (a, b, c) {
          var d = this.elements;
          this.multiplyMatrices(a, b);
          c[0] = d[0];
          c[1] = d[1];
          c[2] = d[2];
          c[3] = d[3];
          c[4] = d[4];
          c[5] = d[5];
          c[6] = d[6];
          c[7] = d[7];
          c[8] = d[8];
          c[9] = d[9];
          c[10] = d[10];
          c[11] = d[11];
          c[12] = d[12];
          c[13] = d[13];
          c[14] = d[14];
          c[15] = d[15];
          return this;
        },
        multiplyScalar: function (a) {
          var b = this.elements;
          b[0] *= a;
          b[4] *= a;
          b[8] *= a;
          b[12] *= a;
          b[1] *= a;
          b[5] *= a;
          b[9] *= a;
          b[13] *= a;
          b[2] *= a;
          b[6] *= a;
          b[10] *= a;
          b[14] *= a;
          b[3] *= a;
          b[7] *= a;
          b[11] *= a;
          b[15] *= a;
          return this;
        },
        applyToVector3Array: (function () {
          var a;
          return function (b, c, d) {
            void 0 === a && (a = new THREE.Vector3());
            void 0 === c && (c = 0);
            void 0 === d && (d = b.length);
            for (var e = 0; e < d; e += 3, c += 3)
              a.fromArray(b, c), a.applyMatrix4(this), a.toArray(b, c);
            return b;
          };
        })(),
        applyToBuffer: (function () {
          var a;
          return function (b, c, d) {
            void 0 === a && (a = new THREE.Vector3());
            void 0 === c && (c = 0);
            void 0 === d && (d = b.length / b.itemSize);
            for (var e = 0; e < d; e++, c++)
              (a.x = b.getX(c)),
                (a.y = b.getY(c)),
                (a.z = b.getZ(c)),
                a.applyMatrix4(this),
                b.setXYZ(a.x, a.y, a.z);
            return b;
          };
        })(),
        determinant: function () {
          var a = this.elements,
            b = a[0],
            c = a[4],
            d = a[8],
            e = a[12],
            f = a[1],
            g = a[5],
            h = a[9],
            k = a[13],
            l = a[2],
            n = a[6],
            p = a[10],
            m = a[14];
          return (
            a[3] *
              (+e * h * n -
                d * k * n -
                e * g * p +
                c * k * p +
                d * g * m -
                c * h * m) +
            a[7] *
              (+b * h * m -
                b * k * p +
                e * f * p -
                d * f * m +
                d * k * l -
                e * h * l) +
            a[11] *
              (+b * k * n -
                b * g * m -
                e * f * n +
                c * f * m +
                e * g * l -
                c * k * l) +
            a[15] *
              (-d * g * l -
                b * h * n +
                b * g * p +
                d * f * n -
                c * f * p +
                c * h * l)
          );
        },
        transpose: function () {
          var a = this.elements,
            b;
          b = a[1];
          a[1] = a[4];
          a[4] = b;
          b = a[2];
          a[2] = a[8];
          a[8] = b;
          b = a[6];
          a[6] = a[9];
          a[9] = b;
          b = a[3];
          a[3] = a[12];
          a[12] = b;
          b = a[7];
          a[7] = a[13];
          a[13] = b;
          b = a[11];
          a[11] = a[14];
          a[14] = b;
          return this;
        },
        flattenToArrayOffset: function (a, b) {
          var c = this.elements;
          a[b] = c[0];
          a[b + 1] = c[1];
          a[b + 2] = c[2];
          a[b + 3] = c[3];
          a[b + 4] = c[4];
          a[b + 5] = c[5];
          a[b + 6] = c[6];
          a[b + 7] = c[7];
          a[b + 8] = c[8];
          a[b + 9] = c[9];
          a[b + 10] = c[10];
          a[b + 11] = c[11];
          a[b + 12] = c[12];
          a[b + 13] = c[13];
          a[b + 14] = c[14];
          a[b + 15] = c[15];
          return a;
        },
        getPosition: (function () {
          var a;
          return function () {
            void 0 === a && (a = new THREE.Vector3());
            console.warn(
              "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
            );
            var b = this.elements;
            return a.set(b[12], b[13], b[14]);
          };
        })(),
        setPosition: function (a) {
          var b = this.elements;
          b[12] = a.x;
          b[13] = a.y;
          b[14] = a.z;
          return this;
        },
        getInverse: function (a, b) {
          var c = this.elements,
            d = a.elements,
            e = d[0],
            f = d[4],
            g = d[8],
            h = d[12],
            k = d[1],
            l = d[5],
            n = d[9],
            p = d[13],
            m = d[2],
            q = d[6],
            s = d[10],
            u = d[14],
            t = d[3],
            x = d[7],
            v = d[11],
            d = d[15];
          c[0] =
            n * u * x -
            p * s * x +
            p * q * v -
            l * u * v -
            n * q * d +
            l * s * d;
          c[4] =
            h * s * x -
            g * u * x -
            h * q * v +
            f * u * v +
            g * q * d -
            f * s * d;
          c[8] =
            g * p * x -
            h * n * x +
            h * l * v -
            f * p * v -
            g * l * d +
            f * n * d;
          c[12] =
            h * n * q -
            g * p * q -
            h * l * s +
            f * p * s +
            g * l * u -
            f * n * u;
          c[1] =
            p * s * t -
            n * u * t -
            p * m * v +
            k * u * v +
            n * m * d -
            k * s * d;
          c[5] =
            g * u * t -
            h * s * t +
            h * m * v -
            e * u * v -
            g * m * d +
            e * s * d;
          c[9] =
            h * n * t -
            g * p * t -
            h * k * v +
            e * p * v +
            g * k * d -
            e * n * d;
          c[13] =
            g * p * m -
            h * n * m +
            h * k * s -
            e * p * s -
            g * k * u +
            e * n * u;
          c[2] =
            l * u * t -
            p * q * t +
            p * m * x -
            k * u * x -
            l * m * d +
            k * q * d;
          c[6] =
            h * q * t -
            f * u * t -
            h * m * x +
            e * u * x +
            f * m * d -
            e * q * d;
          c[10] =
            f * p * t -
            h * l * t +
            h * k * x -
            e * p * x -
            f * k * d +
            e * l * d;
          c[14] =
            h * l * m -
            f * p * m -
            h * k * q +
            e * p * q +
            f * k * u -
            e * l * u;
          c[3] =
            n * q * t -
            l * s * t -
            n * m * x +
            k * s * x +
            l * m * v -
            k * q * v;
          c[7] =
            f * s * t -
            g * q * t +
            g * m * x -
            e * s * x -
            f * m * v +
            e * q * v;
          c[11] =
            g * l * t -
            f * n * t -
            g * k * x +
            e * n * x +
            f * k * v -
            e * l * v;
          c[15] =
            f * n * m -
            g * l * m +
            g * k * q -
            e * n * q -
            f * k * s +
            e * l * s;
          c = e * c[0] + k * c[4] + m * c[8] + t * c[12];
          if (0 === c) {
            if (b)
              throw Error(
                "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"
              );
            console.warn(
              "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"
            );
            this.identity();
            return this;
          }
          this.multiplyScalar(1 / c);
          return this;
        },
        scale: function (a) {
          var b = this.elements,
            c = a.x,
            d = a.y;
          a = a.z;
          b[0] *= c;
          b[4] *= d;
          b[8] *= a;
          b[1] *= c;
          b[5] *= d;
          b[9] *= a;
          b[2] *= c;
          b[6] *= d;
          b[10] *= a;
          b[3] *= c;
          b[7] *= d;
          b[11] *= a;
          return this;
        },
        getMaxScaleOnAxis: function () {
          var a = this.elements;
          return Math.sqrt(
            Math.max(
              a[0] * a[0] + a[1] * a[1] + a[2] * a[2],
              a[4] * a[4] + a[5] * a[5] + a[6] * a[6],
              a[8] * a[8] + a[9] * a[9] + a[10] * a[10]
            )
          );
        },
        makeTranslation: function (a, b, c) {
          this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
          return this;
        },
        makeRotationX: function (a) {
          var b = Math.cos(a);
          a = Math.sin(a);
          this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
          return this;
        },
        makeRotationY: function (a) {
          var b = Math.cos(a);
          a = Math.sin(a);
          this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
          return this;
        },
        makeRotationZ: function (a) {
          var b = Math.cos(a);
          a = Math.sin(a);
          this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        },
        makeRotationAxis: function (a, b) {
          var c = Math.cos(b),
            d = Math.sin(b),
            e = 1 - c,
            f = a.x,
            g = a.y,
            h = a.z,
            k = e * f,
            l = e * g;
          this.set(
            k * f + c,
            k * g - d * h,
            k * h + d * g,
            0,
            k * g + d * h,
            l * g + c,
            l * h - d * f,
            0,
            k * h - d * g,
            l * h + d * f,
            e * h * h + c,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        },
        makeScale: function (a, b, c) {
          this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
          return this;
        },
        compose: function (a, b, c) {
          this.makeRotationFromQuaternion(b);
          this.scale(c);
          this.setPosition(a);
          return this;
        },
        decompose: (function () {
          var a, b;
          return function (c, d, e) {
            void 0 === a && (a = new THREE.Vector3());
            void 0 === b && (b = new THREE.Matrix4());
            var f = this.elements,
              g = a.set(f[0], f[1], f[2]).length(),
              h = a.set(f[4], f[5], f[6]).length(),
              k = a.set(f[8], f[9], f[10]).length();
            0 > this.determinant() && (g = -g);
            c.x = f[12];
            c.y = f[13];
            c.z = f[14];
            b.elements.set(this.elements);
            c = 1 / g;
            var f = 1 / h,
              l = 1 / k;
            b.elements[0] *= c;
            b.elements[1] *= c;
            b.elements[2] *= c;
            b.elements[4] *= f;
            b.elements[5] *= f;
            b.elements[6] *= f;
            b.elements[8] *= l;
            b.elements[9] *= l;
            b.elements[10] *= l;
            d.setFromRotationMatrix(b);
            e.x = g;
            e.y = h;
            e.z = k;
            return this;
          };
        })(),
        makeFrustum: function (a, b, c, d, e, f) {
          var g = this.elements;
          g[0] = (2 * e) / (b - a);
          g[4] = 0;
          g[8] = (b + a) / (b - a);
          g[12] = 0;
          g[1] = 0;
          g[5] = (2 * e) / (d - c);
          g[9] = (d + c) / (d - c);
          g[13] = 0;
          g[2] = 0;
          g[6] = 0;
          g[10] = -(f + e) / (f - e);
          g[14] = (-2 * f * e) / (f - e);
          g[3] = 0;
          g[7] = 0;
          g[11] = -1;
          g[15] = 0;
          return this;
        },
        makePerspective: function (a, b, c, d) {
          a = c * Math.tan(THREE.Math.degToRad(0.5 * a));
          var e = -a;
          return this.makeFrustum(e * b, a * b, e, a, c, d);
        },
        makeOrthographic: function (a, b, c, d, e, f) {
          var g = this.elements,
            h = b - a,
            k = c - d,
            l = f - e;
          g[0] = 2 / h;
          g[4] = 0;
          g[8] = 0;
          g[12] = -((b + a) / h);
          g[1] = 0;
          g[5] = 2 / k;
          g[9] = 0;
          g[13] = -((c + d) / k);
          g[2] = 0;
          g[6] = 0;
          g[10] = -2 / l;
          g[14] = -((f + e) / l);
          g[3] = 0;
          g[7] = 0;
          g[11] = 0;
          g[15] = 1;
          return this;
        },
        equals: function (a) {
          var b = this.elements;
          a = a.elements;
          for (var c = 0; 16 > c; c++) if (b[c] !== a[c]) return !1;
          return !0;
        },
        fromArray: function (a) {
          this.elements.set(a);
          return this;
        },
        toArray: function () {
          var a = this.elements;
          return [
            a[0],
            a[1],
            a[2],
            a[3],
            a[4],
            a[5],
            a[6],
            a[7],
            a[8],
            a[9],
            a[10],
            a[11],
            a[12],
            a[13],
            a[14],
            a[15],
          ];
        },
      };
      THREE.Ray = function (a, b) {
        this.origin = void 0 !== a ? a : new THREE.Vector3();
        this.direction = void 0 !== b ? b : new THREE.Vector3();
      };
      THREE.Ray.prototype = {
        constructor: THREE.Ray,
        set: function (a, b) {
          this.origin.copy(a);
          this.direction.copy(b);
          return this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.origin.copy(a.origin);
          this.direction.copy(a.direction);
          return this;
        },
        at: function (a, b) {
          return (b || new THREE.Vector3())
            .copy(this.direction)
            .multiplyScalar(a)
            .add(this.origin);
        },
        lookAt: function (a) {
          this.direction.copy(a).sub(this.origin).normalize();
        },
        recast: (function () {
          var a = new THREE.Vector3();
          return function (b) {
            this.origin.copy(this.at(b, a));
            return this;
          };
        })(),
        closestPointToPoint: function (a, b) {
          var c = b || new THREE.Vector3();
          c.subVectors(a, this.origin);
          var d = c.dot(this.direction);
          return 0 > d
            ? c.copy(this.origin)
            : c.copy(this.direction).multiplyScalar(d).add(this.origin);
        },
        distanceToPoint: function (a) {
          return Math.sqrt(this.distanceSqToPoint(a));
        },
        distanceSqToPoint: (function () {
          var a = new THREE.Vector3();
          return function (b) {
            var c = a.subVectors(b, this.origin).dot(this.direction);
            if (0 > c) return this.origin.distanceToSquared(b);
            a.copy(this.direction).multiplyScalar(c).add(this.origin);
            return a.distanceToSquared(b);
          };
        })(),
        distanceSqToSegment: (function () {
          var a = new THREE.Vector3(),
            b = new THREE.Vector3(),
            c = new THREE.Vector3();
          return function (d, e, f, g) {
            a.copy(d).add(e).multiplyScalar(0.5);
            b.copy(e).sub(d).normalize();
            c.copy(this.origin).sub(a);
            var h = 0.5 * d.distanceTo(e),
              k = -this.direction.dot(b),
              l = c.dot(this.direction),
              n = -c.dot(b),
              p = c.lengthSq(),
              m = Math.abs(1 - k * k),
              q;
            0 < m
              ? ((d = k * n - l),
                (e = k * l - n),
                (q = h * m),
                0 <= d
                  ? e >= -q
                    ? e <= q
                      ? ((h = 1 / m),
                        (d *= h),
                        (e *= h),
                        (k =
                          d * (d + k * e + 2 * l) +
                          e * (k * d + e + 2 * n) +
                          p))
                      : ((e = h),
                        (d = Math.max(0, -(k * e + l))),
                        (k = -d * d + e * (e + 2 * n) + p))
                    : ((e = -h),
                      (d = Math.max(0, -(k * e + l))),
                      (k = -d * d + e * (e + 2 * n) + p))
                  : e <= -q
                  ? ((d = Math.max(0, -(-k * h + l))),
                    (e = 0 < d ? -h : Math.min(Math.max(-h, -n), h)),
                    (k = -d * d + e * (e + 2 * n) + p))
                  : e <= q
                  ? ((d = 0),
                    (e = Math.min(Math.max(-h, -n), h)),
                    (k = e * (e + 2 * n) + p))
                  : ((d = Math.max(0, -(k * h + l))),
                    (e = 0 < d ? h : Math.min(Math.max(-h, -n), h)),
                    (k = -d * d + e * (e + 2 * n) + p)))
              : ((e = 0 < k ? -h : h),
                (d = Math.max(0, -(k * e + l))),
                (k = -d * d + e * (e + 2 * n) + p));
            f && f.copy(this.direction).multiplyScalar(d).add(this.origin);
            g && g.copy(b).multiplyScalar(e).add(a);
            return k;
          };
        })(),
        intersectSphere: (function () {
          var a = new THREE.Vector3();
          return function (b, c) {
            a.subVectors(b.center, this.origin);
            var d = a.dot(this.direction),
              e = a.dot(a) - d * d,
              f = b.radius * b.radius;
            if (e > f) return null;
            f = Math.sqrt(f - e);
            e = d - f;
            d += f;
            return 0 > e && 0 > d
              ? null
              : 0 > e
              ? this.at(d, c)
              : this.at(e, c);
          };
        })(),
        intersectsSphere: function (a) {
          return this.distanceToPoint(a.center) <= a.radius;
        },
        distanceToPlane: function (a) {
          var b = a.normal.dot(this.direction);
          if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
          a = -(this.origin.dot(a.normal) + a.constant) / b;
          return 0 <= a ? a : null;
        },
        intersectPlane: function (a, b) {
          var c = this.distanceToPlane(a);
          return null === c ? null : this.at(c, b);
        },
        intersectsPlane: function (a) {
          var b = a.distanceToPoint(this.origin);
          return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
        },
        intersectBox: function (a, b) {
          var c, d, e, f, g;
          d = 1 / this.direction.x;
          f = 1 / this.direction.y;
          g = 1 / this.direction.z;
          var h = this.origin;
          0 <= d
            ? ((c = (a.min.x - h.x) * d), (d *= a.max.x - h.x))
            : ((c = (a.max.x - h.x) * d), (d *= a.min.x - h.x));
          0 <= f
            ? ((e = (a.min.y - h.y) * f), (f *= a.max.y - h.y))
            : ((e = (a.max.y - h.y) * f), (f *= a.min.y - h.y));
          if (c > f || e > d) return null;
          if (e > c || c !== c) c = e;
          if (f < d || d !== d) d = f;
          0 <= g
            ? ((e = (a.min.z - h.z) * g), (g *= a.max.z - h.z))
            : ((e = (a.max.z - h.z) * g), (g *= a.min.z - h.z));
          if (c > g || e > d) return null;
          if (e > c || c !== c) c = e;
          if (g < d || d !== d) d = g;
          return 0 > d ? null : this.at(0 <= c ? c : d, b);
        },
        intersectsBox: (function () {
          var a = new THREE.Vector3();
          return function (b) {
            return null !== this.intersectBox(b, a);
          };
        })(),
        intersectTriangle: (function () {
          var a = new THREE.Vector3(),
            b = new THREE.Vector3(),
            c = new THREE.Vector3(),
            d = new THREE.Vector3();
          return function (e, f, g, h, k) {
            b.subVectors(f, e);
            c.subVectors(g, e);
            d.crossVectors(b, c);
            f = this.direction.dot(d);
            if (0 < f) {
              if (h) return null;
              h = 1;
            } else if (0 > f) (h = -1), (f = -f);
            else return null;
            a.subVectors(this.origin, e);
            e = h * this.direction.dot(c.crossVectors(a, c));
            if (0 > e) return null;
            g = h * this.direction.dot(b.cross(a));
            if (0 > g || e + g > f) return null;
            e = -h * a.dot(d);
            return 0 > e ? null : this.at(e / f, k);
          };
        })(),
        applyMatrix4: function (a) {
          this.direction.add(this.origin).applyMatrix4(a);
          this.origin.applyMatrix4(a);
          this.direction.sub(this.origin);
          this.direction.normalize();
          return this;
        },
        equals: function (a) {
          return (
            a.origin.equals(this.origin) && a.direction.equals(this.direction)
          );
        },
      };
      THREE.Sphere = function (a, b) {
        this.center = void 0 !== a ? a : new THREE.Vector3();
        this.radius = void 0 !== b ? b : 0;
      };
      THREE.Sphere.prototype = {
        constructor: THREE.Sphere,
        set: function (a, b) {
          this.center.copy(a);
          this.radius = b;
          return this;
        },
        setFromPoints: (function () {
          var a = new THREE.Box3();
          return function (b, c) {
            var d = this.center;
            void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
            for (var e = 0, f = 0, g = b.length; f < g; f++)
              e = Math.max(e, d.distanceToSquared(b[f]));
            this.radius = Math.sqrt(e);
            return this;
          };
        })(),
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.center.copy(a.center);
          this.radius = a.radius;
          return this;
        },
        empty: function () {
          return 0 >= this.radius;
        },
        containsPoint: function (a) {
          return a.distanceToSquared(this.center) <= this.radius * this.radius;
        },
        distanceToPoint: function (a) {
          return a.distanceTo(this.center) - this.radius;
        },
        intersectsSphere: function (a) {
          var b = this.radius + a.radius;
          return a.center.distanceToSquared(this.center) <= b * b;
        },
        intersectsBox: function (a) {
          return a.intersectsSphere(this);
        },
        intersectsPlane: function (a) {
          return (
            Math.abs(this.center.dot(a.normal) - a.constant) <= this.radius
          );
        },
        clampPoint: function (a, b) {
          var c = this.center.distanceToSquared(a),
            d = b || new THREE.Vector3();
          d.copy(a);
          c > this.radius * this.radius &&
            (d.sub(this.center).normalize(),
            d.multiplyScalar(this.radius).add(this.center));
          return d;
        },
        getBoundingBox: function (a) {
          a = a || new THREE.Box3();
          a.set(this.center, this.center);
          a.expandByScalar(this.radius);
          return a;
        },
        applyMatrix4: function (a) {
          this.center.applyMatrix4(a);
          this.radius *= a.getMaxScaleOnAxis();
          return this;
        },
        translate: function (a) {
          this.center.add(a);
          return this;
        },
        equals: function (a) {
          return a.center.equals(this.center) && a.radius === this.radius;
        },
      };
      THREE.Frustum = function (a, b, c, d, e, f) {
        this.planes = [
          void 0 !== a ? a : new THREE.Plane(),
          void 0 !== b ? b : new THREE.Plane(),
          void 0 !== c ? c : new THREE.Plane(),
          void 0 !== d ? d : new THREE.Plane(),
          void 0 !== e ? e : new THREE.Plane(),
          void 0 !== f ? f : new THREE.Plane(),
        ];
      };
      THREE.Frustum.prototype = {
        constructor: THREE.Frustum,
        set: function (a, b, c, d, e, f) {
          var g = this.planes;
          g[0].copy(a);
          g[1].copy(b);
          g[2].copy(c);
          g[3].copy(d);
          g[4].copy(e);
          g[5].copy(f);
          return this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
          return this;
        },
        setFromMatrix: function (a) {
          var b = this.planes,
            c = a.elements;
          a = c[0];
          var d = c[1],
            e = c[2],
            f = c[3],
            g = c[4],
            h = c[5],
            k = c[6],
            l = c[7],
            n = c[8],
            p = c[9],
            m = c[10],
            q = c[11],
            s = c[12],
            u = c[13],
            t = c[14],
            c = c[15];
          b[0].setComponents(f - a, l - g, q - n, c - s).normalize();
          b[1].setComponents(f + a, l + g, q + n, c + s).normalize();
          b[2].setComponents(f + d, l + h, q + p, c + u).normalize();
          b[3].setComponents(f - d, l - h, q - p, c - u).normalize();
          b[4].setComponents(f - e, l - k, q - m, c - t).normalize();
          b[5].setComponents(f + e, l + k, q + m, c + t).normalize();
          return this;
        },
        intersectsObject: (function () {
          var a = new THREE.Sphere();
          return function (b) {
            var c = b.geometry;
            null === c.boundingSphere && c.computeBoundingSphere();
            a.copy(c.boundingSphere);
            a.applyMatrix4(b.matrixWorld);
            return this.intersectsSphere(a);
          };
        })(),
        intersectsSphere: function (a) {
          var b = this.planes,
            c = a.center;
          a = -a.radius;
          for (var d = 0; 6 > d; d++)
            if (b[d].distanceToPoint(c) < a) return !1;
          return !0;
        },
        intersectsBox: (function () {
          var a = new THREE.Vector3(),
            b = new THREE.Vector3();
          return function (c) {
            for (var d = this.planes, e = 0; 6 > e; e++) {
              var f = d[e];
              a.x = 0 < f.normal.x ? c.min.x : c.max.x;
              b.x = 0 < f.normal.x ? c.max.x : c.min.x;
              a.y = 0 < f.normal.y ? c.min.y : c.max.y;
              b.y = 0 < f.normal.y ? c.max.y : c.min.y;
              a.z = 0 < f.normal.z ? c.min.z : c.max.z;
              b.z = 0 < f.normal.z ? c.max.z : c.min.z;
              var g = f.distanceToPoint(a),
                f = f.distanceToPoint(b);
              if (0 > g && 0 > f) return !1;
            }
            return !0;
          };
        })(),
        containsPoint: function (a) {
          for (var b = this.planes, c = 0; 6 > c; c++)
            if (0 > b[c].distanceToPoint(a)) return !1;
          return !0;
        },
      };
      THREE.Plane = function (a, b) {
        this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
        this.constant = void 0 !== b ? b : 0;
      };
      THREE.Plane.prototype = {
        constructor: THREE.Plane,
        set: function (a, b) {
          this.normal.copy(a);
          this.constant = b;
          return this;
        },
        setComponents: function (a, b, c, d) {
          this.normal.set(a, b, c);
          this.constant = d;
          return this;
        },
        setFromNormalAndCoplanarPoint: function (a, b) {
          this.normal.copy(a);
          this.constant = -b.dot(this.normal);
          return this;
        },
        setFromCoplanarPoints: (function () {
          var a = new THREE.Vector3(),
            b = new THREE.Vector3();
          return function (c, d, e) {
            d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
            this.setFromNormalAndCoplanarPoint(d, c);
            return this;
          };
        })(),
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.normal.copy(a.normal);
          this.constant = a.constant;
          return this;
        },
        normalize: function () {
          var a = 1 / this.normal.length();
          this.normal.multiplyScalar(a);
          this.constant *= a;
          return this;
        },
        negate: function () {
          this.constant *= -1;
          this.normal.negate();
          return this;
        },
        distanceToPoint: function (a) {
          return this.normal.dot(a) + this.constant;
        },
        distanceToSphere: function (a) {
          return this.distanceToPoint(a.center) - a.radius;
        },
        projectPoint: function (a, b) {
          return this.orthoPoint(a, b).sub(a).negate();
        },
        orthoPoint: function (a, b) {
          var c = this.distanceToPoint(a);
          return (b || new THREE.Vector3()).copy(this.normal).multiplyScalar(c);
        },
        intersectLine: (function () {
          var a = new THREE.Vector3();
          return function (b, c) {
            var d = c || new THREE.Vector3(),
              e = b.delta(a),
              f = this.normal.dot(e);
            if (0 === f) {
              if (0 === this.distanceToPoint(b.start)) return d.copy(b.start);
            } else
              return (
                (f = -(b.start.dot(this.normal) + this.constant) / f),
                0 > f || 1 < f
                  ? void 0
                  : d.copy(e).multiplyScalar(f).add(b.start)
              );
          };
        })(),
        intersectsLine: function (a) {
          var b = this.distanceToPoint(a.start);
          a = this.distanceToPoint(a.end);
          return (0 > b && 0 < a) || (0 > a && 0 < b);
        },
        intersectsBox: function (a) {
          return a.intersectsPlane(this);
        },
        intersectsSphere: function (a) {
          return a.intersectsPlane(this);
        },
        coplanarPoint: function (a) {
          return (a || new THREE.Vector3())
            .copy(this.normal)
            .multiplyScalar(-this.constant);
        },
        applyMatrix4: (function () {
          var a = new THREE.Vector3(),
            b = new THREE.Vector3(),
            c = new THREE.Matrix3();
          return function (d, e) {
            var f = e || c.getNormalMatrix(d),
              f = a.copy(this.normal).applyMatrix3(f),
              g = this.coplanarPoint(b);
            g.applyMatrix4(d);
            this.setFromNormalAndCoplanarPoint(f, g);
            return this;
          };
        })(),
        translate: function (a) {
          this.constant -= a.dot(this.normal);
          return this;
        },
        equals: function (a) {
          return a.normal.equals(this.normal) && a.constant === this.constant;
        },
      };
      THREE.Math = {
        generateUUID: (function () {
          var a =
              "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(
                ""
              ),
            b = Array(36),
            c = 0,
            d;
          return function () {
            for (var e = 0; 36 > e; e++)
              8 === e || 13 === e || 18 === e || 23 === e
                ? (b[e] = "-")
                : 14 === e
                ? (b[e] = "4")
                : (2 >= c && (c = (33554432 + 16777216 * Math.random()) | 0),
                  (d = c & 15),
                  (c >>= 4),
                  (b[e] = a[19 === e ? (d & 3) | 8 : d]));
            return b.join("");
          };
        })(),
        clamp: function (a, b, c) {
          return Math.max(b, Math.min(c, a));
        },
        euclideanModulo: function (a, b) {
          return ((a % b) + b) % b;
        },
        mapLinear: function (a, b, c, d, e) {
          return d + ((a - b) * (e - d)) / (c - b);
        },
        smoothstep: function (a, b, c) {
          if (a <= b) return 0;
          if (a >= c) return 1;
          a = (a - b) / (c - b);
          return a * a * (3 - 2 * a);
        },
        smootherstep: function (a, b, c) {
          if (a <= b) return 0;
          if (a >= c) return 1;
          a = (a - b) / (c - b);
          return a * a * a * (a * (6 * a - 15) + 10);
        },
        random16: function () {
          console.warn(
            "THREE.Math.random16() has been deprecated. Use Math.random() instead."
          );
          return Math.random();
        },
        randInt: function (a, b) {
          return a + Math.floor(Math.random() * (b - a + 1));
        },
        randFloat: function (a, b) {
          return a + Math.random() * (b - a);
        },
        randFloatSpread: function (a) {
          return a * (0.5 - Math.random());
        },
        degToRad: (function () {
          var a = Math.PI / 180;
          return function (b) {
            return b * a;
          };
        })(),
        radToDeg: (function () {
          var a = 180 / Math.PI;
          return function (b) {
            return b * a;
          };
        })(),
        isPowerOfTwo: function (a) {
          return 0 === (a & (a - 1)) && 0 !== a;
        },
        nearestPowerOfTwo: function (a) {
          return Math.pow(2, Math.round(Math.log(a) / Math.LN2));
        },
        nextPowerOfTwo: function (a) {
          a--;
          a |= a >> 1;
          a |= a >> 2;
          a |= a >> 4;
          a |= a >> 8;
          a |= a >> 16;
          a++;
          return a;
        },
      };
      THREE.Spline = function (a) {
        function b(a, b, c, d, e, f, g) {
          a = 0.5 * (c - a);
          d = 0.5 * (d - b);
          return (
            (2 * (b - c) + a + d) * g +
            (-3 * (b - c) - 2 * a - d) * f +
            a * e +
            b
          );
        }
        this.points = a;
        var c = [],
          d = { x: 0, y: 0, z: 0 },
          e,
          f,
          g,
          h,
          k,
          l,
          n,
          p,
          m;
        this.initFromArray = function (a) {
          this.points = [];
          for (var b = 0; b < a.length; b++)
            this.points[b] = { x: a[b][0], y: a[b][1], z: a[b][2] };
        };
        this.getPoint = function (a) {
          e = (this.points.length - 1) * a;
          f = Math.floor(e);
          g = e - f;
          c[0] = 0 === f ? f : f - 1;
          c[1] = f;
          c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;
          c[3] = f > this.points.length - 3 ? this.points.length - 1 : f + 2;
          l = this.points[c[0]];
          n = this.points[c[1]];
          p = this.points[c[2]];
          m = this.points[c[3]];
          h = g * g;
          k = g * h;
          d.x = b(l.x, n.x, p.x, m.x, g, h, k);
          d.y = b(l.y, n.y, p.y, m.y, g, h, k);
          d.z = b(l.z, n.z, p.z, m.z, g, h, k);
          return d;
        };
        this.getControlPointsArray = function () {
          var a,
            b,
            c = this.points.length,
            d = [];
          for (a = 0; a < c; a++)
            (b = this.points[a]), (d[a] = [b.x, b.y, b.z]);
          return d;
        };
        this.getLength = function (a) {
          var b,
            c,
            d,
            e = (b = b = 0),
            f = new THREE.Vector3(),
            g = new THREE.Vector3(),
            h = [],
            k = 0;
          h[0] = 0;
          a || (a = 100);
          c = this.points.length * a;
          f.copy(this.points[0]);
          for (a = 1; a < c; a++)
            (b = a / c),
              (d = this.getPoint(b)),
              g.copy(d),
              (k += g.distanceTo(f)),
              f.copy(d),
              (b *= this.points.length - 1),
              (b = Math.floor(b)),
              b !== e && ((h[b] = k), (e = b));
          h[h.length] = k;
          return { chunks: h, total: k };
        };
        this.reparametrizeByArcLength = function (a) {
          var b,
            c,
            d,
            e,
            f,
            g,
            h = [],
            k = new THREE.Vector3(),
            m = this.getLength();
          h.push(k.copy(this.points[0]).clone());
          for (b = 1; b < this.points.length; b++) {
            c = m.chunks[b] - m.chunks[b - 1];
            g = Math.ceil((a * c) / m.total);
            e = (b - 1) / (this.points.length - 1);
            f = b / (this.points.length - 1);
            for (c = 1; c < g - 1; c++)
              (d = e + (1 / g) * c * (f - e)),
                (d = this.getPoint(d)),
                h.push(k.copy(d).clone());
            h.push(k.copy(this.points[b]).clone());
          }
          this.points = h;
        };
      };
      THREE.Triangle = function (a, b, c) {
        this.a = void 0 !== a ? a : new THREE.Vector3();
        this.b = void 0 !== b ? b : new THREE.Vector3();
        this.c = void 0 !== c ? c : new THREE.Vector3();
      };
      THREE.Triangle.normal = (function () {
        var a = new THREE.Vector3();
        return function (b, c, d, e) {
          e = e || new THREE.Vector3();
          e.subVectors(d, c);
          a.subVectors(b, c);
          e.cross(a);
          b = e.lengthSq();
          return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
        };
      })();
      THREE.Triangle.barycoordFromPoint = (function () {
        var a = new THREE.Vector3(),
          b = new THREE.Vector3(),
          c = new THREE.Vector3();
        return function (d, e, f, g, h) {
          a.subVectors(g, e);
          b.subVectors(f, e);
          c.subVectors(d, e);
          d = a.dot(a);
          e = a.dot(b);
          f = a.dot(c);
          var k = b.dot(b);
          g = b.dot(c);
          var l = d * k - e * e;
          h = h || new THREE.Vector3();
          if (0 === l) return h.set(-2, -1, -1);
          l = 1 / l;
          k = (k * f - e * g) * l;
          d = (d * g - e * f) * l;
          return h.set(1 - k - d, d, k);
        };
      })();
      THREE.Triangle.containsPoint = (function () {
        var a = new THREE.Vector3();
        return function (b, c, d, e) {
          b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
          return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y;
        };
      })();
      THREE.Triangle.prototype = {
        constructor: THREE.Triangle,
        set: function (a, b, c) {
          this.a.copy(a);
          this.b.copy(b);
          this.c.copy(c);
          return this;
        },
        setFromPointsAndIndices: function (a, b, c, d) {
          this.a.copy(a[b]);
          this.b.copy(a[c]);
          this.c.copy(a[d]);
          return this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.a.copy(a.a);
          this.b.copy(a.b);
          this.c.copy(a.c);
          return this;
        },
        area: (function () {
          var a = new THREE.Vector3(),
            b = new THREE.Vector3();
          return function () {
            a.subVectors(this.c, this.b);
            b.subVectors(this.a, this.b);
            return 0.5 * a.cross(b).length();
          };
        })(),
        midpoint: function (a) {
          return (a || new THREE.Vector3())
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        },
        normal: function (a) {
          return THREE.Triangle.normal(this.a, this.b, this.c, a);
        },
        plane: function (a) {
          return (a || new THREE.Plane()).setFromCoplanarPoints(
            this.a,
            this.b,
            this.c
          );
        },
        barycoordFromPoint: function (a, b) {
          return THREE.Triangle.barycoordFromPoint(
            a,
            this.a,
            this.b,
            this.c,
            b
          );
        },
        containsPoint: function (a) {
          return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);
        },
        equals: function (a) {
          return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
        },
      };
      THREE.Interpolant = function (a, b, c, d) {
        this.parameterPositions = a;
        this._cachedIndex = 0;
        this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
        this.sampleValues = b;
        this.valueSize = c;
      };
      THREE.Interpolant.prototype = {
        constructor: THREE.Interpolant,
        evaluate: function (a) {
          var b = this.parameterPositions,
            c = this._cachedIndex,
            d = b[c],
            e = b[c - 1];
          a: {
            b: {
              c: {
                d: if (!(a < d)) {
                  for (var f = c + 2; ; ) {
                    if (void 0 === d) {
                      if (a < e) break d;
                      this._cachedIndex = c = b.length;
                      return this.afterEnd_(c - 1, a, e);
                    }
                    if (c === f) break;
                    e = d;
                    d = b[++c];
                    if (a < d) break b;
                  }
                  d = b.length;
                  break c;
                }
                if (a >= e) break a;
                else {
                  f = b[1];
                  a < f && ((c = 2), (e = f));
                  for (f = c - 2; ; ) {
                    if (void 0 === e)
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, a, d)
                      );
                    if (c === f) break;
                    d = e;
                    e = b[--c - 1];
                    if (a >= e) break b;
                  }
                  d = c;
                  c = 0;
                }
              }
              for (; c < d; )
                (e = (c + d) >>> 1), a < b[e] ? (d = e) : (c = e + 1);
              d = b[c];
              e = b[c - 1];
              if (void 0 === e)
                return (this._cachedIndex = 0), this.beforeStart_(0, a, d);
              if (void 0 === d)
                return (
                  (this._cachedIndex = c = b.length),
                  this.afterEnd_(c - 1, e, a)
                );
            }
            this._cachedIndex = c;
            this.intervalChanged_(c, e, d);
          }
          return this.interpolate_(c, e, a, d);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function () {
          return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function (a) {
          var b = this.resultBuffer,
            c = this.sampleValues,
            d = this.valueSize;
          a *= d;
          for (var e = 0; e !== d; ++e) b[e] = c[a + e];
          return b;
        },
        interpolate_: function (a, b, c, d) {
          throw Error("call to abstract method");
        },
        intervalChanged_: function (a, b, c) {},
      };
      Object.assign(THREE.Interpolant.prototype, {
        beforeStart_: THREE.Interpolant.prototype.copySampleValue_,
        afterEnd_: THREE.Interpolant.prototype.copySampleValue_,
      });
      THREE.CubicInterpolant = function (a, b, c, d) {
        THREE.Interpolant.call(this, a, b, c, d);
        this._offsetNext =
          this._weightNext =
          this._offsetPrev =
          this._weightPrev =
            -0;
      };
      THREE.CubicInterpolant.prototype = Object.assign(
        Object.create(THREE.Interpolant.prototype),
        {
          constructor: THREE.CubicInterpolant,
          DefaultSettings_: {
            endingStart: THREE.ZeroCurvatureEnding,
            endingEnd: THREE.ZeroCurvatureEnding,
          },
          intervalChanged_: function (a, b, c) {
            var d = this.parameterPositions,
              e = a - 2,
              f = a + 1,
              g = d[e],
              h = d[f];
            if (void 0 === g)
              switch (this.getSettings_().endingStart) {
                case THREE.ZeroSlopeEnding:
                  e = a;
                  g = 2 * b - c;
                  break;
                case THREE.WrapAroundEnding:
                  e = d.length - 2;
                  g = b + d[e] - d[e + 1];
                  break;
                default:
                  (e = a), (g = c);
              }
            if (void 0 === h)
              switch (this.getSettings_().endingEnd) {
                case THREE.ZeroSlopeEnding:
                  f = a;
                  h = 2 * c - b;
                  break;
                case THREE.WrapAroundEnding:
                  f = 1;
                  h = c + d[1] - d[0];
                  break;
                default:
                  (f = a - 1), (h = b);
              }
            a = 0.5 * (c - b);
            d = this.valueSize;
            this._weightPrev = a / (b - g);
            this._weightNext = a / (h - c);
            this._offsetPrev = e * d;
            this._offsetNext = f * d;
          },
          interpolate_: function (a, b, c, d) {
            var e = this.resultBuffer,
              f = this.sampleValues,
              g = this.valueSize;
            a *= g;
            var h = a - g,
              k = this._offsetPrev,
              l = this._offsetNext,
              n = this._weightPrev,
              p = this._weightNext,
              m = (c - b) / (d - b);
            c = m * m;
            d = c * m;
            b = -n * d + 2 * n * c - n * m;
            n = (1 + n) * d + (-1.5 - 2 * n) * c + (-0.5 + n) * m + 1;
            m = (-1 - p) * d + (1.5 + p) * c + 0.5 * m;
            p = p * d - p * c;
            for (c = 0; c !== g; ++c)
              e[c] = b * f[k + c] + n * f[h + c] + m * f[a + c] + p * f[l + c];
            return e;
          },
        }
      );
      THREE.DiscreteInterpolant = function (a, b, c, d) {
        THREE.Interpolant.call(this, a, b, c, d);
      };
      THREE.DiscreteInterpolant.prototype = Object.assign(
        Object.create(THREE.Interpolant.prototype),
        {
          constructor: THREE.DiscreteInterpolant,
          interpolate_: function (a, b, c, d) {
            return this.copySampleValue_(a - 1);
          },
        }
      );
      THREE.LinearInterpolant = function (a, b, c, d) {
        THREE.Interpolant.call(this, a, b, c, d);
      };
      THREE.LinearInterpolant.prototype = Object.assign(
        Object.create(THREE.Interpolant.prototype),
        {
          constructor: THREE.LinearInterpolant,
          interpolate_: function (a, b, c, d) {
            var e = this.resultBuffer,
              f = this.sampleValues,
              g = this.valueSize;
            a *= g;
            var h = a - g;
            b = (c - b) / (d - b);
            c = 1 - b;
            for (d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
            return e;
          },
        }
      );
      THREE.QuaternionLinearInterpolant = function (a, b, c, d) {
        THREE.Interpolant.call(this, a, b, c, d);
      };
      THREE.QuaternionLinearInterpolant.prototype = Object.assign(
        Object.create(THREE.Interpolant.prototype),
        {
          constructor: THREE.QuaternionLinearInterpolant,
          interpolate_: function (a, b, c, d) {
            var e = this.resultBuffer,
              f = this.sampleValues,
              g = this.valueSize;
            a *= g;
            b = (c - b) / (d - b);
            for (c = a + g; a !== c; a += 4)
              THREE.Quaternion.slerpFlat(e, 0, f, a - g, f, a, b);
            return e;
          },
        }
      );
      THREE.Clock = function (a) {
        this.autoStart = void 0 !== a ? a : !0;
        this.elapsedTime = this.oldTime = this.startTime = 0;
        this.running = !1;
      };
      THREE.Clock.prototype = {
        constructor: THREE.Clock,
        start: function () {
          this.oldTime = this.startTime = performance.now();
          this.running = !0;
        },
        stop: function () {
          this.getElapsedTime();
          this.running = !1;
        },
        getElapsedTime: function () {
          this.getDelta();
          return this.elapsedTime;
        },
        getDelta: function () {
          var a = 0;
          this.autoStart && !this.running && this.start();
          if (this.running) {
            var b = performance.now(),
              a = 0.001 * (b - this.oldTime);
            this.oldTime = b;
            this.elapsedTime += a;
          }
          return a;
        },
      };
      THREE.EventDispatcher = function () {};
      THREE.EventDispatcher.prototype = {
        constructor: THREE.EventDispatcher,
        apply: function (a) {
          a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
          a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
          a.removeEventListener =
            THREE.EventDispatcher.prototype.removeEventListener;
          a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
        },
        addEventListener: function (a, b) {
          void 0 === this._listeners && (this._listeners = {});
          var c = this._listeners;
          void 0 === c[a] && (c[a] = []);
          -1 === c[a].indexOf(b) && c[a].push(b);
        },
        hasEventListener: function (a, b) {
          if (void 0 === this._listeners) return !1;
          var c = this._listeners;
          return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1;
        },
        removeEventListener: function (a, b) {
          if (void 0 !== this._listeners) {
            var c = this._listeners[a];
            if (void 0 !== c) {
              var d = c.indexOf(b);
              -1 !== d && c.splice(d, 1);
            }
          }
        },
        dispatchEvent: function (a) {
          if (void 0 !== this._listeners) {
            var b = this._listeners[a.type];
            if (void 0 !== b) {
              a.target = this;
              for (var c = [], d = b.length, e = 0; e < d; e++) c[e] = b[e];
              for (e = 0; e < d; e++) c[e].call(this, a);
            }
          }
        },
      };
      THREE.Layers = function () {
        this.mask = 1;
      };
      THREE.Layers.prototype = {
        constructor: THREE.Layers,
        set: function (a) {
          this.mask = 1 << a;
        },
        enable: function (a) {
          this.mask |= 1 << a;
        },
        toggle: function (a) {
          this.mask ^= 1 << a;
        },
        disable: function (a) {
          this.mask &= ~(1 << a);
        },
        test: function (a) {
          return 0 !== (this.mask & a.mask);
        },
      };
      (function (a) {
        function b(a, b) {
          return a.distance - b.distance;
        }
        function c(a, b, f, g) {
          if (!1 !== a.visible && (a.raycast(b, f), !0 === g)) {
            a = a.children;
            g = 0;
            for (var h = a.length; g < h; g++) c(a[g], b, f, !0);
          }
        }
        a.Raycaster = function (b, c, f, g) {
          this.ray = new a.Ray(b, c);
          this.near = f || 0;
          this.far = g || Infinity;
          this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {},
          };
          Object.defineProperties(this.params, {
            PointCloud: {
              get: function () {
                console.warn(
                  "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                );
                return this.Points;
              },
            },
          });
        };
        a.Raycaster.prototype = {
          constructor: a.Raycaster,
          linePrecision: 1,
          set: function (a, b) {
            this.ray.set(a, b);
          },
          setFromCamera: function (b, c) {
            c instanceof a.PerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(c.matrixWorld),
                this.ray.direction
                  .set(b.x, b.y, 0.5)
                  .unproject(c)
                  .sub(this.ray.origin)
                  .normalize())
              : c instanceof a.OrthographicCamera
              ? (this.ray.origin.set(b.x, b.y, -1).unproject(c),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(c.matrixWorld))
              : console.error("THREE.Raycaster: Unsupported camera type.");
          },
          intersectObject: function (a, e) {
            var f = [];
            c(a, this, f, e);
            f.sort(b);
            return f;
          },
          intersectObjects: function (a, e) {
            var f = [];
            if (!1 === Array.isArray(a))
              return (
                console.warn(
                  "THREE.Raycaster.intersectObjects: objects is not an Array."
                ),
                f
              );
            for (var g = 0, h = a.length; g < h; g++) c(a[g], this, f, e);
            f.sort(b);
            return f;
          },
        };
      })(THREE);
      THREE.Object3D = function () {
        Object.defineProperty(this, "id", { value: THREE.Object3DIdCount++ });
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = THREE.Object3D.DefaultUp.clone();
        var a = new THREE.Vector3(),
          b = new THREE.Euler(),
          c = new THREE.Quaternion(),
          d = new THREE.Vector3(1, 1, 1);
        b.onChange(function () {
          c.setFromEuler(b, !1);
        });
        c.onChange(function () {
          b.setFromQuaternion(c, void 0, !1);
        });
        Object.defineProperties(this, {
          position: { enumerable: !0, value: a },
          rotation: { enumerable: !0, value: b },
          quaternion: { enumerable: !0, value: c },
          scale: { enumerable: !0, value: d },
          modelViewMatrix: { value: new THREE.Matrix4() },
          normalMatrix: { value: new THREE.Matrix3() },
        });
        this.rotationAutoUpdate = !0;
        this.matrix = new THREE.Matrix4();
        this.matrixWorld = new THREE.Matrix4();
        this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = !1;
        this.layers = new THREE.Layers();
        this.visible = !0;
        this.receiveShadow = this.castShadow = !1;
        this.frustumCulled = !0;
        this.renderOrder = 0;
        this.userData = {};
      };
      THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
      THREE.Object3D.DefaultMatrixAutoUpdate = !0;
      THREE.Object3D.prototype = {
        constructor: THREE.Object3D,
        applyMatrix: function (a) {
          this.matrix.multiplyMatrices(a, this.matrix);
          this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        setRotationFromAxisAngle: function (a, b) {
          this.quaternion.setFromAxisAngle(a, b);
        },
        setRotationFromEuler: function (a) {
          this.quaternion.setFromEuler(a, !0);
        },
        setRotationFromMatrix: function (a) {
          this.quaternion.setFromRotationMatrix(a);
        },
        setRotationFromQuaternion: function (a) {
          this.quaternion.copy(a);
        },
        rotateOnAxis: (function () {
          var a = new THREE.Quaternion();
          return function (b, c) {
            a.setFromAxisAngle(b, c);
            this.quaternion.multiply(a);
            return this;
          };
        })(),
        rotateX: (function () {
          var a = new THREE.Vector3(1, 0, 0);
          return function (b) {
            return this.rotateOnAxis(a, b);
          };
        })(),
        rotateY: (function () {
          var a = new THREE.Vector3(0, 1, 0);
          return function (b) {
            return this.rotateOnAxis(a, b);
          };
        })(),
        rotateZ: (function () {
          var a = new THREE.Vector3(0, 0, 1);
          return function (b) {
            return this.rotateOnAxis(a, b);
          };
        })(),
        translateOnAxis: (function () {
          var a = new THREE.Vector3();
          return function (b, c) {
            a.copy(b).applyQuaternion(this.quaternion);
            this.position.add(a.multiplyScalar(c));
            return this;
          };
        })(),
        translateX: (function () {
          var a = new THREE.Vector3(1, 0, 0);
          return function (b) {
            return this.translateOnAxis(a, b);
          };
        })(),
        translateY: (function () {
          var a = new THREE.Vector3(0, 1, 0);
          return function (b) {
            return this.translateOnAxis(a, b);
          };
        })(),
        translateZ: (function () {
          var a = new THREE.Vector3(0, 0, 1);
          return function (b) {
            return this.translateOnAxis(a, b);
          };
        })(),
        localToWorld: function (a) {
          return a.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: (function () {
          var a = new THREE.Matrix4();
          return function (b) {
            return b.applyMatrix4(a.getInverse(this.matrixWorld));
          };
        })(),
        lookAt: (function () {
          var a = new THREE.Matrix4();
          return function (b) {
            a.lookAt(b, this.position, this.up);
            this.quaternion.setFromRotationMatrix(a);
          };
        })(),
        add: function (a) {
          if (1 < arguments.length) {
            for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
            return this;
          }
          if (a === this)
            return (
              console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                a
              ),
              this
            );
          a instanceof THREE.Object3D
            ? (null !== a.parent && a.parent.remove(a),
              (a.parent = this),
              a.dispatchEvent({ type: "added" }),
              this.children.push(a))
            : console.error(
                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                a
              );
          return this;
        },
        remove: function (a) {
          if (1 < arguments.length)
            for (var b = 0; b < arguments.length; b++)
              this.remove(arguments[b]);
          b = this.children.indexOf(a);
          -1 !== b &&
            ((a.parent = null),
            a.dispatchEvent({ type: "removed" }),
            this.children.splice(b, 1));
        },
        getObjectById: function (a) {
          return this.getObjectByProperty("id", a);
        },
        getObjectByName: function (a) {
          return this.getObjectByProperty("name", a);
        },
        getObjectByProperty: function (a, b) {
          if (this[a] === b) return this;
          for (var c = 0, d = this.children.length; c < d; c++) {
            var e = this.children[c].getObjectByProperty(a, b);
            if (void 0 !== e) return e;
          }
        },
        getWorldPosition: function (a) {
          a = a || new THREE.Vector3();
          this.updateMatrixWorld(!0);
          return a.setFromMatrixPosition(this.matrixWorld);
        },
        getWorldQuaternion: (function () {
          var a = new THREE.Vector3(),
            b = new THREE.Vector3();
          return function (c) {
            c = c || new THREE.Quaternion();
            this.updateMatrixWorld(!0);
            this.matrixWorld.decompose(a, c, b);
            return c;
          };
        })(),
        getWorldRotation: (function () {
          var a = new THREE.Quaternion();
          return function (b) {
            b = b || new THREE.Euler();
            this.getWorldQuaternion(a);
            return b.setFromQuaternion(a, this.rotation.order, !1);
          };
        })(),
        getWorldScale: (function () {
          var a = new THREE.Vector3(),
            b = new THREE.Quaternion();
          return function (c) {
            c = c || new THREE.Vector3();
            this.updateMatrixWorld(!0);
            this.matrixWorld.decompose(a, b, c);
            return c;
          };
        })(),
        getWorldDirection: (function () {
          var a = new THREE.Quaternion();
          return function (b) {
            b = b || new THREE.Vector3();
            this.getWorldQuaternion(a);
            return b.set(0, 0, 1).applyQuaternion(a);
          };
        })(),
        raycast: function () {},
        traverse: function (a) {
          a(this);
          for (var b = this.children, c = 0, d = b.length; c < d; c++)
            b[c].traverse(a);
        },
        traverseVisible: function (a) {
          if (!1 !== this.visible) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; c < d; c++)
              b[c].traverseVisible(a);
          }
        },
        traverseAncestors: function (a) {
          var b = this.parent;
          null !== b && (a(b), b.traverseAncestors(a));
        },
        updateMatrix: function () {
          this.matrix.compose(this.position, this.quaternion, this.scale);
          this.matrixWorldNeedsUpdate = !0;
        },
        updateMatrixWorld: function (a) {
          !0 === this.matrixAutoUpdate && this.updateMatrix();
          if (!0 === this.matrixWorldNeedsUpdate || !0 === a)
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
              (this.matrixWorldNeedsUpdate = !1),
              (a = !0);
          for (var b = 0, c = this.children.length; b < c; b++)
            this.children[b].updateMatrixWorld(a);
        },
        toJSON: function (a) {
          function b(a) {
            var b = [],
              c;
            for (c in a) {
              var d = a[c];
              delete d.metadata;
              b.push(d);
            }
            return b;
          }
          var c = void 0 === a,
            d = {};
          c &&
            ((a = { geometries: {}, materials: {}, textures: {}, images: {} }),
            (d.metadata = {
              version: 4.4,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          var e = {};
          e.uuid = this.uuid;
          e.type = this.type;
          "" !== this.name && (e.name = this.name);
          "{}" !== JSON.stringify(this.userData) &&
            (e.userData = this.userData);
          !0 === this.castShadow && (e.castShadow = !0);
          !0 === this.receiveShadow && (e.receiveShadow = !0);
          !1 === this.visible && (e.visible = !1);
          e.matrix = this.matrix.toArray();
          void 0 !== this.geometry &&
            (void 0 === a.geometries[this.geometry.uuid] &&
              (a.geometries[this.geometry.uuid] = this.geometry.toJSON(a)),
            (e.geometry = this.geometry.uuid));
          void 0 !== this.material &&
            (void 0 === a.materials[this.material.uuid] &&
              (a.materials[this.material.uuid] = this.material.toJSON(a)),
            (e.material = this.material.uuid));
          if (0 < this.children.length) {
            e.children = [];
            for (var f = 0; f < this.children.length; f++)
              e.children.push(this.children[f].toJSON(a).object);
          }
          if (c) {
            var c = b(a.geometries),
              f = b(a.materials),
              g = b(a.textures);
            a = b(a.images);
            0 < c.length && (d.geometries = c);
            0 < f.length && (d.materials = f);
            0 < g.length && (d.textures = g);
            0 < a.length && (d.images = a);
          }
          d.object = e;
          return d;
        },
        clone: function (a) {
          return new this.constructor().copy(this, a);
        },
        copy: function (a, b) {
          void 0 === b && (b = !0);
          this.name = a.name;
          this.up.copy(a.up);
          this.position.copy(a.position);
          this.quaternion.copy(a.quaternion);
          this.scale.copy(a.scale);
          this.rotationAutoUpdate = a.rotationAutoUpdate;
          this.matrix.copy(a.matrix);
          this.matrixWorld.copy(a.matrixWorld);
          this.matrixAutoUpdate = a.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
          this.visible = a.visible;
          this.castShadow = a.castShadow;
          this.receiveShadow = a.receiveShadow;
          this.frustumCulled = a.frustumCulled;
          this.renderOrder = a.renderOrder;
          this.userData = JSON.parse(JSON.stringify(a.userData));
          if (!0 === b)
            for (var c = 0; c < a.children.length; c++)
              this.add(a.children[c].clone());
          return this;
        },
      };
      THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
      THREE.Object3DIdCount = 0;
      THREE.Face3 = function (a, b, c, d, e, f) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3();
        this.vertexNormals = Array.isArray(d) ? d : [];
        this.color = e instanceof THREE.Color ? e : new THREE.Color();
        this.vertexColors = Array.isArray(e) ? e : [];
        this.materialIndex = void 0 !== f ? f : 0;
      };
      THREE.Face3.prototype = {
        constructor: THREE.Face3,
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.a = a.a;
          this.b = a.b;
          this.c = a.c;
          this.normal.copy(a.normal);
          this.color.copy(a.color);
          this.materialIndex = a.materialIndex;
          for (var b = 0, c = a.vertexNormals.length; b < c; b++)
            this.vertexNormals[b] = a.vertexNormals[b].clone();
          b = 0;
          for (c = a.vertexColors.length; b < c; b++)
            this.vertexColors[b] = a.vertexColors[b].clone();
          return this;
        },
      };
      THREE.BufferAttribute = function (a, b) {
        this.uuid = THREE.Math.generateUUID();
        this.array = a;
        this.itemSize = b;
        this.dynamic = !1;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
      };
      THREE.BufferAttribute.prototype = {
        constructor: THREE.BufferAttribute,
        get count() {
          return this.array.length / this.itemSize;
        },
        set needsUpdate(a) {
          !0 === a && this.version++;
        },
        setDynamic: function (a) {
          this.dynamic = a;
          return this;
        },
        copy: function (a) {
          this.array = new a.array.constructor(a.array);
          this.itemSize = a.itemSize;
          this.dynamic = a.dynamic;
          return this;
        },
        copyAt: function (a, b, c) {
          a *= this.itemSize;
          c *= b.itemSize;
          for (var d = 0, e = this.itemSize; d < e; d++)
            this.array[a + d] = b.array[c + d];
          return this;
        },
        copyArray: function (a) {
          this.array.set(a);
          return this;
        },
        copyColorsArray: function (a) {
          for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                d
              ),
              (f = new THREE.Color()));
            b[c++] = f.r;
            b[c++] = f.g;
            b[c++] = f.b;
          }
          return this;
        },
        copyIndicesArray: function (a) {
          for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            b[c++] = f.a;
            b[c++] = f.b;
            b[c++] = f.c;
          }
          return this;
        },
        copyVector2sArray: function (a) {
          for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                d
              ),
              (f = new THREE.Vector2()));
            b[c++] = f.x;
            b[c++] = f.y;
          }
          return this;
        },
        copyVector3sArray: function (a) {
          for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                d
              ),
              (f = new THREE.Vector3()));
            b[c++] = f.x;
            b[c++] = f.y;
            b[c++] = f.z;
          }
          return this;
        },
        copyVector4sArray: function (a) {
          for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                d
              ),
              (f = new THREE.Vector4()));
            b[c++] = f.x;
            b[c++] = f.y;
            b[c++] = f.z;
            b[c++] = f.w;
          }
          return this;
        },
        set: function (a, b) {
          void 0 === b && (b = 0);
          this.array.set(a, b);
          return this;
        },
        getX: function (a) {
          return this.array[a * this.itemSize];
        },
        setX: function (a, b) {
          this.array[a * this.itemSize] = b;
          return this;
        },
        getY: function (a) {
          return this.array[a * this.itemSize + 1];
        },
        setY: function (a, b) {
          this.array[a * this.itemSize + 1] = b;
          return this;
        },
        getZ: function (a) {
          return this.array[a * this.itemSize + 2];
        },
        setZ: function (a, b) {
          this.array[a * this.itemSize + 2] = b;
          return this;
        },
        getW: function (a) {
          return this.array[a * this.itemSize + 3];
        },
        setW: function (a, b) {
          this.array[a * this.itemSize + 3] = b;
          return this;
        },
        setXY: function (a, b, c) {
          a *= this.itemSize;
          this.array[a + 0] = b;
          this.array[a + 1] = c;
          return this;
        },
        setXYZ: function (a, b, c, d) {
          a *= this.itemSize;
          this.array[a + 0] = b;
          this.array[a + 1] = c;
          this.array[a + 2] = d;
          return this;
        },
        setXYZW: function (a, b, c, d, e) {
          a *= this.itemSize;
          this.array[a + 0] = b;
          this.array[a + 1] = c;
          this.array[a + 2] = d;
          this.array[a + 3] = e;
          return this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      };
      THREE.Int8Attribute = function (a, b) {
        return new THREE.BufferAttribute(new Int8Array(a), b);
      };
      THREE.Uint8Attribute = function (a, b) {
        return new THREE.BufferAttribute(new Uint8Array(a), b);
      };
      THREE.Uint8ClampedAttribute = function (a, b) {
        return new THREE.BufferAttribute(new Uint8ClampedArray(a), b);
      };
      THREE.Int16Attribute = function (a, b) {
        return new THREE.BufferAttribute(new Int16Array(a), b);
      };
      THREE.Uint16Attribute = function (a, b) {
        return new THREE.BufferAttribute(new Uint16Array(a), b);
      };
      THREE.Int32Attribute = function (a, b) {
        return new THREE.BufferAttribute(new Int32Array(a), b);
      };
      THREE.Uint32Attribute = function (a, b) {
        return new THREE.BufferAttribute(new Uint32Array(a), b);
      };
      THREE.Float32Attribute = function (a, b) {
        return new THREE.BufferAttribute(new Float32Array(a), b);
      };
      THREE.Float64Attribute = function (a, b) {
        return new THREE.BufferAttribute(new Float64Array(a), b);
      };
      THREE.DynamicBufferAttribute = function (a, b) {
        console.warn(
          "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
        );
        return new THREE.BufferAttribute(a, b).setDynamic(!0);
      };
      THREE.InstancedBufferAttribute = function (a, b, c) {
        THREE.BufferAttribute.call(this, a, b);
        this.meshPerAttribute = c || 1;
      };
      THREE.InstancedBufferAttribute.prototype = Object.create(
        THREE.BufferAttribute.prototype
      );
      THREE.InstancedBufferAttribute.prototype.constructor =
        THREE.InstancedBufferAttribute;
      THREE.InstancedBufferAttribute.prototype.copy = function (a) {
        THREE.BufferAttribute.prototype.copy.call(this, a);
        this.meshPerAttribute = a.meshPerAttribute;
        return this;
      };
      THREE.InterleavedBuffer = function (a, b) {
        this.uuid = THREE.Math.generateUUID();
        this.array = a;
        this.stride = b;
        this.dynamic = !1;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
      };
      THREE.InterleavedBuffer.prototype = {
        constructor: THREE.InterleavedBuffer,
        get length() {
          return this.array.length;
        },
        get count() {
          return this.array.length / this.stride;
        },
        set needsUpdate(a) {
          !0 === a && this.version++;
        },
        setDynamic: function (a) {
          this.dynamic = a;
          return this;
        },
        copy: function (a) {
          this.array = new a.array.constructor(a.array);
          this.stride = a.stride;
          this.dynamic = a.dynamic;
          return this;
        },
        copyAt: function (a, b, c) {
          a *= this.stride;
          c *= b.stride;
          for (var d = 0, e = this.stride; d < e; d++)
            this.array[a + d] = b.array[c + d];
          return this;
        },
        set: function (a, b) {
          void 0 === b && (b = 0);
          this.array.set(a, b);
          return this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      };
      THREE.InstancedInterleavedBuffer = function (a, b, c) {
        THREE.InterleavedBuffer.call(this, a, b);
        this.meshPerAttribute = c || 1;
      };
      THREE.InstancedInterleavedBuffer.prototype = Object.create(
        THREE.InterleavedBuffer.prototype
      );
      THREE.InstancedInterleavedBuffer.prototype.constructor =
        THREE.InstancedInterleavedBuffer;
      THREE.InstancedInterleavedBuffer.prototype.copy = function (a) {
        THREE.InterleavedBuffer.prototype.copy.call(this, a);
        this.meshPerAttribute = a.meshPerAttribute;
        return this;
      };
      THREE.InterleavedBufferAttribute = function (a, b, c) {
        this.uuid = THREE.Math.generateUUID();
        this.data = a;
        this.itemSize = b;
        this.offset = c;
      };
      THREE.InterleavedBufferAttribute.prototype = {
        constructor: THREE.InterleavedBufferAttribute,
        get length() {
          console.warn(
            "THREE.BufferAttribute: .length has been deprecated. Please use .count."
          );
          return this.array.length;
        },
        get count() {
          return this.data.count;
        },
        setX: function (a, b) {
          this.data.array[a * this.data.stride + this.offset] = b;
          return this;
        },
        setY: function (a, b) {
          this.data.array[a * this.data.stride + this.offset + 1] = b;
          return this;
        },
        setZ: function (a, b) {
          this.data.array[a * this.data.stride + this.offset + 2] = b;
          return this;
        },
        setW: function (a, b) {
          this.data.array[a * this.data.stride + this.offset + 3] = b;
          return this;
        },
        getX: function (a) {
          return this.data.array[a * this.data.stride + this.offset];
        },
        getY: function (a) {
          return this.data.array[a * this.data.stride + this.offset + 1];
        },
        getZ: function (a) {
          return this.data.array[a * this.data.stride + this.offset + 2];
        },
        getW: function (a) {
          return this.data.array[a * this.data.stride + this.offset + 3];
        },
        setXY: function (a, b, c) {
          a = a * this.data.stride + this.offset;
          this.data.array[a + 0] = b;
          this.data.array[a + 1] = c;
          return this;
        },
        setXYZ: function (a, b, c, d) {
          a = a * this.data.stride + this.offset;
          this.data.array[a + 0] = b;
          this.data.array[a + 1] = c;
          this.data.array[a + 2] = d;
          return this;
        },
        setXYZW: function (a, b, c, d, e) {
          a = a * this.data.stride + this.offset;
          this.data.array[a + 0] = b;
          this.data.array[a + 1] = c;
          this.data.array[a + 2] = d;
          this.data.array[a + 3] = e;
          return this;
        },
      };
      THREE.Geometry = function () {
        Object.defineProperty(this, "id", { value: THREE.GeometryIdCount++ });
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.type = "Geometry";
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingSphere = this.boundingBox = null;
        this.groupsNeedUpdate =
          this.lineDistancesNeedUpdate =
          this.colorsNeedUpdate =
          this.normalsNeedUpdate =
          this.uvsNeedUpdate =
          this.elementsNeedUpdate =
          this.verticesNeedUpdate =
            !1;
      };
      THREE.Geometry.prototype = {
        constructor: THREE.Geometry,
        applyMatrix: function (a) {
          for (
            var b = new THREE.Matrix3().getNormalMatrix(a),
              c = 0,
              d = this.vertices.length;
            c < d;
            c++
          )
            this.vertices[c].applyMatrix4(a);
          c = 0;
          for (d = this.faces.length; c < d; c++) {
            a = this.faces[c];
            a.normal.applyMatrix3(b).normalize();
            for (var e = 0, f = a.vertexNormals.length; e < f; e++)
              a.vertexNormals[e].applyMatrix3(b).normalize();
          }
          null !== this.boundingBox && this.computeBoundingBox();
          null !== this.boundingSphere && this.computeBoundingSphere();
          this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
        },
        rotateX: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeRotationX(b);
            this.applyMatrix(a);
            return this;
          };
        })(),
        rotateY: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeRotationY(b);
            this.applyMatrix(a);
            return this;
          };
        })(),
        rotateZ: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeRotationZ(b);
            this.applyMatrix(a);
            return this;
          };
        })(),
        translate: (function () {
          var a;
          return function (b, c, d) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeTranslation(b, c, d);
            this.applyMatrix(a);
            return this;
          };
        })(),
        scale: (function () {
          var a;
          return function (b, c, d) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeScale(b, c, d);
            this.applyMatrix(a);
            return this;
          };
        })(),
        lookAt: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Object3D());
            a.lookAt(b);
            a.updateMatrix();
            this.applyMatrix(a.matrix);
          };
        })(),
        fromBufferGeometry: function (a) {
          function b(a, b, d) {
            var e =
                void 0 !== g ? [n[a].clone(), n[b].clone(), n[d].clone()] : [],
              f =
                void 0 !== h
                  ? [
                      c.colors[a].clone(),
                      c.colors[b].clone(),
                      c.colors[d].clone(),
                    ]
                  : [],
              e = new THREE.Face3(a, b, d, e, f);
            c.faces.push(e);
            void 0 !== k &&
              c.faceVertexUvs[0].push([
                p[a].clone(),
                p[b].clone(),
                p[d].clone(),
              ]);
            void 0 !== l &&
              c.faceVertexUvs[1].push([
                m[a].clone(),
                m[b].clone(),
                m[d].clone(),
              ]);
          }
          var c = this,
            d = null !== a.index ? a.index.array : void 0,
            e = a.attributes,
            f = e.position.array,
            g = void 0 !== e.normal ? e.normal.array : void 0,
            h = void 0 !== e.color ? e.color.array : void 0,
            k = void 0 !== e.uv ? e.uv.array : void 0,
            l = void 0 !== e.uv2 ? e.uv2.array : void 0;
          void 0 !== l && (this.faceVertexUvs[1] = []);
          for (
            var n = [], p = [], m = [], q = (e = 0);
            e < f.length;
            e += 3, q += 2
          )
            c.vertices.push(new THREE.Vector3(f[e], f[e + 1], f[e + 2])),
              void 0 !== g &&
                n.push(new THREE.Vector3(g[e], g[e + 1], g[e + 2])),
              void 0 !== h &&
                c.colors.push(new THREE.Color(h[e], h[e + 1], h[e + 2])),
              void 0 !== k && p.push(new THREE.Vector2(k[q], k[q + 1])),
              void 0 !== l && m.push(new THREE.Vector2(l[q], l[q + 1]));
          if (void 0 !== d)
            if (((f = a.groups), 0 < f.length))
              for (e = 0; e < f.length; e++)
                for (
                  var q = f[e], s = q.start, u = q.count, q = s, s = s + u;
                  q < s;
                  q += 3
                )
                  b(d[q], d[q + 1], d[q + 2]);
            else for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]);
          else for (e = 0; e < f.length / 3; e += 3) b(e, e + 1, e + 2);
          this.computeFaceNormals();
          null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
          null !== a.boundingSphere &&
            (this.boundingSphere = a.boundingSphere.clone());
          return this;
        },
        center: function () {
          this.computeBoundingBox();
          var a = this.boundingBox.center().negate();
          this.translate(a.x, a.y, a.z);
          return a;
        },
        normalize: function () {
          this.computeBoundingSphere();
          var a = this.boundingSphere.center,
            b = this.boundingSphere.radius,
            b = 0 === b ? 1 : 1 / b,
            c = new THREE.Matrix4();
          c.set(
            b,
            0,
            0,
            -b * a.x,
            0,
            b,
            0,
            -b * a.y,
            0,
            0,
            b,
            -b * a.z,
            0,
            0,
            0,
            1
          );
          this.applyMatrix(c);
          return this;
        },
        computeFaceNormals: function () {
          for (
            var a = new THREE.Vector3(),
              b = new THREE.Vector3(),
              c = 0,
              d = this.faces.length;
            c < d;
            c++
          ) {
            var e = this.faces[c],
              f = this.vertices[e.a],
              g = this.vertices[e.b];
            a.subVectors(this.vertices[e.c], g);
            b.subVectors(f, g);
            a.cross(b);
            a.normalize();
            e.normal.copy(a);
          }
        },
        computeVertexNormals: function (a) {
          void 0 === a && (a = !0);
          var b, c, d;
          d = Array(this.vertices.length);
          b = 0;
          for (c = this.vertices.length; b < c; b++) d[b] = new THREE.Vector3();
          if (a) {
            var e,
              f,
              g,
              h = new THREE.Vector3(),
              k = new THREE.Vector3();
            a = 0;
            for (b = this.faces.length; a < b; a++)
              (c = this.faces[a]),
                (e = this.vertices[c.a]),
                (f = this.vertices[c.b]),
                (g = this.vertices[c.c]),
                h.subVectors(g, f),
                k.subVectors(e, f),
                h.cross(k),
                d[c.a].add(h),
                d[c.b].add(h),
                d[c.c].add(h);
          } else
            for (a = 0, b = this.faces.length; a < b; a++)
              (c = this.faces[a]),
                d[c.a].add(c.normal),
                d[c.b].add(c.normal),
                d[c.c].add(c.normal);
          b = 0;
          for (c = this.vertices.length; b < c; b++) d[b].normalize();
          a = 0;
          for (b = this.faces.length; a < b; a++)
            (c = this.faces[a]),
              (e = c.vertexNormals),
              3 === e.length
                ? (e[0].copy(d[c.a]), e[1].copy(d[c.b]), e[2].copy(d[c.c]))
                : ((e[0] = d[c.a].clone()),
                  (e[1] = d[c.b].clone()),
                  (e[2] = d[c.c].clone()));
          0 < this.faces.length && (this.normalsNeedUpdate = !0);
        },
        computeMorphNormals: function () {
          var a, b, c, d, e;
          c = 0;
          for (d = this.faces.length; c < d; c++)
            for (
              e = this.faces[c],
                e.__originalFaceNormal
                  ? e.__originalFaceNormal.copy(e.normal)
                  : (e.__originalFaceNormal = e.normal.clone()),
                e.__originalVertexNormals || (e.__originalVertexNormals = []),
                a = 0,
                b = e.vertexNormals.length;
              a < b;
              a++
            )
              e.__originalVertexNormals[a]
                ? e.__originalVertexNormals[a].copy(e.vertexNormals[a])
                : (e.__originalVertexNormals[a] = e.vertexNormals[a].clone());
          var f = new THREE.Geometry();
          f.faces = this.faces;
          a = 0;
          for (b = this.morphTargets.length; a < b; a++) {
            if (!this.morphNormals[a]) {
              this.morphNormals[a] = {};
              this.morphNormals[a].faceNormals = [];
              this.morphNormals[a].vertexNormals = [];
              e = this.morphNormals[a].faceNormals;
              var g = this.morphNormals[a].vertexNormals,
                h,
                k;
              c = 0;
              for (d = this.faces.length; c < d; c++)
                (h = new THREE.Vector3()),
                  (k = {
                    a: new THREE.Vector3(),
                    b: new THREE.Vector3(),
                    c: new THREE.Vector3(),
                  }),
                  e.push(h),
                  g.push(k);
            }
            g = this.morphNormals[a];
            f.vertices = this.morphTargets[a].vertices;
            f.computeFaceNormals();
            f.computeVertexNormals();
            c = 0;
            for (d = this.faces.length; c < d; c++)
              (e = this.faces[c]),
                (h = g.faceNormals[c]),
                (k = g.vertexNormals[c]),
                h.copy(e.normal),
                k.a.copy(e.vertexNormals[0]),
                k.b.copy(e.vertexNormals[1]),
                k.c.copy(e.vertexNormals[2]);
          }
          c = 0;
          for (d = this.faces.length; c < d; c++)
            (e = this.faces[c]),
              (e.normal = e.__originalFaceNormal),
              (e.vertexNormals = e.__originalVertexNormals);
        },
        computeTangents: function () {
          console.warn("THREE.Geometry: .computeTangents() has been removed.");
        },
        computeLineDistances: function () {
          for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++)
            0 < c && (a += b[c].distanceTo(b[c - 1])),
              (this.lineDistances[c] = a);
        },
        computeBoundingBox: function () {
          null === this.boundingBox && (this.boundingBox = new THREE.Box3());
          this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function () {
          null === this.boundingSphere &&
            (this.boundingSphere = new THREE.Sphere());
          this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function (a, b, c) {
          if (!1 === a instanceof THREE.Geometry)
            console.error(
              "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
              a
            );
          else {
            var d,
              e = this.vertices.length,
              f = this.vertices,
              g = a.vertices,
              h = this.faces,
              k = a.faces,
              l = this.faceVertexUvs[0];
            a = a.faceVertexUvs[0];
            void 0 === c && (c = 0);
            void 0 !== b && (d = new THREE.Matrix3().getNormalMatrix(b));
            for (var n = 0, p = g.length; n < p; n++) {
              var m = g[n].clone();
              void 0 !== b && m.applyMatrix4(b);
              f.push(m);
            }
            n = 0;
            for (p = k.length; n < p; n++) {
              var g = k[n],
                q,
                s = g.vertexNormals,
                u = g.vertexColors,
                m = new THREE.Face3(g.a + e, g.b + e, g.c + e);
              m.normal.copy(g.normal);
              void 0 !== d && m.normal.applyMatrix3(d).normalize();
              b = 0;
              for (f = s.length; b < f; b++)
                (q = s[b].clone()),
                  void 0 !== d && q.applyMatrix3(d).normalize(),
                  m.vertexNormals.push(q);
              m.color.copy(g.color);
              b = 0;
              for (f = u.length; b < f; b++)
                (q = u[b]), m.vertexColors.push(q.clone());
              m.materialIndex = g.materialIndex + c;
              h.push(m);
            }
            n = 0;
            for (p = a.length; n < p; n++)
              if (((c = a[n]), (d = []), void 0 !== c)) {
                b = 0;
                for (f = c.length; b < f; b++) d.push(c[b].clone());
                l.push(d);
              }
          }
        },
        mergeMesh: function (a) {
          !1 === a instanceof THREE.Mesh
            ? console.error(
                "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
                a
              )
            : (a.matrixAutoUpdate && a.updateMatrix(),
              this.merge(a.geometry, a.matrix));
        },
        mergeVertices: function () {
          var a = {},
            b = [],
            c = [],
            d,
            e = Math.pow(10, 4),
            f,
            g;
          f = 0;
          for (g = this.vertices.length; f < g; f++)
            (d = this.vertices[f]),
              (d =
                Math.round(d.x * e) +
                "_" +
                Math.round(d.y * e) +
                "_" +
                Math.round(d.z * e)),
              void 0 === a[d]
                ? ((a[d] = f), b.push(this.vertices[f]), (c[f] = b.length - 1))
                : (c[f] = c[a[d]]);
          a = [];
          f = 0;
          for (g = this.faces.length; f < g; f++)
            for (
              e = this.faces[f],
                e.a = c[e.a],
                e.b = c[e.b],
                e.c = c[e.c],
                e = [e.a, e.b, e.c],
                d = 0;
              3 > d;
              d++
            )
              if (e[d] === e[(d + 1) % 3]) {
                a.push(f);
                break;
              }
          for (f = a.length - 1; 0 <= f; f--)
            for (
              e = a[f],
                this.faces.splice(e, 1),
                c = 0,
                g = this.faceVertexUvs.length;
              c < g;
              c++
            )
              this.faceVertexUvs[c].splice(e, 1);
          f = this.vertices.length - b.length;
          this.vertices = b;
          return f;
        },
        sortFacesByMaterialIndex: function () {
          for (var a = this.faces, b = a.length, c = 0; c < b; c++)
            a[c]._id = c;
          a.sort(function (a, b) {
            return a.materialIndex - b.materialIndex;
          });
          var d = this.faceVertexUvs[0],
            e = this.faceVertexUvs[1],
            f,
            g;
          d && d.length === b && (f = []);
          e && e.length === b && (g = []);
          for (c = 0; c < b; c++) {
            var h = a[c]._id;
            f && f.push(d[h]);
            g && g.push(e[h]);
          }
          f && (this.faceVertexUvs[0] = f);
          g && (this.faceVertexUvs[1] = g);
        },
        toJSON: function () {
          function a(a, b, c) {
            return c ? a | (1 << b) : a & ~(1 << b);
          }
          function b(a) {
            var b = a.x.toString() + a.y.toString() + a.z.toString();
            if (void 0 !== l[b]) return l[b];
            l[b] = k.length / 3;
            k.push(a.x, a.y, a.z);
            return l[b];
          }
          function c(a) {
            var b = a.r.toString() + a.g.toString() + a.b.toString();
            if (void 0 !== p[b]) return p[b];
            p[b] = n.length;
            n.push(a.getHex());
            return p[b];
          }
          function d(a) {
            var b = a.x.toString() + a.y.toString();
            if (void 0 !== q[b]) return q[b];
            q[b] = m.length / 2;
            m.push(a.x, a.y);
            return q[b];
          }
          var e = {
            metadata: {
              version: 4.4,
              type: "Geometry",
              generator: "Geometry.toJSON",
            },
          };
          e.uuid = this.uuid;
          e.type = this.type;
          "" !== this.name && (e.name = this.name);
          if (void 0 !== this.parameters) {
            var f = this.parameters,
              g;
            for (g in f) void 0 !== f[g] && (e[g] = f[g]);
            return e;
          }
          f = [];
          for (g = 0; g < this.vertices.length; g++) {
            var h = this.vertices[g];
            f.push(h.x, h.y, h.z);
          }
          var h = [],
            k = [],
            l = {},
            n = [],
            p = {},
            m = [],
            q = {};
          for (g = 0; g < this.faces.length; g++) {
            var s = this.faces[g],
              u = void 0 !== this.faceVertexUvs[0][g],
              t = 0 < s.normal.length(),
              x = 0 < s.vertexNormals.length,
              v = 1 !== s.color.r || 1 !== s.color.g || 1 !== s.color.b,
              C = 0 < s.vertexColors.length,
              w = 0,
              w = a(w, 0, 0),
              w = a(w, 1, !0),
              w = a(w, 2, !1),
              w = a(w, 3, u),
              w = a(w, 4, t),
              w = a(w, 5, x),
              w = a(w, 6, v),
              w = a(w, 7, C);
            h.push(w);
            h.push(s.a, s.b, s.c);
            h.push(s.materialIndex);
            u &&
              ((u = this.faceVertexUvs[0][g]),
              h.push(d(u[0]), d(u[1]), d(u[2])));
            t && h.push(b(s.normal));
            x && ((t = s.vertexNormals), h.push(b(t[0]), b(t[1]), b(t[2])));
            v && h.push(c(s.color));
            C && ((s = s.vertexColors), h.push(c(s[0]), c(s[1]), c(s[2])));
          }
          e.data = {};
          e.data.vertices = f;
          e.data.normals = k;
          0 < n.length && (e.data.colors = n);
          0 < m.length && (e.data.uvs = [m]);
          e.data.faces = h;
          return e;
        },
        clone: function () {
          return new THREE.Geometry().copy(this);
        },
        copy: function (a) {
          this.vertices = [];
          this.faces = [];
          this.faceVertexUvs = [[]];
          for (var b = a.vertices, c = 0, d = b.length; c < d; c++)
            this.vertices.push(b[c].clone());
          b = a.faces;
          c = 0;
          for (d = b.length; c < d; c++) this.faces.push(b[c].clone());
          c = 0;
          for (d = a.faceVertexUvs.length; c < d; c++) {
            b = a.faceVertexUvs[c];
            void 0 === this.faceVertexUvs[c] && (this.faceVertexUvs[c] = []);
            for (var e = 0, f = b.length; e < f; e++) {
              for (var g = b[e], h = [], k = 0, l = g.length; k < l; k++)
                h.push(g[k].clone());
              this.faceVertexUvs[c].push(h);
            }
          }
          return this;
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      };
      THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
      THREE.GeometryIdCount = 0;
      THREE.DirectGeometry = function () {
        Object.defineProperty(this, "id", { value: THREE.GeometryIdCount++ });
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.type = "DirectGeometry";
        this.indices = [];
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {};
        this.skinWeights = [];
        this.skinIndices = [];
        this.boundingSphere = this.boundingBox = null;
        this.groupsNeedUpdate =
          this.uvsNeedUpdate =
          this.colorsNeedUpdate =
          this.normalsNeedUpdate =
          this.verticesNeedUpdate =
            !1;
      };
      THREE.DirectGeometry.prototype = {
        constructor: THREE.DirectGeometry,
        computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
        computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
        computeFaceNormals: function () {
          console.warn(
            "THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry."
          );
        },
        computeVertexNormals: function () {
          console.warn(
            "THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry."
          );
        },
        computeGroups: function (a) {
          var b,
            c = [],
            d;
          a = a.faces;
          for (var e = 0; e < a.length; e++) {
            var f = a[e];
            f.materialIndex !== d &&
              ((d = f.materialIndex),
              void 0 !== b && ((b.count = 3 * e - b.start), c.push(b)),
              (b = { start: 3 * e, materialIndex: d }));
          }
          void 0 !== b && ((b.count = 3 * e - b.start), c.push(b));
          this.groups = c;
        },
        fromGeometry: function (a) {
          var b = a.faces,
            c = a.vertices,
            d = a.faceVertexUvs,
            e = d[0] && 0 < d[0].length,
            f = d[1] && 0 < d[1].length,
            g = a.morphTargets,
            h = g.length,
            k;
          if (0 < h) {
            k = [];
            for (var l = 0; l < h; l++) k[l] = [];
            this.morphTargets.position = k;
          }
          var n = a.morphNormals,
            p = n.length,
            m;
          if (0 < p) {
            m = [];
            for (l = 0; l < p; l++) m[l] = [];
            this.morphTargets.normal = m;
          }
          for (
            var q = a.skinIndices,
              s = a.skinWeights,
              u = q.length === c.length,
              t = s.length === c.length,
              l = 0;
            l < b.length;
            l++
          ) {
            var x = b[l];
            this.vertices.push(c[x.a], c[x.b], c[x.c]);
            var v = x.vertexNormals;
            3 === v.length
              ? this.normals.push(v[0], v[1], v[2])
              : ((v = x.normal), this.normals.push(v, v, v));
            v = x.vertexColors;
            3 === v.length
              ? this.colors.push(v[0], v[1], v[2])
              : ((v = x.color), this.colors.push(v, v, v));
            !0 === e &&
              ((v = d[0][l]),
              void 0 !== v
                ? this.uvs.push(v[0], v[1], v[2])
                : (console.warn(
                    "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                    l
                  ),
                  this.uvs.push(
                    new THREE.Vector2(),
                    new THREE.Vector2(),
                    new THREE.Vector2()
                  )));
            !0 === f &&
              ((v = d[1][l]),
              void 0 !== v
                ? this.uvs2.push(v[0], v[1], v[2])
                : (console.warn(
                    "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                    l
                  ),
                  this.uvs2.push(
                    new THREE.Vector2(),
                    new THREE.Vector2(),
                    new THREE.Vector2()
                  )));
            for (v = 0; v < h; v++) {
              var C = g[v].vertices;
              k[v].push(C[x.a], C[x.b], C[x.c]);
            }
            for (v = 0; v < p; v++)
              (C = n[v].vertexNormals[l]), m[v].push(C.a, C.b, C.c);
            u && this.skinIndices.push(q[x.a], q[x.b], q[x.c]);
            t && this.skinWeights.push(s[x.a], s[x.b], s[x.c]);
          }
          this.computeGroups(a);
          this.verticesNeedUpdate = a.verticesNeedUpdate;
          this.normalsNeedUpdate = a.normalsNeedUpdate;
          this.colorsNeedUpdate = a.colorsNeedUpdate;
          this.uvsNeedUpdate = a.uvsNeedUpdate;
          this.groupsNeedUpdate = a.groupsNeedUpdate;
          return this;
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      };
      THREE.EventDispatcher.prototype.apply(THREE.DirectGeometry.prototype);
      THREE.BufferGeometry = function () {
        Object.defineProperty(this, "id", { value: THREE.GeometryIdCount++ });
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingSphere = this.boundingBox = null;
        this.drawRange = { start: 0, count: Infinity };
      };
      THREE.BufferGeometry.prototype = {
        constructor: THREE.BufferGeometry,
        getIndex: function () {
          return this.index;
        },
        setIndex: function (a) {
          this.index = a;
        },
        addAttribute: function (a, b, c) {
          if (
            !1 === b instanceof THREE.BufferAttribute &&
            !1 === b instanceof THREE.InterleavedBufferAttribute
          )
            console.warn(
              "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
            ),
              this.addAttribute(a, new THREE.BufferAttribute(b, c));
          else if ("index" === a)
            console.warn(
              "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
            ),
              this.setIndex(b);
          else return (this.attributes[a] = b), this;
        },
        getAttribute: function (a) {
          return this.attributes[a];
        },
        removeAttribute: function (a) {
          delete this.attributes[a];
          return this;
        },
        addGroup: function (a, b, c) {
          this.groups.push({
            start: a,
            count: b,
            materialIndex: void 0 !== c ? c : 0,
          });
        },
        clearGroups: function () {
          this.groups = [];
        },
        setDrawRange: function (a, b) {
          this.drawRange.start = a;
          this.drawRange.count = b;
        },
        applyMatrix: function (a) {
          var b = this.attributes.position;
          void 0 !== b &&
            (a.applyToVector3Array(b.array), (b.needsUpdate = !0));
          b = this.attributes.normal;
          void 0 !== b &&
            (new THREE.Matrix3()
              .getNormalMatrix(a)
              .applyToVector3Array(b.array),
            (b.needsUpdate = !0));
          null !== this.boundingBox && this.computeBoundingBox();
          null !== this.boundingSphere && this.computeBoundingSphere();
        },
        rotateX: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeRotationX(b);
            this.applyMatrix(a);
            return this;
          };
        })(),
        rotateY: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeRotationY(b);
            this.applyMatrix(a);
            return this;
          };
        })(),
        rotateZ: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeRotationZ(b);
            this.applyMatrix(a);
            return this;
          };
        })(),
        translate: (function () {
          var a;
          return function (b, c, d) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeTranslation(b, c, d);
            this.applyMatrix(a);
            return this;
          };
        })(),
        scale: (function () {
          var a;
          return function (b, c, d) {
            void 0 === a && (a = new THREE.Matrix4());
            a.makeScale(b, c, d);
            this.applyMatrix(a);
            return this;
          };
        })(),
        lookAt: (function () {
          var a;
          return function (b) {
            void 0 === a && (a = new THREE.Object3D());
            a.lookAt(b);
            a.updateMatrix();
            this.applyMatrix(a.matrix);
          };
        })(),
        center: function () {
          this.computeBoundingBox();
          var a = this.boundingBox.center().negate();
          this.translate(a.x, a.y, a.z);
          return a;
        },
        setFromObject: function (a) {
          var b = a.geometry;
          if (a instanceof THREE.Points || a instanceof THREE.Line) {
            a = new THREE.Float32Attribute(3 * b.vertices.length, 3);
            var c = new THREE.Float32Attribute(3 * b.colors.length, 3);
            this.addAttribute("position", a.copyVector3sArray(b.vertices));
            this.addAttribute("color", c.copyColorsArray(b.colors));
            b.lineDistances &&
              b.lineDistances.length === b.vertices.length &&
              ((a = new THREE.Float32Attribute(b.lineDistances.length, 1)),
              this.addAttribute("lineDistance", a.copyArray(b.lineDistances)));
            null !== b.boundingSphere &&
              (this.boundingSphere = b.boundingSphere.clone());
            null !== b.boundingBox &&
              (this.boundingBox = b.boundingBox.clone());
          } else
            a instanceof THREE.Mesh &&
              b instanceof THREE.Geometry &&
              this.fromGeometry(b);
          return this;
        },
        updateFromObject: function (a) {
          var b = a.geometry;
          if (a instanceof THREE.Mesh) {
            var c = b.__directGeometry;
            if (void 0 === c) return this.fromGeometry(b);
            c.verticesNeedUpdate = b.verticesNeedUpdate;
            c.normalsNeedUpdate = b.normalsNeedUpdate;
            c.colorsNeedUpdate = b.colorsNeedUpdate;
            c.uvsNeedUpdate = b.uvsNeedUpdate;
            c.groupsNeedUpdate = b.groupsNeedUpdate;
            b.verticesNeedUpdate = !1;
            b.normalsNeedUpdate = !1;
            b.colorsNeedUpdate = !1;
            b.uvsNeedUpdate = !1;
            b.groupsNeedUpdate = !1;
            b = c;
          }
          !0 === b.verticesNeedUpdate &&
            ((c = this.attributes.position),
            void 0 !== c &&
              (c.copyVector3sArray(b.vertices), (c.needsUpdate = !0)),
            (b.verticesNeedUpdate = !1));
          !0 === b.normalsNeedUpdate &&
            ((c = this.attributes.normal),
            void 0 !== c &&
              (c.copyVector3sArray(b.normals), (c.needsUpdate = !0)),
            (b.normalsNeedUpdate = !1));
          !0 === b.colorsNeedUpdate &&
            ((c = this.attributes.color),
            void 0 !== c && (c.copyColorsArray(b.colors), (c.needsUpdate = !0)),
            (b.colorsNeedUpdate = !1));
          b.uvsNeedUpdate &&
            ((c = this.attributes.uv),
            void 0 !== c && (c.copyVector2sArray(b.uvs), (c.needsUpdate = !0)),
            (b.uvsNeedUpdate = !1));
          b.lineDistancesNeedUpdate &&
            ((c = this.attributes.lineDistance),
            void 0 !== c &&
              (c.copyArray(b.lineDistances), (c.needsUpdate = !0)),
            (b.lineDistancesNeedUpdate = !1));
          b.groupsNeedUpdate &&
            (b.computeGroups(a.geometry),
            (this.groups = b.groups),
            (b.groupsNeedUpdate = !1));
          return this;
        },
        fromGeometry: function (a) {
          a.__directGeometry = new THREE.DirectGeometry().fromGeometry(a);
          return this.fromDirectGeometry(a.__directGeometry);
        },
        fromDirectGeometry: function (a) {
          var b = new Float32Array(3 * a.vertices.length);
          this.addAttribute(
            "position",
            new THREE.BufferAttribute(b, 3).copyVector3sArray(a.vertices)
          );
          0 < a.normals.length &&
            ((b = new Float32Array(3 * a.normals.length)),
            this.addAttribute(
              "normal",
              new THREE.BufferAttribute(b, 3).copyVector3sArray(a.normals)
            ));
          0 < a.colors.length &&
            ((b = new Float32Array(3 * a.colors.length)),
            this.addAttribute(
              "color",
              new THREE.BufferAttribute(b, 3).copyColorsArray(a.colors)
            ));
          0 < a.uvs.length &&
            ((b = new Float32Array(2 * a.uvs.length)),
            this.addAttribute(
              "uv",
              new THREE.BufferAttribute(b, 2).copyVector2sArray(a.uvs)
            ));
          0 < a.uvs2.length &&
            ((b = new Float32Array(2 * a.uvs2.length)),
            this.addAttribute(
              "uv2",
              new THREE.BufferAttribute(b, 2).copyVector2sArray(a.uvs2)
            ));
          0 < a.indices.length &&
            ((b = new (65535 < a.vertices.length ? Uint32Array : Uint16Array)(
              3 * a.indices.length
            )),
            this.setIndex(
              new THREE.BufferAttribute(b, 1).copyIndicesArray(a.indices)
            ));
          this.groups = a.groups;
          for (var c in a.morphTargets) {
            for (
              var b = [], d = a.morphTargets[c], e = 0, f = d.length;
              e < f;
              e++
            ) {
              var g = d[e],
                h = new THREE.Float32Attribute(3 * g.length, 3);
              b.push(h.copyVector3sArray(g));
            }
            this.morphAttributes[c] = b;
          }
          0 < a.skinIndices.length &&
            ((c = new THREE.Float32Attribute(4 * a.skinIndices.length, 4)),
            this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices)));
          0 < a.skinWeights.length &&
            ((c = new THREE.Float32Attribute(4 * a.skinWeights.length, 4)),
            this.addAttribute(
              "skinWeight",
              c.copyVector4sArray(a.skinWeights)
            ));
          null !== a.boundingSphere &&
            (this.boundingSphere = a.boundingSphere.clone());
          null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
          return this;
        },
        computeBoundingBox: (function () {
          new THREE.Vector3();
          return function () {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3());
            var a = this.attributes.position.array;
            a && this.boundingBox.setFromArray(a);
            if (void 0 === a || 0 === a.length)
              this.boundingBox.min.set(0, 0, 0),
                this.boundingBox.max.set(0, 0, 0);
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
          };
        })(),
        computeBoundingSphere: (function () {
          var a = new THREE.Box3(),
            b = new THREE.Vector3();
          return function () {
            null === this.boundingSphere &&
              (this.boundingSphere = new THREE.Sphere());
            var c = this.attributes.position.array;
            if (c) {
              var d = this.boundingSphere.center;
              a.setFromArray(c);
              a.center(d);
              for (var e = 0, f = 0, g = c.length; f < g; f += 3)
                b.fromArray(c, f), (e = Math.max(e, d.distanceToSquared(b)));
              this.boundingSphere.radius = Math.sqrt(e);
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
            }
          };
        })(),
        computeFaceNormals: function () {},
        computeVertexNormals: function () {
          var a = this.index,
            b = this.attributes,
            c = this.groups;
          if (b.position) {
            var d = b.position.array;
            if (void 0 === b.normal)
              this.addAttribute(
                "normal",
                new THREE.BufferAttribute(new Float32Array(d.length), 3)
              );
            else
              for (var e = b.normal.array, f = 0, g = e.length; f < g; f++)
                e[f] = 0;
            var e = b.normal.array,
              h,
              k,
              l,
              n = new THREE.Vector3(),
              p = new THREE.Vector3(),
              m = new THREE.Vector3(),
              q = new THREE.Vector3(),
              s = new THREE.Vector3();
            if (a) {
              a = a.array;
              0 === c.length && this.addGroup(0, a.length);
              for (var u = 0, t = c.length; u < t; ++u)
                for (
                  f = c[u], g = f.start, h = f.count, f = g, g += h;
                  f < g;
                  f += 3
                )
                  (h = 3 * a[f + 0]),
                    (k = 3 * a[f + 1]),
                    (l = 3 * a[f + 2]),
                    n.fromArray(d, h),
                    p.fromArray(d, k),
                    m.fromArray(d, l),
                    q.subVectors(m, p),
                    s.subVectors(n, p),
                    q.cross(s),
                    (e[h] += q.x),
                    (e[h + 1] += q.y),
                    (e[h + 2] += q.z),
                    (e[k] += q.x),
                    (e[k + 1] += q.y),
                    (e[k + 2] += q.z),
                    (e[l] += q.x),
                    (e[l + 1] += q.y),
                    (e[l + 2] += q.z);
            } else
              for (f = 0, g = d.length; f < g; f += 9)
                n.fromArray(d, f),
                  p.fromArray(d, f + 3),
                  m.fromArray(d, f + 6),
                  q.subVectors(m, p),
                  s.subVectors(n, p),
                  q.cross(s),
                  (e[f] = q.x),
                  (e[f + 1] = q.y),
                  (e[f + 2] = q.z),
                  (e[f + 3] = q.x),
                  (e[f + 4] = q.y),
                  (e[f + 5] = q.z),
                  (e[f + 6] = q.x),
                  (e[f + 7] = q.y),
                  (e[f + 8] = q.z);
            this.normalizeNormals();
            b.normal.needsUpdate = !0;
          }
        },
        merge: function (a, b) {
          if (!1 === a instanceof THREE.BufferGeometry)
            console.error(
              "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
              a
            );
          else {
            void 0 === b && (b = 0);
            var c = this.attributes,
              d;
            for (d in c)
              if (void 0 !== a.attributes[d])
                for (
                  var e = c[d].array,
                    f = a.attributes[d],
                    g = f.array,
                    h = 0,
                    f = f.itemSize * b;
                  h < g.length;
                  h++, f++
                )
                  e[f] = g[h];
            return this;
          }
        },
        normalizeNormals: function () {
          for (
            var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length;
            e < f;
            e += 3
          )
            (b = a[e]),
              (c = a[e + 1]),
              (d = a[e + 2]),
              (b = 1 / Math.sqrt(b * b + c * c + d * d)),
              (a[e] *= b),
              (a[e + 1] *= b),
              (a[e + 2] *= b);
        },
        toNonIndexed: function () {
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
              ),
              this
            );
          var a = new THREE.BufferGeometry(),
            b = this.index.array,
            c = this.attributes,
            d;
          for (d in c) {
            for (
              var e = c[d],
                f = e.array,
                e = e.itemSize,
                g = new f.constructor(b.length * e),
                h = 0,
                k = 0,
                l = 0,
                n = b.length;
              l < n;
              l++
            )
              for (var h = b[l] * e, p = 0; p < e; p++) g[k++] = f[h++];
            a.addAttribute(d, new THREE.BufferAttribute(g, e));
          }
          return a;
        },
        toJSON: function () {
          var a = {
            metadata: {
              version: 4.4,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          a.uuid = this.uuid;
          a.type = this.type;
          "" !== this.name && (a.name = this.name);
          if (void 0 !== this.parameters) {
            var b = this.parameters,
              c;
            for (c in b) void 0 !== b[c] && (a[c] = b[c]);
            return a;
          }
          a.data = { attributes: {} };
          var d = this.index;
          null !== d &&
            ((b = Array.prototype.slice.call(d.array)),
            (a.data.index = { type: d.array.constructor.name, array: b }));
          d = this.attributes;
          for (c in d) {
            var e = d[c],
              b = Array.prototype.slice.call(e.array);
            a.data.attributes[c] = {
              itemSize: e.itemSize,
              type: e.array.constructor.name,
              array: b,
            };
          }
          c = this.groups;
          0 < c.length && (a.data.groups = JSON.parse(JSON.stringify(c)));
          c = this.boundingSphere;
          null !== c &&
            (a.data.boundingSphere = {
              center: c.center.toArray(),
              radius: c.radius,
            });
          return a;
        },
        clone: function () {
          return new THREE.BufferGeometry().copy(this);
        },
        copy: function (a) {
          var b = a.index;
          null !== b && this.setIndex(b.clone());
          var b = a.attributes,
            c;
          for (c in b) this.addAttribute(c, b[c].clone());
          a = a.groups;
          c = 0;
          for (b = a.length; c < b; c++) {
            var d = a[c];
            this.addGroup(d.start, d.count);
          }
          return this;
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      };
      THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
      THREE.BufferGeometry.MaxIndex = 65535;
      THREE.InstancedBufferGeometry = function () {
        THREE.BufferGeometry.call(this);
        this.type = "InstancedBufferGeometry";
        this.maxInstancedCount = void 0;
      };
      THREE.InstancedBufferGeometry.prototype = Object.create(
        THREE.BufferGeometry.prototype
      );
      THREE.InstancedBufferGeometry.prototype.constructor =
        THREE.InstancedBufferGeometry;
      THREE.InstancedBufferGeometry.prototype.addGroup = function (a, b, c) {
        this.groups.push({ start: a, count: b, instances: c });
      };
      THREE.InstancedBufferGeometry.prototype.copy = function (a) {
        var b = a.index;
        null !== b && this.setIndex(b.clone());
        var b = a.attributes,
          c;
        for (c in b) this.addAttribute(c, b[c].clone());
        a = a.groups;
        c = 0;
        for (b = a.length; c < b; c++) {
          var d = a[c];
          this.addGroup(d.start, d.count, d.instances);
        }
        return this;
      };
      THREE.EventDispatcher.prototype.apply(
        THREE.InstancedBufferGeometry.prototype
      );
      THREE.Uniform = function (a, b) {
        this.type = a;
        this.value = b;
        this.dynamic = !1;
      };
      THREE.Uniform.prototype = {
        constructor: THREE.Uniform,
        onUpdate: function (a) {
          this.dynamic = !0;
          this.onUpdateCallback = a;
          return this;
        },
      };
      THREE.AnimationClip = function (a, b, c) {
        this.name = a || THREE.Math.generateUUID();
        this.tracks = c;
        this.duration = void 0 !== b ? b : -1;
        0 > this.duration && this.resetDuration();
        this.trim();
        this.optimize();
      };
      THREE.AnimationClip.prototype = {
        constructor: THREE.AnimationClip,
        resetDuration: function () {
          for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b)
            var d = this.tracks[b],
              a = Math.max(a, d.times[d.times.length - 1]);
          this.duration = a;
        },
        trim: function () {
          for (var a = 0; a < this.tracks.length; a++)
            this.tracks[a].trim(0, this.duration);
          return this;
        },
        optimize: function () {
          for (var a = 0; a < this.tracks.length; a++)
            this.tracks[a].optimize();
          return this;
        },
      };
      Object.assign(THREE.AnimationClip, {
        parse: function (a) {
          for (
            var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length;
            e !== f;
            ++e
          )
            b.push(THREE.KeyframeTrack.parse(c[e]).scale(d));
          return new THREE.AnimationClip(a.name, a.duration, b);
        },
        toJSON: function (a) {
          var b = [],
            c = a.tracks;
          a = { name: a.name, duration: a.duration, tracks: b };
          for (var d = 0, e = c.length; d !== e; ++d)
            b.push(THREE.KeyframeTrack.toJSON(c[d]));
          return a;
        },
        CreateFromMorphTargetSequence: function (a, b, c) {
          for (var d = b.length, e = [], f = 0; f < d; f++) {
            var g = [],
              h = [];
            g.push((f + d - 1) % d, f, (f + 1) % d);
            h.push(0, 1, 0);
            var k = THREE.AnimationUtils.getKeyframeOrder(g),
              g = THREE.AnimationUtils.sortedArray(g, 1, k),
              h = THREE.AnimationUtils.sortedArray(h, 1, k);
            0 === g[0] && (g.push(d), h.push(h[0]));
            e.push(
              new THREE.NumberKeyframeTrack(
                ".morphTargetInfluences[" + b[f].name + "]",
                g,
                h
              ).scale(1 / c)
            );
          }
          return new THREE.AnimationClip(a, -1, e);
        },
        findByName: function (a, b) {
          for (var c = 0; c < a.length; c++) if (a[c].name === b) return a[c];
          return null;
        },
        CreateClipsFromMorphTargetSequences: function (a, b) {
          for (
            var c = {}, d = /^([\w-]*?)([\d]+)$/, e = 0, f = a.length;
            e < f;
            e++
          ) {
            var g = a[e],
              h = g.name.match(d);
            if (h && 1 < h.length) {
              var k = h[1];
              (h = c[k]) || (c[k] = h = []);
              h.push(g);
            }
          }
          d = [];
          for (k in c)
            d.push(
              THREE.AnimationClip.CreateFromMorphTargetSequence(k, c[k], b)
            );
          return d;
        },
        parseAnimation: function (a, b, c) {
          if (!a)
            return console.error("  no animation in JSONLoader data"), null;
          c = function (a, b, c, d, e) {
            if (0 !== c.length) {
              var f = [],
                g = [];
              THREE.AnimationUtils.flattenJSON(c, f, g, d);
              0 !== f.length && e.push(new a(b, f, g));
            }
          };
          var d = [],
            e = a.name || "default",
            f = a.length || -1,
            g = a.fps || 30;
          a = a.hierarchy || [];
          for (var h = 0; h < a.length; h++) {
            var k = a[h].keys;
            if (k && 0 != k.length)
              if (k[0].morphTargets) {
                for (var f = {}, l = 0; l < k.length; l++)
                  if (k[l].morphTargets)
                    for (var n = 0; n < k[l].morphTargets.length; n++)
                      f[k[l].morphTargets[n]] = -1;
                for (var p in f) {
                  for (
                    var m = [], q = [], n = 0;
                    n !== k[l].morphTargets.length;
                    ++n
                  ) {
                    var s = k[l];
                    m.push(s.time);
                    q.push(s.morphTarget === p ? 1 : 0);
                  }
                  d.push(
                    new THREE.NumberKeyframeTrack(
                      ".morphTargetInfluence[" + p + "]",
                      m,
                      q
                    )
                  );
                }
                f = f.length * (g || 1);
              } else
                (l = ".bones[" + b[h].name + "]"),
                  c(THREE.VectorKeyframeTrack, l + ".position", k, "pos", d),
                  c(
                    THREE.QuaternionKeyframeTrack,
                    l + ".quaternion",
                    k,
                    "rot",
                    d
                  ),
                  c(THREE.VectorKeyframeTrack, l + ".scale", k, "scl", d);
          }
          return 0 === d.length ? null : new THREE.AnimationClip(e, f, d);
        },
      });
      THREE.AnimationMixer = function (a) {
        this._root = a;
        this._initMemoryManager();
        this.time = this._accuIndex = 0;
        this.timeScale = 1;
      };
      THREE.AnimationMixer.prototype = {
        constructor: THREE.AnimationMixer,
        clipAction: function (a, b) {
          var c = (b || this._root).uuid,
            d = "string" === typeof a ? a : a.name,
            e = a !== d ? a : null,
            f = this._actionsByClip[d],
            g;
          if (void 0 !== f) {
            g = f.actionByRoot[c];
            if (void 0 !== g) return g;
            g = f.knownActions[0];
            e = g._clip;
            if (a !== d && a !== e)
              throw Error("Different clips with the same name detected!");
          }
          if (null === e) return null;
          f = new THREE.AnimationMixer._Action(this, e, b);
          this._bindAction(f, g);
          this._addInactiveAction(f, d, c);
          return f;
        },
        existingAction: function (a, b) {
          var c = (b || this._root).uuid,
            d = this._actionsByClip["string" === typeof a ? a : a.name];
          return void 0 !== d ? d.actionByRoot[c] || null : null;
        },
        stopAllAction: function () {
          for (
            var a = this._actions,
              b = this._nActiveActions,
              c = this._bindings,
              d = this._nActiveBindings,
              e = (this._nActiveBindings = this._nActiveActions = 0);
            e !== b;
            ++e
          )
            a[e].reset();
          for (e = 0; e !== d; ++e) c[e].useCount = 0;
          return this;
        },
        update: function (a) {
          a *= this.timeScale;
          for (
            var b = this._actions,
              c = this._nActiveActions,
              d = (this.time += a),
              e = Math.sign(a),
              f = (this._accuIndex ^= 1),
              g = 0;
            g !== c;
            ++g
          ) {
            var h = b[g];
            h.enabled && h._update(d, a, e, f);
          }
          a = this._bindings;
          b = this._nActiveBindings;
          for (g = 0; g !== b; ++g) a[g].apply(f);
          return this;
        },
        getRoot: function () {
          return this._root;
        },
        uncacheClip: function (a) {
          var b = this._actions;
          a = a.name;
          var c = this._actionsByClip,
            d = c[a];
          if (void 0 !== d) {
            for (var d = d.knownActions, e = 0, f = d.length; e !== f; ++e) {
              var g = d[e];
              this._deactivateAction(g);
              var h = g._cacheIndex,
                k = b[b.length - 1];
              g._cacheIndex = null;
              g._byClipCacheIndex = null;
              k._cacheIndex = h;
              b[h] = k;
              b.pop();
              this._removeInactiveBindingsForAction(g);
            }
            delete c[a];
          }
        },
        uncacheRoot: function (a) {
          a = a.uuid;
          var b = this._actionsByClip,
            c;
          for (c in b) {
            var d = b[c].actionByRoot[a];
            void 0 !== d &&
              (this._deactivateAction(d), this._removeInactiveAction(d));
          }
          c = this._bindingsByRootAndName[a];
          if (void 0 !== c)
            for (var e in c)
              (a = c[e]),
                a.restoreOriginalState(),
                this._removeInactiveBinding(a);
        },
        uncacheAction: function (a, b) {
          var c = this.existingAction(a, b);
          null !== c &&
            (this._deactivateAction(c), this._removeInactiveAction(c));
        },
      };
      THREE.EventDispatcher.prototype.apply(THREE.AnimationMixer.prototype);
      THREE.AnimationMixer._Action = function (a, b, c) {
        this._mixer = a;
        this._clip = b;
        this._localRoot = c || null;
        a = b.tracks;
        b = a.length;
        c = Array(b);
        for (
          var d = {
              endingStart: THREE.ZeroCurvatureEnding,
              endingEnd: THREE.ZeroCurvatureEnding,
            },
            e = 0;
          e !== b;
          ++e
        ) {
          var f = a[e].createInterpolant(null);
          c[e] = f;
          f.settings = d;
        }
        this._interpolantSettings = d;
        this._interpolants = c;
        this._propertyBindings = Array(b);
        this._weightInterpolant =
          this._timeScaleInterpolant =
          this._byClipCacheIndex =
          this._cacheIndex =
            null;
        this.loop = THREE.LoopRepeat;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this._effectiveWeight =
          this.weight =
          this._effectiveTimeScale =
          this.timeScale =
            1;
        this.repetitions = Infinity;
        this.paused = !1;
        this.enabled = !0;
        this.clampWhenFinished = !1;
        this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
      };
      THREE.AnimationMixer._Action.prototype = {
        constructor: THREE.AnimationMixer._Action,
        play: function () {
          this._mixer._activateAction(this);
          return this;
        },
        stop: function () {
          this._mixer._deactivateAction(this);
          return this.reset();
        },
        reset: function () {
          this.paused = !1;
          this.enabled = !0;
          this.time = 0;
          this._loopCount = -1;
          this._startTime = null;
          return this.stopFading().stopWarping();
        },
        isRunning: function () {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        },
        isScheduled: function () {
          return this._mixer._isActiveAction(this);
        },
        startAt: function (a) {
          this._startTime = a;
          return this;
        },
        setLoop: function (a, b) {
          this.loop = a;
          this.repetitions = b;
          return this;
        },
        setEffectiveWeight: function (a) {
          this.weight = a;
          this._effectiveWeight = this.enabled ? a : 0;
          return this.stopFading();
        },
        getEffectiveWeight: function () {
          return this._effectiveWeight;
        },
        fadeIn: function (a) {
          return this._scheduleFading(a, 0, 1);
        },
        fadeOut: function (a) {
          return this._scheduleFading(a, 1, 0);
        },
        crossFadeFrom: function (a, b, c) {
          a.fadeOut(b);
          this.fadeIn(b);
          if (c) {
            c = this._clip.duration;
            var d = a._clip.duration,
              e = c / d;
            a.warp(1, d / c, b);
            this.warp(e, 1, b);
          }
          return this;
        },
        crossFadeTo: function (a, b, c) {
          return a.crossFadeFrom(this, b, c);
        },
        stopFading: function () {
          var a = this._weightInterpolant;
          null !== a &&
            ((this._weightInterpolant = null),
            this._mixer._takeBackControlInterpolant(a));
          return this;
        },
        setEffectiveTimeScale: function (a) {
          this.timeScale = a;
          this._effectiveTimeScale = this.paused ? 0 : a;
          return this.stopWarping();
        },
        getEffectiveTimeScale: function () {
          return this._effectiveTimeScale;
        },
        setDuration: function (a) {
          this.timeScale = this._clip.duration / a;
          return this.stopWarping();
        },
        syncWith: function (a) {
          this.time = a.time;
          this.timeScale = a.timeScale;
          return this.stopWarping();
        },
        halt: function (a) {
          return this.warp(this._currentTimeScale, 0, a);
        },
        warp: function (a, b, c) {
          var d = this._mixer,
            e = d.time,
            f = this._timeScaleInterpolant,
            g = this.timeScale;
          null === f &&
            (this._timeScaleInterpolant = f = d._lendControlInterpolant());
          d = f.parameterPositions;
          f = f.sampleValues;
          d[0] = e;
          d[1] = e + c;
          f[0] = a / g;
          f[1] = b / g;
          return this;
        },
        stopWarping: function () {
          var a = this._timeScaleInterpolant;
          null !== a &&
            ((this._timeScaleInterpolant = null),
            this._mixer._takeBackControlInterpolant(a));
          return this;
        },
        getMixer: function () {
          return this._mixer;
        },
        getClip: function () {
          return this._clip;
        },
        getRoot: function () {
          return this._localRoot || this._mixer._root;
        },
        _update: function (a, b, c, d) {
          var e = this._startTime;
          if (null !== e) {
            b = (a - e) * c;
            if (0 > b || 0 === c) return;
            this._startTime = null;
            b *= c;
          }
          b *= this._updateTimeScale(a);
          c = this._updateTime(b);
          a = this._updateWeight(a);
          if (0 < a) {
            b = this._interpolants;
            for (
              var e = this._propertyBindings, f = 0, g = b.length;
              f !== g;
              ++f
            )
              b[f].evaluate(c), e[f].accumulate(d, a);
          }
        },
        _updateWeight: function (a) {
          var b = 0;
          if (this.enabled) {
            var b = this.weight,
              c = this._weightInterpolant;
            if (null !== c) {
              var d = c.evaluate(a)[0],
                b = b * d;
              a > c.parameterPositions[1] &&
                (this.stopFading(), 0 === d && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = b);
        },
        _updateTimeScale: function (a) {
          var b = 0;
          if (!this.paused) {
            var b = this.timeScale,
              c = this._timeScaleInterpolant;
            if (null !== c) {
              var d = c.evaluate(a)[0],
                b = b * d;
              a > c.parameterPositions[1] &&
                (this.stopWarping(),
                0 === b ? (this.pause = !0) : (this.timeScale = b));
            }
          }
          return (this._effectiveTimeScale = b);
        },
        _updateTime: function (a) {
          var b = this.time + a;
          if (0 === a) return b;
          var c = this._clip.duration,
            d = this.loop,
            e = this._loopCount,
            f = !1;
          switch (d) {
            case THREE.LoopOnce:
              -1 === e && ((this.loopCount = 0), this._setEndings(!0, !0, !1));
              if (b >= c) b = c;
              else if (0 > b) b = 0;
              else break;
              this.clampWhenFinished ? (this.pause = !0) : (this.enabled = !1);
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: 0 > a ? -1 : 1,
              });
              break;
            case THREE.LoopPingPong:
              f = !0;
            case THREE.LoopRepeat:
              -1 === e &&
                (0 < a
                  ? ((e = 0), this._setEndings(!0, 0 === this.repetitions, f))
                  : this._setEndings(0 === this.repetitions, !0, f));
              if (b >= c || 0 > b) {
                var g = Math.floor(b / c),
                  b = b - c * g,
                  e = e + Math.abs(g),
                  h = this.repetitions - e;
                if (0 > h) {
                  this.clampWhenFinished
                    ? (this.paused = !0)
                    : (this.enabled = !1);
                  b = 0 < a ? c : 0;
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 < a ? 1 : -1,
                  });
                  break;
                } else
                  0 === h
                    ? ((a = 0 > a), this._setEndings(a, !a, f))
                    : this._setEndings(!1, !1, f);
                this._loopCount = e;
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: g,
                });
              }
              if (d === THREE.LoopPingPong && 1 === (e & 1))
                return (this.time = b), c - b;
          }
          return (this.time = b);
        },
        _setEndings: function (a, b, c) {
          var d = this._interpolantSettings;
          c
            ? ((d.endingStart = THREE.ZeroSlopeEnding),
              (d.endingEnd = THREE.ZeroSlopeEnding))
            : ((d.endingStart = a
                ? this.zeroSlopeAtStart
                  ? THREE.ZeroSlopeEnding
                  : THREE.ZeroCurvatureEnding
                : THREE.WrapAroundEnding),
              (d.endingEnd = b
                ? this.zeroSlopeAtEnd
                  ? THREE.ZeroSlopeEnding
                  : THREE.ZeroCurvatureEnding
                : THREE.WrapAroundEnding));
        },
        _scheduleFading: function (a, b, c) {
          var d = this._mixer,
            e = d.time,
            f = this._weightInterpolant;
          null === f &&
            (this._weightInterpolant = f = d._lendControlInterpolant());
          d = f.parameterPositions;
          f = f.sampleValues;
          d[0] = e;
          f[0] = b;
          d[1] = e + a;
          f[1] = c;
          return this;
        },
      };
      Object.assign(THREE.AnimationMixer.prototype, {
        _bindAction: function (a, b) {
          var c = a._localRoot || this._root,
            d = a._clip.tracks,
            e = d.length,
            f = a._propertyBindings,
            g = a._interpolants,
            h = c.uuid,
            k = this._bindingsByRootAndName,
            l = k[h];
          void 0 === l && ((l = {}), (k[h] = l));
          for (k = 0; k !== e; ++k) {
            var n = d[k],
              p = n.name,
              m = l[p];
            if (void 0 === m) {
              m = f[k];
              if (void 0 !== m) {
                null === m._cacheIndex &&
                  (++m.referenceCount, this._addInactiveBinding(m, h, p));
                continue;
              }
              m = new THREE.PropertyMixer(
                THREE.PropertyBinding.create(
                  c,
                  p,
                  b && b._propertyBindings[k].binding.parsedPath
                ),
                n.ValueTypeName,
                n.getValueSize()
              );
              ++m.referenceCount;
              this._addInactiveBinding(m, h, p);
            }
            f[k] = m;
            g[k].resultBuffer = m.buffer;
          }
        },
        _activateAction: function (a) {
          if (!this._isActiveAction(a)) {
            if (null === a._cacheIndex) {
              var b = (a._localRoot || this._root).uuid,
                c = a._clip.name,
                d = this._actionsByClip[c];
              this._bindAction(a, d && d.knownActions[0]);
              this._addInactiveAction(a, c, b);
            }
            b = a._propertyBindings;
            c = 0;
            for (d = b.length; c !== d; ++c) {
              var e = b[c];
              0 === e.useCount++ &&
                (this._lendBinding(e), e.saveOriginalState());
            }
            this._lendAction(a);
          }
        },
        _deactivateAction: function (a) {
          if (this._isActiveAction(a)) {
            for (
              var b = a._propertyBindings, c = 0, d = b.length;
              c !== d;
              ++c
            ) {
              var e = b[c];
              0 === --e.useCount &&
                (e.restoreOriginalState(), this._takeBackBinding(e));
            }
            this._takeBackAction(a);
          }
        },
        _initMemoryManager: function () {
          this._actions = [];
          this._nActiveActions = 0;
          this._actionsByClip = {};
          this._bindings = [];
          this._nActiveBindings = 0;
          this._bindingsByRootAndName = {};
          this._controlInterpolants = [];
          this._nActiveControlInterpolants = 0;
          var a = this;
          this.stats = {
            actions: {
              get total() {
                return a._actions.length;
              },
              get inUse() {
                return a._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return a._bindings.length;
              },
              get inUse() {
                return a._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return a._controlInterpolants.length;
              },
              get inUse() {
                return a._nActiveControlInterpolants;
              },
            },
          };
        },
        _isActiveAction: function (a) {
          a = a._cacheIndex;
          return null !== a && a < this._nActiveActions;
        },
        _addInactiveAction: function (a, b, c) {
          var d = this._actions,
            e = this._actionsByClip,
            f = e[b];
          void 0 === f
            ? ((f = { knownActions: [a], actionByRoot: {} }),
              (a._byClipCacheIndex = 0),
              (e[b] = f))
            : ((b = f.knownActions),
              (a._byClipCacheIndex = b.length),
              b.push(a));
          a._cacheIndex = d.length;
          d.push(a);
          f.actionByRoot[c] = a;
        },
        _removeInactiveAction: function (a) {
          var b = this._actions,
            c = b[b.length - 1],
            d = a._cacheIndex;
          c._cacheIndex = d;
          b[d] = c;
          b.pop();
          a._cacheIndex = null;
          var c = a._clip.name,
            d = this._actionsByClip,
            e = d[c],
            f = e.knownActions,
            g = f[f.length - 1],
            h = a._byClipCacheIndex;
          g._byClipCacheIndex = h;
          f[h] = g;
          f.pop();
          a._byClipCacheIndex = null;
          delete e.actionByRoot[(b._localRoot || this._root).uuid];
          0 === f.length && delete d[c];
          this._removeInactiveBindingsForAction(a);
        },
        _removeInactiveBindingsForAction: function (a) {
          a = a._propertyBindings;
          for (var b = 0, c = a.length; b !== c; ++b) {
            var d = a[b];
            0 === --d.referenceCount && this._removeInactiveBinding(d);
          }
        },
        _lendAction: function (a) {
          var b = this._actions,
            c = a._cacheIndex,
            d = this._nActiveActions++,
            e = b[d];
          a._cacheIndex = d;
          b[d] = a;
          e._cacheIndex = c;
          b[c] = e;
        },
        _takeBackAction: function (a) {
          var b = this._actions,
            c = a._cacheIndex,
            d = --this._nActiveActions,
            e = b[d];
          a._cacheIndex = d;
          b[d] = a;
          e._cacheIndex = c;
          b[c] = e;
        },
        _addInactiveBinding: function (a, b, c) {
          var d = this._bindingsByRootAndName,
            e = d[b],
            f = this._bindings;
          void 0 === e && ((e = {}), (d[b] = e));
          e[c] = a;
          a._cacheIndex = f.length;
          f.push(a);
        },
        _removeInactiveBinding: function (a) {
          var b = this._bindings,
            c = a.binding,
            d = c.rootNode.uuid,
            c = c.path,
            e = this._bindingsByRootAndName,
            f = e[d],
            g = b[b.length - 1];
          a = a._cacheIndex;
          g._cacheIndex = a;
          b[a] = g;
          b.pop();
          delete f[c];
          a: {
            for (var h in f) break a;
            delete e[d];
          }
        },
        _lendBinding: function (a) {
          var b = this._bindings,
            c = a._cacheIndex,
            d = this._nActiveBindings++,
            e = b[d];
          a._cacheIndex = d;
          b[d] = a;
          e._cacheIndex = c;
          b[c] = e;
        },
        _takeBackBinding: function (a) {
          var b = this._bindings,
            c = a._cacheIndex,
            d = --this._nActiveBindings,
            e = b[d];
          a._cacheIndex = d;
          b[d] = a;
          e._cacheIndex = c;
          b[c] = e;
        },
        _lendControlInterpolant: function () {
          var a = this._controlInterpolants,
            b = this._nActiveControlInterpolants++,
            c = a[b];
          void 0 === c &&
            ((c = new THREE.LinearInterpolant(
              new Float32Array(2),
              new Float32Array(2),
              1,
              this._controlInterpolantsResultBuffer
            )),
            (c.__cacheIndex = b),
            (a[b] = c));
          return c;
        },
        _takeBackControlInterpolant: function (a) {
          var b = this._controlInterpolants,
            c = a.__cacheIndex,
            d = --this._nActiveControlInterpolants,
            e = b[d];
          a.__cacheIndex = d;
          b[d] = a;
          e.__cacheIndex = c;
          b[c] = e;
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
      });
      THREE.AnimationObjectGroup = function (a) {
        this.uuid = THREE.Math.generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        var b = {};
        this._indicesByUUID = b;
        for (var c = 0, d = arguments.length; c !== d; ++c)
          b[arguments[c].uuid] = c;
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        var e = this;
        this.stats = {
          objects: {
            get total() {
              return e._objects.length;
            },
            get inUse() {
              return this.total - e.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return e._bindings.length;
          },
        };
      };
      THREE.AnimationObjectGroup.prototype = {
        constructor: THREE.AnimationObjectGroup,
        add: function (a) {
          for (
            var b = this._objects,
              c = b.length,
              d = this.nCachedObjects_,
              e = this._indicesByUUID,
              f = this._paths,
              g = this._parsedPaths,
              h = this._bindings,
              k = h.length,
              l = 0,
              n = arguments.length;
            l !== n;
            ++l
          ) {
            var p = arguments[l],
              m = p.uuid,
              q = e[m];
            if (void 0 === q) {
              q = c++;
              e[m] = q;
              b.push(p);
              for (var m = 0, s = k; m !== s; ++m)
                h[m].push(new THREE.PropertyBinding(p, f[m], g[m]));
            } else if (q < d) {
              var u = b[q],
                t = --d,
                s = b[t];
              e[s.uuid] = q;
              b[q] = s;
              e[m] = t;
              b[t] = p;
              m = 0;
              for (s = k; m !== s; ++m) {
                var x = h[m],
                  v = x[q];
                x[q] = x[t];
                void 0 === v && (v = new THREE.PropertyBinding(p, f[m], g[m]));
                x[t] = v;
              }
            } else
              b[q] !== u &&
                console.error(
                  "Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes..."
                );
          }
          this.nCachedObjects_ = d;
        },
        remove: function (a) {
          for (
            var b = this._objects,
              c = this.nCachedObjects_,
              d = this._indicesByUUID,
              e = this._bindings,
              f = e.length,
              g = 0,
              h = arguments.length;
            g !== h;
            ++g
          ) {
            var k = arguments[g],
              l = k.uuid,
              n = d[l];
            if (void 0 !== n && n >= c) {
              var p = c++,
                m = b[p];
              d[m.uuid] = n;
              b[n] = m;
              d[l] = p;
              b[p] = k;
              k = 0;
              for (l = f; k !== l; ++k) {
                var m = e[k],
                  q = m[n];
                m[n] = m[p];
                m[p] = q;
              }
            }
          }
          this.nCachedObjects_ = c;
        },
        uncache: function (a) {
          for (
            var b = this._objects,
              c = b.length,
              d = this.nCachedObjects_,
              e = this._indicesByUUID,
              f = this._bindings,
              g = f.length,
              h = 0,
              k = arguments.length;
            h !== k;
            ++h
          ) {
            var l = arguments[h].uuid,
              n = e[l];
            if (void 0 !== n)
              if ((delete e[l], n < d)) {
                var l = --d,
                  p = b[l],
                  m = --c,
                  q = b[m];
                e[p.uuid] = n;
                b[n] = p;
                e[q.uuid] = l;
                b[l] = q;
                b.pop();
                p = 0;
                for (q = g; p !== q; ++p) {
                  var s = f[p],
                    u = s[m];
                  s[n] = s[l];
                  s[l] = u;
                  s.pop();
                }
              } else
                for (
                  m = --c,
                    q = b[m],
                    e[q.uuid] = n,
                    b[n] = q,
                    b.pop(),
                    p = 0,
                    q = g;
                  p !== q;
                  ++p
                )
                  (s = f[p]), (s[n] = s[m]), s.pop();
          }
          this.nCachedObjects_ = d;
        },
        subscribe_: function (a, b) {
          var c = this._bindingsIndicesByPath,
            d = c[a],
            e = this._bindings;
          if (void 0 !== d) return e[d];
          var f = this._paths,
            g = this._parsedPaths,
            h = this._objects,
            k = this.nCachedObjects_,
            l = Array(h.length),
            d = e.length;
          c[a] = d;
          f.push(a);
          g.push(b);
          e.push(l);
          c = k;
          for (d = h.length; c !== d; ++c)
            l[c] = new THREE.PropertyBinding(h[c], a, b);
          return l;
        },
        unsubscribe_: function (a) {
          var b = this._bindingsIndicesByPath,
            c = b[a];
          if (void 0 !== c) {
            var d = this._paths,
              e = this._parsedPaths,
              f = this._bindings,
              g = f.length - 1,
              h = f[g];
            b[a[g]] = c;
            f[c] = h;
            f.pop();
            e[c] = e[g];
            e.pop();
            d[c] = d[g];
            d.pop();
          }
        },
      };
      THREE.AnimationUtils = {
        arraySlice: function (a, b, c) {
          return THREE.AnimationUtils.isTypedArray(a)
            ? new a.constructor(a.subarray(b, c))
            : a.slice(b, c);
        },
        convertArray: function (a, b, c) {
          return !a || (!c && a.constructor === b)
            ? a
            : "number" === typeof b.BYTES_PER_ELEMENT
            ? new b(a)
            : Array.prototype.slice.call(a);
        },
        isTypedArray: function (a) {
          return ArrayBuffer.isView(a) && !(a instanceof DataView);
        },
        getKeyframeOrder: function (a) {
          for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
          c.sort(function (b, c) {
            return a[b] - a[c];
          });
          return c;
        },
        sortedArray: function (a, b, c) {
          for (
            var d = a.length, e = new a.constructor(d), f = 0, g = 0;
            g !== d;
            ++f
          )
            for (var h = c[f] * b, k = 0; k !== b; ++k) e[g++] = a[h + k];
          return e;
        },
        flattenJSON: function (a, b, c, d) {
          for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d]; )
            f = a[e++];
          if (void 0 !== f) {
            var g = f[d];
            if (void 0 !== g)
              if (Array.isArray(g)) {
                do
                  (g = f[d]),
                    void 0 !== g && (b.push(f.time), c.push.apply(c, g)),
                    (f = a[e++]);
                while (void 0 !== f);
              } else if (void 0 !== g.toArray) {
                do
                  (g = f[d]),
                    void 0 !== g && (b.push(f.time), g.toArray(c, c.length)),
                    (f = a[e++]);
                while (void 0 !== f);
              } else {
                do
                  (g = f[d]),
                    void 0 !== g && (b.push(f.time), c.push(g)),
                    (f = a[e++]);
                while (void 0 !== f);
              }
          }
        },
      };
      THREE.KeyframeTrack = function (a, b, c, d) {
        if (void 0 === a) throw Error("track name is undefined");
        if (void 0 === b || 0 === b.length)
          throw Error("no keyframes in track named " + a);
        this.name = a;
        this.times = THREE.AnimationUtils.convertArray(b, this.TimeBufferType);
        this.values = THREE.AnimationUtils.convertArray(
          c,
          this.ValueBufferType
        );
        this.setInterpolation(d || this.DefaultInterpolation);
        this.validate();
        this.optimize();
      };
      THREE.KeyframeTrack.prototype = {
        constructor: THREE.KeyframeTrack,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: THREE.InterpolateLinear,
        InterpolantFactoryMethodDiscrete: function (a) {
          return new THREE.DiscreteInterpolant(
            this.times,
            this.values,
            this.getValueSize(),
            a
          );
        },
        InterpolantFactoryMethodLinear: function (a) {
          return new THREE.LinearInterpolant(
            this.times,
            this.values,
            this.getValueSize(),
            a
          );
        },
        InterpolantFactoryMethodSmooth: function (a) {
          return new THREE.CubicInterpolant(
            this.times,
            this.values,
            this.getValueSize(),
            a
          );
        },
        setInterpolation: function (a) {
          var b = void 0;
          switch (a) {
            case THREE.InterpolateDiscrete:
              b = this.InterpolantFactoryMethodDiscrete;
              break;
            case THREE.InterpolateLinear:
              b = this.InterpolantFactoryMethodLinear;
              break;
            case THREE.InterpolateSmooth:
              b = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === b) {
            b =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant)
              if (a !== this.DefaultInterpolation)
                this.setInterpolation(this.DefaultInterpolation);
              else throw Error(b);
            console.warn(b);
          } else this.createInterpolant = b;
        },
        getInterpolation: function () {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return THREE.InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
              return THREE.InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
              return THREE.InterpolateSmooth;
          }
        },
        getValueSize: function () {
          return this.values.length / this.times.length;
        },
        shift: function (a) {
          if (0 !== a)
            for (var b = this.times, c = 0, d = b.length; c !== d; ++c)
              b[c] += a;
          return this;
        },
        scale: function (a) {
          if (1 !== a)
            for (var b = this.times, c = 0, d = b.length; c !== d; ++c)
              b[c] *= a;
          return this;
        },
        trim: function (a, b) {
          for (
            var c = this.times, d = c.length, e = 0, f = d - 1;
            e !== d && c[e] < a;

          )
            ++e;
          for (; -1 !== f && c[f] > b; ) --f;
          ++f;
          if (0 !== e || f !== d)
            e >= f && ((f = Math.max(f, 1)), (e = f - 1)),
              (d = this.getValueSize()),
              (this.times = THREE.AnimationUtils.arraySlice(c, e, f)),
              (this.values = THREE.AnimationUtils.arraySlice(
                this.values,
                e * d,
                f * d
              ));
          return this;
        },
        validate: function () {
          var a = !0,
            b = this.getValueSize();
          0 !== b - Math.floor(b) &&
            (console.error("invalid value size in track", this), (a = !1));
          var c = this.times,
            b = this.values,
            d = c.length;
          0 === d && (console.error("track is empty", this), (a = !1));
          for (var e = null, f = 0; f !== d; f++) {
            var g = c[f];
            if ("number" === typeof g && isNaN(g)) {
              console.error("time is not a valid number", this, f, g);
              a = !1;
              break;
            }
            if (null !== e && e > g) {
              console.error("out of order keys", this, f, g, e);
              a = !1;
              break;
            }
            e = g;
          }
          if (void 0 !== b && THREE.AnimationUtils.isTypedArray(b))
            for (f = 0, c = b.length; f !== c; ++f)
              if (((d = b[f]), isNaN(d))) {
                console.error("value is not a valid number", this, f, d);
                a = !1;
                break;
              }
          return a;
        },
        optimize: function () {
          for (
            var a = this.times,
              b = this.values,
              c = this.getValueSize(),
              d = 1,
              e = 1,
              f = a.length - 1;
            e <= f;
            ++e
          ) {
            var g = !1,
              h = a[e];
            if (h !== a[e + 1] && (1 !== e || h !== h[0]))
              for (var k = e * c, l = k - c, n = k + c, h = 0; h !== c; ++h) {
                var p = b[k + h];
                if (p !== b[l + h] || p !== b[n + h]) {
                  g = !0;
                  break;
                }
              }
            if (g) {
              if (e !== d)
                for (a[d] = a[e], g = e * c, k = d * c, h = 0; h !== c; ++h)
                  b[k + h] = b[g + h];
              ++d;
            }
          }
          d !== a.length &&
            ((this.times = THREE.AnimationUtils.arraySlice(a, 0, d)),
            (this.values = THREE.AnimationUtils.arraySlice(b, 0, d * c)));
          return this;
        },
      };
      Object.assign(THREE.KeyframeTrack, {
        parse: function (a) {
          if (void 0 === a.type)
            throw Error("track type undefined, can not parse");
          var b = THREE.KeyframeTrack._getTrackTypeForValueTypeName(a.type);
          if (void 0 === a.times) {
            console.warn("legacy JSON format detected, converting");
            var c = [],
              d = [];
            THREE.AnimationUtils.flattenJSON(a.keys, c, d, "value");
            a.times = c;
            a.values = d;
          }
          return void 0 !== b.parse
            ? b.parse(a)
            : new b(a.name, a.times, a.values, a.interpolation);
        },
        toJSON: function (a) {
          var b = a.constructor;
          if (void 0 !== b.toJSON) b = b.toJSON(a);
          else {
            var b = {
                name: a.name,
                times: THREE.AnimationUtils.convertArray(a.times, Array),
                values: THREE.AnimationUtils.convertArray(a.values, Array),
              },
              c = a.getInterpolation();
            c !== a.DefaultInterpolation && (b.interpolation = c);
          }
          b.type = a.ValueTypeName;
          return b;
        },
        _getTrackTypeForValueTypeName: function (a) {
          switch (a.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return THREE.NumberKeyframeTrack;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return THREE.VectorKeyframeTrack;
            case "color":
              return THREE.ColorKeyframeTrack;
            case "quaternion":
              return THREE.QuaternionKeyframeTrack;
            case "bool":
            case "boolean":
              return THREE.BooleanKeyframeTrack;
            case "string":
              return THREE.StringKeyframeTrack;
          }
          throw Error("Unsupported typeName: " + a);
        },
      });
      THREE.PropertyBinding = function (a, b, c) {
        this.path = b;
        this.parsedPath = c || THREE.PropertyBinding.parseTrackName(b);
        this.node =
          THREE.PropertyBinding.findNode(a, this.parsedPath.nodeName) || a;
        this.rootNode = a;
      };
      THREE.PropertyBinding.prototype = {
        constructor: THREE.PropertyBinding,
        getValue: function (a, b) {
          this.bind();
          this.getValue(a, b);
        },
        setValue: function (a, b) {
          this.bind();
          this.setValue(a, b);
        },
        bind: function () {
          var a = this.node,
            b = this.parsedPath,
            c = b.objectName,
            d = b.propertyName,
            e = b.propertyIndex;
          a ||
            (this.node = a =
              THREE.PropertyBinding.findNode(this.rootNode, b.nodeName) ||
              this.rootNode);
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;
          if (a) {
            if (c) {
              var f = b.objectIndex;
              switch (c) {
                case "materials":
                  if (!a.material) {
                    console.error(
                      "  can not bind to material as node does not have a material",
                      this
                    );
                    return;
                  }
                  if (!a.material.materials) {
                    console.error(
                      "  can not bind to material.materials as node.material does not have a materials array",
                      this
                    );
                    return;
                  }
                  a = a.material.materials;
                  break;
                case "bones":
                  if (!a.skeleton) {
                    console.error(
                      "  can not bind to bones as node does not have a skeleton",
                      this
                    );
                    return;
                  }
                  a = a.skeleton.bones;
                  for (c = 0; c < a.length; c++)
                    if (a[c].name === f) {
                      f = c;
                      break;
                    }
                  break;
                default:
                  if (void 0 === a[c]) {
                    console.error(
                      "  can not bind to objectName of node, undefined",
                      this
                    );
                    return;
                  }
                  a = a[c];
              }
              if (void 0 !== f) {
                if (void 0 === a[f]) {
                  console.error(
                    "  trying to bind to objectIndex of objectName, but is undefined:",
                    this,
                    a
                  );
                  return;
                }
                a = a[f];
              }
            }
            if ((f = a[d])) {
              b = this.Versioning.None;
              void 0 !== a.needsUpdate
                ? ((b = this.Versioning.NeedsUpdate), (this.targetObject = a))
                : void 0 !== a.matrixWorldNeedsUpdate &&
                  ((b = this.Versioning.MatrixWorldNeedsUpdate),
                  (this.targetObject = a));
              c = this.BindingType.Direct;
              if (void 0 !== e) {
                if ("morphTargetInfluences" === d) {
                  if (!a.geometry) {
                    console.error(
                      "  can not bind to morphTargetInfluences becasuse node does not have a geometry",
                      this
                    );
                    return;
                  }
                  if (!a.geometry.morphTargets) {
                    console.error(
                      "  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets",
                      this
                    );
                    return;
                  }
                  for (c = 0; c < this.node.geometry.morphTargets.length; c++)
                    if (a.geometry.morphTargets[c].name === e) {
                      e = c;
                      break;
                    }
                }
                c = this.BindingType.ArrayElement;
                this.resolvedProperty = f;
                this.propertyIndex = e;
              } else
                void 0 !== f.fromArray && void 0 !== f.toArray
                  ? ((c = this.BindingType.HasFromToArray),
                    (this.resolvedProperty = f))
                  : void 0 !== f.length
                  ? ((c = this.BindingType.EntireArray),
                    (this.resolvedProperty = f))
                  : (this.propertyName = d);
              this.getValue = this.GetterByBindingType[c];
              this.setValue = this.SetterByBindingTypeAndVersioning[c][b];
            } else
              console.error(
                "  trying to update property for track: " +
                  b.nodeName +
                  "." +
                  d +
                  " but it wasn't found.",
                a
              );
          } else
            console.error(
              "  trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
        },
        unbind: function () {
          this.node = null;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        },
      };
      Object.assign(THREE.PropertyBinding.prototype, {
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
        _getValue_unbound: THREE.PropertyBinding.prototype.getValue,
        _setValue_unbound: THREE.PropertyBinding.prototype.setValue,
        BindingType: {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        },
        Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
        GetterByBindingType: [
          function (a, b) {
            a[b] = this.node[this.propertyName];
          },
          function (a, b) {
            for (
              var c = this.resolvedProperty, d = 0, e = c.length;
              d !== e;
              ++d
            )
              a[b++] = c[d];
          },
          function (a, b) {
            a[b] = this.resolvedProperty[this.propertyIndex];
          },
          function (a, b) {
            this.resolvedProperty.toArray(a, b);
          },
        ],
        SetterByBindingTypeAndVersioning: [
          [
            function (a, b) {
              this.node[this.propertyName] = a[b];
            },
            function (a, b) {
              this.node[this.propertyName] = a[b];
              this.targetObject.needsUpdate = !0;
            },
            function (a, b) {
              this.node[this.propertyName] = a[b];
              this.targetObject.matrixWorldNeedsUpdate = !0;
            },
          ],
          [
            function (a, b) {
              for (
                var c = this.resolvedProperty, d = 0, e = c.length;
                d !== e;
                ++d
              )
                c[d] = a[b++];
            },
            function (a, b) {
              for (
                var c = this.resolvedProperty, d = 0, e = c.length;
                d !== e;
                ++d
              )
                c[d] = a[b++];
              this.targetObject.needsUpdate = !0;
            },
            function (a, b) {
              for (
                var c = this.resolvedProperty, d = 0, e = c.length;
                d !== e;
                ++d
              )
                c[d] = a[b++];
              this.targetObject.matrixWorldNeedsUpdate = !0;
            },
          ],
          [
            function (a, b) {
              this.resolvedProperty[this.propertyIndex] = a[b];
            },
            function (a, b) {
              this.resolvedProperty[this.propertyIndex] = a[b];
              this.targetObject.needsUpdate = !0;
            },
            function (a, b) {
              this.resolvedProperty[this.propertyIndex] = a[b];
              this.targetObject.matrixWorldNeedsUpdate = !0;
            },
          ],
          [
            function (a, b) {
              this.resolvedProperty.fromArray(a, b);
            },
            function (a, b) {
              this.resolvedProperty.fromArray(a, b);
              this.targetObject.needsUpdate = !0;
            },
            function (a, b) {
              this.resolvedProperty.fromArray(a, b);
              this.targetObject.matrixWorldNeedsUpdate = !0;
            },
          ],
        ],
      });
      THREE.PropertyBinding.Composite = function (a, b, c) {
        c = c || THREE.PropertyBinding.parseTrackName(b);
        this._targetGroup = a;
        this._bindings = a.subscribe_(b, c);
      };
      THREE.PropertyBinding.Composite.prototype = {
        constructor: THREE.PropertyBinding.Composite,
        getValue: function (a, b) {
          this.bind();
          var c = this._bindings[this._targetGroup.nCachedObjects_];
          void 0 !== c && c.getValue(a, b);
        },
        setValue: function (a, b) {
          for (
            var c = this._bindings,
              d = this._targetGroup.nCachedObjects_,
              e = c.length;
            d !== e;
            ++d
          )
            c[d].setValue(a, b);
        },
        bind: function () {
          for (
            var a = this._bindings,
              b = this._targetGroup.nCachedObjects_,
              c = a.length;
            b !== c;
            ++b
          )
            a[b].bind();
        },
        unbind: function () {
          for (
            var a = this._bindings,
              b = this._targetGroup.nCachedObjects_,
              c = a.length;
            b !== c;
            ++b
          )
            a[b].unbind();
        },
      };
      THREE.PropertyBinding.create = function (a, b, c) {
        return a instanceof THREE.AnimationObjectGroup
          ? new THREE.PropertyBinding.Composite(a, b, c)
          : new THREE.PropertyBinding(a, b, c);
      };
      THREE.PropertyBinding.parseTrackName = function (a) {
        var b =
            /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/,
          c = b.exec(a);
        if (!c) throw Error("cannot parse trackName at all: " + a);
        c.index === b.lastIndex && b.lastIndex++;
        b = {
          nodeName: c[3],
          objectName: c[5],
          objectIndex: c[7],
          propertyName: c[9],
          propertyIndex: c[11],
        };
        if (null === b.propertyName || 0 === b.propertyName.length)
          throw Error("can not parse propertyName from trackName: " + a);
        return b;
      };
      THREE.PropertyBinding.findNode = function (a, b) {
        if (
          !b ||
          "" === b ||
          "root" === b ||
          "." === b ||
          -1 === b ||
          b === a.name ||
          b === a.uuid
        )
          return a;
        if (a.skeleton) {
          var c = (function (a) {
            for (var c = 0; c < a.bones.length; c++) {
              var d = a.bones[c];
              if (d.name === b) return d;
            }
            return null;
          })(a.skeleton);
          if (c) return c;
        }
        if (a.children) {
          var d = function (a) {
            for (var c = 0; c < a.length; c++) {
              var g = a[c];
              if (g.name === b || g.uuid === b || (g = d(g.children))) return g;
            }
            return null;
          };
          if ((c = d(a.children))) return c;
        }
        return null;
      };
      THREE.PropertyMixer = function (a, b, c) {
        this.binding = a;
        this.valueSize = c;
        a = Float64Array;
        switch (b) {
          case "quaternion":
            b = this._slerp;
            break;
          case "string":
          case "bool":
            a = Array;
            b = this._select;
            break;
          default:
            b = this._lerp;
        }
        this.buffer = new a(4 * c);
        this._mixBufferRegion = b;
        this.referenceCount = this.useCount = this.cumulativeWeight = 0;
      };
      THREE.PropertyMixer.prototype = {
        constructor: THREE.PropertyMixer,
        accumulate: function (a, b) {
          var c = this.buffer,
            d = this.valueSize,
            e = a * d + d,
            f = this.cumulativeWeight;
          if (0 === f) {
            for (f = 0; f !== d; ++f) c[e + f] = c[f];
            f = b;
          } else (f += b), this._mixBufferRegion(c, e, 0, b / f, d);
          this.cumulativeWeight = f;
        },
        apply: function (a) {
          var b = this.valueSize,
            c = this.buffer;
          a = a * b + b;
          var d = this.cumulativeWeight,
            e = this.binding;
          this.cumulativeWeight = 0;
          1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
          for (var d = b, f = b + b; d !== f; ++d)
            if (c[d] !== c[d + b]) {
              e.setValue(c, a);
              break;
            }
        },
        saveOriginalState: function () {
          var a = this.buffer,
            b = this.valueSize,
            c = 3 * b;
          this.binding.getValue(a, c);
          for (var d = b; d !== c; ++d) a[d] = a[c + (d % b)];
          this.cumulativeWeight = 0;
        },
        restoreOriginalState: function () {
          this.binding.setValue(this.buffer, 3 * this.valueSize);
        },
        _select: function (a, b, c, d, e) {
          if (0.5 <= d) for (d = 0; d !== e; ++d) a[b + d] = a[c + d];
        },
        _slerp: function (a, b, c, d, e) {
          THREE.Quaternion.slerpFlat(a, b, a, b, a, c, d);
        },
        _lerp: function (a, b, c, d, e) {
          for (var f = 1 - d, g = 0; g !== e; ++g) {
            var h = b + g;
            a[h] = a[h] * f + a[c + g] * d;
          }
        },
      };
      THREE.BooleanKeyframeTrack = function (a, b, c) {
        THREE.KeyframeTrack.call(this, a, b, c);
      };
      THREE.BooleanKeyframeTrack.prototype = Object.assign(
        Object.create(THREE.KeyframeTrack.prototype),
        {
          constructor: THREE.BooleanKeyframeTrack,
          ValueTypeName: "bool",
          ValueBufferType: Array,
          DefaultInterpolation: THREE.IntepolateDiscrete,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        }
      );
      THREE.NumberKeyframeTrack = function (a, b, c, d) {
        THREE.KeyframeTrack.call(this, a, b, c, d);
      };
      THREE.NumberKeyframeTrack.prototype = Object.assign(
        Object.create(THREE.KeyframeTrack.prototype),
        { constructor: THREE.NumberKeyframeTrack, ValueTypeName: "number" }
      );
      THREE.QuaternionKeyframeTrack = function (a, b, c, d) {
        THREE.KeyframeTrack.call(this, a, b, c, d);
      };
      THREE.QuaternionKeyframeTrack.prototype = Object.assign(
        Object.create(THREE.KeyframeTrack.prototype),
        {
          constructor: THREE.QuaternionKeyframeTrack,
          ValueTypeName: "quaternion",
          DefaultInterpolation: THREE.InterpolateLinear,
          InterpolantFactoryMethodLinear: function (a) {
            return new THREE.QuaternionLinearInterpolant(
              this.times,
              this.values,
              this.getValueSize(),
              a
            );
          },
          InterpolantFactoryMethodSmooth: void 0,
        }
      );
      THREE.StringKeyframeTrack = function (a, b, c, d) {
        THREE.KeyframeTrack.call(this, a, b, c, d);
      };
      THREE.StringKeyframeTrack.prototype = Object.assign(
        Object.create(THREE.KeyframeTrack.prototype),
        {
          constructor: THREE.StringKeyframeTrack,
          ValueTypeName: "string",
          ValueBufferType: Array,
          DefaultInterpolation: THREE.IntepolateDiscrete,
          InterpolantFactoryMethodLinear: void 0,
          InterpolantFactoryMethodSmooth: void 0,
        }
      );
      THREE.VectorKeyframeTrack = function (a, b, c, d) {
        THREE.KeyframeTrack.call(this, a, b, c, d);
      };
      THREE.VectorKeyframeTrack.prototype = Object.assign(
        Object.create(THREE.KeyframeTrack.prototype),
        { constructor: THREE.VectorKeyframeTrack, ValueTypeName: "vector" }
      );
      THREE.Audio = function (a) {
        THREE.Object3D.call(this);
        this.type = "Audio";
        this.context = a.context;
        this.source = this.context.createBufferSource();
        this.source.onended = this.onEnded.bind(this);
        this.gain = this.context.createGain();
        this.gain.connect(a.getInput());
        this.autoplay = !1;
        this.startTime = 0;
        this.playbackRate = 1;
        this.isPlaying = !1;
        this.hasPlaybackControl = !0;
        this.sourceType = "empty";
        this.filter = null;
      };
      THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Audio.prototype.constructor = THREE.Audio;
      THREE.Audio.prototype.getOutput = function () {
        return this.gain;
      };
      THREE.Audio.prototype.load = function (a) {
        var b = new THREE.AudioBuffer(this.context);
        b.load(a);
        this.setBuffer(b);
        return this;
      };
      THREE.Audio.prototype.setNodeSource = function (a) {
        this.hasPlaybackControl = !1;
        this.sourceType = "audioNode";
        this.source = a;
        this.connect();
        return this;
      };
      THREE.Audio.prototype.setBuffer = function (a) {
        var b = this;
        a.onReady(function (a) {
          b.source.buffer = a;
          b.sourceType = "buffer";
          b.autoplay && b.play();
        });
        return this;
      };
      THREE.Audio.prototype.play = function () {
        if (!0 === this.isPlaying)
          console.warn("THREE.Audio: Audio is already playing.");
        else if (!1 === this.hasPlaybackControl)
          console.warn("THREE.Audio: this Audio has no playback control.");
        else {
          var a = this.context.createBufferSource();
          a.buffer = this.source.buffer;
          a.loop = this.source.loop;
          a.onended = this.source.onended;
          a.start(0, this.startTime);
          a.playbackRate.value = this.playbackRate;
          this.isPlaying = !0;
          this.source = a;
          this.connect();
        }
      };
      THREE.Audio.prototype.pause = function () {
        !1 === this.hasPlaybackControl
          ? console.warn("THREE.Audio: this Audio has no playback control.")
          : (this.source.stop(), (this.startTime = this.context.currentTime));
      };
      THREE.Audio.prototype.stop = function () {
        !1 === this.hasPlaybackControl
          ? console.warn("THREE.Audio: this Audio has no playback control.")
          : (this.source.stop(), (this.startTime = 0));
      };
      THREE.Audio.prototype.connect = function () {
        null !== this.filter
          ? (this.source.connect(this.filter),
            this.filter.connect(this.getOutput()))
          : this.source.connect(this.getOutput());
      };
      THREE.Audio.prototype.disconnect = function () {
        null !== this.filter
          ? (this.source.disconnect(this.filter),
            this.filter.disconnect(this.getOutput()))
          : this.source.disconnect(this.getOutput());
      };
      THREE.Audio.prototype.getFilter = function () {
        return this.filter;
      };
      THREE.Audio.prototype.setFilter = function (a) {
        void 0 === a && (a = null);
        !0 === this.isPlaying
          ? (this.disconnect(), (this.filter = a), this.connect())
          : (this.filter = a);
      };
      THREE.Audio.prototype.setPlaybackRate = function (a) {
        !1 === this.hasPlaybackControl
          ? console.warn("THREE.Audio: this Audio has no playback control.")
          : ((this.playbackRate = a),
            !0 === this.isPlaying &&
              (this.source.playbackRate.value = this.playbackRate));
      };
      THREE.Audio.prototype.getPlaybackRate = function () {
        return this.playbackRate;
      };
      THREE.Audio.prototype.onEnded = function () {
        this.isPlaying = !1;
      };
      THREE.Audio.prototype.setLoop = function (a) {
        !1 === this.hasPlaybackControl
          ? console.warn("THREE.Audio: this Audio has no playback control.")
          : (this.source.loop = a);
      };
      THREE.Audio.prototype.getLoop = function () {
        return !1 === this.hasPlaybackControl
          ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1)
          : this.source.loop;
      };
      THREE.Audio.prototype.setVolume = function (a) {
        this.gain.gain.value = a;
      };
      THREE.Audio.prototype.getVolume = function () {
        return this.gain.gain.value;
      };
      THREE.AudioAnalyser = function (a, b) {
        this.analyser = a.context.createAnalyser();
        this.analyser.fftSize = void 0 !== b ? b : 2048;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        a.getOutput().connect(this.analyser);
      };
      THREE.AudioAnalyser.prototype = {
        constructor: THREE.AudioAnalyser,
        getData: function () {
          this.analyser.getByteFrequencyData(this.data);
          return this.data;
        },
      };
      THREE.AudioBuffer = function (a) {
        this.context = a;
        this.ready = !1;
        this.readyCallbacks = [];
      };
      THREE.AudioBuffer.prototype.load = function (a) {
        var b = this,
          c = new XMLHttpRequest();
        c.open("GET", a, !0);
        c.responseType = "arraybuffer";
        c.onload = function (a) {
          b.context.decodeAudioData(this.response, function (a) {
            b.buffer = a;
            b.ready = !0;
            for (a = 0; a < b.readyCallbacks.length; a++)
              b.readyCallbacks[a](b.buffer);
            b.readyCallbacks = [];
          });
        };
        c.send();
        return this;
      };
      THREE.AudioBuffer.prototype.onReady = function (a) {
        this.ready ? a(this.buffer) : this.readyCallbacks.push(a);
      };
      THREE.PositionalAudio = function (a) {
        THREE.Audio.call(this, a);
        this.panner = this.context.createPanner();
        this.panner.connect(this.gain);
      };
      THREE.PositionalAudio.prototype = Object.create(THREE.Audio.prototype);
      THREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;
      THREE.PositionalAudio.prototype.getOutput = function () {
        return this.panner;
      };
      THREE.PositionalAudio.prototype.setRefDistance = function (a) {
        this.panner.refDistance = a;
      };
      THREE.PositionalAudio.prototype.getRefDistance = function () {
        return this.panner.refDistance;
      };
      THREE.PositionalAudio.prototype.setRolloffFactor = function (a) {
        this.panner.rolloffFactor = a;
      };
      THREE.PositionalAudio.prototype.getRolloffFactor = function () {
        return this.panner.rolloffFactor;
      };
      THREE.PositionalAudio.prototype.setDistanceModel = function (a) {
        this.panner.distanceModel = a;
      };
      THREE.PositionalAudio.prototype.getDistanceModel = function () {
        return this.panner.distanceModel;
      };
      THREE.PositionalAudio.prototype.setMaxDistance = function (a) {
        this.panner.maxDistance = a;
      };
      THREE.PositionalAudio.prototype.getMaxDistance = function () {
        return this.panner.maxDistance;
      };
      THREE.PositionalAudio.prototype.updateMatrixWorld = (function () {
        var a = new THREE.Vector3();
        return function (b) {
          THREE.Object3D.prototype.updateMatrixWorld.call(this, b);
          a.setFromMatrixPosition(this.matrixWorld);
          this.panner.setPosition(a.x, a.y, a.z);
        };
      })();
      THREE.AudioListener = function () {
        THREE.Object3D.call(this);
        this.type = "AudioListener";
        this.context = new (window.AudioContext || window.webkitAudioContext)();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
      };
      THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
      THREE.AudioListener.prototype.constructor = THREE.AudioListener;
      THREE.AudioListener.prototype.getInput = function () {
        return this.gain;
      };
      THREE.AudioListener.prototype.removeFilter = function () {
        null !== this.filter &&
          (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination),
          this.gain.connect(this.context.destination),
          (this.filter = null));
      };
      THREE.AudioListener.prototype.setFilter = function (a) {
        null !== this.filter
          ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination))
          : this.gain.disconnect(this.context.destination);
        this.filter = a;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
      };
      THREE.AudioListener.prototype.getFilter = function () {
        return this.filter;
      };
      THREE.AudioListener.prototype.setMasterVolume = function (a) {
        this.gain.gain.value = a;
      };
      THREE.AudioListener.prototype.getMasterVolume = function () {
        return this.gain.gain.value;
      };
      THREE.AudioListener.prototype.updateMatrixWorld = (function () {
        var a = new THREE.Vector3(),
          b = new THREE.Quaternion(),
          c = new THREE.Vector3(),
          d = new THREE.Vector3();
        return function (e) {
          THREE.Object3D.prototype.updateMatrixWorld.call(this, e);
          e = this.context.listener;
          var f = this.up;
          this.matrixWorld.decompose(a, b, c);
          d.set(0, 0, -1).applyQuaternion(b);
          e.setPosition(a.x, a.y, a.z);
          e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z);
        };
      })();
      THREE.Camera = function () {
        THREE.Object3D.call(this);
        this.type = "Camera";
        this.matrixWorldInverse = new THREE.Matrix4();
        this.projectionMatrix = new THREE.Matrix4();
      };
      THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Camera.prototype.constructor = THREE.Camera;
      THREE.Camera.prototype.getWorldDirection = (function () {
        var a = new THREE.Quaternion();
        return function (b) {
          b = b || new THREE.Vector3();
          this.getWorldQuaternion(a);
          return b.set(0, 0, -1).applyQuaternion(a);
        };
      })();
      THREE.Camera.prototype.lookAt = (function () {
        var a = new THREE.Matrix4();
        return function (b) {
          a.lookAt(this.position, b, this.up);
          this.quaternion.setFromRotationMatrix(a);
        };
      })();
      THREE.Camera.prototype.clone = function () {
        return new this.constructor().copy(this);
      };
      THREE.Camera.prototype.copy = function (a) {
        THREE.Object3D.prototype.copy.call(this, a);
        this.matrixWorldInverse.copy(a.matrixWorldInverse);
        this.projectionMatrix.copy(a.projectionMatrix);
        return this;
      };
      THREE.CubeCamera = function (a, b, c) {
        THREE.Object3D.call(this);
        this.type = "CubeCamera";
        var d = new THREE.PerspectiveCamera(90, 1, a, b);
        d.up.set(0, -1, 0);
        d.lookAt(new THREE.Vector3(1, 0, 0));
        this.add(d);
        var e = new THREE.PerspectiveCamera(90, 1, a, b);
        e.up.set(0, -1, 0);
        e.lookAt(new THREE.Vector3(-1, 0, 0));
        this.add(e);
        var f = new THREE.PerspectiveCamera(90, 1, a, b);
        f.up.set(0, 0, 1);
        f.lookAt(new THREE.Vector3(0, 1, 0));
        this.add(f);
        var g = new THREE.PerspectiveCamera(90, 1, a, b);
        g.up.set(0, 0, -1);
        g.lookAt(new THREE.Vector3(0, -1, 0));
        this.add(g);
        var h = new THREE.PerspectiveCamera(90, 1, a, b);
        h.up.set(0, -1, 0);
        h.lookAt(new THREE.Vector3(0, 0, 1));
        this.add(h);
        var k = new THREE.PerspectiveCamera(90, 1, a, b);
        k.up.set(0, -1, 0);
        k.lookAt(new THREE.Vector3(0, 0, -1));
        this.add(k);
        this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
          format: THREE.RGBFormat,
          magFilter: THREE.LinearFilter,
          minFilter: THREE.LinearFilter,
        });
        this.updateCubeMap = function (a, b) {
          null === this.parent && this.updateMatrixWorld();
          var c = this.renderTarget,
            m = c.texture.generateMipmaps;
          c.texture.generateMipmaps = !1;
          c.activeCubeFace = 0;
          a.render(b, d, c);
          c.activeCubeFace = 1;
          a.render(b, e, c);
          c.activeCubeFace = 2;
          a.render(b, f, c);
          c.activeCubeFace = 3;
          a.render(b, g, c);
          c.activeCubeFace = 4;
          a.render(b, h, c);
          c.texture.generateMipmaps = m;
          c.activeCubeFace = 5;
          a.render(b, k, c);
          a.setRenderTarget(null);
        };
      };
      THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
      THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
      THREE.OrthographicCamera = function (a, b, c, d, e, f) {
        THREE.Camera.call(this);
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.left = a;
        this.right = b;
        this.top = c;
        this.bottom = d;
        this.near = void 0 !== e ? e : 0.1;
        this.far = void 0 !== f ? f : 2e3;
        this.updateProjectionMatrix();
      };
      THREE.OrthographicCamera.prototype = Object.create(
        THREE.Camera.prototype
      );
      THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
      THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
        var a = (this.right - this.left) / (2 * this.zoom),
          b = (this.top - this.bottom) / (2 * this.zoom),
          c = (this.right + this.left) / 2,
          d = (this.top + this.bottom) / 2;
        this.projectionMatrix.makeOrthographic(
          c - a,
          c + a,
          d + b,
          d - b,
          this.near,
          this.far
        );
      };
      THREE.OrthographicCamera.prototype.copy = function (a) {
        THREE.Camera.prototype.copy.call(this, a);
        this.left = a.left;
        this.right = a.right;
        this.top = a.top;
        this.bottom = a.bottom;
        this.near = a.near;
        this.far = a.far;
        this.zoom = a.zoom;
        return this;
      };
      THREE.OrthographicCamera.prototype.toJSON = function (a) {
        a = THREE.Object3D.prototype.toJSON.call(this, a);
        a.object.zoom = this.zoom;
        a.object.left = this.left;
        a.object.right = this.right;
        a.object.top = this.top;
        a.object.bottom = this.bottom;
        a.object.near = this.near;
        a.object.far = this.far;
        return a;
      };
      THREE.PerspectiveCamera = function (a, b, c, d) {
        THREE.Camera.call(this);
        this.type = "PerspectiveCamera";
        this.focalLength = 10;
        this.zoom = 1;
        this.fov = void 0 !== a ? a : 50;
        this.aspect = void 0 !== b ? b : 1;
        this.near = void 0 !== c ? c : 0.1;
        this.far = void 0 !== d ? d : 2e3;
        this.updateProjectionMatrix();
      };
      THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
      THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
      THREE.PerspectiveCamera.prototype.setLens = function (a, b) {
        void 0 === b && (b = 24);
        this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
        this.updateProjectionMatrix();
      };
      THREE.PerspectiveCamera.prototype.setViewOffset = function (
        a,
        b,
        c,
        d,
        e,
        f
      ) {
        this.fullWidth = a;
        this.fullHeight = b;
        this.x = c;
        this.y = d;
        this.width = e;
        this.height = f;
        this.updateProjectionMatrix();
      };
      THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
        var a = THREE.Math.radToDeg(
          2 *
            Math.atan(Math.tan(0.5 * THREE.Math.degToRad(this.fov)) / this.zoom)
        );
        if (this.fullWidth) {
          var b = this.fullWidth / this.fullHeight,
            a = Math.tan(THREE.Math.degToRad(0.5 * a)) * this.near,
            c = -a,
            d = b * c,
            b = Math.abs(b * a - d),
            c = Math.abs(a - c);
          this.projectionMatrix.makeFrustum(
            d + (this.x * b) / this.fullWidth,
            d + ((this.x + this.width) * b) / this.fullWidth,
            a - ((this.y + this.height) * c) / this.fullHeight,
            a - (this.y * c) / this.fullHeight,
            this.near,
            this.far
          );
        } else
          this.projectionMatrix.makePerspective(
            a,
            this.aspect,
            this.near,
            this.far
          );
      };
      THREE.PerspectiveCamera.prototype.copy = function (a) {
        THREE.Camera.prototype.copy.call(this, a);
        this.focalLength = a.focalLength;
        this.zoom = a.zoom;
        this.fov = a.fov;
        this.aspect = a.aspect;
        this.near = a.near;
        this.far = a.far;
        return this;
      };
      THREE.PerspectiveCamera.prototype.toJSON = function (a) {
        a = THREE.Object3D.prototype.toJSON.call(this, a);
        a.object.focalLength = this.focalLength;
        a.object.zoom = this.zoom;
        a.object.fov = this.fov;
        a.object.aspect = this.aspect;
        a.object.near = this.near;
        a.object.far = this.far;
        return a;
      };
      THREE.StereoCamera = function () {
        this.type = "StereoCamera";
        this.aspect = 1;
        this.cameraL = new THREE.PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = !1;
        this.cameraR = new THREE.PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = !1;
      };
      THREE.StereoCamera.prototype = {
        constructor: THREE.StereoCamera,
        update: (function () {
          var a,
            b,
            c,
            d,
            e,
            f = new THREE.Matrix4(),
            g = new THREE.Matrix4();
          return function (h) {
            if (
              a !== h.focalLength ||
              b !== h.fov ||
              c !== h.aspect * this.aspect ||
              d !== h.near ||
              e !== h.far
            ) {
              a = h.focalLength;
              b = h.fov;
              c = h.aspect * this.aspect;
              d = h.near;
              e = h.far;
              var k = h.projectionMatrix.clone(),
                l = (0.032 * d) / a,
                n = d * Math.tan(THREE.Math.degToRad(0.5 * b)),
                p,
                m;
              g.elements[12] = -0.032;
              f.elements[12] = 0.032;
              p = -n * c + l;
              m = n * c + l;
              k.elements[0] = (2 * d) / (m - p);
              k.elements[8] = (m + p) / (m - p);
              this.cameraL.projectionMatrix.copy(k);
              p = -n * c - l;
              m = n * c - l;
              k.elements[0] = (2 * d) / (m - p);
              k.elements[8] = (m + p) / (m - p);
              this.cameraR.projectionMatrix.copy(k);
            }
            this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(g);
            this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(f);
          };
        })(),
      };
      THREE.Light = function (a, b) {
        THREE.Object3D.call(this);
        this.type = "Light";
        this.color = new THREE.Color(a);
        this.intensity = void 0 !== b ? b : 1;
        this.receiveShadow = void 0;
      };
      THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Light.prototype.constructor = THREE.Light;
      THREE.Light.prototype.copy = function (a) {
        THREE.Object3D.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.intensity = a.intensity;
        return this;
      };
      THREE.Light.prototype.toJSON = function (a) {
        a = THREE.Object3D.prototype.toJSON.call(this, a);
        a.object.color = this.color.getHex();
        a.object.intensity = this.intensity;
        void 0 !== this.groundColor &&
          (a.object.groundColor = this.groundColor.getHex());
        void 0 !== this.distance && (a.object.distance = this.distance);
        void 0 !== this.angle && (a.object.angle = this.angle);
        void 0 !== this.decay && (a.object.decay = this.decay);
        void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
        return a;
      };
      THREE.LightShadow = function (a) {
        this.camera = a;
        this.bias = 0;
        this.radius = 1;
        this.mapSize = new THREE.Vector2(512, 512);
        this.map = null;
        this.matrix = new THREE.Matrix4();
      };
      THREE.LightShadow.prototype = {
        constructor: THREE.LightShadow,
        copy: function (a) {
          this.camera = a.camera.clone();
          this.bias = a.bias;
          this.radius = a.radius;
          this.mapSize.copy(a.mapSize);
          return this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      };
      THREE.AmbientLight = function (a, b) {
        THREE.Light.call(this, a, b);
        this.type = "AmbientLight";
        this.castShadow = void 0;
      };
      THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
      THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
      THREE.DirectionalLight = function (a, b) {
        THREE.Light.call(this, a, b);
        this.type = "DirectionalLight";
        this.position.set(0, 1, 0);
        this.updateMatrix();
        this.target = new THREE.Object3D();
        this.shadow = new THREE.LightShadow(
          new THREE.OrthographicCamera(-5, 5, 5, -5, 0.5, 500)
        );
      };
      THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
      THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
      THREE.DirectionalLight.prototype.copy = function (a) {
        THREE.Light.prototype.copy.call(this, a);
        this.target = a.target.clone();
        this.shadow = a.shadow.clone();
        return this;
      };
      THREE.HemisphereLight = function (a, b, c) {
        THREE.Light.call(this, a, c);
        this.type = "HemisphereLight";
        this.castShadow = void 0;
        this.position.set(0, 1, 0);
        this.updateMatrix();
        this.groundColor = new THREE.Color(b);
      };
      THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
      THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
      THREE.HemisphereLight.prototype.copy = function (a) {
        THREE.Light.prototype.copy.call(this, a);
        this.groundColor.copy(a.groundColor);
        return this;
      };
      THREE.PointLight = function (a, b, c, d) {
        THREE.Light.call(this, a, b);
        this.type = "PointLight";
        this.distance = void 0 !== c ? c : 0;
        this.decay = void 0 !== d ? d : 1;
        this.shadow = new THREE.LightShadow(
          new THREE.PerspectiveCamera(90, 1, 0.5, 500)
        );
      };
      THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
      THREE.PointLight.prototype.constructor = THREE.PointLight;
      THREE.PointLight.prototype.copy = function (a) {
        THREE.Light.prototype.copy.call(this, a);
        this.distance = a.distance;
        this.decay = a.decay;
        this.shadow = a.shadow.clone();
        return this;
      };
      THREE.SpotLight = function (a, b, c, d, e, f) {
        THREE.Light.call(this, a, b);
        this.type = "SpotLight";
        this.position.set(0, 1, 0);
        this.updateMatrix();
        this.target = new THREE.Object3D();
        this.distance = void 0 !== c ? c : 0;
        this.angle = void 0 !== d ? d : Math.PI / 3;
        this.penumbra = void 0 !== e ? e : 0;
        this.decay = void 0 !== f ? f : 1;
        this.shadow = new THREE.LightShadow(
          new THREE.PerspectiveCamera(50, 1, 0.5, 500)
        );
      };
      THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
      THREE.SpotLight.prototype.constructor = THREE.SpotLight;
      THREE.SpotLight.prototype.copy = function (a) {
        THREE.Light.prototype.copy.call(this, a);
        this.distance = a.distance;
        this.angle = a.angle;
        this.penumbra = a.penumbra;
        this.decay = a.decay;
        this.target = a.target.clone();
        this.shadow = a.shadow.clone();
        return this;
      };
      THREE.Cache = {
        enabled: !1,
        files: {},
        add: function (a, b) {
          !1 !== this.enabled && (this.files[a] = b);
        },
        get: function (a) {
          if (!1 !== this.enabled) return this.files[a];
        },
        remove: function (a) {
          delete this.files[a];
        },
        clear: function () {
          this.files = {};
        },
      };
      THREE.Loader = function () {
        this.onLoadStart = function () {};
        this.onLoadProgress = function () {};
        this.onLoadComplete = function () {};
      };
      THREE.Loader.prototype = {
        constructor: THREE.Loader,
        crossOrigin: void 0,
        extractUrlBase: function (a) {
          a = a.split("/");
          if (1 === a.length) return "./";
          a.pop();
          return a.join("/") + "/";
        },
        initMaterials: function (a, b, c) {
          for (var d = [], e = 0; e < a.length; ++e)
            d[e] = this.createMaterial(a[e], b, c);
          return d;
        },
        createMaterial: (function () {
          var a, b, c;
          return function (d, e, f) {
            function g(a, c, d, g, k) {
              a = e + a;
              var l = THREE.Loader.Handlers.get(a);
              null !== l
                ? (a = l.load(a))
                : (b.setCrossOrigin(f), (a = b.load(a)));
              void 0 !== c &&
                (a.repeat.fromArray(c),
                1 !== c[0] && (a.wrapS = THREE.RepeatWrapping),
                1 !== c[1] && (a.wrapT = THREE.RepeatWrapping));
              void 0 !== d && a.offset.fromArray(d);
              void 0 !== g &&
                ("repeat" === g[0] && (a.wrapS = THREE.RepeatWrapping),
                "mirror" === g[0] && (a.wrapS = THREE.MirroredRepeatWrapping),
                "repeat" === g[1] && (a.wrapT = THREE.RepeatWrapping),
                "mirror" === g[1] && (a.wrapT = THREE.MirroredRepeatWrapping));
              void 0 !== k && (a.anisotropy = k);
              c = THREE.Math.generateUUID();
              h[c] = a;
              return c;
            }
            void 0 === a && (a = new THREE.Color());
            void 0 === b && (b = new THREE.TextureLoader());
            void 0 === c && (c = new THREE.MaterialLoader());
            var h = {},
              k = {
                uuid: THREE.Math.generateUUID(),
                type: "MeshLambertMaterial",
              },
              l;
            for (l in d) {
              var n = d[l];
              switch (l) {
                case "DbgColor":
                case "DbgIndex":
                case "opticalDensity":
                case "illumination":
                  break;
                case "DbgName":
                  k.name = n;
                  break;
                case "blending":
                  k.blending = THREE[n];
                  break;
                case "colorAmbient":
                case "mapAmbient":
                  console.warn(
                    "THREE.Loader.createMaterial:",
                    l,
                    "is no longer supported."
                  );
                  break;
                case "colorDiffuse":
                  k.color = a.fromArray(n).getHex();
                  break;
                case "colorSpecular":
                  k.specular = a.fromArray(n).getHex();
                  break;
                case "colorEmissive":
                  k.emissive = a.fromArray(n).getHex();
                  break;
                case "specularCoef":
                  k.shininess = n;
                  break;
                case "shading":
                  "basic" === n.toLowerCase() && (k.type = "MeshBasicMaterial");
                  "phong" === n.toLowerCase() && (k.type = "MeshPhongMaterial");
                  break;
                case "mapDiffuse":
                  k.map = g(
                    n,
                    d.mapDiffuseRepeat,
                    d.mapDiffuseOffset,
                    d.mapDiffuseWrap,
                    d.mapDiffuseAnisotropy
                  );
                  break;
                case "mapDiffuseRepeat":
                case "mapDiffuseOffset":
                case "mapDiffuseWrap":
                case "mapDiffuseAnisotropy":
                  break;
                case "mapLight":
                  k.lightMap = g(
                    n,
                    d.mapLightRepeat,
                    d.mapLightOffset,
                    d.mapLightWrap,
                    d.mapLightAnisotropy
                  );
                  break;
                case "mapLightRepeat":
                case "mapLightOffset":
                case "mapLightWrap":
                case "mapLightAnisotropy":
                  break;
                case "mapAO":
                  k.aoMap = g(
                    n,
                    d.mapAORepeat,
                    d.mapAOOffset,
                    d.mapAOWrap,
                    d.mapAOAnisotropy
                  );
                  break;
                case "mapAORepeat":
                case "mapAOOffset":
                case "mapAOWrap":
                case "mapAOAnisotropy":
                  break;
                case "mapBump":
                  k.bumpMap = g(
                    n,
                    d.mapBumpRepeat,
                    d.mapBumpOffset,
                    d.mapBumpWrap,
                    d.mapBumpAnisotropy
                  );
                  break;
                case "mapBumpScale":
                  k.bumpScale = n;
                  break;
                case "mapBumpRepeat":
                case "mapBumpOffset":
                case "mapBumpWrap":
                case "mapBumpAnisotropy":
                  break;
                case "mapNormal":
                  k.normalMap = g(
                    n,
                    d.mapNormalRepeat,
                    d.mapNormalOffset,
                    d.mapNormalWrap,
                    d.mapNormalAnisotropy
                  );
                  break;
                case "mapNormalFactor":
                  k.normalScale = [n, n];
                  break;
                case "mapNormalRepeat":
                case "mapNormalOffset":
                case "mapNormalWrap":
                case "mapNormalAnisotropy":
                  break;
                case "mapSpecular":
                  k.specularMap = g(
                    n,
                    d.mapSpecularRepeat,
                    d.mapSpecularOffset,
                    d.mapSpecularWrap,
                    d.mapSpecularAnisotropy
                  );
                  break;
                case "mapSpecularRepeat":
                case "mapSpecularOffset":
                case "mapSpecularWrap":
                case "mapSpecularAnisotropy":
                  break;
                case "mapAlpha":
                  k.alphaMap = g(
                    n,
                    d.mapAlphaRepeat,
                    d.mapAlphaOffset,
                    d.mapAlphaWrap,
                    d.mapAlphaAnisotropy
                  );
                  break;
                case "mapAlphaRepeat":
                case "mapAlphaOffset":
                case "mapAlphaWrap":
                case "mapAlphaAnisotropy":
                  break;
                case "flipSided":
                  k.side = THREE.BackSide;
                  break;
                case "doubleSided":
                  k.side = THREE.DoubleSide;
                  break;
                case "transparency":
                  console.warn(
                    "THREE.Loader.createMaterial: transparency has been renamed to opacity"
                  );
                  k.opacity = n;
                  break;
                case "depthTest":
                case "depthWrite":
                case "colorWrite":
                case "opacity":
                case "reflectivity":
                case "transparent":
                case "visible":
                case "wireframe":
                  k[l] = n;
                  break;
                case "vertexColors":
                  !0 === n && (k.vertexColors = THREE.VertexColors);
                  "face" === n && (k.vertexColors = THREE.FaceColors);
                  break;
                default:
                  console.error(
                    "THREE.Loader.createMaterial: Unsupported",
                    l,
                    n
                  );
              }
            }
            "MeshBasicMaterial" === k.type && delete k.emissive;
            "MeshPhongMaterial" !== k.type && delete k.specular;
            1 > k.opacity && (k.transparent = !0);
            c.setTextures(h);
            return c.parse(k);
          };
        })(),
      };
      THREE.Loader.Handlers = {
        handlers: [],
        add: function (a, b) {
          this.handlers.push(a, b);
        },
        get: function (a) {
          for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
            var e = b[c + 1];
            if (b[c].test(a)) return e;
          }
          return null;
        },
      };
      THREE.XHRLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
      };
      THREE.XHRLoader.prototype = {
        constructor: THREE.XHRLoader,
        load: function (a, b, c, d) {
          void 0 !== this.path && (a = this.path + a);
          var e = this,
            f = THREE.Cache.get(a);
          if (void 0 !== f)
            return (
              b &&
                setTimeout(function () {
                  b(f);
                }, 0),
              f
            );
          var g = new XMLHttpRequest();
          g.overrideMimeType("text/plain");
          g.open("GET", a, !0);
          g.addEventListener(
            "load",
            function (c) {
              var f = c.target.response;
              THREE.Cache.add(a, f);
              200 === this.status
                ? (b && b(f), e.manager.itemEnd(a))
                : 0 === this.status
                ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."),
                  b && b(f),
                  e.manager.itemEnd(a))
                : (d && d(c), e.manager.itemError(a));
            },
            !1
          );
          void 0 !== c &&
            g.addEventListener(
              "progress",
              function (a) {
                c(a);
              },
              !1
            );
          g.addEventListener(
            "error",
            function (b) {
              d && d(b);
              e.manager.itemError(a);
            },
            !1
          );
          void 0 !== this.responseType && (g.responseType = this.responseType);
          void 0 !== this.withCredentials &&
            (g.withCredentials = this.withCredentials);
          g.send(null);
          e.manager.itemStart(a);
          return g;
        },
        setPath: function (a) {
          this.path = a;
        },
        setResponseType: function (a) {
          this.responseType = a;
        },
        setWithCredentials: function (a) {
          this.withCredentials = a;
        },
      };
      THREE.FontLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
      };
      THREE.FontLoader.prototype = {
        constructor: THREE.FontLoader,
        load: function (a, b, c, d) {
          new THREE.XHRLoader(this.manager).load(
            a,
            function (a) {
              b(new THREE.Font(JSON.parse(a.substring(65, a.length - 2))));
            },
            c,
            d
          );
        },
      };
      THREE.ImageLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
      };
      THREE.ImageLoader.prototype = {
        constructor: THREE.ImageLoader,
        load: function (a, b, c, d) {
          void 0 !== this.path && (a = this.path + a);
          var e = this,
            f = THREE.Cache.get(a);
          if (void 0 !== f)
            return (
              e.manager.itemStart(a),
              b
                ? setTimeout(function () {
                    b(f);
                    e.manager.itemEnd(a);
                  }, 0)
                : e.manager.itemEnd(a),
              f
            );
          var g = document.createElement("img");
          g.addEventListener(
            "load",
            function (c) {
              THREE.Cache.add(a, this);
              b && b(this);
              e.manager.itemEnd(a);
            },
            !1
          );
          void 0 !== c &&
            g.addEventListener(
              "progress",
              function (a) {
                c(a);
              },
              !1
            );
          g.addEventListener(
            "error",
            function (b) {
              d && d(b);
              e.manager.itemError(a);
            },
            !1
          );
          void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin);
          e.manager.itemStart(a);
          g.src = a;
          return g;
        },
        setCrossOrigin: function (a) {
          this.crossOrigin = a;
        },
        setPath: function (a) {
          this.path = a;
        },
      };
      THREE.JSONLoader = function (a) {
        "boolean" === typeof a &&
          (console.warn(
            "THREE.JSONLoader: showStatus parameter has been removed from constructor."
          ),
          (a = void 0));
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
        this.withCredentials = !1;
      };
      THREE.JSONLoader.prototype = {
        constructor: THREE.JSONLoader,
        get statusDomElement() {
          void 0 === this._statusDomElement &&
            (this._statusDomElement = document.createElement("div"));
          console.warn("THREE.JSONLoader: .statusDomElement has been removed.");
          return this._statusDomElement;
        },
        load: function (a, b, c, d) {
          var e = this,
            f =
              this.texturePath && "string" === typeof this.texturePath
                ? this.texturePath
                : THREE.Loader.prototype.extractUrlBase(a),
            g = new THREE.XHRLoader(this.manager);
          g.setWithCredentials(this.withCredentials);
          g.load(
            a,
            function (c) {
              c = JSON.parse(c);
              var d = c.metadata;
              if (void 0 !== d && ((d = d.type), void 0 !== d)) {
                if ("object" === d.toLowerCase()) {
                  console.error(
                    "THREE.JSONLoader: " +
                      a +
                      " should be loaded with THREE.ObjectLoader instead."
                  );
                  return;
                }
                if ("scene" === d.toLowerCase()) {
                  console.error(
                    "THREE.JSONLoader: " +
                      a +
                      " should be loaded with THREE.SceneLoader instead."
                  );
                  return;
                }
              }
              c = e.parse(c, f);
              b(c.geometry, c.materials);
            },
            c,
            d
          );
        },
        setTexturePath: function (a) {
          this.texturePath = a;
        },
        parse: function (a, b) {
          var c = new THREE.Geometry(),
            d = void 0 !== a.scale ? 1 / a.scale : 1;
          (function (b) {
            var d,
              g,
              h,
              k,
              l,
              n,
              p,
              m,
              q,
              s,
              u,
              t,
              x,
              v = a.faces;
            n = a.vertices;
            var C = a.normals,
              w = a.colors,
              D = 0;
            if (void 0 !== a.uvs) {
              for (d = 0; d < a.uvs.length; d++) a.uvs[d].length && D++;
              for (d = 0; d < D; d++) c.faceVertexUvs[d] = [];
            }
            k = 0;
            for (l = n.length; k < l; )
              (d = new THREE.Vector3()),
                (d.x = n[k++] * b),
                (d.y = n[k++] * b),
                (d.z = n[k++] * b),
                c.vertices.push(d);
            k = 0;
            for (l = v.length; k < l; )
              if (
                ((b = v[k++]),
                (q = b & 1),
                (h = b & 2),
                (d = b & 8),
                (p = b & 16),
                (s = b & 32),
                (n = b & 64),
                (b &= 128),
                q)
              ) {
                q = new THREE.Face3();
                q.a = v[k];
                q.b = v[k + 1];
                q.c = v[k + 3];
                u = new THREE.Face3();
                u.a = v[k + 1];
                u.b = v[k + 2];
                u.c = v[k + 3];
                k += 4;
                h &&
                  ((h = v[k++]), (q.materialIndex = h), (u.materialIndex = h));
                h = c.faces.length;
                if (d)
                  for (d = 0; d < D; d++)
                    for (
                      t = a.uvs[d],
                        c.faceVertexUvs[d][h] = [],
                        c.faceVertexUvs[d][h + 1] = [],
                        g = 0;
                      4 > g;
                      g++
                    )
                      (m = v[k++]),
                        (x = t[2 * m]),
                        (m = t[2 * m + 1]),
                        (x = new THREE.Vector2(x, m)),
                        2 !== g && c.faceVertexUvs[d][h].push(x),
                        0 !== g && c.faceVertexUvs[d][h + 1].push(x);
                p &&
                  ((p = 3 * v[k++]),
                  q.normal.set(C[p++], C[p++], C[p]),
                  u.normal.copy(q.normal));
                if (s)
                  for (d = 0; 4 > d; d++)
                    (p = 3 * v[k++]),
                      (s = new THREE.Vector3(C[p++], C[p++], C[p])),
                      2 !== d && q.vertexNormals.push(s),
                      0 !== d && u.vertexNormals.push(s);
                n &&
                  ((n = v[k++]),
                  (n = w[n]),
                  q.color.setHex(n),
                  u.color.setHex(n));
                if (b)
                  for (d = 0; 4 > d; d++)
                    (n = v[k++]),
                      (n = w[n]),
                      2 !== d && q.vertexColors.push(new THREE.Color(n)),
                      0 !== d && u.vertexColors.push(new THREE.Color(n));
                c.faces.push(q);
                c.faces.push(u);
              } else {
                q = new THREE.Face3();
                q.a = v[k++];
                q.b = v[k++];
                q.c = v[k++];
                h && ((h = v[k++]), (q.materialIndex = h));
                h = c.faces.length;
                if (d)
                  for (d = 0; d < D; d++)
                    for (
                      t = a.uvs[d], c.faceVertexUvs[d][h] = [], g = 0;
                      3 > g;
                      g++
                    )
                      (m = v[k++]),
                        (x = t[2 * m]),
                        (m = t[2 * m + 1]),
                        (x = new THREE.Vector2(x, m)),
                        c.faceVertexUvs[d][h].push(x);
                p && ((p = 3 * v[k++]), q.normal.set(C[p++], C[p++], C[p]));
                if (s)
                  for (d = 0; 3 > d; d++)
                    (p = 3 * v[k++]),
                      (s = new THREE.Vector3(C[p++], C[p++], C[p])),
                      q.vertexNormals.push(s);
                n && ((n = v[k++]), q.color.setHex(w[n]));
                if (b)
                  for (d = 0; 3 > d; d++)
                    (n = v[k++]), q.vertexColors.push(new THREE.Color(w[n]));
                c.faces.push(q);
              }
          })(d);
          (function () {
            var b =
              void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
            if (a.skinWeights)
              for (var d = 0, g = a.skinWeights.length; d < g; d += b)
                c.skinWeights.push(
                  new THREE.Vector4(
                    a.skinWeights[d],
                    1 < b ? a.skinWeights[d + 1] : 0,
                    2 < b ? a.skinWeights[d + 2] : 0,
                    3 < b ? a.skinWeights[d + 3] : 0
                  )
                );
            if (a.skinIndices)
              for (d = 0, g = a.skinIndices.length; d < g; d += b)
                c.skinIndices.push(
                  new THREE.Vector4(
                    a.skinIndices[d],
                    1 < b ? a.skinIndices[d + 1] : 0,
                    2 < b ? a.skinIndices[d + 2] : 0,
                    3 < b ? a.skinIndices[d + 3] : 0
                  )
                );
            c.bones = a.bones;
            c.bones &&
              0 < c.bones.length &&
              (c.skinWeights.length !== c.skinIndices.length ||
                c.skinIndices.length !== c.vertices.length) &&
              console.warn(
                "When skinning, number of vertices (" +
                  c.vertices.length +
                  "), skinIndices (" +
                  c.skinIndices.length +
                  "), and skinWeights (" +
                  c.skinWeights.length +
                  ") should match."
              );
          })();
          (function (b) {
            if (void 0 !== a.morphTargets)
              for (var d = 0, g = a.morphTargets.length; d < g; d++) {
                c.morphTargets[d] = {};
                c.morphTargets[d].name = a.morphTargets[d].name;
                c.morphTargets[d].vertices = [];
                for (
                  var h = c.morphTargets[d].vertices,
                    k = a.morphTargets[d].vertices,
                    l = 0,
                    n = k.length;
                  l < n;
                  l += 3
                ) {
                  var p = new THREE.Vector3();
                  p.x = k[l] * b;
                  p.y = k[l + 1] * b;
                  p.z = k[l + 2] * b;
                  h.push(p);
                }
              }
            if (void 0 !== a.morphColors && 0 < a.morphColors.length)
              for (
                console.warn(
                  'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
                ),
                  b = c.faces,
                  h = a.morphColors[0].colors,
                  d = 0,
                  g = b.length;
                d < g;
                d++
              )
                b[d].color.fromArray(h, 3 * d);
          })(d);
          (function () {
            var b = [],
              d = [];
            void 0 !== a.animation && d.push(a.animation);
            void 0 !== a.animations &&
              (a.animations.length
                ? (d = d.concat(a.animations))
                : d.push(a.animations));
            for (var g = 0; g < d.length; g++) {
              var h = THREE.AnimationClip.parseAnimation(d[g], c.bones);
              h && b.push(h);
            }
            c.morphTargets &&
              ((d = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(
                c.morphTargets,
                10
              )),
              (b = b.concat(d)));
            0 < b.length && (c.animations = b);
          })();
          c.computeFaceNormals();
          c.computeBoundingSphere();
          if (void 0 === a.materials || 0 === a.materials.length)
            return { geometry: c };
          d = THREE.Loader.prototype.initMaterials(
            a.materials,
            b,
            this.crossOrigin
          );
          return { geometry: c, materials: d };
        },
      };
      THREE.LoadingManager = function (a, b, c) {
        var d = this,
          e = !1,
          f = 0,
          g = 0;
        this.onStart = void 0;
        this.onLoad = a;
        this.onProgress = b;
        this.onError = c;
        this.itemStart = function (a) {
          g++;
          if (!1 === e && void 0 !== d.onStart) d.onStart(a, f, g);
          e = !0;
        };
        this.itemEnd = function (a) {
          f++;
          if (void 0 !== d.onProgress) d.onProgress(a, f, g);
          if (f === g && ((e = !1), void 0 !== d.onLoad)) d.onLoad();
        };
        this.itemError = function (a) {
          if (void 0 !== d.onError) d.onError(a);
        };
      };
      THREE.DefaultLoadingManager = new THREE.LoadingManager();
      THREE.BufferGeometryLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
      };
      THREE.BufferGeometryLoader.prototype = {
        constructor: THREE.BufferGeometryLoader,
        load: function (a, b, c, d) {
          var e = this;
          new THREE.XHRLoader(e.manager).load(
            a,
            function (a) {
              b(e.parse(JSON.parse(a)));
            },
            c,
            d
          );
        },
        parse: function (a) {
          var b = new THREE.BufferGeometry(),
            c = a.data.index,
            d = {
              Int8Array: Int8Array,
              Uint8Array: Uint8Array,
              Uint8ClampedArray: Uint8ClampedArray,
              Int16Array: Int16Array,
              Uint16Array: Uint16Array,
              Int32Array: Int32Array,
              Uint32Array: Uint32Array,
              Float32Array: Float32Array,
              Float64Array: Float64Array,
            };
          void 0 !== c &&
            ((c = new d[c.type](c.array)),
            b.setIndex(new THREE.BufferAttribute(c, 1)));
          var e = a.data.attributes,
            f;
          for (f in e) {
            var g = e[f],
              c = new d[g.type](g.array);
            b.addAttribute(f, new THREE.BufferAttribute(c, g.itemSize));
          }
          d = a.data.groups || a.data.drawcalls || a.data.offsets;
          if (void 0 !== d)
            for (f = 0, c = d.length; f !== c; ++f)
              (e = d[f]), b.addGroup(e.start, e.count, e.materialIndex);
          a = a.data.boundingSphere;
          void 0 !== a &&
            ((d = new THREE.Vector3()),
            void 0 !== a.center && d.fromArray(a.center),
            (b.boundingSphere = new THREE.Sphere(d, a.radius)));
          return b;
        },
      };
      THREE.MaterialLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
        this.textures = {};
      };
      THREE.MaterialLoader.prototype = {
        constructor: THREE.MaterialLoader,
        load: function (a, b, c, d) {
          var e = this;
          new THREE.XHRLoader(e.manager).load(
            a,
            function (a) {
              b(e.parse(JSON.parse(a)));
            },
            c,
            d
          );
        },
        setTextures: function (a) {
          this.textures = a;
        },
        getTexture: function (a) {
          var b = this.textures;
          void 0 === b[a] &&
            console.warn("THREE.MaterialLoader: Undefined texture", a);
          return b[a];
        },
        parse: function (a) {
          var b = new THREE[a.type]();
          void 0 !== a.uuid && (b.uuid = a.uuid);
          void 0 !== a.name && (b.name = a.name);
          void 0 !== a.color && b.color.setHex(a.color);
          void 0 !== a.roughness && (b.roughness = a.roughness);
          void 0 !== a.metalness && (b.metalness = a.metalness);
          void 0 !== a.emissive && b.emissive.setHex(a.emissive);
          void 0 !== a.specular && b.specular.setHex(a.specular);
          void 0 !== a.shininess && (b.shininess = a.shininess);
          void 0 !== a.uniforms && (b.uniforms = a.uniforms);
          void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader);
          void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader);
          void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
          void 0 !== a.shading && (b.shading = a.shading);
          void 0 !== a.blending && (b.blending = a.blending);
          void 0 !== a.side && (b.side = a.side);
          void 0 !== a.opacity && (b.opacity = a.opacity);
          void 0 !== a.transparent && (b.transparent = a.transparent);
          void 0 !== a.alphaTest && (b.alphaTest = a.alphaTest);
          void 0 !== a.depthTest && (b.depthTest = a.depthTest);
          void 0 !== a.depthWrite && (b.depthWrite = a.depthWrite);
          void 0 !== a.colorWrite && (b.colorWrite = a.colorWrite);
          void 0 !== a.wireframe && (b.wireframe = a.wireframe);
          void 0 !== a.wireframeLinewidth &&
            (b.wireframeLinewidth = a.wireframeLinewidth);
          void 0 !== a.size && (b.size = a.size);
          void 0 !== a.sizeAttenuation &&
            (b.sizeAttenuation = a.sizeAttenuation);
          void 0 !== a.map && (b.map = this.getTexture(a.map));
          void 0 !== a.alphaMap &&
            ((b.alphaMap = this.getTexture(a.alphaMap)), (b.transparent = !0));
          void 0 !== a.bumpMap && (b.bumpMap = this.getTexture(a.bumpMap));
          void 0 !== a.bumpScale && (b.bumpScale = a.bumpScale);
          void 0 !== a.normalMap &&
            (b.normalMap = this.getTexture(a.normalMap));
          if (void 0 !== a.normalScale) {
            var c = a.normalScale;
            !1 === Array.isArray(c) && (c = [c, c]);
            b.normalScale = new THREE.Vector2().fromArray(c);
          }
          void 0 !== a.displacementMap &&
            (b.displacementMap = this.getTexture(a.displacementMap));
          void 0 !== a.displacementScale &&
            (b.displacementScale = a.displacementScale);
          void 0 !== a.displacementBias &&
            (b.displacementBias = a.displacementBias);
          void 0 !== a.roughnessMap &&
            (b.roughnessMap = this.getTexture(a.roughnessMap));
          void 0 !== a.metalnessMap &&
            (b.metalnessMap = this.getTexture(a.metalnessMap));
          void 0 !== a.emissiveMap &&
            (b.emissiveMap = this.getTexture(a.emissiveMap));
          void 0 !== a.emissiveIntensity &&
            (b.emissiveIntensity = a.emissiveIntensity);
          void 0 !== a.specularMap &&
            (b.specularMap = this.getTexture(a.specularMap));
          void 0 !== a.envMap &&
            ((b.envMap = this.getTexture(a.envMap)),
            (b.combine = THREE.MultiplyOperation));
          a.reflectivity && (b.reflectivity = a.reflectivity);
          void 0 !== a.lightMap && (b.lightMap = this.getTexture(a.lightMap));
          void 0 !== a.lightMapIntensity &&
            (b.lightMapIntensity = a.lightMapIntensity);
          void 0 !== a.aoMap && (b.aoMap = this.getTexture(a.aoMap));
          void 0 !== a.aoMapIntensity && (b.aoMapIntensity = a.aoMapIntensity);
          if (void 0 !== a.materials)
            for (var c = 0, d = a.materials.length; c < d; c++)
              b.materials.push(this.parse(a.materials[c]));
          return b;
        },
      };
      THREE.ObjectLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
        this.texturePath = "";
      };
      THREE.ObjectLoader.prototype = {
        constructor: THREE.ObjectLoader,
        load: function (a, b, c, d) {
          "" === this.texturePath &&
            (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
          var e = this;
          new THREE.XHRLoader(e.manager).load(
            a,
            function (a) {
              e.parse(JSON.parse(a), b);
            },
            c,
            d
          );
        },
        setTexturePath: function (a) {
          this.texturePath = a;
        },
        setCrossOrigin: function (a) {
          this.crossOrigin = a;
        },
        parse: function (a, b) {
          var c = this.parseGeometries(a.geometries),
            d = this.parseImages(a.images, function () {
              void 0 !== b && b(e);
            }),
            d = this.parseTextures(a.textures, d),
            d = this.parseMaterials(a.materials, d),
            e = this.parseObject(a.object, c, d);
          a.animations && (e.animations = this.parseAnimations(a.animations));
          (void 0 !== a.images && 0 !== a.images.length) ||
            void 0 === b ||
            b(e);
          return e;
        },
        parseGeometries: function (a) {
          var b = {};
          if (void 0 !== a)
            for (
              var c = new THREE.JSONLoader(),
                d = new THREE.BufferGeometryLoader(),
                e = 0,
                f = a.length;
              e < f;
              e++
            ) {
              var g,
                h = a[e];
              switch (h.type) {
                case "PlaneGeometry":
                case "PlaneBufferGeometry":
                  g = new THREE[h.type](
                    h.width,
                    h.height,
                    h.widthSegments,
                    h.heightSegments
                  );
                  break;
                case "BoxGeometry":
                case "CubeGeometry":
                  g = new THREE.BoxGeometry(
                    h.width,
                    h.height,
                    h.depth,
                    h.widthSegments,
                    h.heightSegments,
                    h.depthSegments
                  );
                  break;
                case "CircleBufferGeometry":
                  g = new THREE.CircleBufferGeometry(
                    h.radius,
                    h.segments,
                    h.thetaStart,
                    h.thetaLength
                  );
                  break;
                case "CircleGeometry":
                  g = new THREE.CircleGeometry(
                    h.radius,
                    h.segments,
                    h.thetaStart,
                    h.thetaLength
                  );
                  break;
                case "CylinderGeometry":
                  g = new THREE.CylinderGeometry(
                    h.radiusTop,
                    h.radiusBottom,
                    h.height,
                    h.radialSegments,
                    h.heightSegments,
                    h.openEnded,
                    h.thetaStart,
                    h.thetaLength
                  );
                  break;
                case "SphereGeometry":
                  g = new THREE.SphereGeometry(
                    h.radius,
                    h.widthSegments,
                    h.heightSegments,
                    h.phiStart,
                    h.phiLength,
                    h.thetaStart,
                    h.thetaLength
                  );
                  break;
                case "SphereBufferGeometry":
                  g = new THREE.SphereBufferGeometry(
                    h.radius,
                    h.widthSegments,
                    h.heightSegments,
                    h.phiStart,
                    h.phiLength,
                    h.thetaStart,
                    h.thetaLength
                  );
                  break;
                case "DodecahedronGeometry":
                  g = new THREE.DodecahedronGeometry(h.radius, h.detail);
                  break;
                case "IcosahedronGeometry":
                  g = new THREE.IcosahedronGeometry(h.radius, h.detail);
                  break;
                case "OctahedronGeometry":
                  g = new THREE.OctahedronGeometry(h.radius, h.detail);
                  break;
                case "TetrahedronGeometry":
                  g = new THREE.TetrahedronGeometry(h.radius, h.detail);
                  break;
                case "RingGeometry":
                  g = new THREE.RingGeometry(
                    h.innerRadius,
                    h.outerRadius,
                    h.thetaSegments,
                    h.phiSegments,
                    h.thetaStart,
                    h.thetaLength
                  );
                  break;
                case "TorusGeometry":
                  g = new THREE.TorusGeometry(
                    h.radius,
                    h.tube,
                    h.radialSegments,
                    h.tubularSegments,
                    h.arc
                  );
                  break;
                case "TorusKnotGeometry":
                  g = new THREE.TorusKnotGeometry(
                    h.radius,
                    h.tube,
                    h.radialSegments,
                    h.tubularSegments,
                    h.p,
                    h.q,
                    h.heightScale
                  );
                  break;
                case "LatheGeometry":
                  g = new THREE.LatheGeometry(
                    h.points,
                    h.segments,
                    h.phiStart,
                    h.phiLength
                  );
                  break;
                case "BufferGeometry":
                  g = d.parse(h);
                  break;
                case "Geometry":
                  g = c.parse(h.data, this.texturePath).geometry;
                  break;
                default:
                  console.warn(
                    'THREE.ObjectLoader: Unsupported geometry type "' +
                      h.type +
                      '"'
                  );
                  continue;
              }
              g.uuid = h.uuid;
              void 0 !== h.name && (g.name = h.name);
              b[h.uuid] = g;
            }
          return b;
        },
        parseMaterials: function (a, b) {
          var c = {};
          if (void 0 !== a) {
            var d = new THREE.MaterialLoader();
            d.setTextures(b);
            for (var e = 0, f = a.length; e < f; e++) {
              var g = d.parse(a[e]);
              c[g.uuid] = g;
            }
          }
          return c;
        },
        parseAnimations: function (a) {
          for (var b = [], c = 0; c < a.length; c++) {
            var d = THREE.AnimationClip.parse(a[c]);
            b.push(d);
          }
          return b;
        },
        parseImages: function (a, b) {
          function c(a) {
            d.manager.itemStart(a);
            return g.load(a, function () {
              d.manager.itemEnd(a);
            });
          }
          var d = this,
            e = {};
          if (void 0 !== a && 0 < a.length) {
            var f = new THREE.LoadingManager(b),
              g = new THREE.ImageLoader(f);
            g.setCrossOrigin(this.crossOrigin);
            for (var f = 0, h = a.length; f < h; f++) {
              var k = a[f],
                l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(k.url)
                  ? k.url
                  : d.texturePath + k.url;
              e[k.uuid] = c(l);
            }
          }
          return e;
        },
        parseTextures: function (a, b) {
          function c(a) {
            if ("number" === typeof a) return a;
            console.warn(
              "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
              a
            );
            return THREE[a];
          }
          var d = {};
          if (void 0 !== a)
            for (var e = 0, f = a.length; e < f; e++) {
              var g = a[e];
              void 0 === g.image &&
                console.warn(
                  'THREE.ObjectLoader: No "image" specified for',
                  g.uuid
                );
              void 0 === b[g.image] &&
                console.warn("THREE.ObjectLoader: Undefined image", g.image);
              var h = new THREE.Texture(b[g.image]);
              h.needsUpdate = !0;
              h.uuid = g.uuid;
              void 0 !== g.name && (h.name = g.name);
              void 0 !== g.mapping && (h.mapping = c(g.mapping));
              void 0 !== g.offset &&
                (h.offset = new THREE.Vector2(g.offset[0], g.offset[1]));
              void 0 !== g.repeat &&
                (h.repeat = new THREE.Vector2(g.repeat[0], g.repeat[1]));
              void 0 !== g.minFilter && (h.minFilter = c(g.minFilter));
              void 0 !== g.magFilter && (h.magFilter = c(g.magFilter));
              void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy);
              Array.isArray(g.wrap) &&
                ((h.wrapS = c(g.wrap[0])), (h.wrapT = c(g.wrap[1])));
              d[g.uuid] = h;
            }
          return d;
        },
        parseObject: (function () {
          var a = new THREE.Matrix4();
          return function (b, c, d) {
            function e(a) {
              void 0 === c[a] &&
                console.warn("THREE.ObjectLoader: Undefined geometry", a);
              return c[a];
            }
            function f(a) {
              if (void 0 !== a)
                return (
                  void 0 === d[a] &&
                    console.warn("THREE.ObjectLoader: Undefined material", a),
                  d[a]
                );
            }
            var g;
            switch (b.type) {
              case "Scene":
                g = new THREE.Scene();
                break;
              case "PerspectiveCamera":
                g = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
                break;
              case "OrthographicCamera":
                g = new THREE.OrthographicCamera(
                  b.left,
                  b.right,
                  b.top,
                  b.bottom,
                  b.near,
                  b.far
                );
                break;
              case "AmbientLight":
                g = new THREE.AmbientLight(b.color, b.intensity);
                break;
              case "DirectionalLight":
                g = new THREE.DirectionalLight(b.color, b.intensity);
                break;
              case "PointLight":
                g = new THREE.PointLight(
                  b.color,
                  b.intensity,
                  b.distance,
                  b.decay
                );
                break;
              case "SpotLight":
                g = new THREE.SpotLight(
                  b.color,
                  b.intensity,
                  b.distance,
                  b.angle,
                  b.penumbra,
                  b.decay
                );
                break;
              case "HemisphereLight":
                g = new THREE.HemisphereLight(
                  b.color,
                  b.groundColor,
                  b.intensity
                );
                break;
              case "Mesh":
                g = e(b.geometry);
                var h = f(b.material);
                g =
                  g.bones && 0 < g.bones.length
                    ? new THREE.SkinnedMesh(g, h)
                    : new THREE.Mesh(g, h);
                break;
              case "LOD":
                g = new THREE.LOD();
                break;
              case "Line":
                g = new THREE.Line(e(b.geometry), f(b.material), b.mode);
                break;
              case "PointCloud":
              case "Points":
                g = new THREE.Points(e(b.geometry), f(b.material));
                break;
              case "Sprite":
                g = new THREE.Sprite(f(b.material));
                break;
              case "Group":
                g = new THREE.Group();
                break;
              default:
                g = new THREE.Object3D();
            }
            g.uuid = b.uuid;
            void 0 !== b.name && (g.name = b.name);
            void 0 !== b.matrix
              ? (a.fromArray(b.matrix),
                a.decompose(g.position, g.quaternion, g.scale))
              : (void 0 !== b.position && g.position.fromArray(b.position),
                void 0 !== b.rotation && g.rotation.fromArray(b.rotation),
                void 0 !== b.scale && g.scale.fromArray(b.scale));
            void 0 !== b.castShadow && (g.castShadow = b.castShadow);
            void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow);
            void 0 !== b.visible && (g.visible = b.visible);
            void 0 !== b.userData && (g.userData = b.userData);
            if (void 0 !== b.children)
              for (var k in b.children)
                g.add(this.parseObject(b.children[k], c, d));
            if ("LOD" === b.type)
              for (b = b.levels, h = 0; h < b.length; h++) {
                var l = b[h];
                k = g.getObjectByProperty("uuid", l.object);
                void 0 !== k && g.addLevel(k, l.distance);
              }
            return g;
          };
        })(),
      };
      THREE.TextureLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
      };
      THREE.TextureLoader.prototype = {
        constructor: THREE.TextureLoader,
        load: function (a, b, c, d) {
          var e = new THREE.Texture(),
            f = new THREE.ImageLoader(this.manager);
          f.setCrossOrigin(this.crossOrigin);
          f.setPath(this.path);
          f.load(
            a,
            function (a) {
              e.image = a;
              e.needsUpdate = !0;
              void 0 !== b && b(e);
            },
            c,
            d
          );
          return e;
        },
        setCrossOrigin: function (a) {
          this.crossOrigin = a;
        },
        setPath: function (a) {
          this.path = a;
        },
      };
      THREE.CubeTextureLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
      };
      THREE.CubeTextureLoader.prototype = {
        constructor: THREE.CubeTextureLoader,
        load: function (a, b, c, d) {
          function e(c) {
            g.load(
              a[c],
              function (a) {
                f.images[c] = a;
                h++;
                6 === h && ((f.needsUpdate = !0), b && b(f));
              },
              void 0,
              d
            );
          }
          var f = new THREE.CubeTexture([]),
            g = new THREE.ImageLoader(this.manager);
          g.setCrossOrigin(this.crossOrigin);
          g.setPath(this.path);
          var h = 0;
          for (c = 0; c < a.length; ++c) e(c);
          return f;
        },
        setCrossOrigin: function (a) {
          this.crossOrigin = a;
        },
        setPath: function (a) {
          this.path = a;
        },
      };
      THREE.DataTextureLoader = THREE.BinaryTextureLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
        this._parser = null;
      };
      THREE.BinaryTextureLoader.prototype = {
        constructor: THREE.BinaryTextureLoader,
        load: function (a, b, c, d) {
          var e = this,
            f = new THREE.DataTexture(),
            g = new THREE.XHRLoader(this.manager);
          g.setResponseType("arraybuffer");
          g.load(
            a,
            function (a) {
              if ((a = e._parser(a)))
                void 0 !== a.image
                  ? (f.image = a.image)
                  : void 0 !== a.data &&
                    ((f.image.width = a.width),
                    (f.image.height = a.height),
                    (f.image.data = a.data)),
                  (f.wrapS =
                    void 0 !== a.wrapS ? a.wrapS : THREE.ClampToEdgeWrapping),
                  (f.wrapT =
                    void 0 !== a.wrapT ? a.wrapT : THREE.ClampToEdgeWrapping),
                  (f.magFilter =
                    void 0 !== a.magFilter ? a.magFilter : THREE.LinearFilter),
                  (f.minFilter =
                    void 0 !== a.minFilter
                      ? a.minFilter
                      : THREE.LinearMipMapLinearFilter),
                  (f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1),
                  void 0 !== a.format && (f.format = a.format),
                  void 0 !== a.type && (f.type = a.type),
                  void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps),
                  1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter),
                  (f.needsUpdate = !0),
                  b && b(f, a);
            },
            c,
            d
          );
          return f;
        },
      };
      THREE.CompressedTextureLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
        this._parser = null;
      };
      THREE.CompressedTextureLoader.prototype = {
        constructor: THREE.CompressedTextureLoader,
        load: function (a, b, c, d) {
          function e(e) {
            k.load(
              a[e],
              function (a) {
                a = f._parser(a, !0);
                g[e] = {
                  width: a.width,
                  height: a.height,
                  format: a.format,
                  mipmaps: a.mipmaps,
                };
                l += 1;
                6 === l &&
                  (1 === a.mipmapCount && (h.minFilter = THREE.LinearFilter),
                  (h.format = a.format),
                  (h.needsUpdate = !0),
                  b && b(h));
              },
              c,
              d
            );
          }
          var f = this,
            g = [],
            h = new THREE.CompressedTexture();
          h.image = g;
          var k = new THREE.XHRLoader(this.manager);
          k.setPath(this.path);
          k.setResponseType("arraybuffer");
          if (Array.isArray(a))
            for (var l = 0, n = 0, p = a.length; n < p; ++n) e(n);
          else
            k.load(
              a,
              function (a) {
                a = f._parser(a, !0);
                if (a.isCubemap)
                  for (
                    var c = a.mipmaps.length / a.mipmapCount, d = 0;
                    d < c;
                    d++
                  ) {
                    g[d] = { mipmaps: [] };
                    for (var e = 0; e < a.mipmapCount; e++)
                      g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]),
                        (g[d].format = a.format),
                        (g[d].width = a.width),
                        (g[d].height = a.height);
                  }
                else
                  (h.image.width = a.width),
                    (h.image.height = a.height),
                    (h.mipmaps = a.mipmaps);
                1 === a.mipmapCount && (h.minFilter = THREE.LinearFilter);
                h.format = a.format;
                h.needsUpdate = !0;
                b && b(h);
              },
              c,
              d
            );
          return h;
        },
        setPath: function (a) {
          this.path = a;
        },
      };
      THREE.Material = function () {
        Object.defineProperty(this, "id", { value: THREE.MaterialIdCount++ });
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.type = "Material";
        this.side = THREE.FrontSide;
        this.opacity = 1;
        this.transparent = !1;
        this.blending = THREE.NormalBlending;
        this.blendSrc = THREE.SrcAlphaFactor;
        this.blendDst = THREE.OneMinusSrcAlphaFactor;
        this.blendEquation = THREE.AddEquation;
        this.blendEquationAlpha =
          this.blendDstAlpha =
          this.blendSrcAlpha =
            null;
        this.depthFunc = THREE.LessEqualDepth;
        this.colorWrite = this.depthWrite = this.depthTest = !0;
        this.precision = null;
        this.polygonOffset = !1;
        this.overdraw =
          this.alphaTest =
          this.polygonOffsetUnits =
          this.polygonOffsetFactor =
            0;
        this._needsUpdate = this.visible = !0;
      };
      THREE.Material.prototype = {
        constructor: THREE.Material,
        get needsUpdate() {
          return this._needsUpdate;
        },
        set needsUpdate(a) {
          !0 === a && this.update();
          this._needsUpdate = a;
        },
        setValues: function (a) {
          if (void 0 !== a)
            for (var b in a) {
              var c = a[b];
              if (void 0 === c)
                console.warn(
                  "THREE.Material: '" + b + "' parameter is undefined."
                );
              else {
                var d = this[b];
                void 0 === d
                  ? console.warn(
                      "THREE." +
                        this.type +
                        ": '" +
                        b +
                        "' is not a property of this material."
                    )
                  : d instanceof THREE.Color
                  ? d.set(c)
                  : d instanceof THREE.Vector3 && c instanceof THREE.Vector3
                  ? d.copy(c)
                  : (this[b] = "overdraw" === b ? Number(c) : c);
              }
            }
        },
        toJSON: function (a) {
          function b(a) {
            var b = [],
              c;
            for (c in a) {
              var d = a[c];
              delete d.metadata;
              b.push(d);
            }
            return b;
          }
          var c = void 0 === a;
          c && (a = { textures: {}, images: {} });
          var d = {
            metadata: {
              version: 4.4,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          d.uuid = this.uuid;
          d.type = this.type;
          "" !== this.name && (d.name = this.name);
          this.color instanceof THREE.Color && (d.color = this.color.getHex());
          0.5 !== this.roughness && (d.roughness = this.roughness);
          0.5 !== this.metalness && (d.metalness = this.metalness);
          this.emissive instanceof THREE.Color &&
            (d.emissive = this.emissive.getHex());
          this.specular instanceof THREE.Color &&
            (d.specular = this.specular.getHex());
          void 0 !== this.shininess && (d.shininess = this.shininess);
          this.map instanceof THREE.Texture &&
            (d.map = this.map.toJSON(a).uuid);
          this.alphaMap instanceof THREE.Texture &&
            (d.alphaMap = this.alphaMap.toJSON(a).uuid);
          this.lightMap instanceof THREE.Texture &&
            (d.lightMap = this.lightMap.toJSON(a).uuid);
          this.bumpMap instanceof THREE.Texture &&
            ((d.bumpMap = this.bumpMap.toJSON(a).uuid),
            (d.bumpScale = this.bumpScale));
          this.normalMap instanceof THREE.Texture &&
            ((d.normalMap = this.normalMap.toJSON(a).uuid),
            (d.normalScale = this.normalScale.toArray()));
          this.displacementMap instanceof THREE.Texture &&
            ((d.displacementMap = this.displacementMap.toJSON(a).uuid),
            (d.displacementScale = this.displacementScale),
            (d.displacementBias = this.displacementBias));
          this.roughnessMap instanceof THREE.Texture &&
            (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
          this.metalnessMap instanceof THREE.Texture &&
            (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
          this.emissiveMap instanceof THREE.Texture &&
            (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
          this.specularMap instanceof THREE.Texture &&
            (d.specularMap = this.specularMap.toJSON(a).uuid);
          this.envMap instanceof THREE.Texture &&
            ((d.envMap = this.envMap.toJSON(a).uuid),
            (d.reflectivity = this.reflectivity));
          void 0 !== this.size && (d.size = this.size);
          void 0 !== this.sizeAttenuation &&
            (d.sizeAttenuation = this.sizeAttenuation);
          void 0 !== this.vertexColors &&
            this.vertexColors !== THREE.NoColors &&
            (d.vertexColors = this.vertexColors);
          void 0 !== this.shading &&
            this.shading !== THREE.SmoothShading &&
            (d.shading = this.shading);
          void 0 !== this.blending &&
            this.blending !== THREE.NormalBlending &&
            (d.blending = this.blending);
          void 0 !== this.side &&
            this.side !== THREE.FrontSide &&
            (d.side = this.side);
          1 > this.opacity && (d.opacity = this.opacity);
          !0 === this.transparent && (d.transparent = this.transparent);
          0 < this.alphaTest && (d.alphaTest = this.alphaTest);
          !0 === this.wireframe && (d.wireframe = this.wireframe);
          1 < this.wireframeLinewidth &&
            (d.wireframeLinewidth = this.wireframeLinewidth);
          c &&
            ((c = b(a.textures)),
            (a = b(a.images)),
            0 < c.length && (d.textures = c),
            0 < a.length && (d.images = a));
          return d;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.name = a.name;
          this.side = a.side;
          this.opacity = a.opacity;
          this.transparent = a.transparent;
          this.blending = a.blending;
          this.blendSrc = a.blendSrc;
          this.blendDst = a.blendDst;
          this.blendEquation = a.blendEquation;
          this.blendSrcAlpha = a.blendSrcAlpha;
          this.blendDstAlpha = a.blendDstAlpha;
          this.blendEquationAlpha = a.blendEquationAlpha;
          this.depthFunc = a.depthFunc;
          this.depthTest = a.depthTest;
          this.depthWrite = a.depthWrite;
          this.colorWrite = a.colorWrite;
          this.precision = a.precision;
          this.polygonOffset = a.polygonOffset;
          this.polygonOffsetFactor = a.polygonOffsetFactor;
          this.polygonOffsetUnits = a.polygonOffsetUnits;
          this.alphaTest = a.alphaTest;
          this.overdraw = a.overdraw;
          this.visible = a.visible;
          return this;
        },
        update: function () {
          this.dispatchEvent({ type: "update" });
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      };
      THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
      THREE.MaterialIdCount = 0;
      THREE.LineBasicMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "LineBasicMaterial";
        this.color = new THREE.Color(16777215);
        this.linewidth = 1;
        this.linejoin = this.linecap = "round";
        this.vertexColors = THREE.NoColors;
        this.fog = !0;
        this.setValues(a);
      };
      THREE.LineBasicMaterial.prototype = Object.create(
        THREE.Material.prototype
      );
      THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
      THREE.LineBasicMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.linewidth = a.linewidth;
        this.linecap = a.linecap;
        this.linejoin = a.linejoin;
        this.vertexColors = a.vertexColors;
        this.fog = a.fog;
        return this;
      };
      THREE.LineDashedMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "LineDashedMaterial";
        this.color = new THREE.Color(16777215);
        this.scale = this.linewidth = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.vertexColors = THREE.NoColors;
        this.fog = !0;
        this.setValues(a);
      };
      THREE.LineDashedMaterial.prototype = Object.create(
        THREE.Material.prototype
      );
      THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
      THREE.LineDashedMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.linewidth = a.linewidth;
        this.scale = a.scale;
        this.dashSize = a.dashSize;
        this.gapSize = a.gapSize;
        this.vertexColors = a.vertexColors;
        this.fog = a.fog;
        return this;
      };
      THREE.MeshBasicMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "MeshBasicMaterial";
        this.color = new THREE.Color(16777215);
        this.aoMap = this.map = null;
        this.aoMapIntensity = 1;
        this.envMap = this.alphaMap = this.specularMap = null;
        this.combine = THREE.MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.fog = !0;
        this.shading = THREE.SmoothShading;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.vertexColors = THREE.NoColors;
        this.morphTargets = this.skinning = !1;
        this.setValues(a);
      };
      THREE.MeshBasicMaterial.prototype = Object.create(
        THREE.Material.prototype
      );
      THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
      THREE.MeshBasicMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.fog = a.fog;
        this.shading = a.shading;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.vertexColors = a.vertexColors;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        return this;
      };
      THREE.MeshLambertMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "MeshLambertMaterial";
        this.color = new THREE.Color(16777215);
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new THREE.Color(0);
        this.emissiveIntensity = 1;
        this.envMap =
          this.alphaMap =
          this.specularMap =
          this.emissiveMap =
            null;
        this.combine = THREE.MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.fog = !0;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.vertexColors = THREE.NoColors;
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a);
      };
      THREE.MeshLambertMaterial.prototype = Object.create(
        THREE.Material.prototype
      );
      THREE.MeshLambertMaterial.prototype.constructor =
        THREE.MeshLambertMaterial;
      THREE.MeshLambertMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity = a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.emissive.copy(a.emissive);
        this.emissiveMap = a.emissiveMap;
        this.emissiveIntensity = a.emissiveIntensity;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.fog = a.fog;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.vertexColors = a.vertexColors;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this;
      };
      THREE.MeshPhongMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "MeshPhongMaterial";
        this.color = new THREE.Color(16777215);
        this.specular = new THREE.Color(1118481);
        this.shininess = 30;
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new THREE.Color(0);
        this.emissiveIntensity = 1;
        this.bumpMap = this.emissiveMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new THREE.Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.envMap = this.alphaMap = this.specularMap = null;
        this.combine = THREE.MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.fog = !0;
        this.shading = THREE.SmoothShading;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.vertexColors = THREE.NoColors;
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a);
      };
      THREE.MeshPhongMaterial.prototype = Object.create(
        THREE.Material.prototype
      );
      THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
      THREE.MeshPhongMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.specular.copy(a.specular);
        this.shininess = a.shininess;
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity = a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.emissive.copy(a.emissive);
        this.emissiveMap = a.emissiveMap;
        this.emissiveIntensity = a.emissiveIntensity;
        this.bumpMap = a.bumpMap;
        this.bumpScale = a.bumpScale;
        this.normalMap = a.normalMap;
        this.normalScale.copy(a.normalScale);
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.fog = a.fog;
        this.shading = a.shading;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.vertexColors = a.vertexColors;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this;
      };
      THREE.MeshStandardMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "MeshStandardMaterial";
        this.color = new THREE.Color(16777215);
        this.metalness = this.roughness = 0.5;
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new THREE.Color(0);
        this.emissiveIntensity = 1;
        this.bumpMap = this.emissiveMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new THREE.Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.envMap =
          this.alphaMap =
          this.metalnessMap =
          this.roughnessMap =
            null;
        this.envMapIntensity = 1;
        this.refractionRatio = 0.98;
        this.fog = !0;
        this.shading = THREE.SmoothShading;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.vertexColors = THREE.NoColors;
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a);
      };
      THREE.MeshStandardMaterial.prototype = Object.create(
        THREE.Material.prototype
      );
      THREE.MeshStandardMaterial.prototype.constructor =
        THREE.MeshStandardMaterial;
      THREE.MeshStandardMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.roughness = a.roughness;
        this.metalness = a.metalness;
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity = a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.emissive.copy(a.emissive);
        this.emissiveMap = a.emissiveMap;
        this.emissiveIntensity = a.emissiveIntensity;
        this.bumpMap = a.bumpMap;
        this.bumpScale = a.bumpScale;
        this.normalMap = a.normalMap;
        this.normalScale.copy(a.normalScale);
        this.displacementMap = a.displacementMap;
        this.displacementScale = a.displacementScale;
        this.displacementBias = a.displacementBias;
        this.roughnessMap = a.roughnessMap;
        this.metalnessMap = a.metalnessMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.envMapIntensity = a.envMapIntensity;
        this.refractionRatio = a.refractionRatio;
        this.fog = a.fog;
        this.shading = a.shading;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.vertexColors = a.vertexColors;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        return this;
      };
      THREE.MeshDepthMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "MeshDepthMaterial";
        this.wireframe = this.morphTargets = !1;
        this.wireframeLinewidth = 1;
        this.setValues(a);
      };
      THREE.MeshDepthMaterial.prototype = Object.create(
        THREE.Material.prototype
      );
      THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
      THREE.MeshDepthMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        return this;
      };
      THREE.MeshNormalMaterial = function (a) {
        THREE.Material.call(this, a);
        this.type = "MeshNormalMaterial";
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.morphTargets = !1;
        this.setValues(a);
      };
      THREE.MeshNormalMaterial.prototype = Object.create(
        THREE.Material.prototype
      );
      THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
      THREE.MeshNormalMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        return this;
      };
      THREE.MultiMaterial = function (a) {
        this.uuid = THREE.Math.generateUUID();
        this.type = "MultiMaterial";
        this.materials = a instanceof Array ? a : [];
        this.visible = !0;
      };
      THREE.MultiMaterial.prototype = {
        constructor: THREE.MultiMaterial,
        toJSON: function (a) {
          for (
            var b = {
                metadata: {
                  version: 4.2,
                  type: "material",
                  generator: "MaterialExporter",
                },
                uuid: this.uuid,
                type: this.type,
                materials: [],
              },
              c = this.materials,
              d = 0,
              e = c.length;
            d < e;
            d++
          ) {
            var f = c[d].toJSON(a);
            delete f.metadata;
            b.materials.push(f);
          }
          b.visible = this.visible;
          return b;
        },
        clone: function () {
          for (
            var a = new this.constructor(), b = 0;
            b < this.materials.length;
            b++
          )
            a.materials.push(this.materials[b].clone());
          a.visible = this.visible;
          return a;
        },
      };
      THREE.PointsMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "PointsMaterial";
        this.color = new THREE.Color(16777215);
        this.map = null;
        this.size = 1;
        this.sizeAttenuation = !0;
        this.vertexColors = THREE.NoColors;
        this.fog = !0;
        this.setValues(a);
      };
      THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype);
      THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
      THREE.PointsMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.size = a.size;
        this.sizeAttenuation = a.sizeAttenuation;
        this.vertexColors = a.vertexColors;
        this.fog = a.fog;
        return this;
      };
      THREE.ShaderMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.vertexShader =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
        this.fragmentShader =
          "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        this.shading = THREE.SmoothShading;
        this.linewidth = 1;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.lights = this.fog = !1;
        this.vertexColors = THREE.NoColors;
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        };
        this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0],
        };
        this.index0AttributeName = void 0;
        void 0 !== a &&
          (void 0 !== a.attributes &&
            console.error(
              "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
            ),
          this.setValues(a));
      };
      THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
      THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
      THREE.ShaderMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.fragmentShader = a.fragmentShader;
        this.vertexShader = a.vertexShader;
        this.uniforms = THREE.UniformsUtils.clone(a.uniforms);
        this.defines = a.defines;
        this.shading = a.shading;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.fog = a.fog;
        this.lights = a.lights;
        this.vertexColors = a.vertexColors;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        this.extensions = a.extensions;
        return this;
      };
      THREE.ShaderMaterial.prototype.toJSON = function (a) {
        a = THREE.Material.prototype.toJSON.call(this, a);
        a.uniforms = this.uniforms;
        a.vertexShader = this.vertexShader;
        a.fragmentShader = this.fragmentShader;
        return a;
      };
      THREE.RawShaderMaterial = function (a) {
        THREE.ShaderMaterial.call(this, a);
        this.type = "RawShaderMaterial";
      };
      THREE.RawShaderMaterial.prototype = Object.create(
        THREE.ShaderMaterial.prototype
      );
      THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
      THREE.SpriteMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "SpriteMaterial";
        this.color = new THREE.Color(16777215);
        this.map = null;
        this.rotation = 0;
        this.fog = !1;
        this.setValues(a);
      };
      THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
      THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
      THREE.SpriteMaterial.prototype.copy = function (a) {
        THREE.Material.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.rotation = a.rotation;
        this.fog = a.fog;
        return this;
      };
      THREE.Texture = function (a, b, c, d, e, f, g, h, k) {
        Object.defineProperty(this, "id", { value: THREE.TextureIdCount++ });
        this.uuid = THREE.Math.generateUUID();
        this.sourceFile = this.name = "";
        this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE;
        this.mipmaps = [];
        this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING;
        this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
        this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
        this.magFilter = void 0 !== e ? e : THREE.LinearFilter;
        this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;
        this.anisotropy = void 0 !== k ? k : 1;
        this.format = void 0 !== g ? g : THREE.RGBAFormat;
        this.type = void 0 !== h ? h : THREE.UnsignedByteType;
        this.offset = new THREE.Vector2(0, 0);
        this.repeat = new THREE.Vector2(1, 1);
        this.generateMipmaps = !0;
        this.premultiplyAlpha = !1;
        this.flipY = !0;
        this.unpackAlignment = 4;
        this.version = 0;
        this.onUpdate = null;
      };
      THREE.Texture.DEFAULT_IMAGE = void 0;
      THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
      THREE.Texture.prototype = {
        constructor: THREE.Texture,
        set needsUpdate(a) {
          !0 === a && this.version++;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.image = a.image;
          this.mipmaps = a.mipmaps.slice(0);
          this.mapping = a.mapping;
          this.wrapS = a.wrapS;
          this.wrapT = a.wrapT;
          this.magFilter = a.magFilter;
          this.minFilter = a.minFilter;
          this.anisotropy = a.anisotropy;
          this.format = a.format;
          this.type = a.type;
          this.offset.copy(a.offset);
          this.repeat.copy(a.repeat);
          this.generateMipmaps = a.generateMipmaps;
          this.premultiplyAlpha = a.premultiplyAlpha;
          this.flipY = a.flipY;
          this.unpackAlignment = a.unpackAlignment;
          return this;
        },
        toJSON: function (a) {
          if (void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
          var b = {
            metadata: {
              version: 4.4,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            wrap: [this.wrapS, this.wrapT],
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
          };
          if (void 0 !== this.image) {
            var c = this.image;
            void 0 === c.uuid && (c.uuid = THREE.Math.generateUUID());
            if (void 0 === a.images[c.uuid]) {
              var d = a.images,
                e = c.uuid,
                f = c.uuid,
                g;
              void 0 !== c.toDataURL
                ? (g = c)
                : ((g = document.createElement("canvas")),
                  (g.width = c.width),
                  (g.height = c.height),
                  g.getContext("2d").drawImage(c, 0, 0, c.width, c.height));
              g =
                2048 < g.width || 2048 < g.height
                  ? g.toDataURL("image/jpeg", 0.6)
                  : g.toDataURL("image/png");
              d[e] = { uuid: f, url: g };
            }
            b.image = c.uuid;
          }
          return (a.textures[this.uuid] = b);
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
        transformUv: function (a) {
          if (this.mapping === THREE.UVMapping) {
            a.multiply(this.repeat);
            a.add(this.offset);
            if (0 > a.x || 1 < a.x)
              switch (this.wrapS) {
                case THREE.RepeatWrapping:
                  a.x -= Math.floor(a.x);
                  break;
                case THREE.ClampToEdgeWrapping:
                  a.x = 0 > a.x ? 0 : 1;
                  break;
                case THREE.MirroredRepeatWrapping:
                  1 === Math.abs(Math.floor(a.x) % 2)
                    ? (a.x = Math.ceil(a.x) - a.x)
                    : (a.x -= Math.floor(a.x));
              }
            if (0 > a.y || 1 < a.y)
              switch (this.wrapT) {
                case THREE.RepeatWrapping:
                  a.y -= Math.floor(a.y);
                  break;
                case THREE.ClampToEdgeWrapping:
                  a.y = 0 > a.y ? 0 : 1;
                  break;
                case THREE.MirroredRepeatWrapping:
                  1 === Math.abs(Math.floor(a.y) % 2)
                    ? (a.y = Math.ceil(a.y) - a.y)
                    : (a.y -= Math.floor(a.y));
              }
            this.flipY && (a.y = 1 - a.y);
          }
        },
      };
      THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
      THREE.TextureIdCount = 0;
      THREE.CanvasTexture = function (a, b, c, d, e, f, g, h, k) {
        THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);
        this.needsUpdate = !0;
      };
      THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
      THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
      THREE.CubeTexture = function (a, b, c, d, e, f, g, h, k) {
        b = void 0 !== b ? b : THREE.CubeReflectionMapping;
        THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);
        this.images = a;
        this.flipY = !1;
      };
      THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
      THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
      THREE.CubeTexture.prototype.copy = function (a) {
        THREE.Texture.prototype.copy.call(this, a);
        this.images = a.images;
        return this;
      };
      THREE.CompressedTexture = function (a, b, c, d, e, f, g, h, k, l, n) {
        THREE.Texture.call(this, null, f, g, h, k, l, d, e, n);
        this.image = { width: b, height: c };
        this.mipmaps = a;
        this.generateMipmaps = this.flipY = !1;
      };
      THREE.CompressedTexture.prototype = Object.create(
        THREE.Texture.prototype
      );
      THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
      THREE.DataTexture = function (a, b, c, d, e, f, g, h, k, l, n) {
        THREE.Texture.call(this, null, f, g, h, k, l, d, e, n);
        this.image = { data: a, width: b, height: c };
        this.magFilter = void 0 !== k ? k : THREE.NearestFilter;
        this.minFilter = void 0 !== l ? l : THREE.NearestFilter;
        this.generateMipmaps = this.flipY = !1;
      };
      THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
      THREE.DataTexture.prototype.constructor = THREE.DataTexture;
      THREE.VideoTexture = function (a, b, c, d, e, f, g, h, k) {
        function l() {
          requestAnimationFrame(l);
          a.readyState === a.HAVE_ENOUGH_DATA && (n.needsUpdate = !0);
        }
        THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);
        this.generateMipmaps = !1;
        var n = this;
        l();
      };
      THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
      THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
      THREE.Group = function () {
        THREE.Object3D.call(this);
        this.type = "Group";
      };
      THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Group.prototype.constructor = THREE.Group;
      THREE.Points = function (a, b) {
        THREE.Object3D.call(this);
        this.type = "Points";
        this.geometry = void 0 !== a ? a : new THREE.Geometry();
        this.material =
          void 0 !== b
            ? b
            : new THREE.PointsMaterial({ color: 16777215 * Math.random() });
      };
      THREE.Points.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Points.prototype.constructor = THREE.Points;
      THREE.Points.prototype.raycast = (function () {
        var a = new THREE.Matrix4(),
          b = new THREE.Ray(),
          c = new THREE.Sphere();
        return function (d, e) {
          function f(a, c) {
            var f = b.distanceSqToPoint(a);
            if (f < n) {
              var h = b.closestPointToPoint(a);
              h.applyMatrix4(k);
              var l = d.ray.origin.distanceTo(h);
              l < d.near ||
                l > d.far ||
                e.push({
                  distance: l,
                  distanceToRay: Math.sqrt(f),
                  point: h.clone(),
                  index: c,
                  face: null,
                  object: g,
                });
            }
          }
          var g = this,
            h = this.geometry,
            k = this.matrixWorld,
            l = d.params.Points.threshold;
          null === h.boundingSphere && h.computeBoundingSphere();
          c.copy(h.boundingSphere);
          c.applyMatrix4(k);
          if (!1 !== d.ray.intersectsSphere(c)) {
            a.getInverse(k);
            b.copy(d.ray).applyMatrix4(a);
            var l = l / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              n = l * l,
              l = new THREE.Vector3();
            if (h instanceof THREE.BufferGeometry) {
              var p = h.index,
                h = h.attributes.position.array;
              if (null !== p)
                for (var m = p.array, p = 0, q = m.length; p < q; p++) {
                  var s = m[p];
                  l.fromArray(h, 3 * s);
                  f(l, s);
                }
              else
                for (p = 0, m = h.length / 3; p < m; p++)
                  l.fromArray(h, 3 * p), f(l, p);
            } else
              for (l = h.vertices, p = 0, m = l.length; p < m; p++) f(l[p], p);
          }
        };
      })();
      THREE.Points.prototype.clone = function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      };
      THREE.Line = function (a, b, c) {
        if (1 === c)
          return (
            console.warn(
              "THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."
            ),
            new THREE.LineSegments(a, b)
          );
        THREE.Object3D.call(this);
        this.type = "Line";
        this.geometry = void 0 !== a ? a : new THREE.Geometry();
        this.material =
          void 0 !== b
            ? b
            : new THREE.LineBasicMaterial({ color: 16777215 * Math.random() });
      };
      THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Line.prototype.constructor = THREE.Line;
      THREE.Line.prototype.raycast = (function () {
        var a = new THREE.Matrix4(),
          b = new THREE.Ray(),
          c = new THREE.Sphere();
        return function (d, e) {
          var f = d.linePrecision,
            f = f * f,
            g = this.geometry,
            h = this.matrixWorld;
          null === g.boundingSphere && g.computeBoundingSphere();
          c.copy(g.boundingSphere);
          c.applyMatrix4(h);
          if (!1 !== d.ray.intersectsSphere(c)) {
            a.getInverse(h);
            b.copy(d.ray).applyMatrix4(a);
            var k = new THREE.Vector3(),
              l = new THREE.Vector3(),
              h = new THREE.Vector3(),
              n = new THREE.Vector3(),
              p = this instanceof THREE.LineSegments ? 2 : 1;
            if (g instanceof THREE.BufferGeometry) {
              var m = g.index,
                q = g.attributes.position.array;
              if (null !== m)
                for (var m = m.array, g = 0, s = m.length - 1; g < s; g += p) {
                  var u = m[g + 1];
                  k.fromArray(q, 3 * m[g]);
                  l.fromArray(q, 3 * u);
                  u = b.distanceSqToSegment(k, l, n, h);
                  u > f ||
                    (n.applyMatrix4(this.matrixWorld),
                    (u = d.ray.origin.distanceTo(n)),
                    u < d.near ||
                      u > d.far ||
                      e.push({
                        distance: u,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: g,
                        face: null,
                        faceIndex: null,
                        object: this,
                      }));
                }
              else
                for (g = 0, s = q.length / 3 - 1; g < s; g += p)
                  k.fromArray(q, 3 * g),
                    l.fromArray(q, 3 * g + 3),
                    (u = b.distanceSqToSegment(k, l, n, h)),
                    u > f ||
                      (n.applyMatrix4(this.matrixWorld),
                      (u = d.ray.origin.distanceTo(n)),
                      u < d.near ||
                        u > d.far ||
                        e.push({
                          distance: u,
                          point: h.clone().applyMatrix4(this.matrixWorld),
                          index: g,
                          face: null,
                          faceIndex: null,
                          object: this,
                        }));
            } else if (g instanceof THREE.Geometry)
              for (k = g.vertices, l = k.length, g = 0; g < l - 1; g += p)
                (u = b.distanceSqToSegment(k[g], k[g + 1], n, h)),
                  u > f ||
                    (n.applyMatrix4(this.matrixWorld),
                    (u = d.ray.origin.distanceTo(n)),
                    u < d.near ||
                      u > d.far ||
                      e.push({
                        distance: u,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: g,
                        face: null,
                        faceIndex: null,
                        object: this,
                      }));
          }
        };
      })();
      THREE.Line.prototype.clone = function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      };
      THREE.LineStrip = 0;
      THREE.LinePieces = 1;
      THREE.LineSegments = function (a, b) {
        THREE.Line.call(this, a, b);
        this.type = "LineSegments";
      };
      THREE.LineSegments.prototype = Object.create(THREE.Line.prototype);
      THREE.LineSegments.prototype.constructor = THREE.LineSegments;
      THREE.Mesh = function (a, b) {
        THREE.Object3D.call(this);
        this.type = "Mesh";
        this.geometry = void 0 !== a ? a : new THREE.Geometry();
        this.material =
          void 0 !== b
            ? b
            : new THREE.MeshBasicMaterial({ color: 16777215 * Math.random() });
        this.drawMode = THREE.TrianglesDrawMode;
        this.updateMorphTargets();
      };
      THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Mesh.prototype.constructor = THREE.Mesh;
      THREE.Mesh.prototype.setDrawMode = function (a) {
        this.drawMode = a;
      };
      THREE.Mesh.prototype.updateMorphTargets = function () {
        if (
          void 0 !== this.geometry.morphTargets &&
          0 < this.geometry.morphTargets.length
        ) {
          this.morphTargetBase = -1;
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++)
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[this.geometry.morphTargets[a].name] =
                a);
        }
      };
      THREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {
        if (void 0 !== this.morphTargetDictionary[a])
          return this.morphTargetDictionary[a];
        console.warn(
          "THREE.Mesh.getMorphTargetIndexByName: morph target " +
            a +
            " does not exist. Returning 0."
        );
        return 0;
      };
      THREE.Mesh.prototype.raycast = (function () {
        function a(a, b, c, d, e, f, g) {
          THREE.Triangle.barycoordFromPoint(a, b, c, d, u);
          e.multiplyScalar(u.x);
          f.multiplyScalar(u.y);
          g.multiplyScalar(u.z);
          e.add(f).add(g);
          return e.clone();
        }
        function b(a, b, c, d, e, f, g) {
          var h = a.material;
          if (
            null ===
            (h.side === THREE.BackSide
              ? c.intersectTriangle(f, e, d, !0, g)
              : c.intersectTriangle(d, e, f, h.side !== THREE.DoubleSide, g))
          )
            return null;
          x.copy(g);
          x.applyMatrix4(a.matrixWorld);
          c = b.ray.origin.distanceTo(x);
          return c < b.near || c > b.far
            ? null
            : { distance: c, point: x.clone(), object: a };
        }
        function c(c, d, e, f, l, n, p, x) {
          g.fromArray(f, 3 * n);
          h.fromArray(f, 3 * p);
          k.fromArray(f, 3 * x);
          if ((c = b(c, d, e, g, h, k, t)))
            l &&
              (m.fromArray(l, 2 * n),
              q.fromArray(l, 2 * p),
              s.fromArray(l, 2 * x),
              (c.uv = a(t, g, h, k, m, q, s))),
              (c.face = new THREE.Face3(
                n,
                p,
                x,
                THREE.Triangle.normal(g, h, k)
              )),
              (c.faceIndex = n);
          return c;
        }
        var d = new THREE.Matrix4(),
          e = new THREE.Ray(),
          f = new THREE.Sphere(),
          g = new THREE.Vector3(),
          h = new THREE.Vector3(),
          k = new THREE.Vector3(),
          l = new THREE.Vector3(),
          n = new THREE.Vector3(),
          p = new THREE.Vector3(),
          m = new THREE.Vector2(),
          q = new THREE.Vector2(),
          s = new THREE.Vector2(),
          u = new THREE.Vector3(),
          t = new THREE.Vector3(),
          x = new THREE.Vector3();
        return function (x, u) {
          var w = this.geometry,
            D = this.material,
            z = this.matrixWorld;
          if (
            void 0 !== D &&
            (null === w.boundingSphere && w.computeBoundingSphere(),
            f.copy(w.boundingSphere),
            f.applyMatrix4(z),
            !1 !== x.ray.intersectsSphere(f) &&
              (d.getInverse(z),
              e.copy(x.ray).applyMatrix4(d),
              null === w.boundingBox || !1 !== e.intersectsBox(w.boundingBox)))
          ) {
            var y, A;
            if (w instanceof THREE.BufferGeometry) {
              var H,
                G,
                D = w.index,
                z = w.attributes,
                w = z.position.array;
              void 0 !== z.uv && (y = z.uv.array);
              if (null !== D)
                for (var z = D.array, E = 0, K = z.length; E < K; E += 3) {
                  if (
                    ((D = z[E]),
                    (H = z[E + 1]),
                    (G = z[E + 2]),
                    (A = c(this, x, e, w, y, D, H, G)))
                  )
                    (A.faceIndex = Math.floor(E / 3)), u.push(A);
                }
              else
                for (E = 0, K = w.length; E < K; E += 9)
                  if (
                    ((D = E / 3),
                    (H = D + 1),
                    (G = D + 2),
                    (A = c(this, x, e, w, y, D, H, G)))
                  )
                    (A.index = D), u.push(A);
            } else if (w instanceof THREE.Geometry) {
              var P,
                N,
                z = D instanceof THREE.MultiMaterial,
                E = !0 === z ? D.materials : null,
                K = w.vertices;
              H = w.faces;
              G = w.faceVertexUvs[0];
              0 < G.length && (y = G);
              for (var L = 0, B = H.length; L < B; L++) {
                var M = H[L];
                A = !0 === z ? E[M.materialIndex] : D;
                if (void 0 !== A) {
                  G = K[M.a];
                  P = K[M.b];
                  N = K[M.c];
                  if (!0 === A.morphTargets) {
                    A = w.morphTargets;
                    var Q = this.morphTargetInfluences;
                    g.set(0, 0, 0);
                    h.set(0, 0, 0);
                    k.set(0, 0, 0);
                    for (var O = 0, S = A.length; O < S; O++) {
                      var J = Q[O];
                      if (0 !== J) {
                        var F = A[O].vertices;
                        g.addScaledVector(l.subVectors(F[M.a], G), J);
                        h.addScaledVector(n.subVectors(F[M.b], P), J);
                        k.addScaledVector(p.subVectors(F[M.c], N), J);
                      }
                    }
                    g.add(G);
                    h.add(P);
                    k.add(N);
                    G = g;
                    P = h;
                    N = k;
                  }
                  if ((A = b(this, x, e, G, P, N, t)))
                    y &&
                      ((Q = y[L]),
                      m.copy(Q[0]),
                      q.copy(Q[1]),
                      s.copy(Q[2]),
                      (A.uv = a(t, G, P, N, m, q, s))),
                      (A.face = M),
                      (A.faceIndex = L),
                      u.push(A);
                }
              }
            }
          }
        };
      })();
      THREE.Mesh.prototype.clone = function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      };
      THREE.Bone = function (a) {
        THREE.Object3D.call(this);
        this.type = "Bone";
        this.skin = a;
      };
      THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Bone.prototype.constructor = THREE.Bone;
      THREE.Bone.prototype.copy = function (a) {
        THREE.Object3D.prototype.copy.call(this, a);
        this.skin = a.skin;
        return this;
      };
      THREE.Skeleton = function (a, b, c) {
        this.useVertexTexture = void 0 !== c ? c : !0;
        this.identityMatrix = new THREE.Matrix4();
        a = a || [];
        this.bones = a.slice(0);
        this.useVertexTexture
          ? ((a = Math.sqrt(4 * this.bones.length)),
            (a = THREE.Math.nextPowerOfTwo(Math.ceil(a))),
            (this.boneTextureHeight =
              this.boneTextureWidth =
              a =
                Math.max(a, 4)),
            (this.boneMatrices = new Float32Array(
              this.boneTextureWidth * this.boneTextureHeight * 4
            )),
            (this.boneTexture = new THREE.DataTexture(
              this.boneMatrices,
              this.boneTextureWidth,
              this.boneTextureHeight,
              THREE.RGBAFormat,
              THREE.FloatType
            )))
          : (this.boneMatrices = new Float32Array(16 * this.bones.length));
        if (void 0 === b) this.calculateInverses();
        else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
        else
          for (
            console.warn("THREE.Skeleton bonInverses is the wrong length."),
              this.boneInverses = [],
              b = 0,
              a = this.bones.length;
            b < a;
            b++
          )
            this.boneInverses.push(new THREE.Matrix4());
      };
      THREE.Skeleton.prototype.calculateInverses = function () {
        this.boneInverses = [];
        for (var a = 0, b = this.bones.length; a < b; a++) {
          var c = new THREE.Matrix4();
          this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
          this.boneInverses.push(c);
        }
      };
      THREE.Skeleton.prototype.pose = function () {
        for (var a, b = 0, c = this.bones.length; b < c; b++)
          (a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
        b = 0;
        for (c = this.bones.length; b < c; b++)
          if ((a = this.bones[b]))
            a.parent
              ? (a.matrix.getInverse(a.parent.matrixWorld),
                a.matrix.multiply(a.matrixWorld))
              : a.matrix.copy(a.matrixWorld),
              a.matrix.decompose(a.position, a.quaternion, a.scale);
      };
      THREE.Skeleton.prototype.update = (function () {
        var a = new THREE.Matrix4();
        return function () {
          for (var b = 0, c = this.bones.length; b < c; b++)
            a.multiplyMatrices(
              this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix,
              this.boneInverses[b]
            ),
              a.flattenToArrayOffset(this.boneMatrices, 16 * b);
          this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
        };
      })();
      THREE.Skeleton.prototype.clone = function () {
        return new THREE.Skeleton(
          this.bones,
          this.boneInverses,
          this.useVertexTexture
        );
      };
      THREE.SkinnedMesh = function (a, b, c) {
        THREE.Mesh.call(this, a, b);
        this.type = "SkinnedMesh";
        this.bindMode = "attached";
        this.bindMatrix = new THREE.Matrix4();
        this.bindMatrixInverse = new THREE.Matrix4();
        a = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
          for (var d, e = 0, f = this.geometry.bones.length; e < f; ++e)
            (d = this.geometry.bones[e]),
              (b = new THREE.Bone(this)),
              a.push(b),
              (b.name = d.name),
              b.position.fromArray(d.pos),
              b.quaternion.fromArray(d.rotq),
              void 0 !== d.scl && b.scale.fromArray(d.scl);
          e = 0;
          for (f = this.geometry.bones.length; e < f; ++e)
            (d = this.geometry.bones[e]),
              -1 !== d.parent && null !== d.parent
                ? a[d.parent].add(a[e])
                : this.add(a[e]);
        }
        this.normalizeSkinWeights();
        this.updateMatrixWorld(!0);
        this.bind(new THREE.Skeleton(a, void 0, c), this.matrixWorld);
      };
      THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
      THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
      THREE.SkinnedMesh.prototype.bind = function (a, b) {
        this.skeleton = a;
        void 0 === b &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (b = this.matrixWorld));
        this.bindMatrix.copy(b);
        this.bindMatrixInverse.getInverse(b);
      };
      THREE.SkinnedMesh.prototype.pose = function () {
        this.skeleton.pose();
      };
      THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
        if (this.geometry instanceof THREE.Geometry)
          for (var a = 0; a < this.geometry.skinWeights.length; a++) {
            var b = this.geometry.skinWeights[a],
              c = 1 / b.lengthManhattan();
            Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0);
          }
        else if (this.geometry instanceof THREE.BufferGeometry)
          for (
            var b = new THREE.Vector4(),
              d = this.geometry.attributes.skinWeight,
              a = 0;
            a < d.count;
            a++
          )
            (b.x = d.getX(a)),
              (b.y = d.getY(a)),
              (b.z = d.getZ(a)),
              (b.w = d.getW(a)),
              (c = 1 / b.lengthManhattan()),
              Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0),
              d.setXYZW(a, b.x, b.y, b.z, b.w);
      };
      THREE.SkinnedMesh.prototype.updateMatrixWorld = function (a) {
        THREE.Mesh.prototype.updateMatrixWorld.call(this, !0);
        "attached" === this.bindMode
          ? this.bindMatrixInverse.getInverse(this.matrixWorld)
          : "detached" === this.bindMode
          ? this.bindMatrixInverse.getInverse(this.bindMatrix)
          : console.warn(
              "THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode
            );
      };
      THREE.SkinnedMesh.prototype.clone = function () {
        return new this.constructor(
          this.geometry,
          this.material,
          this.useVertexTexture
        ).copy(this);
      };
      THREE.LOD = function () {
        THREE.Object3D.call(this);
        this.type = "LOD";
        Object.defineProperties(this, {
          levels: { enumerable: !0, value: [] },
          objects: {
            get: function () {
              console.warn("THREE.LOD: .objects has been renamed to .levels.");
              return this.levels;
            },
          },
        });
      };
      THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
      THREE.LOD.prototype.constructor = THREE.LOD;
      THREE.LOD.prototype.addLevel = function (a, b) {
        void 0 === b && (b = 0);
        b = Math.abs(b);
        for (
          var c = this.levels, d = 0;
          d < c.length && !(b < c[d].distance);
          d++
        );
        c.splice(d, 0, { distance: b, object: a });
        this.add(a);
      };
      THREE.LOD.prototype.getObjectForDistance = function (a) {
        for (
          var b = this.levels, c = 1, d = b.length;
          c < d && !(a < b[c].distance);
          c++
        );
        return b[c - 1].object;
      };
      THREE.LOD.prototype.raycast = (function () {
        var a = new THREE.Vector3();
        return function (b, c) {
          a.setFromMatrixPosition(this.matrixWorld);
          var d = b.ray.origin.distanceTo(a);
          this.getObjectForDistance(d).raycast(b, c);
        };
      })();
      THREE.LOD.prototype.update = (function () {
        var a = new THREE.Vector3(),
          b = new THREE.Vector3();
        return function (c) {
          var d = this.levels;
          if (1 < d.length) {
            a.setFromMatrixPosition(c.matrixWorld);
            b.setFromMatrixPosition(this.matrixWorld);
            c = a.distanceTo(b);
            d[0].object.visible = !0;
            for (var e = 1, f = d.length; e < f; e++)
              if (c >= d[e].distance)
                (d[e - 1].object.visible = !1), (d[e].object.visible = !0);
              else break;
            for (; e < f; e++) d[e].object.visible = !1;
          }
        };
      })();
      THREE.LOD.prototype.copy = function (a) {
        THREE.Object3D.prototype.copy.call(this, a, !1);
        a = a.levels;
        for (var b = 0, c = a.length; b < c; b++) {
          var d = a[b];
          this.addLevel(d.object.clone(), d.distance);
        }
        return this;
      };
      THREE.LOD.prototype.toJSON = function (a) {
        a = THREE.Object3D.prototype.toJSON.call(this, a);
        a.object.levels = [];
        for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
          var e = b[c];
          a.object.levels.push({ object: e.object.uuid, distance: e.distance });
        }
        return a;
      };
      THREE.Sprite = (function () {
        var a = new Uint16Array([0, 1, 2, 0, 2, 3]),
          b = new Float32Array([
            -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0,
          ]),
          c = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          d = new THREE.BufferGeometry();
        d.setIndex(new THREE.BufferAttribute(a, 1));
        d.addAttribute("position", new THREE.BufferAttribute(b, 3));
        d.addAttribute("uv", new THREE.BufferAttribute(c, 2));
        return function (a) {
          THREE.Object3D.call(this);
          this.type = "Sprite";
          this.geometry = d;
          this.material = void 0 !== a ? a : new THREE.SpriteMaterial();
        };
      })();
      THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Sprite.prototype.constructor = THREE.Sprite;
      THREE.Sprite.prototype.raycast = (function () {
        var a = new THREE.Vector3();
        return function (b, c) {
          a.setFromMatrixPosition(this.matrixWorld);
          var d = b.ray.distanceSqToPoint(a);
          d > this.scale.x * this.scale.y ||
            c.push({
              distance: Math.sqrt(d),
              point: this.position,
              face: null,
              object: this,
            });
        };
      })();
      THREE.Sprite.prototype.clone = function () {
        return new this.constructor(this.material).copy(this);
      };
      THREE.Particle = THREE.Sprite;
      THREE.LensFlare = function (a, b, c, d, e) {
        THREE.Object3D.call(this);
        this.lensFlares = [];
        this.positionScreen = new THREE.Vector3();
        this.customUpdateCallback = void 0;
        void 0 !== a && this.add(a, b, c, d, e);
      };
      THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
      THREE.LensFlare.prototype.constructor = THREE.LensFlare;
      THREE.LensFlare.prototype.add = function (a, b, c, d, e, f) {
        void 0 === b && (b = -1);
        void 0 === c && (c = 0);
        void 0 === f && (f = 1);
        void 0 === e && (e = new THREE.Color(16777215));
        void 0 === d && (d = THREE.NormalBlending);
        c = Math.min(c, Math.max(0, c));
        this.lensFlares.push({
          texture: a,
          size: b,
          distance: c,
          x: 0,
          y: 0,
          z: 0,
          scale: 1,
          rotation: 0,
          opacity: f,
          color: e,
          blending: d,
        });
      };
      THREE.LensFlare.prototype.updateLensFlares = function () {
        var a,
          b = this.lensFlares.length,
          c,
          d = 2 * -this.positionScreen.x,
          e = 2 * -this.positionScreen.y;
        for (a = 0; a < b; a++)
          (c = this.lensFlares[a]),
            (c.x = this.positionScreen.x + d * c.distance),
            (c.y = this.positionScreen.y + e * c.distance),
            (c.wantedRotation = c.x * Math.PI * 0.25),
            (c.rotation += 0.25 * (c.wantedRotation - c.rotation));
      };
      THREE.LensFlare.prototype.copy = function (a) {
        THREE.Object3D.prototype.copy.call(this, a);
        this.positionScreen.copy(a.positionScreen);
        this.customUpdateCallback = a.customUpdateCallback;
        for (var b = 0, c = a.lensFlares.length; b < c; b++)
          this.lensFlares.push(a.lensFlares[b]);
        return this;
      };
      THREE.Scene = function () {
        THREE.Object3D.call(this);
        this.type = "Scene";
        this.overrideMaterial = this.fog = null;
        this.autoUpdate = !0;
      };
      THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
      THREE.Scene.prototype.constructor = THREE.Scene;
      THREE.Scene.prototype.copy = function (a, b) {
        THREE.Object3D.prototype.copy.call(this, a, b);
        null !== a.fog && (this.fog = a.fog.clone());
        null !== a.overrideMaterial &&
          (this.overrideMaterial = a.overrideMaterial.clone());
        this.autoUpdate = a.autoUpdate;
        this.matrixAutoUpdate = a.matrixAutoUpdate;
        return this;
      };
      THREE.Fog = function (a, b, c) {
        this.name = "";
        this.color = new THREE.Color(a);
        this.near = void 0 !== b ? b : 1;
        this.far = void 0 !== c ? c : 1e3;
      };
      THREE.Fog.prototype.clone = function () {
        return new THREE.Fog(this.color.getHex(), this.near, this.far);
      };
      THREE.FogExp2 = function (a, b) {
        this.name = "";
        this.color = new THREE.Color(a);
        this.density = void 0 !== b ? b : 2.5e-4;
      };
      THREE.FogExp2.prototype.clone = function () {
        return new THREE.FogExp2(this.color.getHex(), this.density);
      };
      THREE.ShaderChunk = {};
      THREE.ShaderChunk.alphamap_fragment =
        "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
      THREE.ShaderChunk.alphamap_pars_fragment =
        "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
      THREE.ShaderChunk.alphatest_fragment =
        "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
      THREE.ShaderChunk.ambient_pars =
        "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\treturn PI * ambientLightColor;\n}\n";
      THREE.ShaderChunk.aomap_fragment =
        "#ifdef USE_AOMAP\n\treflectedLight.indirectDiffuse *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n#endif\n";
      THREE.ShaderChunk.aomap_pars_fragment =
        "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
      THREE.ShaderChunk.begin_vertex =
        "\nvec3 transformed = vec3( position );\n";
      THREE.ShaderChunk.beginnormal_vertex =
        "\nvec3 objectNormal = vec3( normal );\n";
      THREE.ShaderChunk.bsdfs =
        "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat calcLightAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif ( decayExponent > 0.0 ) {\n\t  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = alpha * alpha;\n\tfloat gl = dotNL + pow( a2 + ( 1.0 - a2 ) * dotNL * dotNL, 0.5 );\n\tfloat gv = dotNV + pow( a2 + ( 1.0 - a2 ) * dotNV * dotNV, 0.5 );\n\treturn 1.0 / ( gl * gv );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = alpha * alpha;\n\tfloat denom = dotNH * dotNH * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / ( denom * denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = roughness * roughness;\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_Smith( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / square( ggxRoughness + 0.0001 ) - 2.0 );\n}\n";
      THREE.ShaderChunk.bumpmap_pars_fragment =
        "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
      THREE.ShaderChunk.color_fragment =
        "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
      THREE.ShaderChunk.color_pars_fragment =
        "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
      THREE.ShaderChunk.color_pars_vertex =
        "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
      THREE.ShaderChunk.color_vertex =
        "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
      THREE.ShaderChunk.common =
        "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat square( const in float x ) { return x*x; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nvec3 inputToLinear( in vec3 a ) {\n\t#ifdef GAMMA_INPUT\n\t\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n";
      THREE.ShaderChunk.defaultnormal_vertex =
        "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
      THREE.ShaderChunk.displacementmap_vertex =
        "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
      THREE.ShaderChunk.displacementmap_pars_vertex =
        "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
      THREE.ShaderChunk.emissivemap_fragment =
        "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\ttotalEmissiveLight *= emissiveColor.rgb;\n#endif\n";
      THREE.ShaderChunk.emissivemap_pars_fragment =
        "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
      THREE.ShaderChunk.envmap_fragment =
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\tenvColor.xyz = inputToLinear( envColor.xyz );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
      THREE.ShaderChunk.envmap_pars_fragment =
        "#if defined( USE_ENVMAP ) || defined( STANDARD )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
      THREE.ShaderChunk.envmap_pars_vertex =
        "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n\tvarying vec3 vReflect;\n\tuniform float refractionRatio;\n#endif\n";
      THREE.ShaderChunk.envmap_vertex =
        "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t#ifdef ENVMAP_MODE_REFLECTION\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t#else\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t#endif\n#endif\n";
      THREE.ShaderChunk.fog_fragment =
        "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\t\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\n#endif";
      THREE.ShaderChunk.fog_pars_fragment =
        "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
      THREE.ShaderChunk.lightmap_fragment =
        "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
      THREE.ShaderChunk.lightmap_pars_fragment =
        "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
      THREE.ShaderChunk.lights_lambert_vertex =
        "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tdirectLight = getPointDirectLight( pointLights[ i ], geometry );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tdirectLight = getSpotDirectLight( spotLights[ i ], geometry );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectLight = getDirectionalDirectLight( directionalLights[ i ], geometry );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
      THREE.ShaderChunk.lights_pars =
        "#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tIncidentLight getDirectionalDirectLight( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\n\t\tIncidentLight directLight;\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t\treturn directLight;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tIncidentLight getPointDirectLight( const in PointLight pointLight, const in GeometricContext geometry ) {\n\t\tIncidentLight directLight;\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= calcLightAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t\treturn directLight;\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat angleCos;\n\t\tfloat penumbra;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tIncidentLight getSpotDirectLight( const in SpotLight spotLight, const in GeometricContext geometry ) {\n\t\tIncidentLight directLight;\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat spotEffect = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( spotEffect > spotLight.angleCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = dot( spotLight.direction, directLight.direction );\n\t\t\tspotEffect *= clamp( ( spotEffect - spotLight.angleCos ) / spotLight.penumbra, 0.0, 1.0 );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= ( spotEffect * calcLightAttenuation( lightDistance, spotLight.distance, spotLight.decay ) );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t\treturn directLight;\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\treturn PI * mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( STANDARD )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t#else\n\t\t\tvec3 envMapColor = vec3( 0.0 );\n\t\t#endif\n\t\tenvMapColor.rgb = inputToLinear( envMapColor.rgb );\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( square( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t#endif\n\t\tenvMapColor.rgb = inputToLinear( envMapColor.rgb );\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
      THREE.ShaderChunk.lights_phong_fragment =
        "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
      THREE.ShaderChunk.lights_phong_pars_fragment =
        "#ifdef USE_ENVMAP\n\tvarying vec3 vWorldPosition;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * PI * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
      THREE.ShaderChunk.lights_phong_pars_vertex =
        "#ifdef USE_ENVMAP\n\tvarying vec3 vWorldPosition;\n#endif\n";
      THREE.ShaderChunk.lights_phong_vertex =
        "#ifdef USE_ENVMAP\n\tvWorldPosition = worldPosition.xyz;\n#endif\n";
      THREE.ShaderChunk.lights_standard_fragment =
        "StandardMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n";
      THREE.ShaderChunk.lights_standard_pars_fragment =
        "struct StandardMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n};\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * PI * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Standard\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Standard\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Standard\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n";
      THREE.ShaderChunk.lights_template =
        "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tdirectLight = getPointDirectLight( pointLight, geometry );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tdirectLight = getSpotDirectLight( spotLight, geometry );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tdirectLight = getDirectionalDirectLight( directionalLight, geometry );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tirradiance += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n";
      THREE.ShaderChunk.linear_to_gamma_fragment =
        "\n\toutgoingLight = linearToOutput( outgoingLight );\n";
      THREE.ShaderChunk.logdepthbuf_fragment =
        "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
      THREE.ShaderChunk.logdepthbuf_pars_fragment =
        "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
      THREE.ShaderChunk.logdepthbuf_pars_vertex =
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
      THREE.ShaderChunk.logdepthbuf_vertex =
        "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";
      THREE.ShaderChunk.map_fragment =
        "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\n\tdiffuseColor *= texelColor;\n#endif\n";
      THREE.ShaderChunk.map_pars_fragment =
        "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
      THREE.ShaderChunk.map_particle_fragment =
        "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n#endif\n";
      THREE.ShaderChunk.map_particle_pars_fragment =
        "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";
      THREE.ShaderChunk.metalnessmap_fragment =
        "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";
      THREE.ShaderChunk.metalnessmap_pars_fragment =
        "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
      THREE.ShaderChunk.morphnormal_vertex =
        "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
      THREE.ShaderChunk.morphtarget_pars_vertex =
        "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
      THREE.ShaderChunk.morphtarget_vertex =
        "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
      THREE.ShaderChunk.normal_fragment =
        "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
      THREE.ShaderChunk.normalmap_pars_fragment =
        "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
      THREE.ShaderChunk.project_vertex =
        "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
      THREE.ShaderChunk.roughnessmap_fragment =
        "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";
      THREE.ShaderChunk.roughnessmap_pars_fragment =
        "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
      THREE.ShaderChunk.shadowmap_pars_fragment =
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\treturn dot( rgba_depth, bit_shift );\n\t}\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
      THREE.ShaderChunk.shadowmap_pars_vertex =
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
      THREE.ShaderChunk.shadowmap_vertex =
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
      THREE.ShaderChunk.shadowmask_pars_fragment =
        "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
      THREE.ShaderChunk.skinbase_vertex =
        "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
      THREE.ShaderChunk.skinning_pars_vertex =
        "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
      THREE.ShaderChunk.skinning_vertex =
        "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";
      THREE.ShaderChunk.skinnormal_vertex =
        "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
      THREE.ShaderChunk.specularmap_fragment =
        "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
      THREE.ShaderChunk.specularmap_pars_fragment =
        "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
      THREE.ShaderChunk.uv2_pars_fragment =
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
      THREE.ShaderChunk.uv2_pars_vertex =
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
      THREE.ShaderChunk.uv2_vertex =
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
      THREE.ShaderChunk.uv_pars_fragment =
        "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
      THREE.ShaderChunk.uv_pars_vertex =
        "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";
      THREE.ShaderChunk.uv_vertex =
        "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
      THREE.ShaderChunk.worldpos_vertex =
        "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";
      THREE.UniformsUtils = {
        merge: function (a) {
          for (var b = {}, c = 0; c < a.length; c++) {
            var d = this.clone(a[c]),
              e;
            for (e in d) b[e] = d[e];
          }
          return b;
        },
        clone: function (a) {
          var b = {},
            c;
          for (c in a) {
            b[c] = {};
            for (var d in a[c]) {
              var e = a[c][d];
              e instanceof THREE.Color ||
              e instanceof THREE.Vector2 ||
              e instanceof THREE.Vector3 ||
              e instanceof THREE.Vector4 ||
              e instanceof THREE.Matrix3 ||
              e instanceof THREE.Matrix4 ||
              e instanceof THREE.Texture
                ? (b[c][d] = e.clone())
                : Array.isArray(e)
                ? (b[c][d] = e.slice())
                : (b[c][d] = e);
            }
          }
          return b;
        },
      };
      THREE.UniformsLib = {
        common: {
          diffuse: { type: "c", value: new THREE.Color(15658734) },
          opacity: { type: "f", value: 1 },
          map: { type: "t", value: null },
          offsetRepeat: { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) },
          specularMap: { type: "t", value: null },
          alphaMap: { type: "t", value: null },
          envMap: { type: "t", value: null },
          flipEnvMap: { type: "f", value: -1 },
          reflectivity: { type: "f", value: 1 },
          refractionRatio: { type: "f", value: 0.98 },
        },
        aomap: {
          aoMap: { type: "t", value: null },
          aoMapIntensity: { type: "f", value: 1 },
        },
        lightmap: {
          lightMap: { type: "t", value: null },
          lightMapIntensity: { type: "f", value: 1 },
        },
        emissivemap: { emissiveMap: { type: "t", value: null } },
        bumpmap: {
          bumpMap: { type: "t", value: null },
          bumpScale: { type: "f", value: 1 },
        },
        normalmap: {
          normalMap: { type: "t", value: null },
          normalScale: { type: "v2", value: new THREE.Vector2(1, 1) },
        },
        displacementmap: {
          displacementMap: { type: "t", value: null },
          displacementScale: { type: "f", value: 1 },
          displacementBias: { type: "f", value: 0 },
        },
        roughnessmap: { roughnessMap: { type: "t", value: null } },
        metalnessmap: { metalnessMap: { type: "t", value: null } },
        fog: {
          fogDensity: { type: "f", value: 2.5e-4 },
          fogNear: { type: "f", value: 1 },
          fogFar: { type: "f", value: 2e3 },
          fogColor: { type: "c", value: new THREE.Color(16777215) },
        },
        ambient: { ambientLightColor: { type: "fv", value: [] } },
        lights: {
          directionalLights: {
            type: "sa",
            value: [],
            properties: {
              direction: { type: "v3" },
              color: { type: "c" },
              shadow: { type: "i" },
              shadowBias: { type: "f" },
              shadowRadius: { type: "f" },
              shadowMapSize: { type: "v2" },
            },
          },
          directionalShadowMap: { type: "tv", value: [] },
          directionalShadowMatrix: { type: "m4v", value: [] },
          spotLights: {
            type: "sa",
            value: [],
            properties: {
              color: { type: "c" },
              position: { type: "v3" },
              direction: { type: "v3" },
              distance: { type: "f" },
              angleCos: { type: "f" },
              penumbra: { type: "f" },
              decay: { type: "f" },
              shadow: { type: "i" },
              shadowBias: { type: "f" },
              shadowRadius: { type: "f" },
              shadowMapSize: { type: "v2" },
            },
          },
          spotShadowMap: { type: "tv", value: [] },
          spotShadowMatrix: { type: "m4v", value: [] },
          pointLights: {
            type: "sa",
            value: [],
            properties: {
              color: { type: "c" },
              position: { type: "v3" },
              decay: { type: "f" },
              distance: { type: "f" },
              shadow: { type: "i" },
              shadowBias: { type: "f" },
              shadowRadius: { type: "f" },
              shadowMapSize: { type: "v2" },
            },
          },
          pointShadowMap: { type: "tv", value: [] },
          pointShadowMatrix: { type: "m4v", value: [] },
          hemisphereLights: {
            type: "sa",
            value: [],
            properties: {
              direction: { type: "v3" },
              skyColor: { type: "c" },
              groundColor: { type: "c" },
            },
          },
        },
        points: {
          diffuse: { type: "c", value: new THREE.Color(15658734) },
          opacity: { type: "f", value: 1 },
          size: { type: "f", value: 1 },
          scale: { type: "f", value: 1 },
          map: { type: "t", value: null },
          offsetRepeat: { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) },
        },
      };
      THREE.ShaderLib = {
        basic: {
          uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.common,
            THREE.UniformsLib.aomap,
            THREE.UniformsLib.fog,
          ]),
          vertexShader: [
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.uv_pars_vertex,
            THREE.ShaderChunk.uv2_pars_vertex,
            THREE.ShaderChunk.envmap_pars_vertex,
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.uv_vertex,
            THREE.ShaderChunk.uv2_vertex,
            THREE.ShaderChunk.color_vertex,
            THREE.ShaderChunk.skinbase_vertex,
            "\t#ifdef USE_ENVMAP",
            THREE.ShaderChunk.beginnormal_vertex,
            THREE.ShaderChunk.morphnormal_vertex,
            THREE.ShaderChunk.skinnormal_vertex,
            THREE.ShaderChunk.defaultnormal_vertex,
            "\t#endif",
            THREE.ShaderChunk.begin_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.project_vertex,
            THREE.ShaderChunk.logdepthbuf_vertex,
            THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.envmap_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.uv_pars_fragment,
            THREE.ShaderChunk.uv2_pars_fragment,
            THREE.ShaderChunk.map_pars_fragment,
            THREE.ShaderChunk.alphamap_pars_fragment,
            THREE.ShaderChunk.aomap_pars_fragment,
            THREE.ShaderChunk.envmap_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.specularmap_pars_fragment,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );",
            THREE.ShaderChunk.logdepthbuf_fragment,
            THREE.ShaderChunk.map_fragment,
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.alphamap_fragment,
            THREE.ShaderChunk.alphatest_fragment,
            THREE.ShaderChunk.specularmap_fragment,
            "\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );",
            THREE.ShaderChunk.aomap_fragment,
            "\tvec3 outgoingLight = reflectedLight.indirectDiffuse;",
            THREE.ShaderChunk.envmap_fragment,
            THREE.ShaderChunk.linear_to_gamma_fragment,
            THREE.ShaderChunk.fog_fragment,
            "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}",
          ].join("\n"),
        },
        lambert: {
          uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.common,
            THREE.UniformsLib.aomap,
            THREE.UniformsLib.lightmap,
            THREE.UniformsLib.emissivemap,
            THREE.UniformsLib.fog,
            THREE.UniformsLib.ambient,
            THREE.UniformsLib.lights,
            { emissive: { type: "c", value: new THREE.Color(0) } },
          ]),
          vertexShader: [
            "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.uv_pars_vertex,
            THREE.ShaderChunk.uv2_pars_vertex,
            THREE.ShaderChunk.envmap_pars_vertex,
            THREE.ShaderChunk.bsdfs,
            THREE.ShaderChunk.lights_pars,
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            THREE.ShaderChunk.shadowmap_pars_vertex,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.uv_vertex,
            THREE.ShaderChunk.uv2_vertex,
            THREE.ShaderChunk.color_vertex,
            THREE.ShaderChunk.beginnormal_vertex,
            THREE.ShaderChunk.morphnormal_vertex,
            THREE.ShaderChunk.skinbase_vertex,
            THREE.ShaderChunk.skinnormal_vertex,
            THREE.ShaderChunk.defaultnormal_vertex,
            THREE.ShaderChunk.begin_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.project_vertex,
            THREE.ShaderChunk.logdepthbuf_vertex,
            THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.envmap_vertex,
            THREE.ShaderChunk.lights_lambert_vertex,
            THREE.ShaderChunk.shadowmap_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.uv_pars_fragment,
            THREE.ShaderChunk.uv2_pars_fragment,
            THREE.ShaderChunk.map_pars_fragment,
            THREE.ShaderChunk.alphamap_pars_fragment,
            THREE.ShaderChunk.aomap_pars_fragment,
            THREE.ShaderChunk.lightmap_pars_fragment,
            THREE.ShaderChunk.emissivemap_pars_fragment,
            THREE.ShaderChunk.envmap_pars_fragment,
            THREE.ShaderChunk.bsdfs,
            THREE.ShaderChunk.ambient_pars,
            THREE.ShaderChunk.lights_pars,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.shadowmap_pars_fragment,
            THREE.ShaderChunk.shadowmask_pars_fragment,
            THREE.ShaderChunk.specularmap_pars_fragment,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveLight = emissive;",
            THREE.ShaderChunk.logdepthbuf_fragment,
            THREE.ShaderChunk.map_fragment,
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.alphamap_fragment,
            THREE.ShaderChunk.alphatest_fragment,
            THREE.ShaderChunk.specularmap_fragment,
            THREE.ShaderChunk.emissivemap_fragment,
            "\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );",
            THREE.ShaderChunk.lightmap_fragment,
            "\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();",
            THREE.ShaderChunk.aomap_fragment,
            "\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveLight;",
            THREE.ShaderChunk.envmap_fragment,
            THREE.ShaderChunk.linear_to_gamma_fragment,
            THREE.ShaderChunk.fog_fragment,
            "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}",
          ].join("\n"),
        },
        phong: {
          uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.common,
            THREE.UniformsLib.aomap,
            THREE.UniformsLib.lightmap,
            THREE.UniformsLib.emissivemap,
            THREE.UniformsLib.bumpmap,
            THREE.UniformsLib.normalmap,
            THREE.UniformsLib.displacementmap,
            THREE.UniformsLib.fog,
            THREE.UniformsLib.ambient,
            THREE.UniformsLib.lights,
            {
              emissive: { type: "c", value: new THREE.Color(0) },
              specular: { type: "c", value: new THREE.Color(1118481) },
              shininess: { type: "f", value: 30 },
            },
          ]),
          vertexShader: [
            "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.uv_pars_vertex,
            THREE.ShaderChunk.uv2_pars_vertex,
            THREE.ShaderChunk.displacementmap_pars_vertex,
            THREE.ShaderChunk.envmap_pars_vertex,
            THREE.ShaderChunk.lights_phong_pars_vertex,
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            THREE.ShaderChunk.shadowmap_pars_vertex,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.uv_vertex,
            THREE.ShaderChunk.uv2_vertex,
            THREE.ShaderChunk.color_vertex,
            THREE.ShaderChunk.beginnormal_vertex,
            THREE.ShaderChunk.morphnormal_vertex,
            THREE.ShaderChunk.skinbase_vertex,
            THREE.ShaderChunk.skinnormal_vertex,
            THREE.ShaderChunk.defaultnormal_vertex,
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif",
            THREE.ShaderChunk.begin_vertex,
            THREE.ShaderChunk.displacementmap_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.project_vertex,
            THREE.ShaderChunk.logdepthbuf_vertex,
            "\tvViewPosition = - mvPosition.xyz;",
            THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.envmap_vertex,
            THREE.ShaderChunk.lights_phong_vertex,
            THREE.ShaderChunk.shadowmap_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.uv_pars_fragment,
            THREE.ShaderChunk.uv2_pars_fragment,
            THREE.ShaderChunk.map_pars_fragment,
            THREE.ShaderChunk.alphamap_pars_fragment,
            THREE.ShaderChunk.aomap_pars_fragment,
            THREE.ShaderChunk.lightmap_pars_fragment,
            THREE.ShaderChunk.emissivemap_pars_fragment,
            THREE.ShaderChunk.envmap_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.bsdfs,
            THREE.ShaderChunk.ambient_pars,
            THREE.ShaderChunk.lights_pars,
            THREE.ShaderChunk.lights_phong_pars_fragment,
            THREE.ShaderChunk.shadowmap_pars_fragment,
            THREE.ShaderChunk.bumpmap_pars_fragment,
            THREE.ShaderChunk.normalmap_pars_fragment,
            THREE.ShaderChunk.specularmap_pars_fragment,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveLight = emissive;",
            THREE.ShaderChunk.logdepthbuf_fragment,
            THREE.ShaderChunk.map_fragment,
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.alphamap_fragment,
            THREE.ShaderChunk.alphatest_fragment,
            THREE.ShaderChunk.specularmap_fragment,
            THREE.ShaderChunk.normal_fragment,
            THREE.ShaderChunk.emissivemap_fragment,
            THREE.ShaderChunk.lights_phong_fragment,
            THREE.ShaderChunk.lights_template,
            THREE.ShaderChunk.aomap_fragment,
            "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
            THREE.ShaderChunk.envmap_fragment,
            THREE.ShaderChunk.linear_to_gamma_fragment,
            THREE.ShaderChunk.fog_fragment,
            "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}",
          ].join("\n"),
        },
        standard: {
          uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.common,
            THREE.UniformsLib.aomap,
            THREE.UniformsLib.lightmap,
            THREE.UniformsLib.emissivemap,
            THREE.UniformsLib.bumpmap,
            THREE.UniformsLib.normalmap,
            THREE.UniformsLib.displacementmap,
            THREE.UniformsLib.roughnessmap,
            THREE.UniformsLib.metalnessmap,
            THREE.UniformsLib.fog,
            THREE.UniformsLib.ambient,
            THREE.UniformsLib.lights,
            {
              emissive: { type: "c", value: new THREE.Color(0) },
              roughness: { type: "f", value: 0.5 },
              metalness: { type: "f", value: 0 },
              envMapIntensity: { type: "f", value: 1 },
            },
          ]),
          vertexShader: [
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.uv_pars_vertex,
            THREE.ShaderChunk.uv2_pars_vertex,
            THREE.ShaderChunk.displacementmap_pars_vertex,
            THREE.ShaderChunk.envmap_pars_vertex,
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            THREE.ShaderChunk.shadowmap_pars_vertex,
            THREE.ShaderChunk.specularmap_pars_fragment,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.uv_vertex,
            THREE.ShaderChunk.uv2_vertex,
            THREE.ShaderChunk.color_vertex,
            THREE.ShaderChunk.beginnormal_vertex,
            THREE.ShaderChunk.morphnormal_vertex,
            THREE.ShaderChunk.skinbase_vertex,
            THREE.ShaderChunk.skinnormal_vertex,
            THREE.ShaderChunk.defaultnormal_vertex,
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif",
            THREE.ShaderChunk.begin_vertex,
            THREE.ShaderChunk.displacementmap_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.project_vertex,
            THREE.ShaderChunk.logdepthbuf_vertex,
            "\tvViewPosition = - mvPosition.xyz;",
            THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.envmap_vertex,
            THREE.ShaderChunk.shadowmap_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "#define STANDARD\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.uv_pars_fragment,
            THREE.ShaderChunk.uv2_pars_fragment,
            THREE.ShaderChunk.map_pars_fragment,
            THREE.ShaderChunk.alphamap_pars_fragment,
            THREE.ShaderChunk.aomap_pars_fragment,
            THREE.ShaderChunk.lightmap_pars_fragment,
            THREE.ShaderChunk.emissivemap_pars_fragment,
            THREE.ShaderChunk.envmap_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.bsdfs,
            THREE.ShaderChunk.ambient_pars,
            THREE.ShaderChunk.lights_pars,
            THREE.ShaderChunk.lights_standard_pars_fragment,
            THREE.ShaderChunk.shadowmap_pars_fragment,
            THREE.ShaderChunk.bumpmap_pars_fragment,
            THREE.ShaderChunk.normalmap_pars_fragment,
            THREE.ShaderChunk.roughnessmap_pars_fragment,
            THREE.ShaderChunk.metalnessmap_pars_fragment,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveLight = emissive;",
            THREE.ShaderChunk.logdepthbuf_fragment,
            THREE.ShaderChunk.map_fragment,
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.alphamap_fragment,
            THREE.ShaderChunk.alphatest_fragment,
            THREE.ShaderChunk.specularmap_fragment,
            THREE.ShaderChunk.roughnessmap_fragment,
            THREE.ShaderChunk.metalnessmap_fragment,
            THREE.ShaderChunk.normal_fragment,
            THREE.ShaderChunk.emissivemap_fragment,
            THREE.ShaderChunk.lights_standard_fragment,
            THREE.ShaderChunk.lights_template,
            THREE.ShaderChunk.aomap_fragment,
            "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
            THREE.ShaderChunk.linear_to_gamma_fragment,
            THREE.ShaderChunk.fog_fragment,
            "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}",
          ].join("\n"),
        },
        points: {
          uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.points,
            THREE.UniformsLib.fog,
          ]),
          vertexShader: [
            "uniform float size;\nuniform float scale;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.shadowmap_pars_vertex,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.color_vertex,
            THREE.ShaderChunk.begin_vertex,
            THREE.ShaderChunk.project_vertex,
            "\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif",
            THREE.ShaderChunk.logdepthbuf_vertex,
            THREE.ShaderChunk.worldpos_vertex,
            THREE.ShaderChunk.shadowmap_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform vec3 diffuse;\nuniform float opacity;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.map_particle_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.shadowmap_pars_fragment,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );",
            THREE.ShaderChunk.logdepthbuf_fragment,
            THREE.ShaderChunk.map_particle_fragment,
            THREE.ShaderChunk.color_fragment,
            THREE.ShaderChunk.alphatest_fragment,
            "\toutgoingLight = diffuseColor.rgb;",
            THREE.ShaderChunk.fog_fragment,
            "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}",
          ].join("\n"),
        },
        dashed: {
          uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.common,
            THREE.UniformsLib.fog,
            {
              scale: { type: "f", value: 1 },
              dashSize: { type: "f", value: 1 },
              totalSize: { type: "f", value: 2 },
            },
          ]),
          vertexShader: [
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.color_pars_vertex,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.color_vertex,
            "\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;",
            THREE.ShaderChunk.logdepthbuf_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.color_pars_fragment,
            THREE.ShaderChunk.fog_pars_fragment,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );",
            THREE.ShaderChunk.logdepthbuf_fragment,
            THREE.ShaderChunk.color_fragment,
            "\toutgoingLight = diffuseColor.rgb;",
            THREE.ShaderChunk.fog_fragment,
            "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}",
          ].join("\n"),
        },
        depth: {
          uniforms: {
            mNear: { type: "f", value: 1 },
            mFar: { type: "f", value: 2e3 },
            opacity: { type: "f", value: 1 },
          },
          vertexShader: [
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.begin_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.project_vertex,
            THREE.ShaderChunk.logdepthbuf_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform float mNear;\nuniform float mFar;\nuniform float opacity;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {",
            THREE.ShaderChunk.logdepthbuf_fragment,
            "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\n\tgl_FragColor = vec4( vec3( color ), opacity );\n}",
          ].join("\n"),
        },
        normal: {
          uniforms: { opacity: { type: "f", value: 1 } },
          vertexShader: [
            "varying vec3 vNormal;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {\n\tvNormal = normalize( normalMatrix * normal );",
            THREE.ShaderChunk.begin_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.project_vertex,
            THREE.ShaderChunk.logdepthbuf_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform float opacity;\nvarying vec3 vNormal;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {\n\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",
            THREE.ShaderChunk.logdepthbuf_fragment,
            "}",
          ].join("\n"),
        },
        cube: {
          uniforms: {
            tCube: { type: "t", value: null },
            tFlip: { type: "f", value: -1 },
          },
          vertexShader: [
            "varying vec3 vWorldPosition;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            THREE.ShaderChunk.logdepthbuf_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
            THREE.ShaderChunk.logdepthbuf_fragment,
            "}",
          ].join("\n"),
        },
        equirect: {
          uniforms: {
            tEquirect: { type: "t", value: null },
            tFlip: { type: "f", value: -1 },
          },
          vertexShader: [
            "varying vec3 vWorldPosition;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            THREE.ShaderChunk.logdepthbuf_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "void main() {\nvec3 direction = normalize( vWorldPosition );\nvec2 sampleUV;\nsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\nsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\ngl_FragColor = texture2D( tEquirect, sampleUV );",
            THREE.ShaderChunk.logdepthbuf_fragment,
            "}",
          ].join("\n"),
        },
        depthRGBA: {
          uniforms: {},
          vertexShader: [
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            THREE.ShaderChunk.logdepthbuf_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.skinbase_vertex,
            THREE.ShaderChunk.begin_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.project_vertex,
            THREE.ShaderChunk.logdepthbuf_vertex,
            "}",
          ].join("\n"),
          fragmentShader: [
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.logdepthbuf_pars_fragment,
            "vec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {",
            THREE.ShaderChunk.logdepthbuf_fragment,
            "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}",
          ].join("\n"),
        },
        distanceRGBA: {
          uniforms: {
            lightPos: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
          },
          vertexShader: [
            "varying vec4 vWorldPosition;",
            THREE.ShaderChunk.common,
            THREE.ShaderChunk.morphtarget_pars_vertex,
            THREE.ShaderChunk.skinning_pars_vertex,
            "void main() {",
            THREE.ShaderChunk.skinbase_vertex,
            THREE.ShaderChunk.begin_vertex,
            THREE.ShaderChunk.morphtarget_vertex,
            THREE.ShaderChunk.skinning_vertex,
            THREE.ShaderChunk.project_vertex,
            THREE.ShaderChunk.worldpos_vertex,
            "vWorldPosition = worldPosition;\n}",
          ].join("\n"),
          fragmentShader: [
            "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;",
            THREE.ShaderChunk.common,
            "vec4 pack1K ( float depth ) {\n\tdepth /= 1000.0;\n\tconst vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bitMsk;\n\treturn res; \n}\nfloat unpack1K ( vec4 color ) {\n\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\treturn dot( color, bitSh ) * 1000.0;\n}\nvoid main () {\n\tgl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );\n}",
          ].join("\n"),
        },
      };
      THREE.WebGLRenderer = function (a) {
        function b(a, b, c, d) {
          !0 === Q && ((a *= d), (b *= d), (c *= d));
          I.clearColor(a, b, c, d);
        }
        function c() {
          I.init();
          I.scissor(qa.copy(xa).multiplyScalar(Z));
          I.viewport(ja.copy(ka).multiplyScalar(Z));
          b($.r, $.g, $.b, fa);
        }
        function d() {
          la = ma = null;
          na = "";
          ra = -1;
          I.reset();
        }
        function e(a) {
          a.preventDefault();
          d();
          c();
          T.clear();
        }
        function f(a) {
          a = a.target;
          a.removeEventListener("dispose", f);
          a: {
            var b = T.get(a);
            if (a.image && b.__image__webglTextureCube)
              r.deleteTexture(b.__image__webglTextureCube);
            else {
              if (void 0 === b.__webglInit) break a;
              r.deleteTexture(b.__webglTexture);
            }
            T.delete(a);
          }
          ga.textures--;
        }
        function g(a) {
          a = a.target;
          a.removeEventListener("dispose", g);
          var b = T.get(a),
            c = T.get(a.texture);
          if (a && void 0 !== c.__webglTexture) {
            r.deleteTexture(c.__webglTexture);
            if (a instanceof THREE.WebGLRenderTargetCube)
              for (c = 0; 6 > c; c++)
                r.deleteFramebuffer(b.__webglFramebuffer[c]),
                  r.deleteRenderbuffer(b.__webglDepthbuffer[c]);
            else
              r.deleteFramebuffer(b.__webglFramebuffer),
                r.deleteRenderbuffer(b.__webglDepthbuffer);
            T.delete(a.texture);
            T.delete(a);
          }
          ga.textures--;
        }
        function h(a) {
          a = a.target;
          a.removeEventListener("dispose", h);
          k(a);
          T.delete(a);
        }
        function k(a) {
          var b = T.get(a).program;
          a.program = void 0;
          void 0 !== b && oa.releaseProgram(b);
        }
        function l(a, b) {
          return Math.abs(b[0]) - Math.abs(a[0]);
        }
        function n(a, b) {
          return a.object.renderOrder !== b.object.renderOrder
            ? a.object.renderOrder - b.object.renderOrder
            : a.material.id !== b.material.id
            ? a.material.id - b.material.id
            : a.z !== b.z
            ? a.z - b.z
            : a.id - b.id;
        }
        function p(a, b) {
          return a.object.renderOrder !== b.object.renderOrder
            ? a.object.renderOrder - b.object.renderOrder
            : a.z !== b.z
            ? b.z - a.z
            : a.id - b.id;
        }
        function m(a, b, c, d, e) {
          var f;
          c.transparent ? ((d = Y), (f = ++V)) : ((d = J), (f = ++F));
          f = d[f];
          void 0 !== f
            ? ((f.id = a.id),
              (f.object = a),
              (f.geometry = b),
              (f.material = c),
              (f.z = W.z),
              (f.group = e))
            : ((f = {
                id: a.id,
                object: a,
                geometry: b,
                material: c,
                z: W.z,
                group: e,
              }),
              d.push(f));
        }
        function q(a, b) {
          if (!1 !== a.visible) {
            if (a.layers.test(b.layers))
              if (a instanceof THREE.Light) S.push(a);
              else if (a instanceof THREE.Sprite)
                (!1 !== a.frustumCulled && !0 !== ya.intersectsObject(a)) ||
                  ca.push(a);
              else if (a instanceof THREE.LensFlare) ha.push(a);
              else if (a instanceof THREE.ImmediateRenderObject)
                !0 === X.sortObjects &&
                  (W.setFromMatrixPosition(a.matrixWorld),
                  W.applyProjection(sa)),
                  m(a, null, a.material, W.z, null);
              else if (
                a instanceof THREE.Mesh ||
                a instanceof THREE.Line ||
                a instanceof THREE.Points
              )
                if (
                  (a instanceof THREE.SkinnedMesh && a.skeleton.update(),
                  !1 === a.frustumCulled || !0 === ya.intersectsObject(a))
                ) {
                  var c = a.material;
                  if (!0 === c.visible) {
                    !0 === X.sortObjects &&
                      (W.setFromMatrixPosition(a.matrixWorld),
                      W.applyProjection(sa));
                    var d = pa.update(a);
                    if (c instanceof THREE.MultiMaterial)
                      for (
                        var e = d.groups, f = c.materials, c = 0, g = e.length;
                        c < g;
                        c++
                      ) {
                        var h = e[c],
                          k = f[h.materialIndex];
                        !0 === k.visible && m(a, d, k, W.z, h);
                      }
                    else m(a, d, c, W.z, null);
                  }
                }
            d = a.children;
            c = 0;
            for (g = d.length; c < g; c++) q(d[c], b);
          }
        }
        function s(a, b, c, d) {
          for (var e = 0, f = a.length; e < f; e++) {
            var g = a[e],
              h = g.object,
              k = g.geometry,
              l = void 0 === d ? g.material : d,
              g = g.group;
            h.modelViewMatrix.multiplyMatrices(
              b.matrixWorldInverse,
              h.matrixWorld
            );
            h.normalMatrix.getNormalMatrix(h.modelViewMatrix);
            if (h instanceof THREE.ImmediateRenderObject) {
              u(l);
              var m = t(b, c, l, h);
              na = "";
              h.render(function (a) {
                X.renderBufferImmediate(a, m, l);
              });
            } else X.renderBufferDirect(b, c, k, l, h, g);
          }
        }
        function u(a) {
          a.side !== THREE.DoubleSide
            ? I.enable(r.CULL_FACE)
            : I.disable(r.CULL_FACE);
          I.setFlipSided(a.side === THREE.BackSide);
          !0 === a.transparent
            ? I.setBlending(
                a.blending,
                a.blendEquation,
                a.blendSrc,
                a.blendDst,
                a.blendEquationAlpha,
                a.blendSrcAlpha,
                a.blendDstAlpha
              )
            : I.setBlending(THREE.NoBlending);
          I.setDepthFunc(a.depthFunc);
          I.setDepthTest(a.depthTest);
          I.setDepthWrite(a.depthWrite);
          I.setColorWrite(a.colorWrite);
          I.setPolygonOffset(
            a.polygonOffset,
            a.polygonOffsetFactor,
            a.polygonOffsetUnits
          );
        }
        function t(a, b, c, d) {
          ta = 0;
          var e = T.get(c);
          void 0 === e.program && (c.needsUpdate = !0);
          void 0 !== e.lightsHash &&
            e.lightsHash !== R.hash &&
            (c.needsUpdate = !0);
          if (c.needsUpdate) {
            a: {
              var f = T.get(c),
                g = oa.getParameters(c, R, b, d),
                l = oa.getProgramCode(c, g),
                m = f.program,
                n = !0;
              if (void 0 === m) c.addEventListener("dispose", h);
              else if (m.code !== l) k(c);
              else if (void 0 !== g.shaderID) break a;
              else n = !1;
              n &&
                (g.shaderID
                  ? ((m = THREE.ShaderLib[g.shaderID]),
                    (f.__webglShader = {
                      name: c.type,
                      uniforms: THREE.UniformsUtils.clone(m.uniforms),
                      vertexShader: m.vertexShader,
                      fragmentShader: m.fragmentShader,
                    }))
                  : (f.__webglShader = {
                      name: c.type,
                      uniforms: c.uniforms,
                      vertexShader: c.vertexShader,
                      fragmentShader: c.fragmentShader,
                    }),
                (c.__webglShader = f.__webglShader),
                (m = oa.acquireProgram(c, g, l)),
                (f.program = m),
                (c.program = m));
              g = m.getAttributes();
              if (c.morphTargets)
                for (
                  l = c.numSupportedMorphTargets = 0;
                  l < X.maxMorphTargets;
                  l++
                )
                  0 <= g["morphTarget" + l] && c.numSupportedMorphTargets++;
              if (c.morphNormals)
                for (
                  l = c.numSupportedMorphNormals = 0;
                  l < X.maxMorphNormals;
                  l++
                )
                  0 <= g["morphNormal" + l] && c.numSupportedMorphNormals++;
              f.uniformsList = [];
              var g = f.__webglShader.uniforms,
                l = f.program.getUniforms(),
                q;
              for (q in g)
                (m = l[q]) &&
                  f.uniformsList.push([f.__webglShader.uniforms[q], m]);
              if (
                c instanceof THREE.MeshPhongMaterial ||
                c instanceof THREE.MeshLambertMaterial ||
                c instanceof THREE.MeshStandardMaterial ||
                c.lights
              )
                (f.lightsHash = R.hash),
                  (g.ambientLightColor.value = R.ambient),
                  (g.directionalLights.value = R.directional),
                  (g.spotLights.value = R.spot),
                  (g.pointLights.value = R.point),
                  (g.hemisphereLights.value = R.hemi),
                  (g.directionalShadowMap.value = R.directionalShadowMap),
                  (g.directionalShadowMatrix.value = R.directionalShadowMatrix),
                  (g.spotShadowMap.value = R.spotShadowMap),
                  (g.spotShadowMatrix.value = R.spotShadowMatrix),
                  (g.pointShadowMap.value = R.pointShadowMap),
                  (g.pointShadowMatrix.value = R.pointShadowMatrix);
              f.hasDynamicUniforms = !1;
              q = 0;
              for (g = f.uniformsList.length; q < g; q++)
                if (!0 === f.uniformsList[q][0].dynamic) {
                  f.hasDynamicUniforms = !0;
                  break;
                }
            }
            c.needsUpdate = !1;
          }
          m = l = n = !1;
          f = e.program;
          q = f.getUniforms();
          g = e.__webglShader.uniforms;
          f.id !== ma &&
            (r.useProgram(f.program), (ma = f.id), (m = l = n = !0));
          c.id !== ra && ((ra = c.id), (l = !0));
          if (n || a !== la)
            r.uniformMatrix4fv(
              q.projectionMatrix,
              !1,
              a.projectionMatrix.elements
            ),
              da.logarithmicDepthBuffer &&
                r.uniform1f(
                  q.logDepthBufFC,
                  2 / (Math.log(a.far + 1) / Math.LN2)
                ),
              a !== la && ((la = a), (m = l = !0)),
              (c instanceof THREE.ShaderMaterial ||
                c instanceof THREE.MeshPhongMaterial ||
                c instanceof THREE.MeshStandardMaterial ||
                c.envMap) &&
                void 0 !== q.cameraPosition &&
                (W.setFromMatrixPosition(a.matrixWorld),
                r.uniform3f(q.cameraPosition, W.x, W.y, W.z)),
              (c instanceof THREE.MeshPhongMaterial ||
                c instanceof THREE.MeshLambertMaterial ||
                c instanceof THREE.MeshBasicMaterial ||
                c instanceof THREE.MeshStandardMaterial ||
                c instanceof THREE.ShaderMaterial ||
                c.skinning) &&
                void 0 !== q.viewMatrix &&
                r.uniformMatrix4fv(
                  q.viewMatrix,
                  !1,
                  a.matrixWorldInverse.elements
                );
          c.skinning &&
            (d.bindMatrix &&
              void 0 !== q.bindMatrix &&
              r.uniformMatrix4fv(q.bindMatrix, !1, d.bindMatrix.elements),
            d.bindMatrixInverse &&
              void 0 !== q.bindMatrixInverse &&
              r.uniformMatrix4fv(
                q.bindMatrixInverse,
                !1,
                d.bindMatrixInverse.elements
              ),
            da.floatVertexTextures && d.skeleton && d.skeleton.useVertexTexture
              ? (void 0 !== q.boneTexture &&
                  ((n = x()),
                  r.uniform1i(q.boneTexture, n),
                  X.setTexture(d.skeleton.boneTexture, n)),
                void 0 !== q.boneTextureWidth &&
                  r.uniform1i(q.boneTextureWidth, d.skeleton.boneTextureWidth),
                void 0 !== q.boneTextureHeight &&
                  r.uniform1i(
                    q.boneTextureHeight,
                    d.skeleton.boneTextureHeight
                  ))
              : d.skeleton &&
                d.skeleton.boneMatrices &&
                void 0 !== q.boneGlobalMatrices &&
                r.uniformMatrix4fv(
                  q.boneGlobalMatrices,
                  !1,
                  d.skeleton.boneMatrices
                ));
          if (l) {
            if (
              c instanceof THREE.MeshPhongMaterial ||
              c instanceof THREE.MeshLambertMaterial ||
              c instanceof THREE.MeshStandardMaterial ||
              c.lights
            )
              (l = m),
                (g.ambientLightColor.needsUpdate = l),
                (g.directionalLights.needsUpdate = l),
                (g.pointLights.needsUpdate = l),
                (g.spotLights.needsUpdate = l),
                (g.hemisphereLights.needsUpdate = l);
            b &&
              c.fog &&
              ((g.fogColor.value = b.color),
              b instanceof THREE.Fog
                ? ((g.fogNear.value = b.near), (g.fogFar.value = b.far))
                : b instanceof THREE.FogExp2 &&
                  (g.fogDensity.value = b.density));
            if (
              c instanceof THREE.MeshBasicMaterial ||
              c instanceof THREE.MeshLambertMaterial ||
              c instanceof THREE.MeshPhongMaterial ||
              c instanceof THREE.MeshStandardMaterial
            ) {
              g.opacity.value = c.opacity;
              g.diffuse.value = c.color;
              c.emissive &&
                g.emissive.value
                  .copy(c.emissive)
                  .multiplyScalar(c.emissiveIntensity);
              g.map.value = c.map;
              g.specularMap.value = c.specularMap;
              g.alphaMap.value = c.alphaMap;
              c.aoMap &&
                ((g.aoMap.value = c.aoMap),
                (g.aoMapIntensity.value = c.aoMapIntensity));
              var p;
              c.map
                ? (p = c.map)
                : c.specularMap
                ? (p = c.specularMap)
                : c.displacementMap
                ? (p = c.displacementMap)
                : c.normalMap
                ? (p = c.normalMap)
                : c.bumpMap
                ? (p = c.bumpMap)
                : c.roughnessMap
                ? (p = c.roughnessMap)
                : c.metalnessMap
                ? (p = c.metalnessMap)
                : c.alphaMap
                ? (p = c.alphaMap)
                : c.emissiveMap && (p = c.emissiveMap);
              void 0 !== p &&
                (p instanceof THREE.WebGLRenderTarget && (p = p.texture),
                (b = p.offset),
                (p = p.repeat),
                g.offsetRepeat.value.set(b.x, b.y, p.x, p.y));
              g.envMap.value = c.envMap;
              g.flipEnvMap.value =
                c.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
              g.reflectivity.value = c.reflectivity;
              g.refractionRatio.value = c.refractionRatio;
            }
            c instanceof THREE.LineBasicMaterial
              ? ((g.diffuse.value = c.color), (g.opacity.value = c.opacity))
              : c instanceof THREE.LineDashedMaterial
              ? ((g.diffuse.value = c.color),
                (g.opacity.value = c.opacity),
                (g.dashSize.value = c.dashSize),
                (g.totalSize.value = c.dashSize + c.gapSize),
                (g.scale.value = c.scale))
              : c instanceof THREE.PointsMaterial
              ? ((g.diffuse.value = c.color),
                (g.opacity.value = c.opacity),
                (g.size.value = c.size * Z),
                (g.scale.value = K.clientHeight / 2),
                (g.map.value = c.map),
                null !== c.map &&
                  ((p = c.map.offset),
                  (c = c.map.repeat),
                  g.offsetRepeat.value.set(p.x, p.y, c.x, c.y)))
              : c instanceof THREE.MeshLambertMaterial
              ? (c.lightMap &&
                  ((g.lightMap.value = c.lightMap),
                  (g.lightMapIntensity.value = c.lightMapIntensity)),
                c.emissiveMap && (g.emissiveMap.value = c.emissiveMap))
              : c instanceof THREE.MeshPhongMaterial
              ? ((g.specular.value = c.specular),
                (g.shininess.value = Math.max(c.shininess, 1e-4)),
                c.lightMap &&
                  ((g.lightMap.value = c.lightMap),
                  (g.lightMapIntensity.value = c.lightMapIntensity)),
                c.emissiveMap && (g.emissiveMap.value = c.emissiveMap),
                c.bumpMap &&
                  ((g.bumpMap.value = c.bumpMap),
                  (g.bumpScale.value = c.bumpScale)),
                c.normalMap &&
                  ((g.normalMap.value = c.normalMap),
                  g.normalScale.value.copy(c.normalScale)),
                c.displacementMap &&
                  ((g.displacementMap.value = c.displacementMap),
                  (g.displacementScale.value = c.displacementScale),
                  (g.displacementBias.value = c.displacementBias)))
              : c instanceof THREE.MeshStandardMaterial
              ? ((g.roughness.value = c.roughness),
                (g.metalness.value = c.metalness),
                c.roughnessMap && (g.roughnessMap.value = c.roughnessMap),
                c.metalnessMap && (g.metalnessMap.value = c.metalnessMap),
                c.lightMap &&
                  ((g.lightMap.value = c.lightMap),
                  (g.lightMapIntensity.value = c.lightMapIntensity)),
                c.emissiveMap && (g.emissiveMap.value = c.emissiveMap),
                c.bumpMap &&
                  ((g.bumpMap.value = c.bumpMap),
                  (g.bumpScale.value = c.bumpScale)),
                c.normalMap &&
                  ((g.normalMap.value = c.normalMap),
                  g.normalScale.value.copy(c.normalScale)),
                c.displacementMap &&
                  ((g.displacementMap.value = c.displacementMap),
                  (g.displacementScale.value = c.displacementScale),
                  (g.displacementBias.value = c.displacementBias)),
                c.envMap && (g.envMapIntensity.value = c.envMapIntensity))
              : c instanceof THREE.MeshDepthMaterial
              ? ((g.mNear.value = a.near),
                (g.mFar.value = a.far),
                (g.opacity.value = c.opacity))
              : c instanceof THREE.MeshNormalMaterial &&
                (g.opacity.value = c.opacity);
            v(e.uniformsList);
          }
          r.uniformMatrix4fv(q.modelViewMatrix, !1, d.modelViewMatrix.elements);
          q.normalMatrix &&
            r.uniformMatrix3fv(q.normalMatrix, !1, d.normalMatrix.elements);
          void 0 !== q.modelMatrix &&
            r.uniformMatrix4fv(q.modelMatrix, !1, d.matrixWorld.elements);
          if (!0 === e.hasDynamicUniforms) {
            e = e.uniformsList;
            c = [];
            p = 0;
            for (b = e.length; p < b; p++)
              (q = e[p][0]),
                (g = q.onUpdateCallback),
                void 0 !== g && (g.bind(q)(d, a), c.push(e[p]));
            v(c);
          }
          return f;
        }
        function x() {
          var a = ta;
          a >= da.maxTextures &&
            console.warn(
              "WebGLRenderer: trying to use " +
                a +
                " texture units while this GPU supports only " +
                da.maxTextures
            );
          ta += 1;
          return a;
        }
        function v(a) {
          for (var b, c, d = 0, e = a.length; d < e; d++) {
            var g = a[d][0];
            if (!1 !== g.needsUpdate) {
              var f = g.type;
              b = g.value;
              var h = a[d][1];
              switch (f) {
                case "1i":
                  r.uniform1i(h, b);
                  break;
                case "1f":
                  r.uniform1f(h, b);
                  break;
                case "2f":
                  r.uniform2f(h, b[0], b[1]);
                  break;
                case "3f":
                  r.uniform3f(h, b[0], b[1], b[2]);
                  break;
                case "4f":
                  r.uniform4f(h, b[0], b[1], b[2], b[3]);
                  break;
                case "1iv":
                  r.uniform1iv(h, b);
                  break;
                case "3iv":
                  r.uniform3iv(h, b);
                  break;
                case "1fv":
                  r.uniform1fv(h, b);
                  break;
                case "2fv":
                  r.uniform2fv(h, b);
                  break;
                case "3fv":
                  r.uniform3fv(h, b);
                  break;
                case "4fv":
                  r.uniform4fv(h, b);
                  break;
                case "Matrix2fv":
                  r.uniformMatrix2fv(h, !1, b);
                  break;
                case "Matrix3fv":
                  r.uniformMatrix3fv(h, !1, b);
                  break;
                case "Matrix4fv":
                  r.uniformMatrix4fv(h, !1, b);
                  break;
                case "i":
                  r.uniform1i(h, b);
                  break;
                case "f":
                  r.uniform1f(h, b);
                  break;
                case "v2":
                  r.uniform2f(h, b.x, b.y);
                  break;
                case "v3":
                  r.uniform3f(h, b.x, b.y, b.z);
                  break;
                case "v4":
                  r.uniform4f(h, b.x, b.y, b.z, b.w);
                  break;
                case "c":
                  r.uniform3f(h, b.r, b.g, b.b);
                  break;
                case "sa":
                  for (f = 0; f < b.length; f++)
                    for (var k in g.properties) {
                      var l = h[f][k];
                      c = b[f][k];
                      switch (g.properties[k].type) {
                        case "i":
                          r.uniform1i(l, c);
                          break;
                        case "f":
                          r.uniform1f(l, c);
                          break;
                        case "v2":
                          r.uniform2f(l, c.x, c.y);
                          break;
                        case "v3":
                          r.uniform3f(l, c.x, c.y, c.z);
                          break;
                        case "v4":
                          r.uniform4f(l, c.x, c.y, c.z, c.w);
                          break;
                        case "c":
                          r.uniform3f(l, c.r, c.g, c.b);
                          break;
                        case "m4":
                          r.uniformMatrix4fv(l, !1, c.elements);
                      }
                    }
                  break;
                case "iv1":
                  r.uniform1iv(h, b);
                  break;
                case "iv":
                  r.uniform3iv(h, b);
                  break;
                case "fv1":
                  r.uniform1fv(h, b);
                  break;
                case "fv":
                  r.uniform3fv(h, b);
                  break;
                case "v2v":
                  void 0 === g._array &&
                    (g._array = new Float32Array(2 * b.length));
                  c = f = 0;
                  for (l = b.length; f < l; f++, c += 2)
                    (g._array[c + 0] = b[f].x), (g._array[c + 1] = b[f].y);
                  r.uniform2fv(h, g._array);
                  break;
                case "v3v":
                  void 0 === g._array &&
                    (g._array = new Float32Array(3 * b.length));
                  c = f = 0;
                  for (l = b.length; f < l; f++, c += 3)
                    (g._array[c + 0] = b[f].x),
                      (g._array[c + 1] = b[f].y),
                      (g._array[c + 2] = b[f].z);
                  r.uniform3fv(h, g._array);
                  break;
                case "v4v":
                  void 0 === g._array &&
                    (g._array = new Float32Array(4 * b.length));
                  c = f = 0;
                  for (l = b.length; f < l; f++, c += 4)
                    (g._array[c + 0] = b[f].x),
                      (g._array[c + 1] = b[f].y),
                      (g._array[c + 2] = b[f].z),
                      (g._array[c + 3] = b[f].w);
                  r.uniform4fv(h, g._array);
                  break;
                case "m2":
                  r.uniformMatrix2fv(h, !1, b.elements);
                  break;
                case "m3":
                  r.uniformMatrix3fv(h, !1, b.elements);
                  break;
                case "m3v":
                  void 0 === g._array &&
                    (g._array = new Float32Array(9 * b.length));
                  f = 0;
                  for (l = b.length; f < l; f++)
                    b[f].flattenToArrayOffset(g._array, 9 * f);
                  r.uniformMatrix3fv(h, !1, g._array);
                  break;
                case "m4":
                  r.uniformMatrix4fv(h, !1, b.elements);
                  break;
                case "m4v":
                  void 0 === g._array &&
                    (g._array = new Float32Array(16 * b.length));
                  f = 0;
                  for (l = b.length; f < l; f++)
                    b[f].flattenToArrayOffset(g._array, 16 * f);
                  r.uniformMatrix4fv(h, !1, g._array);
                  break;
                case "t":
                  c = x();
                  r.uniform1i(h, c);
                  if (!b) continue;
                  b instanceof THREE.CubeTexture ||
                  (Array.isArray(b.image) && 6 === b.image.length)
                    ? z(b, c)
                    : b instanceof THREE.WebGLRenderTargetCube
                    ? y(b.texture, c)
                    : b instanceof THREE.WebGLRenderTarget
                    ? X.setTexture(b.texture, c)
                    : X.setTexture(b, c);
                  break;
                case "tv":
                  void 0 === g._array && (g._array = []);
                  f = 0;
                  for (l = g.value.length; f < l; f++) g._array[f] = x();
                  r.uniform1iv(h, g._array);
                  f = 0;
                  for (l = g.value.length; f < l; f++)
                    (b = g.value[f]),
                      (c = g._array[f]),
                      b &&
                        (b instanceof THREE.CubeTexture ||
                        (b.image instanceof Array && 6 === b.image.length)
                          ? z(b, c)
                          : b instanceof THREE.WebGLRenderTarget
                          ? X.setTexture(b.texture, c)
                          : b instanceof THREE.WebGLRenderTargetCube
                          ? y(b.texture, c)
                          : X.setTexture(b, c));
                  break;
                default:
                  console.warn(
                    "THREE.WebGLRenderer: Unknown uniform type: " + f
                  );
              }
            }
          }
        }
        function C(a, b, c) {
          c
            ? (r.texParameteri(a, r.TEXTURE_WRAP_S, E(b.wrapS)),
              r.texParameteri(a, r.TEXTURE_WRAP_T, E(b.wrapT)),
              r.texParameteri(a, r.TEXTURE_MAG_FILTER, E(b.magFilter)),
              r.texParameteri(a, r.TEXTURE_MIN_FILTER, E(b.minFilter)))
            : (r.texParameteri(a, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
              r.texParameteri(a, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
              (b.wrapS === THREE.ClampToEdgeWrapping &&
                b.wrapT === THREE.ClampToEdgeWrapping) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
                  b
                ),
              r.texParameteri(a, r.TEXTURE_MAG_FILTER, G(b.magFilter)),
              r.texParameteri(a, r.TEXTURE_MIN_FILTER, G(b.minFilter)),
              b.minFilter !== THREE.NearestFilter &&
                b.minFilter !== THREE.LinearFilter &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
                  b
                ));
          !(c = U.get("EXT_texture_filter_anisotropic")) ||
            (b.type === THREE.FloatType &&
              null === U.get("OES_texture_float_linear")) ||
            (b.type === THREE.HalfFloatType &&
              null === U.get("OES_texture_half_float_linear")) ||
            !(1 < b.anisotropy || T.get(b).__currentAnisotropy) ||
            (r.texParameterf(
              a,
              c.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(b.anisotropy, X.getMaxAnisotropy())
            ),
            (T.get(b).__currentAnisotropy = b.anisotropy));
        }
        function w(a, b) {
          if (a.width > b || a.height > b) {
            var c = b / Math.max(a.width, a.height),
              d = document.createElement("canvas");
            d.width = Math.floor(a.width * c);
            d.height = Math.floor(a.height * c);
            d.getContext("2d").drawImage(
              a,
              0,
              0,
              a.width,
              a.height,
              0,
              0,
              d.width,
              d.height
            );
            console.warn(
              "THREE.WebGLRenderer: image is too big (" +
                a.width +
                "x" +
                a.height +
                "). Resized to " +
                d.width +
                "x" +
                d.height,
              a
            );
            return d;
          }
          return a;
        }
        function D(a) {
          return (
            THREE.Math.isPowerOfTwo(a.width) &&
            THREE.Math.isPowerOfTwo(a.height)
          );
        }
        function z(a, b) {
          var c = T.get(a);
          if (6 === a.image.length)
            if (0 < a.version && c.__version !== a.version) {
              c.__image__webglTextureCube ||
                (a.addEventListener("dispose", f),
                (c.__image__webglTextureCube = r.createTexture()),
                ga.textures++);
              I.activeTexture(r.TEXTURE0 + b);
              I.bindTexture(r.TEXTURE_CUBE_MAP, c.__image__webglTextureCube);
              r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, a.flipY);
              for (
                var d = a instanceof THREE.CompressedTexture,
                  e = a.image[0] instanceof THREE.DataTexture,
                  g = [],
                  h = 0;
                6 > h;
                h++
              )
                g[h] =
                  !X.autoScaleCubemaps || d || e
                    ? e
                      ? a.image[h].image
                      : a.image[h]
                    : w(a.image[h], da.maxCubemapSize);
              var k = D(g[0]),
                l = E(a.format),
                m = E(a.type);
              C(r.TEXTURE_CUBE_MAP, a, k);
              for (h = 0; 6 > h; h++)
                if (d)
                  for (var n, q = g[h].mipmaps, p = 0, s = q.length; p < s; p++)
                    (n = q[p]),
                      a.format !== THREE.RGBAFormat &&
                      a.format !== THREE.RGBFormat
                        ? -1 < I.getCompressedTextureFormats().indexOf(l)
                          ? I.compressedTexImage2D(
                              r.TEXTURE_CUBE_MAP_POSITIVE_X + h,
                              p,
                              l,
                              n.width,
                              n.height,
                              0,
                              n.data
                            )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()"
                            )
                        : I.texImage2D(
                            r.TEXTURE_CUBE_MAP_POSITIVE_X + h,
                            p,
                            l,
                            n.width,
                            n.height,
                            0,
                            l,
                            m,
                            n.data
                          );
                else
                  e
                    ? I.texImage2D(
                        r.TEXTURE_CUBE_MAP_POSITIVE_X + h,
                        0,
                        l,
                        g[h].width,
                        g[h].height,
                        0,
                        l,
                        m,
                        g[h].data
                      )
                    : I.texImage2D(
                        r.TEXTURE_CUBE_MAP_POSITIVE_X + h,
                        0,
                        l,
                        l,
                        m,
                        g[h]
                      );
              a.generateMipmaps && k && r.generateMipmap(r.TEXTURE_CUBE_MAP);
              c.__version = a.version;
              if (a.onUpdate) a.onUpdate(a);
            } else
              I.activeTexture(r.TEXTURE0 + b),
                I.bindTexture(r.TEXTURE_CUBE_MAP, c.__image__webglTextureCube);
        }
        function y(a, b) {
          I.activeTexture(r.TEXTURE0 + b);
          I.bindTexture(r.TEXTURE_CUBE_MAP, T.get(a).__webglTexture);
        }
        function A(a, b, c, d) {
          var e = E(b.texture.format),
            g = E(b.texture.type);
          I.texImage2D(d, 0, e, b.width, b.height, 0, e, g, null);
          r.bindFramebuffer(r.FRAMEBUFFER, a);
          r.framebufferTexture2D(
            r.FRAMEBUFFER,
            c,
            d,
            T.get(b.texture).__webglTexture,
            0
          );
          r.bindFramebuffer(r.FRAMEBUFFER, null);
        }
        function H(a, b) {
          r.bindRenderbuffer(r.RENDERBUFFER, a);
          b.depthBuffer && !b.stencilBuffer
            ? (r.renderbufferStorage(
                r.RENDERBUFFER,
                r.DEPTH_COMPONENT16,
                b.width,
                b.height
              ),
              r.framebufferRenderbuffer(
                r.FRAMEBUFFER,
                r.DEPTH_ATTACHMENT,
                r.RENDERBUFFER,
                a
              ))
            : b.depthBuffer && b.stencilBuffer
            ? (r.renderbufferStorage(
                r.RENDERBUFFER,
                r.DEPTH_STENCIL,
                b.width,
                b.height
              ),
              r.framebufferRenderbuffer(
                r.FRAMEBUFFER,
                r.DEPTH_STENCIL_ATTACHMENT,
                r.RENDERBUFFER,
                a
              ))
            : r.renderbufferStorage(r.RENDERBUFFER, r.RGBA4, b.width, b.height);
          r.bindRenderbuffer(r.RENDERBUFFER, null);
        }
        function G(a) {
          return a === THREE.NearestFilter ||
            a === THREE.NearestMipMapNearestFilter ||
            a === THREE.NearestMipMapLinearFilter
            ? r.NEAREST
            : r.LINEAR;
        }
        function E(a) {
          var b;
          if (a === THREE.RepeatWrapping) return r.REPEAT;
          if (a === THREE.ClampToEdgeWrapping) return r.CLAMP_TO_EDGE;
          if (a === THREE.MirroredRepeatWrapping) return r.MIRRORED_REPEAT;
          if (a === THREE.NearestFilter) return r.NEAREST;
          if (a === THREE.NearestMipMapNearestFilter)
            return r.NEAREST_MIPMAP_NEAREST;
          if (a === THREE.NearestMipMapLinearFilter)
            return r.NEAREST_MIPMAP_LINEAR;
          if (a === THREE.LinearFilter) return r.LINEAR;
          if (a === THREE.LinearMipMapNearestFilter)
            return r.LINEAR_MIPMAP_NEAREST;
          if (a === THREE.LinearMipMapLinearFilter)
            return r.LINEAR_MIPMAP_LINEAR;
          if (a === THREE.UnsignedByteType) return r.UNSIGNED_BYTE;
          if (a === THREE.UnsignedShort4444Type)
            return r.UNSIGNED_SHORT_4_4_4_4;
          if (a === THREE.UnsignedShort5551Type)
            return r.UNSIGNED_SHORT_5_5_5_1;
          if (a === THREE.UnsignedShort565Type) return r.UNSIGNED_SHORT_5_6_5;
          if (a === THREE.ByteType) return r.BYTE;
          if (a === THREE.ShortType) return r.SHORT;
          if (a === THREE.UnsignedShortType) return r.UNSIGNED_SHORT;
          if (a === THREE.IntType) return r.INT;
          if (a === THREE.UnsignedIntType) return r.UNSIGNED_INT;
          if (a === THREE.FloatType) return r.FLOAT;
          b = U.get("OES_texture_half_float");
          if (null !== b && a === THREE.HalfFloatType) return b.HALF_FLOAT_OES;
          if (a === THREE.AlphaFormat) return r.ALPHA;
          if (a === THREE.RGBFormat) return r.RGB;
          if (a === THREE.RGBAFormat) return r.RGBA;
          if (a === THREE.LuminanceFormat) return r.LUMINANCE;
          if (a === THREE.LuminanceAlphaFormat) return r.LUMINANCE_ALPHA;
          if (a === THREE.AddEquation) return r.FUNC_ADD;
          if (a === THREE.SubtractEquation) return r.FUNC_SUBTRACT;
          if (a === THREE.ReverseSubtractEquation)
            return r.FUNC_REVERSE_SUBTRACT;
          if (a === THREE.ZeroFactor) return r.ZERO;
          if (a === THREE.OneFactor) return r.ONE;
          if (a === THREE.SrcColorFactor) return r.SRC_COLOR;
          if (a === THREE.OneMinusSrcColorFactor) return r.ONE_MINUS_SRC_COLOR;
          if (a === THREE.SrcAlphaFactor) return r.SRC_ALPHA;
          if (a === THREE.OneMinusSrcAlphaFactor) return r.ONE_MINUS_SRC_ALPHA;
          if (a === THREE.DstAlphaFactor) return r.DST_ALPHA;
          if (a === THREE.OneMinusDstAlphaFactor) return r.ONE_MINUS_DST_ALPHA;
          if (a === THREE.DstColorFactor) return r.DST_COLOR;
          if (a === THREE.OneMinusDstColorFactor) return r.ONE_MINUS_DST_COLOR;
          if (a === THREE.SrcAlphaSaturateFactor) return r.SRC_ALPHA_SATURATE;
          b = U.get("WEBGL_compressed_texture_s3tc");
          if (null !== b) {
            if (a === THREE.RGB_S3TC_DXT1_Format)
              return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT1_Format)
              return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT3_Format)
              return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (a === THREE.RGBA_S3TC_DXT5_Format)
              return b.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          b = U.get("WEBGL_compressed_texture_pvrtc");
          if (null !== b) {
            if (a === THREE.RGB_PVRTC_4BPPV1_Format)
              return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGB_PVRTC_2BPPV1_Format)
              return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_4BPPV1_Format)
              return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_2BPPV1_Format)
              return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          b = U.get("WEBGL_compressed_texture_etc1");
          if (null !== b && a === THREE.RGB_ETC1_Format)
            return b.COMPRESSED_RGB_ETC1_WEBGL;
          b = U.get("EXT_blend_minmax");
          if (null !== b) {
            if (a === THREE.MinEquation) return b.MIN_EXT;
            if (a === THREE.MaxEquation) return b.MAX_EXT;
          }
          return 0;
        }
        console.log("THREE.WebGLRenderer", THREE.REVISION);
        a = a || {};
        var K =
            void 0 !== a.canvas ? a.canvas : document.createElement("canvas"),
          P = void 0 !== a.context ? a.context : null,
          N = void 0 !== a.alpha ? a.alpha : !1,
          L = void 0 !== a.depth ? a.depth : !0,
          B = void 0 !== a.stencil ? a.stencil : !0,
          M = void 0 !== a.antialias ? a.antialias : !1,
          Q = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
          O = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
          S = [],
          J = [],
          F = -1,
          Y = [],
          V = -1,
          aa = new Float32Array(8),
          ca = [],
          ha = [];
        this.domElement = K;
        this.context = null;
        this.sortObjects =
          this.autoClearStencil =
          this.autoClearDepth =
          this.autoClearColor =
          this.autoClear =
            !0;
        this.gammaFactor = 2;
        this.gammaOutput = this.gammaInput = !1;
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
        this.autoScaleCubemaps = !0;
        var X = this,
          ma = null,
          ia = null,
          ba = null,
          ra = -1,
          na = "",
          la = null,
          qa = new THREE.Vector4(),
          za = null,
          ja = new THREE.Vector4(),
          ta = 0,
          $ = new THREE.Color(0),
          fa = 0,
          ua = K.width,
          va = K.height,
          Z = 1,
          xa = new THREE.Vector4(0, 0, ua, va),
          Aa = !1,
          ka = new THREE.Vector4(0, 0, ua, va),
          ya = new THREE.Frustum(),
          sa = new THREE.Matrix4(),
          W = new THREE.Vector3(),
          R = {
            hash: "",
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            shadows: [],
            shadowsPointLight: 0,
          },
          ga = { geometries: 0, textures: 0 },
          ea = { calls: 0, vertices: 0, faces: 0, points: 0 };
        this.info = { render: ea, memory: ga, programs: null };
        var r;
        try {
          N = {
            alpha: N,
            depth: L,
            stencil: B,
            antialias: M,
            premultipliedAlpha: Q,
            preserveDrawingBuffer: O,
          };
          r =
            P ||
            K.getContext("webgl", N) ||
            K.getContext("experimental-webgl", N);
          if (null === r) {
            if (null !== K.getContext("webgl"))
              throw "Error creating WebGL context with your selected attributes.";
            throw "Error creating WebGL context.";
          }
          K.addEventListener("webglcontextlost", e, !1);
        } catch (Ca) {
          console.error("THREE.WebGLRenderer: " + Ca);
        }
        var U = new THREE.WebGLExtensions(r);
        U.get("OES_texture_float");
        U.get("OES_texture_float_linear");
        U.get("OES_texture_half_float");
        U.get("OES_texture_half_float_linear");
        U.get("OES_standard_derivatives");
        U.get("ANGLE_instanced_arrays");
        U.get("OES_element_index_uint") &&
          (THREE.BufferGeometry.MaxIndex = 4294967296);
        var da = new THREE.WebGLCapabilities(r, U, a),
          I = new THREE.WebGLState(r, U, E),
          T = new THREE.WebGLProperties(),
          pa = new THREE.WebGLObjects(r, T, this.info),
          oa = new THREE.WebGLPrograms(this, da),
          wa = new THREE.WebGLLights();
        this.info.programs = oa.programs;
        var Da = new THREE.WebGLBufferRenderer(r, U, ea),
          Ea = new THREE.WebGLIndexedBufferRenderer(r, U, ea);
        c();
        this.context = r;
        this.capabilities = da;
        this.extensions = U;
        this.properties = T;
        this.state = I;
        var Ba = new THREE.WebGLShadowMap(this, R, pa);
        this.shadowMap = Ba;
        var Fa = new THREE.SpritePlugin(this, ca),
          Ga = new THREE.LensFlarePlugin(this, ha);
        this.getContext = function () {
          return r;
        };
        this.getContextAttributes = function () {
          return r.getContextAttributes();
        };
        this.forceContextLoss = function () {
          U.get("WEBGL_lose_context").loseContext();
        };
        this.getMaxAnisotropy = (function () {
          var a;
          return function () {
            if (void 0 !== a) return a;
            var b = U.get("EXT_texture_filter_anisotropic");
            return (a =
              null !== b
                ? r.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                : 0);
          };
        })();
        this.getPrecision = function () {
          return da.precision;
        };
        this.getPixelRatio = function () {
          return Z;
        };
        this.setPixelRatio = function (a) {
          void 0 !== a && ((Z = a), this.setSize(ka.z, ka.w, !1));
        };
        this.getSize = function () {
          return { width: ua, height: va };
        };
        this.setSize = function (a, b, c) {
          ua = a;
          va = b;
          K.width = a * Z;
          K.height = b * Z;
          !1 !== c && ((K.style.width = a + "px"), (K.style.height = b + "px"));
          this.setViewport(0, 0, a, b);
        };
        this.setViewport = function (a, b, c, d) {
          I.viewport(ka.set(a, b, c, d));
        };
        this.setScissor = function (a, b, c, d) {
          I.scissor(xa.set(a, b, c, d));
        };
        this.setScissorTest = function (a) {
          I.setScissorTest((Aa = a));
        };
        this.getClearColor = function () {
          return $;
        };
        this.setClearColor = function (a, c) {
          $.set(a);
          fa = void 0 !== c ? c : 1;
          b($.r, $.g, $.b, fa);
        };
        this.getClearAlpha = function () {
          return fa;
        };
        this.setClearAlpha = function (a) {
          fa = a;
          b($.r, $.g, $.b, fa);
        };
        this.clear = function (a, b, c) {
          var d = 0;
          if (void 0 === a || a) d |= r.COLOR_BUFFER_BIT;
          if (void 0 === b || b) d |= r.DEPTH_BUFFER_BIT;
          if (void 0 === c || c) d |= r.STENCIL_BUFFER_BIT;
          r.clear(d);
        };
        this.clearColor = function () {
          this.clear(!0, !1, !1);
        };
        this.clearDepth = function () {
          this.clear(!1, !0, !1);
        };
        this.clearStencil = function () {
          this.clear(!1, !1, !0);
        };
        this.clearTarget = function (a, b, c, d) {
          this.setRenderTarget(a);
          this.clear(b, c, d);
        };
        this.resetGLState = d;
        this.dispose = function () {
          K.removeEventListener("webglcontextlost", e, !1);
        };
        this.renderBufferImmediate = function (a, b, c) {
          I.initAttributes();
          var d = T.get(a);
          a.hasPositions && !d.position && (d.position = r.createBuffer());
          a.hasNormals && !d.normal && (d.normal = r.createBuffer());
          a.hasUvs && !d.uv && (d.uv = r.createBuffer());
          a.hasColors && !d.color && (d.color = r.createBuffer());
          b = b.getAttributes();
          a.hasPositions &&
            (r.bindBuffer(r.ARRAY_BUFFER, d.position),
            r.bufferData(r.ARRAY_BUFFER, a.positionArray, r.DYNAMIC_DRAW),
            I.enableAttribute(b.position),
            r.vertexAttribPointer(b.position, 3, r.FLOAT, !1, 0, 0));
          if (a.hasNormals) {
            r.bindBuffer(r.ARRAY_BUFFER, d.normal);
            if (
              "MeshPhongMaterial" !== c.type &&
              "MeshStandardMaterial" !== c.type &&
              c.shading === THREE.FlatShading
            )
              for (var e = 0, g = 3 * a.count; e < g; e += 9) {
                var f = a.normalArray,
                  h = (f[e + 0] + f[e + 3] + f[e + 6]) / 3,
                  k = (f[e + 1] + f[e + 4] + f[e + 7]) / 3,
                  l = (f[e + 2] + f[e + 5] + f[e + 8]) / 3;
                f[e + 0] = h;
                f[e + 1] = k;
                f[e + 2] = l;
                f[e + 3] = h;
                f[e + 4] = k;
                f[e + 5] = l;
                f[e + 6] = h;
                f[e + 7] = k;
                f[e + 8] = l;
              }
            r.bufferData(r.ARRAY_BUFFER, a.normalArray, r.DYNAMIC_DRAW);
            I.enableAttribute(b.normal);
            r.vertexAttribPointer(b.normal, 3, r.FLOAT, !1, 0, 0);
          }
          a.hasUvs &&
            c.map &&
            (r.bindBuffer(r.ARRAY_BUFFER, d.uv),
            r.bufferData(r.ARRAY_BUFFER, a.uvArray, r.DYNAMIC_DRAW),
            I.enableAttribute(b.uv),
            r.vertexAttribPointer(b.uv, 2, r.FLOAT, !1, 0, 0));
          a.hasColors &&
            c.vertexColors !== THREE.NoColors &&
            (r.bindBuffer(r.ARRAY_BUFFER, d.color),
            r.bufferData(r.ARRAY_BUFFER, a.colorArray, r.DYNAMIC_DRAW),
            I.enableAttribute(b.color),
            r.vertexAttribPointer(b.color, 3, r.FLOAT, !1, 0, 0));
          I.disableUnusedAttributes();
          r.drawArrays(r.TRIANGLES, 0, a.count);
          a.count = 0;
        };
        this.renderBufferDirect = function (a, b, c, d, e, f) {
          u(d);
          var g = t(a, b, d, e),
            h = !1;
          a = c.id + "_" + g.id + "_" + d.wireframe;
          a !== na && ((na = a), (h = !0));
          b = e.morphTargetInfluences;
          if (void 0 !== b) {
            a = [];
            for (var k = 0, h = b.length; k < h; k++) {
              var m = b[k];
              a.push([m, k]);
            }
            a.sort(l);
            8 < a.length && (a.length = 8);
            for (var n = c.morphAttributes, k = 0, h = a.length; k < h; k++)
              (m = a[k]),
                (aa[k] = m[0]),
                0 !== m[0]
                  ? ((b = m[1]),
                    !0 === d.morphTargets &&
                      n.position &&
                      c.addAttribute("morphTarget" + k, n.position[b]),
                    !0 === d.morphNormals &&
                      n.normal &&
                      c.addAttribute("morphNormal" + k, n.normal[b]))
                  : (!0 === d.morphTargets &&
                      c.removeAttribute("morphTarget" + k),
                    !0 === d.morphNormals &&
                      c.removeAttribute("morphNormal" + k));
            a = g.getUniforms();
            null !== a.morphTargetInfluences &&
              r.uniform1fv(a.morphTargetInfluences, aa);
            h = !0;
          }
          b = c.index;
          k = c.attributes.position;
          !0 === d.wireframe && (b = pa.getWireframeAttribute(c));
          null !== b ? ((a = Ea), a.setIndex(b)) : (a = Da);
          if (h) {
            a: {
              var h = void 0,
                q;
              if (
                c instanceof THREE.InstancedBufferGeometry &&
                ((q = U.get("ANGLE_instanced_arrays")), null === q)
              ) {
                console.error(
                  "THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
                break a;
              }
              void 0 === h && (h = 0);
              I.initAttributes();
              var m = c.attributes,
                g = g.getAttributes(),
                n = d.defaultAttributeValues,
                p;
              for (p in g) {
                var s = g[p];
                if (0 <= s) {
                  var x = m[p];
                  if (void 0 !== x) {
                    var v = x.itemSize,
                      w = pa.getAttributeBuffer(x);
                    if (x instanceof THREE.InterleavedBufferAttribute) {
                      var C = x.data,
                        V = C.stride,
                        x = x.offset;
                      C instanceof THREE.InstancedInterleavedBuffer
                        ? (I.enableAttributeAndDivisor(
                            s,
                            C.meshPerAttribute,
                            q
                          ),
                          void 0 === c.maxInstancedCount &&
                            (c.maxInstancedCount =
                              C.meshPerAttribute * C.count))
                        : I.enableAttribute(s);
                      r.bindBuffer(r.ARRAY_BUFFER, w);
                      r.vertexAttribPointer(
                        s,
                        v,
                        r.FLOAT,
                        !1,
                        V * C.array.BYTES_PER_ELEMENT,
                        (h * V + x) * C.array.BYTES_PER_ELEMENT
                      );
                    } else
                      x instanceof THREE.InstancedBufferAttribute
                        ? (I.enableAttributeAndDivisor(
                            s,
                            x.meshPerAttribute,
                            q
                          ),
                          void 0 === c.maxInstancedCount &&
                            (c.maxInstancedCount =
                              x.meshPerAttribute * x.count))
                        : I.enableAttribute(s),
                        r.bindBuffer(r.ARRAY_BUFFER, w),
                        r.vertexAttribPointer(s, v, r.FLOAT, !1, 0, h * v * 4);
                  } else if (void 0 !== n && ((v = n[p]), void 0 !== v))
                    switch (v.length) {
                      case 2:
                        r.vertexAttrib2fv(s, v);
                        break;
                      case 3:
                        r.vertexAttrib3fv(s, v);
                        break;
                      case 4:
                        r.vertexAttrib4fv(s, v);
                        break;
                      default:
                        r.vertexAttrib1fv(s, v);
                    }
                }
              }
              I.disableUnusedAttributes();
            }
            null !== b &&
              r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, pa.getAttributeBuffer(b));
          }
          q = Infinity;
          null !== b ? (q = b.count) : void 0 !== k && (q = k.count);
          p = c.drawRange.start;
          b = c.drawRange.count;
          k = null !== f ? f.start : 0;
          h = null !== f ? f.count : Infinity;
          f = Math.max(0, p, k);
          q = Math.min(0 + q, p + b, k + h) - 1;
          q = Math.max(0, q - f + 1);
          if (e instanceof THREE.Mesh)
            if (!0 === d.wireframe)
              I.setLineWidth(d.wireframeLinewidth * (null === ia ? Z : 1)),
                a.setMode(r.LINES);
            else
              switch (e.drawMode) {
                case THREE.TrianglesDrawMode:
                  a.setMode(r.TRIANGLES);
                  break;
                case THREE.TriangleStripDrawMode:
                  a.setMode(r.TRIANGLE_STRIP);
                  break;
                case THREE.TriangleFanDrawMode:
                  a.setMode(r.TRIANGLE_FAN);
              }
          else
            e instanceof THREE.Line
              ? ((d = d.linewidth),
                void 0 === d && (d = 1),
                I.setLineWidth(d * (null === ia ? Z : 1)),
                e instanceof THREE.LineSegments
                  ? a.setMode(r.LINES)
                  : a.setMode(r.LINE_STRIP))
              : e instanceof THREE.Points && a.setMode(r.POINTS);
          c instanceof THREE.InstancedBufferGeometry && 0 < c.maxInstancedCount
            ? a.renderInstances(c, f, q)
            : a.render(f, q);
        };
        this.render = function (a, b, c, d) {
          if (!1 === b instanceof THREE.Camera)
            console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
          else {
            var e = a.fog;
            na = "";
            ra = -1;
            la = null;
            !0 === a.autoUpdate && a.updateMatrixWorld();
            null === b.parent && b.updateMatrixWorld();
            b.matrixWorldInverse.getInverse(b.matrixWorld);
            sa.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
            ya.setFromMatrix(sa);
            S.length = 0;
            V = F = -1;
            ca.length = 0;
            ha.length = 0;
            q(a, b);
            J.length = F + 1;
            Y.length = V + 1;
            !0 === X.sortObjects && (J.sort(n), Y.sort(p));
            var f = S,
              g,
              h,
              k,
              l = 0,
              m = 0,
              x = 0,
              t,
              v,
              u,
              w = b.matrixWorldInverse,
              C = 0,
              y = 0,
              z = 0,
              A = 0,
              E = 0;
            g = R.shadowsPointLight = 0;
            for (h = f.length; g < h; g++)
              if (
                ((k = f[g]),
                (t = k.color),
                (v = k.intensity),
                (u = k.distance),
                k instanceof THREE.AmbientLight)
              )
                (l += t.r * v), (m += t.g * v), (x += t.b * v);
              else if (k instanceof THREE.DirectionalLight) {
                var B = wa.get(k);
                B.color.copy(k.color).multiplyScalar(k.intensity);
                B.direction.setFromMatrixPosition(k.matrixWorld);
                W.setFromMatrixPosition(k.target.matrixWorld);
                B.direction.sub(W);
                B.direction.transformDirection(w);
                if ((B.shadow = k.castShadow))
                  (B.shadowBias = k.shadow.bias),
                    (B.shadowRadius = k.shadow.radius),
                    (B.shadowMapSize = k.shadow.mapSize),
                    (R.shadows[E++] = k);
                R.directionalShadowMap[C] = k.shadow.map;
                R.directionalShadowMatrix[C] = k.shadow.matrix;
                R.directional[C++] = B;
              } else if (k instanceof THREE.SpotLight) {
                B = wa.get(k);
                B.position.setFromMatrixPosition(k.matrixWorld);
                B.position.applyMatrix4(w);
                B.color.copy(t).multiplyScalar(v);
                B.distance = u;
                B.direction.setFromMatrixPosition(k.matrixWorld);
                W.setFromMatrixPosition(k.target.matrixWorld);
                B.direction.sub(W);
                B.direction.transformDirection(w);
                B.angleCos = Math.cos(k.angle);
                B.penumbra = Math.cos(k.angle) * k.penumbra;
                B.decay = 0 === k.distance ? 0 : k.decay;
                if ((B.shadow = k.castShadow))
                  (B.shadowBias = k.shadow.bias),
                    (B.shadowRadius = k.shadow.radius),
                    (B.shadowMapSize = k.shadow.mapSize),
                    (R.shadows[E++] = k);
                R.spotShadowMap[z] = k.shadow.map;
                R.spotShadowMatrix[z] = k.shadow.matrix;
                R.spot[z++] = B;
              } else if (k instanceof THREE.PointLight) {
                B = wa.get(k);
                B.position.setFromMatrixPosition(k.matrixWorld);
                B.position.applyMatrix4(w);
                B.color.copy(k.color).multiplyScalar(k.intensity);
                B.distance = k.distance;
                B.decay = 0 === k.distance ? 0 : k.decay;
                if ((B.shadow = k.castShadow))
                  (B.shadowBias = k.shadow.bias),
                    (B.shadowRadius = k.shadow.radius),
                    (B.shadowMapSize = k.shadow.mapSize),
                    (R.shadows[E++] = k);
                R.pointShadowMap[y] = k.shadow.map;
                void 0 === R.pointShadowMatrix[y] &&
                  (R.pointShadowMatrix[y] = new THREE.Matrix4());
                W.setFromMatrixPosition(k.matrixWorld).negate();
                R.pointShadowMatrix[y].identity().setPosition(W);
                R.point[y++] = B;
              } else
                k instanceof THREE.HemisphereLight &&
                  ((B = wa.get(k)),
                  B.direction.setFromMatrixPosition(k.matrixWorld),
                  B.direction.transformDirection(w),
                  B.direction.normalize(),
                  B.skyColor.copy(k.color).multiplyScalar(v),
                  B.groundColor.copy(k.groundColor).multiplyScalar(v),
                  (R.hemi[A++] = B));
            R.ambient[0] = l;
            R.ambient[1] = m;
            R.ambient[2] = x;
            R.directional.length = C;
            R.spot.length = z;
            R.point.length = y;
            R.hemi.length = A;
            R.shadows.length = E;
            R.hash = C + "," + y + "," + z + "," + A + "," + E;
            Ba.render(a, b);
            ea.calls = 0;
            ea.vertices = 0;
            ea.faces = 0;
            ea.points = 0;
            void 0 === c && (c = null);
            this.setRenderTarget(c);
            (this.autoClear || d) &&
              this.clear(
                this.autoClearColor,
                this.autoClearDepth,
                this.autoClearStencil
              );
            a.overrideMaterial
              ? ((d = a.overrideMaterial), s(J, b, e, d), s(Y, b, e, d))
              : (I.setBlending(THREE.NoBlending), s(J, b, e), s(Y, b, e));
            Fa.render(a, b);
            Ga.render(a, b, ja);
            c &&
              ((a = c.texture),
              a.generateMipmaps &&
                D(c) &&
                a.minFilter !== THREE.NearestFilter &&
                a.minFilter !== THREE.LinearFilter &&
                ((a =
                  c instanceof THREE.WebGLRenderTargetCube
                    ? r.TEXTURE_CUBE_MAP
                    : r.TEXTURE_2D),
                (c = T.get(c.texture).__webglTexture),
                I.bindTexture(a, c),
                r.generateMipmap(a),
                I.bindTexture(a, null)));
            I.setDepthTest(!0);
            I.setDepthWrite(!0);
            I.setColorWrite(!0);
          }
        };
        this.setFaceCulling = function (a, b) {
          a === THREE.CullFaceNone
            ? I.disable(r.CULL_FACE)
            : (b === THREE.FrontFaceDirectionCW
                ? r.frontFace(r.CW)
                : r.frontFace(r.CCW),
              a === THREE.CullFaceBack
                ? r.cullFace(r.BACK)
                : a === THREE.CullFaceFront
                ? r.cullFace(r.FRONT)
                : r.cullFace(r.FRONT_AND_BACK),
              I.enable(r.CULL_FACE));
        };
        this.setTexture = function (a, b) {
          var c = T.get(a);
          if (0 < a.version && c.__version !== a.version) {
            var d = a.image;
            if (void 0 === d)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is undefined",
                a
              );
            else if (!1 === d.complete)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
                a
              );
            else {
              void 0 === c.__webglInit &&
                ((c.__webglInit = !0),
                a.addEventListener("dispose", f),
                (c.__webglTexture = r.createTexture()),
                ga.textures++);
              I.activeTexture(r.TEXTURE0 + b);
              I.bindTexture(r.TEXTURE_2D, c.__webglTexture);
              r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, a.flipY);
              r.pixelStorei(
                r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                a.premultiplyAlpha
              );
              r.pixelStorei(r.UNPACK_ALIGNMENT, a.unpackAlignment);
              var e = w(a.image, da.maxTextureSize);
              if (
                (a.wrapS !== THREE.ClampToEdgeWrapping ||
                  a.wrapT !== THREE.ClampToEdgeWrapping ||
                  (a.minFilter !== THREE.NearestFilter &&
                    a.minFilter !== THREE.LinearFilter)) &&
                !1 === D(e)
              )
                if (
                  ((d = e),
                  d instanceof HTMLImageElement ||
                    d instanceof HTMLCanvasElement)
                ) {
                  var g = document.createElement("canvas");
                  g.width = THREE.Math.nearestPowerOfTwo(d.width);
                  g.height = THREE.Math.nearestPowerOfTwo(d.height);
                  g.getContext("2d").drawImage(d, 0, 0, g.width, g.height);
                  console.warn(
                    "THREE.WebGLRenderer: image is not power of two (" +
                      d.width +
                      "x" +
                      d.height +
                      "). Resized to " +
                      g.width +
                      "x" +
                      g.height,
                    d
                  );
                  e = g;
                } else e = d;
              var d = D(e),
                g = E(a.format),
                h = E(a.type);
              C(r.TEXTURE_2D, a, d);
              var k = a.mipmaps;
              if (a instanceof THREE.DataTexture)
                if (0 < k.length && d) {
                  for (var l = 0, m = k.length; l < m; l++)
                    (e = k[l]),
                      I.texImage2D(
                        r.TEXTURE_2D,
                        l,
                        g,
                        e.width,
                        e.height,
                        0,
                        g,
                        h,
                        e.data
                      );
                  a.generateMipmaps = !1;
                } else
                  I.texImage2D(
                    r.TEXTURE_2D,
                    0,
                    g,
                    e.width,
                    e.height,
                    0,
                    g,
                    h,
                    e.data
                  );
              else if (a instanceof THREE.CompressedTexture)
                for (l = 0, m = k.length; l < m; l++)
                  (e = k[l]),
                    a.format !== THREE.RGBAFormat &&
                    a.format !== THREE.RGBFormat
                      ? -1 < I.getCompressedTextureFormats().indexOf(g)
                        ? I.compressedTexImage2D(
                            r.TEXTURE_2D,
                            l,
                            g,
                            e.width,
                            e.height,
                            0,
                            e.data
                          )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : I.texImage2D(
                          r.TEXTURE_2D,
                          l,
                          g,
                          e.width,
                          e.height,
                          0,
                          g,
                          h,
                          e.data
                        );
              else if (0 < k.length && d) {
                l = 0;
                for (m = k.length; l < m; l++)
                  (e = k[l]), I.texImage2D(r.TEXTURE_2D, l, g, g, h, e);
                a.generateMipmaps = !1;
              } else I.texImage2D(r.TEXTURE_2D, 0, g, g, h, e);
              a.generateMipmaps && d && r.generateMipmap(r.TEXTURE_2D);
              c.__version = a.version;
              if (a.onUpdate) a.onUpdate(a);
            }
          } else
            I.activeTexture(r.TEXTURE0 + b),
              I.bindTexture(r.TEXTURE_2D, c.__webglTexture);
        };
        this.setRenderTarget = function (a) {
          if ((ia = a) && void 0 === T.get(a).__webglFramebuffer) {
            var b = T.get(a),
              c = T.get(a.texture);
            a.addEventListener("dispose", g);
            c.__webglTexture = r.createTexture();
            ga.textures++;
            var d = a instanceof THREE.WebGLRenderTargetCube,
              e =
                THREE.Math.isPowerOfTwo(a.width) &&
                THREE.Math.isPowerOfTwo(a.height);
            if (d) {
              b.__webglFramebuffer = [];
              for (var f = 0; 6 > f; f++)
                b.__webglFramebuffer[f] = r.createFramebuffer();
            } else b.__webglFramebuffer = r.createFramebuffer();
            if (d) {
              I.bindTexture(r.TEXTURE_CUBE_MAP, c.__webglTexture);
              C(r.TEXTURE_CUBE_MAP, a.texture, e);
              for (f = 0; 6 > f; f++)
                A(
                  b.__webglFramebuffer[f],
                  a,
                  r.COLOR_ATTACHMENT0,
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + f
                );
              a.texture.generateMipmaps &&
                e &&
                r.generateMipmap(r.TEXTURE_CUBE_MAP);
              I.bindTexture(r.TEXTURE_CUBE_MAP, null);
            } else
              I.bindTexture(r.TEXTURE_2D, c.__webglTexture),
                C(r.TEXTURE_2D, a.texture, e),
                A(b.__webglFramebuffer, a, r.COLOR_ATTACHMENT0, r.TEXTURE_2D),
                a.texture.generateMipmaps &&
                  e &&
                  r.generateMipmap(r.TEXTURE_2D),
                I.bindTexture(r.TEXTURE_2D, null);
            if (a.depthBuffer) {
              b = T.get(a);
              if (a instanceof THREE.WebGLRenderTargetCube)
                for (b.__webglDepthbuffer = [], c = 0; 6 > c; c++)
                  r.bindFramebuffer(r.FRAMEBUFFER, b.__webglFramebuffer[c]),
                    (b.__webglDepthbuffer[c] = r.createRenderbuffer()),
                    H(b.__webglDepthbuffer[c], a);
              else
                r.bindFramebuffer(r.FRAMEBUFFER, b.__webglFramebuffer),
                  (b.__webglDepthbuffer = r.createRenderbuffer()),
                  H(b.__webglDepthbuffer, a);
              r.bindFramebuffer(r.FRAMEBUFFER, null);
            }
          }
          b = a instanceof THREE.WebGLRenderTargetCube;
          a
            ? ((c = T.get(a)),
              (c = b
                ? c.__webglFramebuffer[a.activeCubeFace]
                : c.__webglFramebuffer),
              qa.copy(a.scissor),
              (za = a.scissorTest),
              ja.copy(a.viewport))
            : ((c = null),
              qa.copy(xa).multiplyScalar(Z),
              (za = Aa),
              ja.copy(ka).multiplyScalar(Z));
          ba !== c && (r.bindFramebuffer(r.FRAMEBUFFER, c), (ba = c));
          I.scissor(qa);
          I.setScissorTest(za);
          I.viewport(ja);
          b &&
            ((b = T.get(a.texture)),
            r.framebufferTexture2D(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace,
              b.__webglTexture,
              0
            ));
        };
        this.readRenderTargetPixels = function (a, b, c, d, e, g) {
          if (!1 === a instanceof THREE.WebGLRenderTarget)
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          else {
            var f = T.get(a).__webglFramebuffer;
            if (f) {
              var h = !1;
              f !== ba && (r.bindFramebuffer(r.FRAMEBUFFER, f), (h = !0));
              try {
                var k = a.texture;
                k.format !== THREE.RGBAFormat &&
                E(k.format) !==
                  r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT)
                  ? console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    )
                  : k.type === THREE.UnsignedByteType ||
                    E(k.type) ===
                      r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) ||
                    (k.type === THREE.FloatType &&
                      U.get("WEBGL_color_buffer_float")) ||
                    (k.type === THREE.HalfFloatType &&
                      U.get("EXT_color_buffer_half_float"))
                  ? r.checkFramebufferStatus(r.FRAMEBUFFER) ===
                    r.FRAMEBUFFER_COMPLETE
                    ? r.readPixels(b, c, d, e, E(k.format), E(k.type), g)
                    : console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                      )
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
              } finally {
                h && r.bindFramebuffer(r.FRAMEBUFFER, ba);
              }
            }
          }
        };
      };
      THREE.WebGLRenderTarget = function (a, b, c) {
        this.uuid = THREE.Math.generateUUID();
        this.width = a;
        this.height = b;
        this.scissor = new THREE.Vector4(0, 0, a, b);
        this.scissorTest = !1;
        this.viewport = new THREE.Vector4(0, 0, a, b);
        c = c || {};
        void 0 === c.minFilter && (c.minFilter = THREE.LinearFilter);
        this.texture = new THREE.Texture(
          void 0,
          void 0,
          c.wrapS,
          c.wrapT,
          c.magFilter,
          c.minFilter,
          c.format,
          c.type,
          c.anisotropy
        );
        this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
        this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
      };
      THREE.WebGLRenderTarget.prototype = {
        constructor: THREE.WebGLRenderTarget,
        setSize: function (a, b) {
          if (this.width !== a || this.height !== b)
            (this.width = a), (this.height = b), this.dispose();
          this.viewport.set(0, 0, a, b);
          this.scissor.set(0, 0, a, b);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (a) {
          this.width = a.width;
          this.height = a.height;
          this.viewport.copy(a.viewport);
          this.texture = a.texture.clone();
          this.depthBuffer = a.depthBuffer;
          this.stencilBuffer = a.stencilBuffer;
          this.shareDepthFrom = a.shareDepthFrom;
          return this;
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      };
      THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
      THREE.WebGLRenderTargetCube = function (a, b, c) {
        THREE.WebGLRenderTarget.call(this, a, b, c);
        this.activeCubeFace = 0;
      };
      THREE.WebGLRenderTargetCube.prototype = Object.create(
        THREE.WebGLRenderTarget.prototype
      );
      THREE.WebGLRenderTargetCube.prototype.constructor =
        THREE.WebGLRenderTargetCube;
      THREE.WebGLBufferRenderer = function (a, b, c) {
        var d;
        this.setMode = function (a) {
          d = a;
        };
        this.render = function (b, f) {
          a.drawArrays(d, b, f);
          c.calls++;
          c.vertices += f;
          d === a.TRIANGLES && (c.faces += f / 3);
        };
        this.renderInstances = function (e) {
          var f = b.get("ANGLE_instanced_arrays");
          if (null === f)
            console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          else {
            var g = e.attributes.position,
              h = 0,
              h =
                g instanceof THREE.InterleavedBufferAttribute
                  ? g.data.count
                  : g.count;
            f.drawArraysInstancedANGLE(d, 0, h, e.maxInstancedCount);
            c.calls++;
            c.vertices += h * e.maxInstancedCount;
            d === a.TRIANGLES && (c.faces += (e.maxInstancedCount * h) / 3);
          }
        };
      };
      THREE.WebGLIndexedBufferRenderer = function (a, b, c) {
        var d, e, f;
        this.setMode = function (a) {
          d = a;
        };
        this.setIndex = function (c) {
          c.array instanceof Uint32Array && b.get("OES_element_index_uint")
            ? ((e = a.UNSIGNED_INT), (f = 4))
            : ((e = a.UNSIGNED_SHORT), (f = 2));
        };
        this.render = function (b, h) {
          a.drawElements(d, h, e, b * f);
          c.calls++;
          c.vertices += h;
          d === a.TRIANGLES && (c.faces += h / 3);
        };
        this.renderInstances = function (g, h, k) {
          var l = b.get("ANGLE_instanced_arrays");
          null === l
            ? console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              )
            : (l.drawElementsInstancedANGLE(
                d,
                k,
                e,
                h * f,
                g.maxInstancedCount
              ),
              c.calls++,
              (c.vertices += k * g.maxInstancedCount),
              d === a.TRIANGLES && (c.faces += (g.maxInstancedCount * k) / 3));
        };
      };
      THREE.WebGLExtensions = function (a) {
        var b = {};
        this.get = function (c) {
          if (void 0 !== b[c]) return b[c];
          var d;
          switch (c) {
            case "EXT_texture_filter_anisotropic":
              d =
                a.getExtension("EXT_texture_filter_anisotropic") ||
                a.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              d =
                a.getExtension("WEBGL_compressed_texture_s3tc") ||
                a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              d =
                a.getExtension("WEBGL_compressed_texture_pvrtc") ||
                a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            case "WEBGL_compressed_texture_etc1":
              d = a.getExtension("WEBGL_compressed_texture_etc1");
              break;
            default:
              d = a.getExtension(c);
          }
          null === d &&
            console.warn(
              "THREE.WebGLRenderer: " + c + " extension not supported."
            );
          return (b[c] = d);
        };
      };
      THREE.WebGLCapabilities = function (a, b, c) {
        function d(b) {
          if ("highp" === b) {
            if (
              0 <
                a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT)
                  .precision &&
              0 <
                a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT)
                  .precision
            )
              return "highp";
            b = "mediump";
          }
          return "mediump" === b &&
            0 <
              a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT)
                .precision &&
            0 <
              a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT)
                .precision
            ? "mediump"
            : "lowp";
        }
        this.getMaxPrecision = d;
        this.precision = void 0 !== c.precision ? c.precision : "highp";
        this.logarithmicDepthBuffer =
          void 0 !== c.logarithmicDepthBuffer ? c.logarithmicDepthBuffer : !1;
        this.maxTextures = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
        this.maxVertexTextures = a.getParameter(
          a.MAX_VERTEX_TEXTURE_IMAGE_UNITS
        );
        this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
        this.maxCubemapSize = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE);
        this.maxAttributes = a.getParameter(a.MAX_VERTEX_ATTRIBS);
        this.maxVertexUniforms = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS);
        this.maxVaryings = a.getParameter(a.MAX_VARYING_VECTORS);
        this.maxFragmentUniforms = a.getParameter(
          a.MAX_FRAGMENT_UNIFORM_VECTORS
        );
        this.vertexTextures = 0 < this.maxVertexTextures;
        this.floatFragmentTextures = !!b.get("OES_texture_float");
        this.floatVertexTextures =
          this.vertexTextures && this.floatFragmentTextures;
        c = d(this.precision);
        c !== this.precision &&
          (console.warn(
            "THREE.WebGLRenderer:",
            this.precision,
            "not supported, using",
            c,
            "instead."
          ),
          (this.precision = c));
        this.logarithmicDepthBuffer &&
          (this.logarithmicDepthBuffer = !!b.get("EXT_frag_depth"));
      };
      THREE.WebGLGeometries = function (a, b, c) {
        function d(a) {
          var h = a.target;
          a = f[h.id];
          null !== a.index && e(a.index);
          var k = a.attributes,
            l;
          for (l in k) e(k[l]);
          h.removeEventListener("dispose", d);
          delete f[h.id];
          l = b.get(h);
          l.wireframe && e(l.wireframe);
          b.delete(h);
          h = b.get(a);
          h.wireframe && e(h.wireframe);
          b.delete(a);
          c.memory.geometries--;
        }
        function e(c) {
          var d;
          d =
            c instanceof THREE.InterleavedBufferAttribute
              ? b.get(c.data).__webglBuffer
              : b.get(c).__webglBuffer;
          void 0 !== d &&
            (a.deleteBuffer(d),
            c instanceof THREE.InterleavedBufferAttribute
              ? b.delete(c.data)
              : b.delete(c));
        }
        var f = {};
        this.get = function (a) {
          var b = a.geometry;
          if (void 0 !== f[b.id]) return f[b.id];
          b.addEventListener("dispose", d);
          var e;
          b instanceof THREE.BufferGeometry
            ? (e = b)
            : b instanceof THREE.Geometry &&
              (void 0 === b._bufferGeometry &&
                (b._bufferGeometry = new THREE.BufferGeometry().setFromObject(
                  a
                )),
              (e = b._bufferGeometry));
          f[b.id] = e;
          c.memory.geometries++;
          return e;
        };
      };
      THREE.WebGLLights = function () {
        var a = {};
        this.get = function (b) {
          if (void 0 !== a[b.id]) return a[b.id];
          var c;
          switch (b.type) {
            case "DirectionalLight":
              c = {
                direction: new THREE.Vector3(),
                color: new THREE.Color(),
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new THREE.Vector2(),
              };
              break;
            case "SpotLight":
              c = {
                position: new THREE.Vector3(),
                direction: new THREE.Vector3(),
                color: new THREE.Color(),
                distance: 0,
                angleCos: 0,
                penumbra: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new THREE.Vector2(),
              };
              break;
            case "PointLight":
              c = {
                position: new THREE.Vector3(),
                color: new THREE.Color(),
                distance: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new THREE.Vector2(),
              };
              break;
            case "HemisphereLight":
              c = {
                direction: new THREE.Vector3(),
                skyColor: new THREE.Color(),
                groundColor: new THREE.Color(),
              };
          }
          return (a[b.id] = c);
        };
      };
      THREE.WebGLObjects = function (a, b, c) {
        function d(c, d) {
          var e = c instanceof THREE.InterleavedBufferAttribute ? c.data : c,
            f = b.get(e);
          void 0 === f.__webglBuffer
            ? ((f.__webglBuffer = a.createBuffer()),
              a.bindBuffer(d, f.__webglBuffer),
              a.bufferData(
                d,
                e.array,
                e.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW
              ),
              (f.version = e.version))
            : f.version !== e.version &&
              (a.bindBuffer(d, f.__webglBuffer),
              !1 === e.dynamic || -1 === e.updateRange.count
                ? a.bufferSubData(d, 0, e.array)
                : 0 === e.updateRange.count
                ? console.error(
                    "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
                  )
                : (a.bufferSubData(
                    d,
                    e.updateRange.offset * e.array.BYTES_PER_ELEMENT,
                    e.array.subarray(
                      e.updateRange.offset,
                      e.updateRange.offset + e.updateRange.count
                    )
                  ),
                  (e.updateRange.count = 0)),
              (f.version = e.version));
        }
        function e(a, b, c) {
          if (b > c) {
            var d = b;
            b = c;
            c = d;
          }
          d = a[b];
          return void 0 === d
            ? ((a[b] = [c]), !0)
            : -1 === d.indexOf(c)
            ? (d.push(c), !0)
            : !1;
        }
        var f = new THREE.WebGLGeometries(a, b, c);
        this.getAttributeBuffer = function (a) {
          return a instanceof THREE.InterleavedBufferAttribute
            ? b.get(a.data).__webglBuffer
            : b.get(a).__webglBuffer;
        };
        this.getWireframeAttribute = function (c) {
          var f = b.get(c);
          if (void 0 !== f.wireframe) return f.wireframe;
          var k = [],
            l = c.index,
            n = c.attributes;
          c = n.position;
          if (null !== l)
            for (var n = {}, l = l.array, p = 0, m = l.length; p < m; p += 3) {
              var q = l[p + 0],
                s = l[p + 1],
                u = l[p + 2];
              e(n, q, s) && k.push(q, s);
              e(n, s, u) && k.push(s, u);
              e(n, u, q) && k.push(u, q);
            }
          else
            for (
              l = n.position.array, p = 0, m = l.length / 3 - 1;
              p < m;
              p += 3
            )
              (q = p + 0), (s = p + 1), (u = p + 2), k.push(q, s, s, u, u, q);
          k = new THREE.BufferAttribute(
            new (65535 < c.count ? Uint32Array : Uint16Array)(k),
            1
          );
          d(k, a.ELEMENT_ARRAY_BUFFER);
          return (f.wireframe = k);
        };
        this.update = function (b) {
          var c = f.get(b);
          b.geometry instanceof THREE.Geometry && c.updateFromObject(b);
          b = c.index;
          var e = c.attributes;
          null !== b && d(b, a.ELEMENT_ARRAY_BUFFER);
          for (var l in e) d(e[l], a.ARRAY_BUFFER);
          b = c.morphAttributes;
          for (l in b)
            for (var e = b[l], n = 0, p = e.length; n < p; n++)
              d(e[n], a.ARRAY_BUFFER);
          return c;
        };
      };
      THREE.WebGLProgram = (function () {
        function a(a, b, d) {
          a = a || {};
          return [
            a.derivatives || b.bumpMap || b.normalMap || b.flatShading
              ? "#extension GL_OES_standard_derivatives : enable"
              : "",
            (a.fragDepth || b.logarithmicDepthBuffer) && d.get("EXT_frag_depth")
              ? "#extension GL_EXT_frag_depth : enable"
              : "",
            a.drawBuffers && d.get("WEBGL_draw_buffers")
              ? "#extension GL_EXT_draw_buffers : require"
              : "",
            (a.shaderTextureLOD || b.envMap) && d.get("EXT_shader_texture_lod")
              ? "#extension GL_EXT_shader_texture_lod : enable"
              : "",
          ]
            .filter(c)
            .join("\n");
        }
        function b(a) {
          var b = [],
            c;
          for (c in a) {
            var d = a[c];
            !1 !== d && b.push("#define " + c + " " + d);
          }
          return b.join("\n");
        }
        function c(a) {
          return "" !== a;
        }
        function d(a, b) {
          return a
            .replace(/NUM_DIR_LIGHTS/g, b.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights)
            .replace(/NUM_POINT_LIGHTS/g, b.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights);
        }
        function e(a) {
          return a.replace(
            /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            function (a, b, c, d) {
              a = "";
              for (b = parseInt(b); b < parseInt(c); b++)
                a += d.replace(/\[ i \]/g, "[ " + b + " ]");
              return a;
            }
          );
        }
        var f = 0,
          g = /^([\w\d_]+)\.([\w\d_]+)$/,
          h = /^([\w\d_]+)\[(\d+)\]\.([\w\d_]+)$/,
          k = /^([\w\d_]+)\[0\]$/;
        return function (l, n, p, m) {
          var q = l.context,
            s = p.extensions,
            u = p.defines,
            t = p.__webglShader.vertexShader,
            x = p.__webglShader.fragmentShader,
            v = "SHADOWMAP_TYPE_BASIC";
          m.shadowMapType === THREE.PCFShadowMap
            ? (v = "SHADOWMAP_TYPE_PCF")
            : m.shadowMapType === THREE.PCFSoftShadowMap &&
              (v = "SHADOWMAP_TYPE_PCF_SOFT");
          var C = "ENVMAP_TYPE_CUBE",
            w = "ENVMAP_MODE_REFLECTION",
            D = "ENVMAP_BLENDING_MULTIPLY";
          if (m.envMap) {
            switch (p.envMap.mapping) {
              case THREE.CubeReflectionMapping:
              case THREE.CubeRefractionMapping:
                C = "ENVMAP_TYPE_CUBE";
                break;
              case THREE.EquirectangularReflectionMapping:
              case THREE.EquirectangularRefractionMapping:
                C = "ENVMAP_TYPE_EQUIREC";
                break;
              case THREE.SphericalReflectionMapping:
                C = "ENVMAP_TYPE_SPHERE";
            }
            switch (p.envMap.mapping) {
              case THREE.CubeRefractionMapping:
              case THREE.EquirectangularRefractionMapping:
                w = "ENVMAP_MODE_REFRACTION";
            }
            switch (p.combine) {
              case THREE.MultiplyOperation:
                D = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case THREE.MixOperation:
                D = "ENVMAP_BLENDING_MIX";
                break;
              case THREE.AddOperation:
                D = "ENVMAP_BLENDING_ADD";
            }
          }
          var z = 0 < l.gammaFactor ? l.gammaFactor : 1,
            s = a(s, m, l.extensions),
            y = b(u),
            A = q.createProgram();
          p instanceof THREE.RawShaderMaterial
            ? (l = u = "")
            : ((u = [
                "precision " + m.precision + " float;",
                "precision " + m.precision + " int;",
                "#define SHADER_NAME " + p.__webglShader.name,
                y,
                m.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                l.gammaInput ? "#define GAMMA_INPUT" : "",
                l.gammaOutput ? "#define GAMMA_OUTPUT" : "",
                "#define GAMMA_FACTOR " + z,
                "#define MAX_BONES " + m.maxBones,
                m.map ? "#define USE_MAP" : "",
                m.envMap ? "#define USE_ENVMAP" : "",
                m.envMap ? "#define " + w : "",
                m.lightMap ? "#define USE_LIGHTMAP" : "",
                m.aoMap ? "#define USE_AOMAP" : "",
                m.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                m.bumpMap ? "#define USE_BUMPMAP" : "",
                m.normalMap ? "#define USE_NORMALMAP" : "",
                m.displacementMap && m.supportsVertexTextures
                  ? "#define USE_DISPLACEMENTMAP"
                  : "",
                m.specularMap ? "#define USE_SPECULARMAP" : "",
                m.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                m.metalnessMap ? "#define USE_METALNESSMAP" : "",
                m.alphaMap ? "#define USE_ALPHAMAP" : "",
                m.vertexColors ? "#define USE_COLOR" : "",
                m.flatShading ? "#define FLAT_SHADED" : "",
                m.skinning ? "#define USE_SKINNING" : "",
                m.useVertexTexture ? "#define BONE_TEXTURE" : "",
                m.morphTargets ? "#define USE_MORPHTARGETS" : "",
                m.morphNormals && !1 === m.flatShading
                  ? "#define USE_MORPHNORMALS"
                  : "",
                m.doubleSided ? "#define DOUBLE_SIDED" : "",
                m.flipSided ? "#define FLIP_SIDED" : "",
                m.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                m.shadowMapEnabled ? "#define " + v : "",
                0 < m.pointLightShadows ? "#define POINT_LIGHT_SHADOWS" : "",
                m.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                m.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                m.logarithmicDepthBuffer && l.extensions.get("EXT_frag_depth")
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "#ifdef USE_COLOR",
                "\tattribute vec3 color;",
                "#endif",
                "#ifdef USE_MORPHTARGETS",
                "\tattribute vec3 morphTarget0;",
                "\tattribute vec3 morphTarget1;",
                "\tattribute vec3 morphTarget2;",
                "\tattribute vec3 morphTarget3;",
                "\t#ifdef USE_MORPHNORMALS",
                "\t\tattribute vec3 morphNormal0;",
                "\t\tattribute vec3 morphNormal1;",
                "\t\tattribute vec3 morphNormal2;",
                "\t\tattribute vec3 morphNormal3;",
                "\t#else",
                "\t\tattribute vec3 morphTarget4;",
                "\t\tattribute vec3 morphTarget5;",
                "\t\tattribute vec3 morphTarget6;",
                "\t\tattribute vec3 morphTarget7;",
                "\t#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "\tattribute vec4 skinIndex;",
                "\tattribute vec4 skinWeight;",
                "#endif",
                "\n",
              ]
                .filter(c)
                .join("\n")),
              (l = [
                s,
                "precision " + m.precision + " float;",
                "precision " + m.precision + " int;",
                "#define SHADER_NAME " + p.__webglShader.name,
                y,
                m.alphaTest ? "#define ALPHATEST " + m.alphaTest : "",
                l.gammaInput ? "#define GAMMA_INPUT" : "",
                l.gammaOutput ? "#define GAMMA_OUTPUT" : "",
                "#define GAMMA_FACTOR " + z,
                m.useFog && m.fog ? "#define USE_FOG" : "",
                m.useFog && m.fogExp ? "#define FOG_EXP2" : "",
                m.map ? "#define USE_MAP" : "",
                m.envMap ? "#define USE_ENVMAP" : "",
                m.envMap ? "#define " + C : "",
                m.envMap ? "#define " + w : "",
                m.envMap ? "#define " + D : "",
                m.lightMap ? "#define USE_LIGHTMAP" : "",
                m.aoMap ? "#define USE_AOMAP" : "",
                m.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                m.bumpMap ? "#define USE_BUMPMAP" : "",
                m.normalMap ? "#define USE_NORMALMAP" : "",
                m.specularMap ? "#define USE_SPECULARMAP" : "",
                m.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                m.metalnessMap ? "#define USE_METALNESSMAP" : "",
                m.alphaMap ? "#define USE_ALPHAMAP" : "",
                m.vertexColors ? "#define USE_COLOR" : "",
                m.flatShading ? "#define FLAT_SHADED" : "",
                m.doubleSided ? "#define DOUBLE_SIDED" : "",
                m.flipSided ? "#define FLIP_SIDED" : "",
                m.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                m.shadowMapEnabled ? "#define " + v : "",
                0 < m.pointLightShadows ? "#define POINT_LIGHT_SHADOWS" : "",
                m.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                m.logarithmicDepthBuffer && l.extensions.get("EXT_frag_depth")
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                m.envMap && l.extensions.get("EXT_shader_texture_lod")
                  ? "#define TEXTURE_LOD_EXT"
                  : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                "\n",
              ]
                .filter(c)
                .join("\n")));
          t = d(t, m);
          x = d(x, m);
          !1 === p instanceof THREE.ShaderMaterial && ((t = e(t)), (x = e(x)));
          x = l + x;
          t = THREE.WebGLShader(q, q.VERTEX_SHADER, u + t);
          x = THREE.WebGLShader(q, q.FRAGMENT_SHADER, x);
          q.attachShader(A, t);
          q.attachShader(A, x);
          void 0 !== p.index0AttributeName
            ? q.bindAttribLocation(A, 0, p.index0AttributeName)
            : !0 === m.morphTargets && q.bindAttribLocation(A, 0, "position");
          q.linkProgram(A);
          m = q.getProgramInfoLog(A);
          v = q.getShaderInfoLog(t);
          C = q.getShaderInfoLog(x);
          D = w = !0;
          if (!1 === q.getProgramParameter(A, q.LINK_STATUS))
            (w = !1),
              console.error(
                "THREE.WebGLProgram: shader error: ",
                q.getError(),
                "gl.VALIDATE_STATUS",
                q.getProgramParameter(A, q.VALIDATE_STATUS),
                "gl.getProgramInfoLog",
                m,
                v,
                C
              );
          else if ("" !== m)
            console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", m);
          else if ("" === v || "" === C) D = !1;
          D &&
            (this.diagnostics = {
              runnable: w,
              material: p,
              programLog: m,
              vertexShader: { log: v, prefix: u },
              fragmentShader: { log: C, prefix: l },
            });
          q.deleteShader(t);
          q.deleteShader(x);
          var H;
          this.getUniforms = function () {
            if (void 0 === H) {
              for (
                var a = {},
                  b = q.getProgramParameter(A, q.ACTIVE_UNIFORMS),
                  c = 0;
                c < b;
                c++
              ) {
                var d = q.getActiveUniform(A, c).name,
                  e = q.getUniformLocation(A, d),
                  f = g.exec(d);
                if (f) {
                  var d = f[1],
                    f = f[2],
                    l = a[d];
                  l || (l = a[d] = {});
                  l[f] = e;
                } else if ((f = h.exec(d))) {
                  var l = f[1],
                    d = f[2],
                    f = f[3],
                    m = a[l];
                  m || (m = a[l] = []);
                  (l = m[d]) || (l = m[d] = {});
                  l[f] = e;
                } else (f = k.exec(d)) ? ((l = f[1]), (a[l] = e)) : (a[d] = e);
              }
              H = a;
            }
            return H;
          };
          var G;
          this.getAttributes = function () {
            if (void 0 === G) {
              for (
                var a = {},
                  b = q.getProgramParameter(A, q.ACTIVE_ATTRIBUTES),
                  c = 0;
                c < b;
                c++
              ) {
                var d = q.getActiveAttrib(A, c).name;
                a[d] = q.getAttribLocation(A, d);
              }
              G = a;
            }
            return G;
          };
          this.destroy = function () {
            q.deleteProgram(A);
            this.program = void 0;
          };
          Object.defineProperties(this, {
            uniforms: {
              get: function () {
                console.warn(
                  "THREE.WebGLProgram: .uniforms is now .getUniforms()."
                );
                return this.getUniforms();
              },
            },
            attributes: {
              get: function () {
                console.warn(
                  "THREE.WebGLProgram: .attributes is now .getAttributes()."
                );
                return this.getAttributes();
              },
            },
          });
          this.id = f++;
          this.code = n;
          this.usedTimes = 1;
          this.program = A;
          this.vertexShader = t;
          this.fragmentShader = x;
          return this;
        };
      })();
      THREE.WebGLPrograms = function (a, b) {
        var c = [],
          d = {
            MeshDepthMaterial: "depth",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshStandardMaterial: "standard",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
          },
          e =
            "precision supportsVertexTextures map envMap envMapMode lightMap aoMap emissiveMap bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals numDirLights numPointLights numSpotLights numHemiLights shadowMapEnabled pointLightShadows shadowMapType alphaTest doubleSided flipSided".split(
              " "
            );
        this.getParameters = function (c, e, h, k) {
          var l = d[c.type],
            n;
          b.floatVertexTextures &&
          k &&
          k.skeleton &&
          k.skeleton.useVertexTexture
            ? (n = 1024)
            : ((n = Math.floor((b.maxVertexUniforms - 20) / 4)),
              void 0 !== k &&
                k instanceof THREE.SkinnedMesh &&
                ((n = Math.min(k.skeleton.bones.length, n)),
                n < k.skeleton.bones.length &&
                  console.warn(
                    "WebGLRenderer: too many bones - " +
                      k.skeleton.bones.length +
                      ", this GPU supports just " +
                      n +
                      " (try OpenGL instead of ANGLE)"
                  )));
          var p = a.getPrecision();
          null !== c.precision &&
            ((p = b.getMaxPrecision(c.precision)),
            p !== c.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                c.precision,
                "not supported, using",
                p,
                "instead."
              ));
          return {
            shaderID: l,
            precision: p,
            supportsVertexTextures: b.vertexTextures,
            map: !!c.map,
            envMap: !!c.envMap,
            envMapMode: c.envMap && c.envMap.mapping,
            lightMap: !!c.lightMap,
            aoMap: !!c.aoMap,
            emissiveMap: !!c.emissiveMap,
            bumpMap: !!c.bumpMap,
            normalMap: !!c.normalMap,
            displacementMap: !!c.displacementMap,
            roughnessMap: !!c.roughnessMap,
            metalnessMap: !!c.metalnessMap,
            specularMap: !!c.specularMap,
            alphaMap: !!c.alphaMap,
            combine: c.combine,
            vertexColors: c.vertexColors,
            fog: h,
            useFog: c.fog,
            fogExp: h instanceof THREE.FogExp2,
            flatShading: c.shading === THREE.FlatShading,
            sizeAttenuation: c.sizeAttenuation,
            logarithmicDepthBuffer: b.logarithmicDepthBuffer,
            skinning: c.skinning,
            maxBones: n,
            useVertexTexture:
              b.floatVertexTextures &&
              k &&
              k.skeleton &&
              k.skeleton.useVertexTexture,
            morphTargets: c.morphTargets,
            morphNormals: c.morphNormals,
            maxMorphTargets: a.maxMorphTargets,
            maxMorphNormals: a.maxMorphNormals,
            numDirLights: e.directional.length,
            numPointLights: e.point.length,
            numSpotLights: e.spot.length,
            numHemiLights: e.hemi.length,
            pointLightShadows: e.shadowsPointLight,
            shadowMapEnabled:
              a.shadowMap.enabled && k.receiveShadow && 0 < e.shadows.length,
            shadowMapType: a.shadowMap.type,
            alphaTest: c.alphaTest,
            doubleSided: c.side === THREE.DoubleSide,
            flipSided: c.side === THREE.BackSide,
          };
        };
        this.getProgramCode = function (a, b) {
          var c = [];
          b.shaderID
            ? c.push(b.shaderID)
            : (c.push(a.fragmentShader), c.push(a.vertexShader));
          if (void 0 !== a.defines)
            for (var d in a.defines) c.push(d), c.push(a.defines[d]);
          for (d = 0; d < e.length; d++) {
            var l = e[d];
            c.push(l);
            c.push(b[l]);
          }
          return c.join();
        };
        this.acquireProgram = function (b, d, e) {
          for (var k, l = 0, n = c.length; l < n; l++) {
            var p = c[l];
            if (p.code === e) {
              k = p;
              ++k.usedTimes;
              break;
            }
          }
          void 0 === k && ((k = new THREE.WebGLProgram(a, e, b, d)), c.push(k));
          return k;
        };
        this.releaseProgram = function (a) {
          if (0 === --a.usedTimes) {
            var b = c.indexOf(a);
            c[b] = c[c.length - 1];
            c.pop();
            a.destroy();
          }
        };
        this.programs = c;
      };
      THREE.WebGLProperties = function () {
        var a = {};
        this.get = function (b) {
          b = b.uuid;
          var c = a[b];
          void 0 === c && ((c = {}), (a[b] = c));
          return c;
        };
        this.delete = function (b) {
          delete a[b.uuid];
        };
        this.clear = function () {
          a = {};
        };
      };
      THREE.WebGLShader = (function () {
        function a(a) {
          a = a.split("\n");
          for (var c = 0; c < a.length; c++) a[c] = c + 1 + ": " + a[c];
          return a.join("\n");
        }
        return function (b, c, d) {
          var e = b.createShader(c);
          b.shaderSource(e, d);
          b.compileShader(e);
          !1 === b.getShaderParameter(e, b.COMPILE_STATUS) &&
            console.error("THREE.WebGLShader: Shader couldn't compile.");
          "" !== b.getShaderInfoLog(e) &&
            console.warn(
              "THREE.WebGLShader: gl.getShaderInfoLog()",
              c === b.VERTEX_SHADER ? "vertex" : "fragment",
              b.getShaderInfoLog(e),
              a(d)
            );
          return e;
        };
      })();
      THREE.WebGLShadowMap = function (a, b, c) {
        function d(a, b, c, d) {
          var e = a.geometry,
            f = null,
            f = q,
            g = a.customDepthMaterial;
          c && ((f = s), (g = a.customDistanceMaterial));
          g
            ? (f = g)
            : ((a = a instanceof THREE.SkinnedMesh && b.skinning),
              (g = 0),
              void 0 !== e.morphTargets &&
                0 < e.morphTargets.length &&
                b.morphTargets &&
                (g |= 1),
              a && (g |= 2),
              (f = f[g]));
          f.visible = b.visible;
          f.wireframe = b.wireframe;
          f.wireframeLinewidth = b.wireframeLinewidth;
          c &&
            void 0 !== f.uniforms.lightPos &&
            f.uniforms.lightPos.value.copy(d);
          return f;
        }
        function e(a, b, c) {
          if (!1 !== a.visible) {
            a.layers.test(b.layers) &&
              (a instanceof THREE.Mesh ||
                a instanceof THREE.Line ||
                a instanceof THREE.Points) &&
              a.castShadow &&
              (!1 === a.frustumCulled || !0 === h.intersectsObject(a)) &&
              !0 === a.material.visible &&
              (a.modelViewMatrix.multiplyMatrices(
                c.matrixWorldInverse,
                a.matrixWorld
              ),
              m.push(a));
            a = a.children;
            for (var d = 0, f = a.length; d < f; d++) e(a[d], b, c);
          }
        }
        for (
          var f = a.context,
            g = a.state,
            h = new THREE.Frustum(),
            k = new THREE.Matrix4(),
            l = new THREE.Vector2(),
            n = new THREE.Vector3(),
            p = new THREE.Vector3(),
            m = [],
            q = Array(4),
            s = Array(4),
            u = [
              new THREE.Vector3(1, 0, 0),
              new THREE.Vector3(-1, 0, 0),
              new THREE.Vector3(0, 0, 1),
              new THREE.Vector3(0, 0, -1),
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(0, -1, 0),
            ],
            t = [
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(0, 0, 1),
              new THREE.Vector3(0, 0, -1),
            ],
            x = [
              new THREE.Vector4(),
              new THREE.Vector4(),
              new THREE.Vector4(),
              new THREE.Vector4(),
              new THREE.Vector4(),
              new THREE.Vector4(),
            ],
            v = THREE.ShaderLib.depthRGBA,
            C = THREE.UniformsUtils.clone(v.uniforms),
            w = THREE.ShaderLib.distanceRGBA,
            D = THREE.UniformsUtils.clone(w.uniforms),
            z = 0;
          4 !== z;
          ++z
        ) {
          var y = 0 !== (z & 1),
            A = 0 !== (z & 2),
            H = new THREE.ShaderMaterial({
              uniforms: C,
              vertexShader: v.vertexShader,
              fragmentShader: v.fragmentShader,
              morphTargets: y,
              skinning: A,
            });
          H._shadowPass = !0;
          q[z] = H;
          y = new THREE.ShaderMaterial({
            uniforms: D,
            vertexShader: w.vertexShader,
            fragmentShader: w.fragmentShader,
            morphTargets: y,
            skinning: A,
          });
          y._shadowPass = !0;
          s[z] = y;
        }
        var G = this;
        this.enabled = !1;
        this.autoUpdate = !0;
        this.needsUpdate = !1;
        this.type = THREE.PCFShadowMap;
        this.cullFace = THREE.CullFaceFront;
        this.render = function (q, s) {
          var v, w;
          if (
            !1 !== G.enabled &&
            (!1 !== G.autoUpdate || !1 !== G.needsUpdate)
          ) {
            g.clearColor(1, 1, 1, 1);
            g.disable(f.BLEND);
            g.enable(f.CULL_FACE);
            f.frontFace(f.CCW);
            f.cullFace(G.cullFace === THREE.CullFaceFront ? f.FRONT : f.BACK);
            g.setDepthTest(!0);
            g.setScissorTest(!1);
            for (var C = b.shadows, y = 0, z = C.length; y < z; y++) {
              var A = C[y],
                D = A.shadow,
                H = D.camera;
              l.copy(D.mapSize);
              if (A instanceof THREE.PointLight) {
                v = 6;
                w = !0;
                var J = l.x,
                  F = l.y;
                x[0].set(2 * J, F, J, F);
                x[1].set(0, F, J, F);
                x[2].set(3 * J, F, J, F);
                x[3].set(J, F, J, F);
                x[4].set(3 * J, 0, J, F);
                x[5].set(J, 0, J, F);
                l.x *= 4;
                l.y *= 2;
              } else (v = 1), (w = !1);
              null === D.map &&
                ((D.map = new THREE.WebGLRenderTarget(l.x, l.y, {
                  minFilter: THREE.NearestFilter,
                  magFilter: THREE.NearestFilter,
                  format: THREE.RGBAFormat,
                })),
                A instanceof THREE.SpotLight && (H.aspect = l.x / l.y),
                H.updateProjectionMatrix());
              J = D.map;
              D = D.matrix;
              p.setFromMatrixPosition(A.matrixWorld);
              H.position.copy(p);
              a.setRenderTarget(J);
              a.clear();
              for (J = 0; J < v; J++) {
                w
                  ? (n.copy(H.position),
                    n.add(u[J]),
                    H.up.copy(t[J]),
                    H.lookAt(n),
                    g.viewport(x[J]))
                  : (n.setFromMatrixPosition(A.target.matrixWorld),
                    H.lookAt(n));
                H.updateMatrixWorld();
                H.matrixWorldInverse.getInverse(H.matrixWorld);
                D.set(
                  0.5,
                  0,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0,
                  0.5,
                  0.5,
                  0,
                  0,
                  0,
                  1
                );
                D.multiply(H.projectionMatrix);
                D.multiply(H.matrixWorldInverse);
                k.multiplyMatrices(H.projectionMatrix, H.matrixWorldInverse);
                h.setFromMatrix(k);
                m.length = 0;
                e(q, s, H);
                for (var F = 0, Y = m.length; F < Y; F++) {
                  var V = m[F],
                    aa = c.update(V),
                    ca = V.material;
                  if (ca instanceof THREE.MultiMaterial)
                    for (
                      var ha = aa.groups,
                        ca = ca.materials,
                        X = 0,
                        ma = ha.length;
                      X < ma;
                      X++
                    ) {
                      var ia = ha[X],
                        ba = ca[ia.materialIndex];
                      !0 === ba.visible &&
                        ((ba = d(V, ba, w, p)),
                        a.renderBufferDirect(H, null, aa, ba, V, ia));
                    }
                  else
                    (ba = d(V, ca, w, p)),
                      a.renderBufferDirect(H, null, aa, ba, V, null);
                }
              }
              a.resetGLState();
            }
            v = a.getClearColor();
            w = a.getClearAlpha();
            a.setClearColor(v, w);
            g.enable(f.BLEND);
            G.cullFace === THREE.CullFaceFront && f.cullFace(f.BACK);
            a.resetGLState();
            G.needsUpdate = !1;
          }
        };
      };
      THREE.WebGLState = function (a, b, c) {
        var d = this,
          e = new THREE.Vector4(),
          f = new Uint8Array(16),
          g = new Uint8Array(16),
          h = new Uint8Array(16),
          k = {},
          l = null,
          n = null,
          p = null,
          m = null,
          q = null,
          s = null,
          u = null,
          t = null,
          x = null,
          v = null,
          C = null,
          w = null,
          D = null,
          z = null,
          y = null,
          A = null,
          H = null,
          G = null,
          E = null,
          K = null,
          P = null,
          N = null,
          L = null,
          B = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
          M = void 0,
          Q = {},
          O = new THREE.Vector4(),
          S = null,
          J = null,
          F = new THREE.Vector4(),
          Y = new THREE.Vector4();
        this.init = function () {
          this.clearColor(0, 0, 0, 1);
          this.clearDepth(1);
          this.clearStencil(0);
          this.enable(a.DEPTH_TEST);
          a.depthFunc(a.LEQUAL);
          a.frontFace(a.CCW);
          a.cullFace(a.BACK);
          this.enable(a.CULL_FACE);
          this.enable(a.BLEND);
          a.blendEquation(a.FUNC_ADD);
          a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA);
        };
        this.initAttributes = function () {
          for (var a = 0, b = f.length; a < b; a++) f[a] = 0;
        };
        this.enableAttribute = function (c) {
          f[c] = 1;
          0 === g[c] && (a.enableVertexAttribArray(c), (g[c] = 1));
          0 !== h[c] &&
            (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, 0),
            (h[c] = 0));
        };
        this.enableAttributeAndDivisor = function (b, c, d) {
          f[b] = 1;
          0 === g[b] && (a.enableVertexAttribArray(b), (g[b] = 1));
          h[b] !== c && (d.vertexAttribDivisorANGLE(b, c), (h[b] = c));
        };
        this.disableUnusedAttributes = function () {
          for (var b = 0, c = g.length; b < c; b++)
            g[b] !== f[b] && (a.disableVertexAttribArray(b), (g[b] = 0));
        };
        this.enable = function (b) {
          !0 !== k[b] && (a.enable(b), (k[b] = !0));
        };
        this.disable = function (b) {
          !1 !== k[b] && (a.disable(b), (k[b] = !1));
        };
        this.getCompressedTextureFormats = function () {
          if (
            null === l &&
            ((l = []),
            b.get("WEBGL_compressed_texture_pvrtc") ||
              b.get("WEBGL_compressed_texture_s3tc") ||
              b.get("WEBGL_compressed_texture_etc1"))
          )
            for (
              var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0;
              d < c.length;
              d++
            )
              l.push(c[d]);
          return l;
        };
        this.setBlending = function (b, d, e, f, g, h, k) {
          b === THREE.NoBlending ? this.disable(a.BLEND) : this.enable(a.BLEND);
          b !== n &&
            (b === THREE.AdditiveBlending
              ? (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE))
              : b === THREE.SubtractiveBlending
              ? (a.blendEquation(a.FUNC_ADD),
                a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR))
              : b === THREE.MultiplyBlending
              ? (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR))
              : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD),
                a.blendFuncSeparate(
                  a.SRC_ALPHA,
                  a.ONE_MINUS_SRC_ALPHA,
                  a.ONE,
                  a.ONE_MINUS_SRC_ALPHA
                )),
            (n = b));
          if (b === THREE.CustomBlending) {
            g = g || d;
            h = h || e;
            k = k || f;
            if (d !== p || g !== s)
              a.blendEquationSeparate(c(d), c(g)), (p = d), (s = g);
            if (e !== m || f !== q || h !== u || k !== t)
              a.blendFuncSeparate(c(e), c(f), c(h), c(k)),
                (m = e),
                (q = f),
                (u = h),
                (t = k);
          } else t = u = s = q = m = p = null;
        };
        this.setDepthFunc = function (b) {
          if (x !== b) {
            if (b)
              switch (b) {
                case THREE.NeverDepth:
                  a.depthFunc(a.NEVER);
                  break;
                case THREE.AlwaysDepth:
                  a.depthFunc(a.ALWAYS);
                  break;
                case THREE.LessDepth:
                  a.depthFunc(a.LESS);
                  break;
                case THREE.LessEqualDepth:
                  a.depthFunc(a.LEQUAL);
                  break;
                case THREE.EqualDepth:
                  a.depthFunc(a.EQUAL);
                  break;
                case THREE.GreaterEqualDepth:
                  a.depthFunc(a.GEQUAL);
                  break;
                case THREE.GreaterDepth:
                  a.depthFunc(a.GREATER);
                  break;
                case THREE.NotEqualDepth:
                  a.depthFunc(a.NOTEQUAL);
                  break;
                default:
                  a.depthFunc(a.LEQUAL);
              }
            else a.depthFunc(a.LEQUAL);
            x = b;
          }
        };
        this.setDepthTest = function (b) {
          b ? this.enable(a.DEPTH_TEST) : this.disable(a.DEPTH_TEST);
        };
        this.setDepthWrite = function (b) {
          v !== b && (a.depthMask(b), (v = b));
        };
        this.setColorWrite = function (b) {
          C !== b && (a.colorMask(b, b, b, b), (C = b));
        };
        this.setStencilFunc = function (b, c, d) {
          if (D !== b || z !== c || y !== d)
            a.stencilFunc(b, c, d), (D = b), (z = c), (y = d);
        };
        this.setStencilOp = function (b, c, d) {
          if (A !== b || H !== c || G !== d)
            a.stencilOp(b, c, d), (A = b), (H = c), (G = d);
        };
        this.setStencilTest = function (b) {
          b ? this.enable(a.STENCIL_TEST) : this.disable(a.STENCIL_TEST);
        };
        this.setStencilWrite = function (b) {
          w !== b && (a.stencilMask(b), (w = b));
        };
        this.setFlipSided = function (b) {
          E !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), (E = b));
        };
        this.setLineWidth = function (b) {
          b !== K && (a.lineWidth(b), (K = b));
        };
        this.setPolygonOffset = function (b, c, d) {
          b
            ? this.enable(a.POLYGON_OFFSET_FILL)
            : this.disable(a.POLYGON_OFFSET_FILL);
          !b ||
            (P === c && N === d) ||
            (a.polygonOffset(c, d), (P = c), (N = d));
        };
        this.getScissorTest = function () {
          return L;
        };
        this.setScissorTest = function (b) {
          (L = b) ? this.enable(a.SCISSOR_TEST) : this.disable(a.SCISSOR_TEST);
        };
        this.activeTexture = function (b) {
          void 0 === b && (b = a.TEXTURE0 + B - 1);
          M !== b && (a.activeTexture(b), (M = b));
        };
        this.bindTexture = function (b, c) {
          void 0 === M && d.activeTexture();
          var e = Q[M];
          void 0 === e && ((e = { type: void 0, texture: void 0 }), (Q[M] = e));
          if (e.type !== b || e.texture !== c)
            a.bindTexture(b, c), (e.type = b), (e.texture = c);
        };
        this.compressedTexImage2D = function () {
          try {
            a.compressedTexImage2D.apply(a, arguments);
          } catch (b) {
            console.error(b);
          }
        };
        this.texImage2D = function () {
          try {
            a.texImage2D.apply(a, arguments);
          } catch (b) {
            console.error(b);
          }
        };
        this.clearColor = function (b, c, d, f) {
          e.set(b, c, d, f);
          !1 === O.equals(e) && (a.clearColor(b, c, d, f), O.copy(e));
        };
        this.clearDepth = function (b) {
          S !== b && (a.clearDepth(b), (S = b));
        };
        this.clearStencil = function (b) {
          J !== b && (a.clearStencil(b), (J = b));
        };
        this.scissor = function (b) {
          !1 === F.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), F.copy(b));
        };
        this.viewport = function (b) {
          !1 === Y.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), Y.copy(b));
        };
        this.reset = function () {
          for (var b = 0; b < g.length; b++)
            1 === g[b] && (a.disableVertexAttribArray(b), (g[b] = 0));
          k = {};
          E = w = v = C = n = l = null;
        };
      };
      THREE.LensFlarePlugin = function (a, b) {
        var c,
          d,
          e,
          f,
          g,
          h,
          k,
          l,
          n,
          p,
          m = a.context,
          q = a.state,
          s,
          u,
          t,
          x,
          v,
          C;
        this.render = function (w, D, z) {
          if (0 !== b.length) {
            w = new THREE.Vector3();
            var y = z.w / z.z,
              A = 0.5 * z.z,
              H = 0.5 * z.w,
              G = 16 / z.w,
              E = new THREE.Vector2(G * y, G),
              K = new THREE.Vector3(1, 1, 0),
              P = new THREE.Vector2(1, 1);
            if (void 0 === t) {
              var G = new Float32Array([
                  -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1,
                ]),
                N = new Uint16Array([0, 1, 2, 0, 2, 3]);
              s = m.createBuffer();
              u = m.createBuffer();
              m.bindBuffer(m.ARRAY_BUFFER, s);
              m.bufferData(m.ARRAY_BUFFER, G, m.STATIC_DRAW);
              m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, u);
              m.bufferData(m.ELEMENT_ARRAY_BUFFER, N, m.STATIC_DRAW);
              v = m.createTexture();
              C = m.createTexture();
              q.bindTexture(m.TEXTURE_2D, v);
              m.texImage2D(
                m.TEXTURE_2D,
                0,
                m.RGB,
                16,
                16,
                0,
                m.RGB,
                m.UNSIGNED_BYTE,
                null
              );
              m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE);
              m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE);
              m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST);
              m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST);
              q.bindTexture(m.TEXTURE_2D, C);
              m.texImage2D(
                m.TEXTURE_2D,
                0,
                m.RGBA,
                16,
                16,
                0,
                m.RGBA,
                m.UNSIGNED_BYTE,
                null
              );
              m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE);
              m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE);
              m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST);
              m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST);
              var G = (x = 0 < m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS))
                  ? {
                      vertexShader:
                        "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                      fragmentShader:
                        "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}",
                    }
                  : {
                      vertexShader:
                        "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                      fragmentShader:
                        "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}",
                    },
                N = m.createProgram(),
                L = m.createShader(m.FRAGMENT_SHADER),
                B = m.createShader(m.VERTEX_SHADER),
                M = "precision " + a.getPrecision() + " float;\n";
              m.shaderSource(L, M + G.fragmentShader);
              m.shaderSource(B, M + G.vertexShader);
              m.compileShader(L);
              m.compileShader(B);
              m.attachShader(N, L);
              m.attachShader(N, B);
              m.linkProgram(N);
              t = N;
              n = m.getAttribLocation(t, "position");
              p = m.getAttribLocation(t, "uv");
              c = m.getUniformLocation(t, "renderType");
              d = m.getUniformLocation(t, "map");
              e = m.getUniformLocation(t, "occlusionMap");
              f = m.getUniformLocation(t, "opacity");
              g = m.getUniformLocation(t, "color");
              h = m.getUniformLocation(t, "scale");
              k = m.getUniformLocation(t, "rotation");
              l = m.getUniformLocation(t, "screenPosition");
            }
            m.useProgram(t);
            q.initAttributes();
            q.enableAttribute(n);
            q.enableAttribute(p);
            q.disableUnusedAttributes();
            m.uniform1i(e, 0);
            m.uniform1i(d, 1);
            m.bindBuffer(m.ARRAY_BUFFER, s);
            m.vertexAttribPointer(n, 2, m.FLOAT, !1, 16, 0);
            m.vertexAttribPointer(p, 2, m.FLOAT, !1, 16, 8);
            m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, u);
            q.disable(m.CULL_FACE);
            q.setDepthWrite(!1);
            N = 0;
            for (L = b.length; N < L; N++)
              if (
                ((G = 16 / z.w),
                E.set(G * y, G),
                (B = b[N]),
                w.set(
                  B.matrixWorld.elements[12],
                  B.matrixWorld.elements[13],
                  B.matrixWorld.elements[14]
                ),
                w.applyMatrix4(D.matrixWorldInverse),
                w.applyProjection(D.projectionMatrix),
                K.copy(w),
                (P.x = K.x * A + A),
                (P.y = K.y * H + H),
                x || (0 < P.x && P.x < z.z && 0 < P.y && P.y < z.w))
              ) {
                q.activeTexture(m.TEXTURE0);
                q.bindTexture(m.TEXTURE_2D, null);
                q.activeTexture(m.TEXTURE1);
                q.bindTexture(m.TEXTURE_2D, v);
                m.copyTexImage2D(
                  m.TEXTURE_2D,
                  0,
                  m.RGB,
                  z.x + P.x - 8,
                  z.y + P.y - 8,
                  16,
                  16,
                  0
                );
                m.uniform1i(c, 0);
                m.uniform2f(h, E.x, E.y);
                m.uniform3f(l, K.x, K.y, K.z);
                q.disable(m.BLEND);
                q.enable(m.DEPTH_TEST);
                m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0);
                q.activeTexture(m.TEXTURE0);
                q.bindTexture(m.TEXTURE_2D, C);
                m.copyTexImage2D(
                  m.TEXTURE_2D,
                  0,
                  m.RGBA,
                  z.x + P.x - 8,
                  z.y + P.y - 8,
                  16,
                  16,
                  0
                );
                m.uniform1i(c, 1);
                q.disable(m.DEPTH_TEST);
                q.activeTexture(m.TEXTURE1);
                q.bindTexture(m.TEXTURE_2D, v);
                m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0);
                B.positionScreen.copy(K);
                B.customUpdateCallback
                  ? B.customUpdateCallback(B)
                  : B.updateLensFlares();
                m.uniform1i(c, 2);
                q.enable(m.BLEND);
                for (var M = 0, Q = B.lensFlares.length; M < Q; M++) {
                  var O = B.lensFlares[M];
                  0.001 < O.opacity &&
                    0.001 < O.scale &&
                    ((K.x = O.x),
                    (K.y = O.y),
                    (K.z = O.z),
                    (G = (O.size * O.scale) / z.w),
                    (E.x = G * y),
                    (E.y = G),
                    m.uniform3f(l, K.x, K.y, K.z),
                    m.uniform2f(h, E.x, E.y),
                    m.uniform1f(k, O.rotation),
                    m.uniform1f(f, O.opacity),
                    m.uniform3f(g, O.color.r, O.color.g, O.color.b),
                    q.setBlending(
                      O.blending,
                      O.blendEquation,
                      O.blendSrc,
                      O.blendDst
                    ),
                    a.setTexture(O.texture, 1),
                    m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0));
                }
              }
            q.enable(m.CULL_FACE);
            q.enable(m.DEPTH_TEST);
            q.setDepthWrite(!0);
            a.resetGLState();
          }
        };
      };
      THREE.SpritePlugin = function (a, b) {
        var c, d, e, f, g, h, k, l, n, p, m, q, s, u, t, x, v;
        function C(a, b) {
          return a.renderOrder !== b.renderOrder
            ? a.renderOrder - b.renderOrder
            : a.z !== b.z
            ? b.z - a.z
            : b.id - a.id;
        }
        var w = a.context,
          D = a.state,
          z,
          y,
          A,
          H,
          G = new THREE.Vector3(),
          E = new THREE.Quaternion(),
          K = new THREE.Vector3();
        this.render = function (P, N) {
          if (0 !== b.length) {
            if (void 0 === A) {
              var L = new Float32Array([
                  -0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5,
                  0, 1,
                ]),
                B = new Uint16Array([0, 1, 2, 0, 2, 3]);
              z = w.createBuffer();
              y = w.createBuffer();
              w.bindBuffer(w.ARRAY_BUFFER, z);
              w.bufferData(w.ARRAY_BUFFER, L, w.STATIC_DRAW);
              w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, y);
              w.bufferData(w.ELEMENT_ARRAY_BUFFER, B, w.STATIC_DRAW);
              var L = w.createProgram(),
                B = w.createShader(w.VERTEX_SHADER),
                M = w.createShader(w.FRAGMENT_SHADER);
              w.shaderSource(
                B,
                [
                  "precision " + a.getPrecision() + " float;",
                  "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}",
                ].join("\n")
              );
              w.shaderSource(
                M,
                [
                  "precision " + a.getPrecision() + " float;",
                  "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}",
                ].join("\n")
              );
              w.compileShader(B);
              w.compileShader(M);
              w.attachShader(L, B);
              w.attachShader(L, M);
              w.linkProgram(L);
              A = L;
              x = w.getAttribLocation(A, "position");
              v = w.getAttribLocation(A, "uv");
              c = w.getUniformLocation(A, "uvOffset");
              d = w.getUniformLocation(A, "uvScale");
              e = w.getUniformLocation(A, "rotation");
              f = w.getUniformLocation(A, "scale");
              g = w.getUniformLocation(A, "color");
              h = w.getUniformLocation(A, "map");
              k = w.getUniformLocation(A, "opacity");
              l = w.getUniformLocation(A, "modelViewMatrix");
              n = w.getUniformLocation(A, "projectionMatrix");
              p = w.getUniformLocation(A, "fogType");
              m = w.getUniformLocation(A, "fogDensity");
              q = w.getUniformLocation(A, "fogNear");
              s = w.getUniformLocation(A, "fogFar");
              u = w.getUniformLocation(A, "fogColor");
              t = w.getUniformLocation(A, "alphaTest");
              L = document.createElement("canvas");
              L.width = 8;
              L.height = 8;
              B = L.getContext("2d");
              B.fillStyle = "white";
              B.fillRect(0, 0, 8, 8);
              H = new THREE.Texture(L);
              H.needsUpdate = !0;
            }
            w.useProgram(A);
            D.initAttributes();
            D.enableAttribute(x);
            D.enableAttribute(v);
            D.disableUnusedAttributes();
            D.disable(w.CULL_FACE);
            D.enable(w.BLEND);
            w.bindBuffer(w.ARRAY_BUFFER, z);
            w.vertexAttribPointer(x, 2, w.FLOAT, !1, 16, 0);
            w.vertexAttribPointer(v, 2, w.FLOAT, !1, 16, 8);
            w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, y);
            w.uniformMatrix4fv(n, !1, N.projectionMatrix.elements);
            D.activeTexture(w.TEXTURE0);
            w.uniform1i(h, 0);
            B = L = 0;
            (M = P.fog)
              ? (w.uniform3f(u, M.color.r, M.color.g, M.color.b),
                M instanceof THREE.Fog
                  ? (w.uniform1f(q, M.near),
                    w.uniform1f(s, M.far),
                    w.uniform1i(p, 1),
                    (B = L = 1))
                  : M instanceof THREE.FogExp2 &&
                    (w.uniform1f(m, M.density), w.uniform1i(p, 2), (B = L = 2)))
              : (w.uniform1i(p, 0), (B = L = 0));
            for (var M = 0, Q = b.length; M < Q; M++) {
              var O = b[M];
              O.modelViewMatrix.multiplyMatrices(
                N.matrixWorldInverse,
                O.matrixWorld
              );
              O.z = -O.modelViewMatrix.elements[14];
            }
            b.sort(C);
            for (var S = [], M = 0, Q = b.length; M < Q; M++) {
              var O = b[M],
                J = O.material;
              w.uniform1f(t, J.alphaTest);
              w.uniformMatrix4fv(l, !1, O.modelViewMatrix.elements);
              O.matrixWorld.decompose(G, E, K);
              S[0] = K.x;
              S[1] = K.y;
              O = 0;
              P.fog && J.fog && (O = B);
              L !== O && (w.uniform1i(p, O), (L = O));
              null !== J.map
                ? (w.uniform2f(c, J.map.offset.x, J.map.offset.y),
                  w.uniform2f(d, J.map.repeat.x, J.map.repeat.y))
                : (w.uniform2f(c, 0, 0), w.uniform2f(d, 1, 1));
              w.uniform1f(k, J.opacity);
              w.uniform3f(g, J.color.r, J.color.g, J.color.b);
              w.uniform1f(e, J.rotation);
              w.uniform2fv(f, S);
              D.setBlending(
                J.blending,
                J.blendEquation,
                J.blendSrc,
                J.blendDst
              );
              D.setDepthTest(J.depthTest);
              D.setDepthWrite(J.depthWrite);
              J.map && J.map.image && J.map.image.width
                ? a.setTexture(J.map, 0)
                : a.setTexture(H, 0);
              w.drawElements(w.TRIANGLES, 6, w.UNSIGNED_SHORT, 0);
            }
            D.enable(w.CULL_FACE);
            a.resetGLState();
          }
        };
      };
      Object.defineProperties(THREE.Box2.prototype, {
        empty: {
          value: function () {
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            );
            return this.isEmpty();
          },
        },
        isIntersectionBox: {
          value: function (a) {
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            );
            return this.intersectsBox(a);
          },
        },
      });
      Object.defineProperties(THREE.Box3.prototype, {
        empty: {
          value: function () {
            console.warn(
              "THREE.Box3: .empty() has been renamed to .isEmpty()."
            );
            return this.isEmpty();
          },
        },
        isIntersectionBox: {
          value: function (a) {
            console.warn(
              "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
            );
            return this.intersectsBox(a);
          },
        },
        isIntersectionSphere: {
          value: function (a) {
            console.warn(
              "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            );
            return this.intersectsSphere(a);
          },
        },
      });
      Object.defineProperties(THREE.Matrix3.prototype, {
        multiplyVector3: {
          value: function (a) {
            console.warn(
              "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
            );
            return a.applyMatrix3(this);
          },
        },
        multiplyVector3Array: {
          value: function (a) {
            console.warn(
              "THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."
            );
            return this.applyToVector3Array(a);
          },
        },
      });
      Object.defineProperties(THREE.Matrix4.prototype, {
        extractPosition: {
          value: function (a) {
            console.warn(
              "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
            );
            return this.copyPosition(a);
          },
        },
        setRotationFromQuaternion: {
          value: function (a) {
            console.warn(
              "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
            );
            return this.makeRotationFromQuaternion(a);
          },
        },
        multiplyVector3: {
          value: function (a) {
            console.warn(
              "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."
            );
            return a.applyProjection(this);
          },
        },
        multiplyVector4: {
          value: function (a) {
            console.warn(
              "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
            );
            return a.applyMatrix4(this);
          },
        },
        multiplyVector3Array: {
          value: function (a) {
            console.warn(
              "THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."
            );
            return this.applyToVector3Array(a);
          },
        },
        rotateAxis: {
          value: function (a) {
            console.warn(
              "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
            );
            a.transformDirection(this);
          },
        },
        crossVector: {
          value: function (a) {
            console.warn(
              "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
            );
            return a.applyMatrix4(this);
          },
        },
        translate: {
          value: function (a) {
            console.error("THREE.Matrix4: .translate() has been removed.");
          },
        },
        rotateX: {
          value: function (a) {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
          },
        },
        rotateY: {
          value: function (a) {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
          },
        },
        rotateZ: {
          value: function (a) {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
          },
        },
        rotateByAxis: {
          value: function (a, b) {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
          },
        },
      });
      Object.defineProperties(THREE.Plane.prototype, {
        isIntersectionLine: {
          value: function (a) {
            console.warn(
              "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
            );
            return this.intersectsLine(a);
          },
        },
      });
      Object.defineProperties(THREE.Quaternion.prototype, {
        multiplyVector3: {
          value: function (a) {
            console.warn(
              "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
            );
            return a.applyQuaternion(this);
          },
        },
      });
      Object.defineProperties(THREE.Ray.prototype, {
        isIntersectionBox: {
          value: function (a) {
            console.warn(
              "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
            );
            return this.intersectsBox(a);
          },
        },
        isIntersectionPlane: {
          value: function (a) {
            console.warn(
              "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
            );
            return this.intersectsPlane(a);
          },
        },
        isIntersectionSphere: {
          value: function (a) {
            console.warn(
              "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            );
            return this.intersectsSphere(a);
          },
        },
      });
      Object.defineProperties(THREE.Vector3.prototype, {
        setEulerFromRotationMatrix: {
          value: function () {
            console.error(
              "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
            );
          },
        },
        setEulerFromQuaternion: {
          value: function () {
            console.error(
              "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
            );
          },
        },
        getPositionFromMatrix: {
          value: function (a) {
            console.warn(
              "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
            );
            return this.setFromMatrixPosition(a);
          },
        },
        getScaleFromMatrix: {
          value: function (a) {
            console.warn(
              "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
            );
            return this.setFromMatrixScale(a);
          },
        },
        getColumnFromMatrix: {
          value: function (a, b) {
            console.warn(
              "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
            );
            return this.setFromMatrixColumn(a, b);
          },
        },
      });
      THREE.Face4 = function (a, b, c, d, e, f, g) {
        console.warn(
          "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
        );
        return new THREE.Face3(a, b, c, e, f, g);
      };
      Object.defineProperties(THREE.Object3D.prototype, {
        eulerOrder: {
          get: function () {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order;
          },
          set: function (a) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = a;
          },
        },
        getChildByName: {
          value: function (a) {
            console.warn(
              "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
            );
            return this.getObjectByName(a);
          },
        },
        renderDepth: {
          set: function (a) {
            console.warn(
              "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
            );
          },
        },
        translate: {
          value: function (a, b) {
            console.warn(
              "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
            );
            return this.translateOnAxis(b, a);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function (a) {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      });
      Object.defineProperties(THREE, {
        PointCloud: {
          value: function (a, b) {
            console.warn("THREE.PointCloud has been renamed to THREE.Points.");
            return new THREE.Points(a, b);
          },
        },
        ParticleSystem: {
          value: function (a, b) {
            console.warn(
              "THREE.ParticleSystem has been renamed to THREE.Points."
            );
            return new THREE.Points(a, b);
          },
        },
      });
      Object.defineProperties(THREE.Light.prototype, {
        onlyShadow: {
          set: function (a) {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            );
            this.shadow.camera.fov = a;
          },
        },
        shadowCameraLeft: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            );
            this.shadow.camera.left = a;
          },
        },
        shadowCameraRight: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            );
            this.shadow.camera.right = a;
          },
        },
        shadowCameraTop: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            );
            this.shadow.camera.top = a;
          },
        },
        shadowCameraBottom: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            );
            this.shadow.camera.bottom = a;
          },
        },
        shadowCameraNear: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            );
            this.shadow.camera.near = a;
          },
        },
        shadowCameraFar: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            );
            this.shadow.camera.far = a;
          },
        },
        shadowCameraVisible: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (a) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = a;
          },
        },
        shadowDarkness: {
          set: function (a) {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            );
            this.shadow.mapSize.width = a;
          },
        },
        shadowMapHeight: {
          set: function (a) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            );
            this.shadow.mapSize.height = a;
          },
        },
      });
      Object.defineProperties(THREE.BufferAttribute.prototype, {
        length: {
          get: function () {
            console.warn(
              "THREE.BufferAttribute: .length has been deprecated. Please use .count."
            );
            return this.array.length;
          },
        },
      });
      Object.defineProperties(THREE.BufferGeometry.prototype, {
        drawcalls: {
          get: function () {
            console.error(
              "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
            );
            return this.groups;
          },
        },
        offsets: {
          get: function () {
            console.warn(
              "THREE.BufferGeometry: .offsets has been renamed to .groups."
            );
            return this.groups;
          },
        },
        addIndex: {
          value: function (a) {
            console.warn(
              "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
            );
            this.setIndex(a);
          },
        },
        addDrawCall: {
          value: function (a, b, c) {
            void 0 !== c &&
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
              );
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
            );
            this.addGroup(a, b);
          },
        },
        clearDrawCalls: {
          value: function () {
            console.warn(
              "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
            );
            this.clearGroups();
          },
        },
        computeTangents: {
          value: function () {
            console.warn(
              "THREE.BufferGeometry: .computeTangents() has been removed."
            );
          },
        },
        computeOffsets: {
          value: function () {
            console.warn(
              "THREE.BufferGeometry: .computeOffsets() has been removed."
            );
          },
        },
      });
      Object.defineProperties(THREE.Material.prototype, {
        wrapAround: {
          get: function () {
            console.warn(
              "THREE." + this.type + ": .wrapAround has been removed."
            );
          },
          set: function (a) {
            console.warn(
              "THREE." + this.type + ": .wrapAround has been removed."
            );
          },
        },
        wrapRGB: {
          get: function () {
            console.warn("THREE." + this.type + ": .wrapRGB has been removed.");
            return new THREE.Color();
          },
        },
      });
      Object.defineProperties(THREE, {
        PointCloudMaterial: {
          value: function (a) {
            console.warn(
              "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
            );
            return new THREE.PointsMaterial(a);
          },
        },
        ParticleBasicMaterial: {
          value: function (a) {
            console.warn(
              "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
            );
            return new THREE.PointsMaterial(a);
          },
        },
        ParticleSystemMaterial: {
          value: function (a) {
            console.warn(
              "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
            );
            return new THREE.PointsMaterial(a);
          },
        },
      });
      Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
        metal: {
          get: function () {
            console.warn(
              "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
            );
            return !1;
          },
          set: function (a) {
            console.warn(
              "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
            );
          },
        },
      });
      Object.defineProperties(THREE.ShaderMaterial.prototype, {
        derivatives: {
          get: function () {
            console.warn(
              "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            );
            return this.extensions.derivatives;
          },
          set: function (a) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            );
            this.extensions.derivatives = a;
          },
        },
      });
      Object.defineProperties(THREE.WebGLRenderer.prototype, {
        supportsFloatTextures: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
            );
            return this.extensions.get("OES_texture_float");
          },
        },
        supportsHalfFloatTextures: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
            );
            return this.extensions.get("OES_texture_half_float");
          },
        },
        supportsStandardDerivatives: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
            );
            return this.extensions.get("OES_standard_derivatives");
          },
        },
        supportsCompressedTextureS3TC: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
            );
            return this.extensions.get("WEBGL_compressed_texture_s3tc");
          },
        },
        supportsCompressedTexturePVRTC: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
            );
            return this.extensions.get("WEBGL_compressed_texture_pvrtc");
          },
        },
        supportsBlendMinMax: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
            );
            return this.extensions.get("EXT_blend_minmax");
          },
        },
        supportsVertexTextures: {
          value: function () {
            return this.capabilities.vertexTextures;
          },
        },
        supportsInstancedArrays: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
            );
            return this.extensions.get("ANGLE_instanced_arrays");
          },
        },
        enableScissorTest: {
          value: function (a) {
            console.warn(
              "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
            );
            this.setScissorTest(a);
          },
        },
        initMaterial: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .initMaterial() has been removed."
            );
          },
        },
        addPrePlugin: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .addPrePlugin() has been removed."
            );
          },
        },
        addPostPlugin: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .addPostPlugin() has been removed."
            );
          },
        },
        updateShadowMap: {
          value: function () {
            console.warn(
              "THREE.WebGLRenderer: .updateShadowMap() has been removed."
            );
          },
        },
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            );
            this.shadowMap.enabled = a;
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            );
            this.shadowMap.type = a;
          },
        },
        shadowMapCullFace: {
          get: function () {
            return this.shadowMap.cullFace;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."
            );
            this.shadowMap.cullFace = a;
          },
        },
      });
      Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
        wrapS: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            );
            return this.texture.wrapS;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            );
            this.texture.wrapS = a;
          },
        },
        wrapT: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            );
            return this.texture.wrapT;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            );
            this.texture.wrapT = a;
          },
        },
        magFilter: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            );
            return this.texture.magFilter;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            );
            this.texture.magFilter = a;
          },
        },
        minFilter: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            );
            return this.texture.minFilter;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            );
            this.texture.minFilter = a;
          },
        },
        anisotropy: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            );
            return this.texture.anisotropy;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            );
            this.texture.anisotropy = a;
          },
        },
        offset: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            );
            return this.texture.offset;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            );
            this.texture.offset = a;
          },
        },
        repeat: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            );
            return this.texture.repeat;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            );
            this.texture.repeat = a;
          },
        },
        format: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            );
            return this.texture.format;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            );
            this.texture.format = a;
          },
        },
        type: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            );
            return this.texture.type;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            );
            this.texture.type = a;
          },
        },
        generateMipmaps: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            );
            return this.texture.generateMipmaps;
          },
          set: function (a) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            );
            this.texture.generateMipmaps = a;
          },
        },
      });
      THREE.GeometryUtils = {
        merge: function (a, b, c) {
          console.warn(
            "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
          );
          var d;
          b instanceof THREE.Mesh &&
            (b.matrixAutoUpdate && b.updateMatrix(),
            (d = b.matrix),
            (b = b.geometry));
          a.merge(b, d, c);
        },
        center: function (a) {
          console.warn(
            "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
          );
          return a.center();
        },
      };
      THREE.ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function (a, b, c, d) {
          console.warn(
            "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
          );
          var e = new THREE.TextureLoader();
          e.setCrossOrigin(this.crossOrigin);
          a = e.load(a, c, void 0, d);
          b && (a.mapping = b);
          return a;
        },
        loadTextureCube: function (a, b, c, d) {
          console.warn(
            "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
          );
          var e = new THREE.CubeTextureLoader();
          e.setCrossOrigin(this.crossOrigin);
          a = e.load(a, c, void 0, d);
          b && (a.mapping = b);
          return a;
        },
        loadCompressedTexture: function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
          );
        },
        loadCompressedTextureCube: function () {
          console.error(
            "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
          );
        },
      };
      THREE.Projector = function () {
        console.error(
          "THREE.Projector has been moved to /examples/js/renderers/Projector.js."
        );
        this.projectVector = function (a, b) {
          console.warn(
            "THREE.Projector: .projectVector() is now vector.project()."
          );
          a.project(b);
        };
        this.unprojectVector = function (a, b) {
          console.warn(
            "THREE.Projector: .unprojectVector() is now vector.unproject()."
          );
          a.unproject(b);
        };
        this.pickingRay = function (a, b) {
          console.error(
            "THREE.Projector: .pickingRay() is now raycaster.setFromCamera()."
          );
        };
      };
      THREE.CanvasRenderer = function () {
        console.error(
          "THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"
        );
        this.domElement = document.createElement("canvas");
        this.clear = function () {};
        this.render = function () {};
        this.setClearColor = function () {};
        this.setSize = function () {};
      };
      THREE.MeshFaceMaterial = THREE.MultiMaterial;
      THREE.CurveUtils = {
        tangentQuadraticBezier: function (a, b, c, d) {
          return 2 * (1 - a) * (c - b) + 2 * a * (d - c);
        },
        tangentCubicBezier: function (a, b, c, d, e) {
          return (
            -3 * b * (1 - a) * (1 - a) +
            3 * c * (1 - a) * (1 - a) -
            6 * a * c * (1 - a) +
            6 * a * d * (1 - a) -
            3 * a * a * d +
            3 * a * a * e
          );
        },
        tangentSpline: function (a, b, c, d, e) {
          return (
            6 * a * a -
            6 * a +
            (3 * a * a - 4 * a + 1) +
            (-6 * a * a + 6 * a) +
            (3 * a * a - 2 * a)
          );
        },
        interpolate: function (a, b, c, d, e) {
          a = 0.5 * (c - a);
          d = 0.5 * (d - b);
          var f = e * e;
          return (
            (2 * b - 2 * c + a + d) * e * f +
            (-3 * b + 3 * c - 2 * a - d) * f +
            a * e +
            b
          );
        },
      };
      THREE.SceneUtils = {
        createMultiMaterialObject: function (a, b) {
          for (var c = new THREE.Group(), d = 0, e = b.length; d < e; d++)
            c.add(new THREE.Mesh(a, b[d]));
          return c;
        },
        detach: function (a, b, c) {
          a.applyMatrix(b.matrixWorld);
          b.remove(a);
          c.add(a);
        },
        attach: function (a, b, c) {
          var d = new THREE.Matrix4();
          d.getInverse(c.matrixWorld);
          a.applyMatrix(d);
          b.remove(a);
          c.add(a);
        },
      };
      THREE.ShapeUtils = {
        area: function (a) {
          for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++)
            c += a[d].x * a[e].y - a[e].x * a[d].y;
          return 0.5 * c;
        },
        triangulate: (function () {
          return function (a, b) {
            var c = a.length;
            if (3 > c) return null;
            var d = [],
              e = [],
              f = [],
              g,
              h,
              k;
            if (0 < THREE.ShapeUtils.area(a)) for (h = 0; h < c; h++) e[h] = h;
            else for (h = 0; h < c; h++) e[h] = c - 1 - h;
            var l = 2 * c;
            for (h = c - 1; 2 < c; ) {
              if (0 >= l--) {
                console.warn(
                  "THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"
                );
                break;
              }
              g = h;
              c <= g && (g = 0);
              h = g + 1;
              c <= h && (h = 0);
              k = h + 1;
              c <= k && (k = 0);
              var n;
              a: {
                var p = (n = void 0),
                  m = void 0,
                  q = void 0,
                  s = void 0,
                  u = void 0,
                  t = void 0,
                  x = void 0,
                  v = void 0,
                  p = a[e[g]].x,
                  m = a[e[g]].y,
                  q = a[e[h]].x,
                  s = a[e[h]].y,
                  u = a[e[k]].x,
                  t = a[e[k]].y;
                if (Number.EPSILON > (q - p) * (t - m) - (s - m) * (u - p))
                  n = !1;
                else {
                  var C = void 0,
                    w = void 0,
                    D = void 0,
                    z = void 0,
                    y = void 0,
                    A = void 0,
                    H = void 0,
                    G = void 0,
                    E = void 0,
                    K = void 0,
                    E = (G = H = v = x = void 0),
                    C = u - q,
                    w = t - s,
                    D = p - u,
                    z = m - t,
                    y = q - p,
                    A = s - m;
                  for (n = 0; n < c; n++)
                    if (
                      ((x = a[e[n]].x),
                      (v = a[e[n]].y),
                      !(
                        (x === p && v === m) ||
                        (x === q && v === s) ||
                        (x === u && v === t)
                      ) &&
                        ((H = x - p),
                        (G = v - m),
                        (E = x - q),
                        (K = v - s),
                        (x -= u),
                        (v -= t),
                        (E = C * K - w * E),
                        (H = y * G - A * H),
                        (G = D * v - z * x),
                        E >= -Number.EPSILON &&
                          G >= -Number.EPSILON &&
                          H >= -Number.EPSILON))
                    ) {
                      n = !1;
                      break a;
                    }
                  n = !0;
                }
              }
              if (n) {
                d.push([a[e[g]], a[e[h]], a[e[k]]]);
                f.push([e[g], e[h], e[k]]);
                g = h;
                for (k = h + 1; k < c; g++, k++) e[g] = e[k];
                c--;
                l = 2 * c;
              }
            }
            return b ? f : d;
          };
        })(),
        triangulateShape: function (a, b) {
          function c(a, b, c) {
            return a.x !== b.x
              ? a.x < b.x
                ? a.x <= c.x && c.x <= b.x
                : b.x <= c.x && c.x <= a.x
              : a.y < b.y
              ? a.y <= c.y && c.y <= b.y
              : b.y <= c.y && c.y <= a.y;
          }
          function d(a, b, d, e, f) {
            var g = b.x - a.x,
              h = b.y - a.y,
              k = e.x - d.x,
              l = e.y - d.y,
              n = a.x - d.x,
              p = a.y - d.y,
              y = h * k - g * l,
              A = h * n - g * p;
            if (Math.abs(y) > Number.EPSILON) {
              if (0 < y) {
                if (0 > A || A > y) return [];
                k = l * n - k * p;
                if (0 > k || k > y) return [];
              } else {
                if (0 < A || A < y) return [];
                k = l * n - k * p;
                if (0 < k || k < y) return [];
              }
              if (0 === k) return !f || (0 !== A && A !== y) ? [a] : [];
              if (k === y) return !f || (0 !== A && A !== y) ? [b] : [];
              if (0 === A) return [d];
              if (A === y) return [e];
              f = k / y;
              return [{ x: a.x + f * g, y: a.y + f * h }];
            }
            if (0 !== A || l * n !== k * p) return [];
            h = 0 === g && 0 === h;
            k = 0 === k && 0 === l;
            if (h && k) return a.x !== d.x || a.y !== d.y ? [] : [a];
            if (h) return c(d, e, a) ? [a] : [];
            if (k) return c(a, b, d) ? [d] : [];
            0 !== g
              ? (a.x < b.x
                  ? ((g = a), (k = a.x), (h = b), (a = b.x))
                  : ((g = b), (k = b.x), (h = a), (a = a.x)),
                d.x < e.x
                  ? ((b = d), (y = d.x), (l = e), (d = e.x))
                  : ((b = e), (y = e.x), (l = d), (d = d.x)))
              : (a.y < b.y
                  ? ((g = a), (k = a.y), (h = b), (a = b.y))
                  : ((g = b), (k = b.y), (h = a), (a = a.y)),
                d.y < e.y
                  ? ((b = d), (y = d.y), (l = e), (d = e.y))
                  : ((b = e), (y = e.y), (l = d), (d = d.y)));
            return k <= y
              ? a < y
                ? []
                : a === y
                ? f
                  ? []
                  : [b]
                : a <= d
                ? [b, h]
                : [b, l]
              : k > d
              ? []
              : k === d
              ? f
                ? []
                : [g]
              : a <= d
              ? [g, h]
              : [g, l];
          }
          function e(a, b, c, d) {
            var e = b.x - a.x,
              f = b.y - a.y;
            b = c.x - a.x;
            c = c.y - a.y;
            var g = d.x - a.x;
            d = d.y - a.y;
            a = e * c - f * b;
            e = e * d - f * g;
            return Math.abs(a) > Number.EPSILON
              ? ((b = g * c - d * b),
                0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b)
              : 0 < e;
          }
          var f,
            g,
            h,
            k,
            l,
            n = {};
          h = a.concat();
          f = 0;
          for (g = b.length; f < g; f++) Array.prototype.push.apply(h, b[f]);
          f = 0;
          for (g = h.length; f < g; f++)
            (l = h[f].x + ":" + h[f].y),
              void 0 !== n[l] &&
                console.warn("THREE.Shape: Duplicate point", l),
              (n[l] = f);
          f = (function (a, b) {
            function c(a, b) {
              var d = h.length - 1,
                f = a - 1;
              0 > f && (f = d);
              var g = a + 1;
              g > d && (g = 0);
              d = e(h[a], h[f], h[g], k[b]);
              if (!d) return !1;
              d = k.length - 1;
              f = b - 1;
              0 > f && (f = d);
              g = b + 1;
              g > d && (g = 0);
              return (d = e(k[b], k[f], k[g], h[a])) ? !0 : !1;
            }
            function f(a, b) {
              var c, e;
              for (c = 0; c < h.length; c++)
                if (
                  ((e = c + 1),
                  (e %= h.length),
                  (e = d(a, b, h[c], h[e], !0)),
                  0 < e.length)
                )
                  return !0;
              return !1;
            }
            function g(a, c) {
              var e, f, h, k;
              for (e = 0; e < l.length; e++)
                for (f = b[l[e]], h = 0; h < f.length; h++)
                  if (
                    ((k = h + 1),
                    (k %= f.length),
                    (k = d(a, c, f[h], f[k], !0)),
                    0 < k.length)
                  )
                    return !0;
              return !1;
            }
            var h = a.concat(),
              k,
              l = [],
              n,
              p,
              z,
              y,
              A,
              H = [],
              G,
              E,
              K,
              P = 0;
            for (n = b.length; P < n; P++) l.push(P);
            G = 0;
            for (var N = 2 * l.length; 0 < l.length; ) {
              N--;
              if (0 > N) {
                console.log(
                  "Infinite Loop! Holes left:" +
                    l.length +
                    ", Probably Hole outside Shape!"
                );
                break;
              }
              for (p = G; p < h.length; p++) {
                z = h[p];
                n = -1;
                for (P = 0; P < l.length; P++)
                  if (
                    ((y = l[P]),
                    (A = z.x + ":" + z.y + ":" + y),
                    void 0 === H[A])
                  ) {
                    k = b[y];
                    for (E = 0; E < k.length; E++)
                      if (((y = k[E]), c(p, E) && !f(z, y) && !g(z, y))) {
                        n = E;
                        l.splice(P, 1);
                        G = h.slice(0, p + 1);
                        y = h.slice(p);
                        E = k.slice(n);
                        K = k.slice(0, n + 1);
                        h = G.concat(E).concat(K).concat(y);
                        G = p;
                        break;
                      }
                    if (0 <= n) break;
                    H[A] = !0;
                  }
                if (0 <= n) break;
              }
            }
            return h;
          })(a, b);
          var p = THREE.ShapeUtils.triangulate(f, !1);
          f = 0;
          for (g = p.length; f < g; f++)
            for (k = p[f], h = 0; 3 > h; h++)
              (l = k[h].x + ":" + k[h].y),
                (l = n[l]),
                void 0 !== l && (k[h] = l);
          return p.concat();
        },
        isClockWise: function (a) {
          return 0 > THREE.ShapeUtils.area(a);
        },
        b2: (function () {
          return function (a, b, c, d) {
            var e = 1 - a;
            return e * e * b + 2 * (1 - a) * a * c + a * a * d;
          };
        })(),
        b3: (function () {
          return function (a, b, c, d, e) {
            var f = 1 - a,
              g = 1 - a;
            return (
              f * f * f * b +
              3 * g * g * a * c +
              3 * (1 - a) * a * a * d +
              a * a * a * e
            );
          };
        })(),
      };
      THREE.Curve = function () {};
      THREE.Curve.prototype = {
        constructor: THREE.Curve,
        getPoint: function (a) {
          console.warn("THREE.Curve: Warning, getPoint() not implemented!");
          return null;
        },
        getPointAt: function (a) {
          a = this.getUtoTmapping(a);
          return this.getPoint(a);
        },
        getPoints: function (a) {
          a || (a = 5);
          var b,
            c = [];
          for (b = 0; b <= a; b++) c.push(this.getPoint(b / a));
          return c;
        },
        getSpacedPoints: function (a) {
          a || (a = 5);
          var b,
            c = [];
          for (b = 0; b <= a; b++) c.push(this.getPointAt(b / a));
          return c;
        },
        getLength: function () {
          var a = this.getLengths();
          return a[a.length - 1];
        },
        getLengths: function (a) {
          a ||
            (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === a + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          var b = [],
            c,
            d = this.getPoint(0),
            e,
            f = 0;
          b.push(0);
          for (e = 1; e <= a; e++)
            (c = this.getPoint(e / a)),
              (f += c.distanceTo(d)),
              b.push(f),
              (d = c);
          return (this.cacheArcLengths = b);
        },
        updateArcLengths: function () {
          this.needsUpdate = !0;
          this.getLengths();
        },
        getUtoTmapping: function (a, b) {
          var c = this.getLengths(),
            d = 0,
            e = c.length,
            f;
          f = b ? b : a * c[e - 1];
          for (var g = 0, h = e - 1, k; g <= h; )
            if (((d = Math.floor(g + (h - g) / 2)), (k = c[d] - f), 0 > k))
              g = d + 1;
            else if (0 < k) h = d - 1;
            else {
              h = d;
              break;
            }
          d = h;
          if (c[d] === f) return d / (e - 1);
          g = c[d];
          return (c = (d + (f - g) / (c[d + 1] - g)) / (e - 1));
        },
        getTangent: function (a) {
          var b = a - 1e-4;
          a += 1e-4;
          0 > b && (b = 0);
          1 < a && (a = 1);
          b = this.getPoint(b);
          return this.getPoint(a).clone().sub(b).normalize();
        },
        getTangentAt: function (a) {
          a = this.getUtoTmapping(a);
          return this.getTangent(a);
        },
      };
      THREE.Curve.create = function (a, b) {
        a.prototype = Object.create(THREE.Curve.prototype);
        a.prototype.constructor = a;
        a.prototype.getPoint = b;
        return a;
      };
      THREE.CurvePath = function () {
        this.curves = [];
        this.autoClose = !1;
      };
      THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
      THREE.CurvePath.prototype.constructor = THREE.CurvePath;
      THREE.CurvePath.prototype.add = function (a) {
        this.curves.push(a);
      };
      THREE.CurvePath.prototype.closePath = function () {
        var a = this.curves[0].getPoint(0),
          b = this.curves[this.curves.length - 1].getPoint(1);
        a.equals(b) || this.curves.push(new THREE.LineCurve(b, a));
      };
      THREE.CurvePath.prototype.getPoint = function (a) {
        for (
          var b = a * this.getLength(), c = this.getCurveLengths(), d = 0;
          d < c.length;

        ) {
          if (c[d] >= b)
            return (
              (a = this.curves[d]),
              (b = 1 - (c[d] - b) / a.getLength()),
              a.getPointAt(b)
            );
          d++;
        }
        return null;
      };
      THREE.CurvePath.prototype.getLength = function () {
        var a = this.getCurveLengths();
        return a[a.length - 1];
      };
      THREE.CurvePath.prototype.getCurveLengths = function () {
        if (
          this.cacheLengths &&
          this.cacheLengths.length === this.curves.length
        )
          return this.cacheLengths;
        for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++)
          (b += this.curves[c].getLength()), a.push(b);
        return (this.cacheLengths = a);
      };
      THREE.CurvePath.prototype.createPointsGeometry = function (a) {
        a = this.getPoints(a);
        return this.createGeometry(a);
      };
      THREE.CurvePath.prototype.createSpacedPointsGeometry = function (a) {
        a = this.getSpacedPoints(a);
        return this.createGeometry(a);
      };
      THREE.CurvePath.prototype.createGeometry = function (a) {
        for (var b = new THREE.Geometry(), c = 0, d = a.length; c < d; c++) {
          var e = a[c];
          b.vertices.push(new THREE.Vector3(e.x, e.y, e.z || 0));
        }
        return b;
      };
      THREE.Font = function (a) {
        this.data = a;
      };
      THREE.Font.prototype = {
        constructor: THREE.Font,
        generateShapes: function (a, b, c) {
          void 0 === b && (b = 100);
          void 0 === c && (c = 4);
          var d = this.data;
          a = String(a).split("");
          var e = b / d.resolution,
            f = 0;
          b = [];
          for (var g = 0; g < a.length; g++) {
            var h;
            h = e;
            var k = f,
              l = d.glyphs[a[g]] || d.glyphs["?"];
            if (l) {
              var n = new THREE.Path(),
                p = [],
                m = THREE.ShapeUtils.b2,
                q = THREE.ShapeUtils.b3,
                s = void 0,
                u = void 0,
                t = (u = s = void 0),
                x = void 0,
                v = void 0,
                C = void 0,
                w = void 0,
                D = void 0,
                x = void 0;
              if (l.o)
                for (
                  var z =
                      l._cachedOutline || (l._cachedOutline = l.o.split(" ")),
                    y = 0,
                    A = z.length;
                  y < A;

                )
                  switch (z[y++]) {
                    case "m":
                      s = z[y++] * h + k;
                      u = z[y++] * h;
                      n.moveTo(s, u);
                      break;
                    case "l":
                      s = z[y++] * h + k;
                      u = z[y++] * h;
                      n.lineTo(s, u);
                      break;
                    case "q":
                      s = z[y++] * h + k;
                      u = z[y++] * h;
                      v = z[y++] * h + k;
                      C = z[y++] * h;
                      n.quadraticCurveTo(v, C, s, u);
                      if ((x = p[p.length - 1]))
                        for (var t = x.x, x = x.y, H = 1; H <= c; H++) {
                          var G = H / c;
                          m(G, t, v, s);
                          m(G, x, C, u);
                        }
                      break;
                    case "b":
                      if (
                        ((s = z[y++] * h + k),
                        (u = z[y++] * h),
                        (v = z[y++] * h + k),
                        (C = z[y++] * h),
                        (w = z[y++] * h + k),
                        (D = z[y++] * h),
                        n.bezierCurveTo(v, C, w, D, s, u),
                        (x = p[p.length - 1]))
                      )
                        for (t = x.x, x = x.y, H = 1; H <= c; H++)
                          (G = H / c), q(G, t, v, w, s), q(G, x, C, D, u);
                  }
              h = { offset: l.ha * h, path: n };
            } else h = void 0;
            f += h.offset;
            b.push(h.path);
          }
          c = [];
          d = 0;
          for (a = b.length; d < a; d++)
            Array.prototype.push.apply(c, b[d].toShapes());
          return c;
        },
      };
      THREE.Path = function (a) {
        THREE.CurvePath.call(this);
        this.actions = [];
        a && this.fromPoints(a);
      };
      THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
      THREE.Path.prototype.constructor = THREE.Path;
      THREE.Path.prototype.fromPoints = function (a) {
        this.moveTo(a[0].x, a[0].y);
        for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y);
      };
      THREE.Path.prototype.moveTo = function (a, b) {
        this.actions.push({ action: "moveTo", args: [a, b] });
      };
      THREE.Path.prototype.lineTo = function (a, b) {
        var c = this.actions[this.actions.length - 1].args,
          c = new THREE.LineCurve(
            new THREE.Vector2(c[c.length - 2], c[c.length - 1]),
            new THREE.Vector2(a, b)
          );
        this.curves.push(c);
        this.actions.push({ action: "lineTo", args: [a, b] });
      };
      THREE.Path.prototype.quadraticCurveTo = function (a, b, c, d) {
        var e = this.actions[this.actions.length - 1].args,
          e = new THREE.QuadraticBezierCurve(
            new THREE.Vector2(e[e.length - 2], e[e.length - 1]),
            new THREE.Vector2(a, b),
            new THREE.Vector2(c, d)
          );
        this.curves.push(e);
        this.actions.push({ action: "quadraticCurveTo", args: [a, b, c, d] });
      };
      THREE.Path.prototype.bezierCurveTo = function (a, b, c, d, e, f) {
        var g = this.actions[this.actions.length - 1].args,
          g = new THREE.CubicBezierCurve(
            new THREE.Vector2(g[g.length - 2], g[g.length - 1]),
            new THREE.Vector2(a, b),
            new THREE.Vector2(c, d),
            new THREE.Vector2(e, f)
          );
        this.curves.push(g);
        this.actions.push({
          action: "bezierCurveTo",
          args: [a, b, c, d, e, f],
        });
      };
      THREE.Path.prototype.splineThru = function (a) {
        var b = Array.prototype.slice.call(arguments),
          c = this.actions[this.actions.length - 1].args,
          c = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])];
        Array.prototype.push.apply(c, a);
        c = new THREE.SplineCurve(c);
        this.curves.push(c);
        this.actions.push({ action: "splineThru", args: b });
      };
      THREE.Path.prototype.arc = function (a, b, c, d, e, f) {
        var g = this.actions[this.actions.length - 1].args;
        this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f);
      };
      THREE.Path.prototype.absarc = function (a, b, c, d, e, f) {
        this.absellipse(a, b, c, c, d, e, f);
      };
      THREE.Path.prototype.ellipse = function (a, b, c, d, e, f, g, h) {
        var k = this.actions[this.actions.length - 1].args;
        this.absellipse(
          a + k[k.length - 2],
          b + k[k.length - 1],
          c,
          d,
          e,
          f,
          g,
          h
        );
      };
      THREE.Path.prototype.absellipse = function (a, b, c, d, e, f, g, h) {
        var k = [a, b, c, d, e, f, g, h || 0];
        a = new THREE.EllipseCurve(a, b, c, d, e, f, g, h);
        this.curves.push(a);
        a = a.getPoint(1);
        k.push(a.x);
        k.push(a.y);
        this.actions.push({ action: "ellipse", args: k });
      };
      THREE.Path.prototype.getSpacedPoints = function (a) {
        a || (a = 40);
        for (var b = [], c = 0; c < a; c++) b.push(this.getPoint(c / a));
        this.autoClose && b.push(b[0]);
        return b;
      };
      THREE.Path.prototype.getPoints = function (a) {
        a = a || 12;
        for (
          var b = THREE.ShapeUtils.b2,
            c = THREE.ShapeUtils.b3,
            d = [],
            e,
            f,
            g,
            h,
            k,
            l,
            n,
            p,
            m,
            q,
            s = 0,
            u = this.actions.length;
          s < u;
          s++
        ) {
          m = this.actions[s];
          var t = m.args;
          switch (m.action) {
            case "moveTo":
              d.push(new THREE.Vector2(t[0], t[1]));
              break;
            case "lineTo":
              d.push(new THREE.Vector2(t[0], t[1]));
              break;
            case "quadraticCurveTo":
              e = t[2];
              f = t[3];
              k = t[0];
              l = t[1];
              0 < d.length
                ? ((m = d[d.length - 1]), (n = m.x), (p = m.y))
                : ((m = this.actions[s - 1].args),
                  (n = m[m.length - 2]),
                  (p = m[m.length - 1]));
              for (t = 1; t <= a; t++)
                (q = t / a),
                  (m = b(q, n, k, e)),
                  (q = b(q, p, l, f)),
                  d.push(new THREE.Vector2(m, q));
              break;
            case "bezierCurveTo":
              e = t[4];
              f = t[5];
              k = t[0];
              l = t[1];
              g = t[2];
              h = t[3];
              0 < d.length
                ? ((m = d[d.length - 1]), (n = m.x), (p = m.y))
                : ((m = this.actions[s - 1].args),
                  (n = m[m.length - 2]),
                  (p = m[m.length - 1]));
              for (t = 1; t <= a; t++)
                (q = t / a),
                  (m = c(q, n, k, g, e)),
                  (q = c(q, p, l, h, f)),
                  d.push(new THREE.Vector2(m, q));
              break;
            case "splineThru":
              m = this.actions[s - 1].args;
              q = [new THREE.Vector2(m[m.length - 2], m[m.length - 1])];
              m = a * t[0].length;
              q = q.concat(t[0]);
              q = new THREE.SplineCurve(q);
              for (t = 1; t <= m; t++) d.push(q.getPointAt(t / m));
              break;
            case "arc":
              e = t[0];
              f = t[1];
              l = t[2];
              g = t[3];
              m = t[4];
              k = !!t[5];
              n = m - g;
              p = 2 * a;
              for (t = 1; t <= p; t++)
                (q = t / p),
                  k || (q = 1 - q),
                  (q = g + q * n),
                  (m = e + l * Math.cos(q)),
                  (q = f + l * Math.sin(q)),
                  d.push(new THREE.Vector2(m, q));
              break;
            case "ellipse":
              e = t[0];
              f = t[1];
              l = t[2];
              h = t[3];
              g = t[4];
              m = t[5];
              k = !!t[6];
              var x = t[7];
              n = m - g;
              p = 2 * a;
              var v, C;
              0 !== x && ((v = Math.cos(x)), (C = Math.sin(x)));
              for (t = 1; t <= p; t++) {
                q = t / p;
                k || (q = 1 - q);
                q = g + q * n;
                m = e + l * Math.cos(q);
                q = f + h * Math.sin(q);
                if (0 !== x) {
                  var w = m;
                  m = (w - e) * v - (q - f) * C + e;
                  q = (w - e) * C + (q - f) * v + f;
                }
                d.push(new THREE.Vector2(m, q));
              }
          }
        }
        a = d[d.length - 1];
        Math.abs(a.x - d[0].x) < Number.EPSILON &&
          Math.abs(a.y - d[0].y) < Number.EPSILON &&
          d.splice(d.length - 1, 1);
        this.autoClose && d.push(d[0]);
        return d;
      };
      THREE.Path.prototype.toShapes = function (a, b) {
        function c(a) {
          for (var b = [], c = 0, d = a.length; c < d; c++) {
            var e = a[c],
              f = new THREE.Shape();
            f.actions = e.actions;
            f.curves = e.curves;
            b.push(f);
          }
          return b;
        }
        function d(a, b) {
          for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
            var g = b[e],
              h = b[f],
              k = h.x - g.x,
              l = h.y - g.y;
            if (Math.abs(l) > Number.EPSILON) {
              if (
                (0 > l && ((g = b[f]), (k = -k), (h = b[e]), (l = -l)),
                !(a.y < g.y || a.y > h.y))
              )
                if (a.y === g.y) {
                  if (a.x === g.x) return !0;
                } else {
                  e = l * (a.x - g.x) - k * (a.y - g.y);
                  if (0 === e) return !0;
                  0 > e || (d = !d);
                }
            } else if (
              a.y === g.y &&
              ((h.x <= a.x && a.x <= g.x) || (g.x <= a.x && a.x <= h.x))
            )
              return !0;
          }
          return d;
        }
        var e = THREE.ShapeUtils.isClockWise,
          f = (function (a) {
            for (
              var b = [], c = new THREE.Path(), d = 0, e = a.length;
              d < e;
              d++
            ) {
              var f = a[d],
                g = f.args,
                f = f.action;
              "moveTo" === f &&
                0 !== c.actions.length &&
                (b.push(c), (c = new THREE.Path()));
              c[f].apply(c, g);
            }
            0 !== c.actions.length && b.push(c);
            return b;
          })(this.actions);
        if (0 === f.length) return [];
        if (!0 === b) return c(f);
        var g,
          h,
          k,
          l = [];
        if (1 === f.length)
          return (
            (h = f[0]),
            (k = new THREE.Shape()),
            (k.actions = h.actions),
            (k.curves = h.curves),
            l.push(k),
            l
          );
        var n = !e(f[0].getPoints()),
          n = a ? !n : n;
        k = [];
        var p = [],
          m = [],
          q = 0,
          s;
        p[q] = void 0;
        m[q] = [];
        for (var u = 0, t = f.length; u < t; u++)
          (h = f[u]),
            (s = h.getPoints()),
            (g = e(s)),
            (g = a ? !g : g)
              ? (!n && p[q] && q++,
                (p[q] = { s: new THREE.Shape(), p: s }),
                (p[q].s.actions = h.actions),
                (p[q].s.curves = h.curves),
                n && q++,
                (m[q] = []))
              : m[q].push({ h: h, p: s[0] });
        if (!p[0]) return c(f);
        if (1 < p.length) {
          u = !1;
          h = [];
          e = 0;
          for (f = p.length; e < f; e++) k[e] = [];
          e = 0;
          for (f = p.length; e < f; e++)
            for (g = m[e], n = 0; n < g.length; n++) {
              q = g[n];
              s = !0;
              for (t = 0; t < p.length; t++)
                d(q.p, p[t].p) &&
                  (e !== t && h.push({ froms: e, tos: t, hole: n }),
                  s ? ((s = !1), k[t].push(q)) : (u = !0));
              s && k[e].push(q);
            }
          0 < h.length && (u || (m = k));
        }
        u = 0;
        for (e = p.length; u < e; u++)
          for (k = p[u].s, l.push(k), h = m[u], f = 0, g = h.length; f < g; f++)
            k.holes.push(h[f].h);
        return l;
      };
      THREE.Shape = function () {
        THREE.Path.apply(this, arguments);
        this.holes = [];
      };
      THREE.Shape.prototype = Object.create(THREE.Path.prototype);
      THREE.Shape.prototype.constructor = THREE.Shape;
      THREE.Shape.prototype.extrude = function (a) {
        return new THREE.ExtrudeGeometry(this, a);
      };
      THREE.Shape.prototype.makeGeometry = function (a) {
        return new THREE.ShapeGeometry(this, a);
      };
      THREE.Shape.prototype.getPointsHoles = function (a) {
        for (var b = [], c = 0, d = this.holes.length; c < d; c++)
          b[c] = this.holes[c].getPoints(a);
        return b;
      };
      THREE.Shape.prototype.extractAllPoints = function (a) {
        return { shape: this.getPoints(a), holes: this.getPointsHoles(a) };
      };
      THREE.Shape.prototype.extractPoints = function (a) {
        return this.extractAllPoints(a);
      };
      THREE.LineCurve = function (a, b) {
        this.v1 = a;
        this.v2 = b;
      };
      THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
      THREE.LineCurve.prototype.constructor = THREE.LineCurve;
      THREE.LineCurve.prototype.getPoint = function (a) {
        var b = this.v2.clone().sub(this.v1);
        b.multiplyScalar(a).add(this.v1);
        return b;
      };
      THREE.LineCurve.prototype.getPointAt = function (a) {
        return this.getPoint(a);
      };
      THREE.LineCurve.prototype.getTangent = function (a) {
        return this.v2.clone().sub(this.v1).normalize();
      };
      THREE.QuadraticBezierCurve = function (a, b, c) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = c;
      };
      THREE.QuadraticBezierCurve.prototype = Object.create(
        THREE.Curve.prototype
      );
      THREE.QuadraticBezierCurve.prototype.constructor =
        THREE.QuadraticBezierCurve;
      THREE.QuadraticBezierCurve.prototype.getPoint = function (a) {
        var b = THREE.ShapeUtils.b2;
        return new THREE.Vector2(
          b(a, this.v0.x, this.v1.x, this.v2.x),
          b(a, this.v0.y, this.v1.y, this.v2.y)
        );
      };
      THREE.QuadraticBezierCurve.prototype.getTangent = function (a) {
        var b = THREE.CurveUtils.tangentQuadraticBezier;
        return new THREE.Vector2(
          b(a, this.v0.x, this.v1.x, this.v2.x),
          b(a, this.v0.y, this.v1.y, this.v2.y)
        ).normalize();
      };
      THREE.CubicBezierCurve = function (a, b, c, d) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = c;
        this.v3 = d;
      };
      THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
      THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
      THREE.CubicBezierCurve.prototype.getPoint = function (a) {
        var b = THREE.ShapeUtils.b3;
        return new THREE.Vector2(
          b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
          b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y)
        );
      };
      THREE.CubicBezierCurve.prototype.getTangent = function (a) {
        var b = THREE.CurveUtils.tangentCubicBezier;
        return new THREE.Vector2(
          b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
          b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y)
        ).normalize();
      };
      THREE.SplineCurve = function (a) {
        this.points = void 0 == a ? [] : a;
      };
      THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
      THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
      THREE.SplineCurve.prototype.getPoint = function (a) {
        var b = this.points;
        a *= b.length - 1;
        var c = Math.floor(a);
        a -= c;
        var d = b[0 === c ? c : c - 1],
          e = b[c],
          f = b[c > b.length - 2 ? b.length - 1 : c + 1],
          b = b[c > b.length - 3 ? b.length - 1 : c + 2],
          c = THREE.CurveUtils.interpolate;
        return new THREE.Vector2(
          c(d.x, e.x, f.x, b.x, a),
          c(d.y, e.y, f.y, b.y, a)
        );
      };
      THREE.EllipseCurve = function (a, b, c, d, e, f, g, h) {
        this.aX = a;
        this.aY = b;
        this.xRadius = c;
        this.yRadius = d;
        this.aStartAngle = e;
        this.aEndAngle = f;
        this.aClockwise = g;
        this.aRotation = h || 0;
      };
      THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
      THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
      THREE.EllipseCurve.prototype.getPoint = function (a) {
        var b = this.aEndAngle - this.aStartAngle;
        0 > b && (b += 2 * Math.PI);
        b > 2 * Math.PI && (b -= 2 * Math.PI);
        b =
          !0 === this.aClockwise
            ? this.aEndAngle + (1 - a) * (2 * Math.PI - b)
            : this.aStartAngle + a * b;
        a = this.aX + this.xRadius * Math.cos(b);
        var c = this.aY + this.yRadius * Math.sin(b);
        if (0 !== this.aRotation) {
          var b = Math.cos(this.aRotation),
            d = Math.sin(this.aRotation),
            e = a;
          a = (e - this.aX) * b - (c - this.aY) * d + this.aX;
          c = (e - this.aX) * d + (c - this.aY) * b + this.aY;
        }
        return new THREE.Vector2(a, c);
      };
      THREE.ArcCurve = function (a, b, c, d, e, f) {
        THREE.EllipseCurve.call(this, a, b, c, c, d, e, f);
      };
      THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
      THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
      THREE.LineCurve3 = THREE.Curve.create(
        function (a, b) {
          this.v1 = a;
          this.v2 = b;
        },
        function (a) {
          var b = new THREE.Vector3();
          b.subVectors(this.v2, this.v1);
          b.multiplyScalar(a);
          b.add(this.v1);
          return b;
        }
      );
      THREE.QuadraticBezierCurve3 = THREE.Curve.create(
        function (a, b, c) {
          this.v0 = a;
          this.v1 = b;
          this.v2 = c;
        },
        function (a) {
          var b = THREE.ShapeUtils.b2;
          return new THREE.Vector3(
            b(a, this.v0.x, this.v1.x, this.v2.x),
            b(a, this.v0.y, this.v1.y, this.v2.y),
            b(a, this.v0.z, this.v1.z, this.v2.z)
          );
        }
      );
      THREE.CubicBezierCurve3 = THREE.Curve.create(
        function (a, b, c, d) {
          this.v0 = a;
          this.v1 = b;
          this.v2 = c;
          this.v3 = d;
        },
        function (a) {
          var b = THREE.ShapeUtils.b3;
          return new THREE.Vector3(
            b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
            b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y),
            b(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z)
          );
        }
      );
      THREE.SplineCurve3 = THREE.Curve.create(
        function (a) {
          console.warn(
            "THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"
          );
          this.points = void 0 == a ? [] : a;
        },
        function (a) {
          var b = this.points;
          a *= b.length - 1;
          var c = Math.floor(a);
          a -= c;
          var d = b[0 == c ? c : c - 1],
            e = b[c],
            f = b[c > b.length - 2 ? b.length - 1 : c + 1],
            b = b[c > b.length - 3 ? b.length - 1 : c + 2],
            c = THREE.CurveUtils.interpolate;
          return new THREE.Vector3(
            c(d.x, e.x, f.x, b.x, a),
            c(d.y, e.y, f.y, b.y, a),
            c(d.z, e.z, f.z, b.z, a)
          );
        }
      );
      THREE.CatmullRomCurve3 = (function () {
        function a() {}
        var b = new THREE.Vector3(),
          c = new a(),
          d = new a(),
          e = new a();
        a.prototype.init = function (a, b, c, d) {
          this.c0 = a;
          this.c1 = c;
          this.c2 = -3 * a + 3 * b - 2 * c - d;
          this.c3 = 2 * a - 2 * b + c + d;
        };
        a.prototype.initNonuniformCatmullRom = function (a, b, c, d, e, n, p) {
          a = ((b - a) / e - (c - a) / (e + n) + (c - b) / n) * n;
          d = ((c - b) / n - (d - b) / (n + p) + (d - c) / p) * n;
          this.init(b, c, a, d);
        };
        a.prototype.initCatmullRom = function (a, b, c, d, e) {
          this.init(b, c, e * (c - a), e * (d - b));
        };
        a.prototype.calc = function (a) {
          var b = a * a;
          return this.c0 + this.c1 * a + this.c2 * b + this.c3 * b * a;
        };
        return THREE.Curve.create(
          function (a) {
            this.points = a || [];
            this.closed = !1;
          },
          function (a) {
            var g = this.points,
              h,
              k;
            k = g.length;
            2 > k && console.log("duh, you need at least 2 points");
            a *= k - (this.closed ? 0 : 1);
            h = Math.floor(a);
            a -= h;
            this.closed
              ? (h +=
                  0 < h
                    ? 0
                    : (Math.floor(Math.abs(h) / g.length) + 1) * g.length)
              : 0 === a && h === k - 1 && ((h = k - 2), (a = 1));
            var l, n, p;
            this.closed || 0 < h
              ? (l = g[(h - 1) % k])
              : (b.subVectors(g[0], g[1]).add(g[0]), (l = b));
            n = g[h % k];
            p = g[(h + 1) % k];
            this.closed || h + 2 < k
              ? (g = g[(h + 2) % k])
              : (b.subVectors(g[k - 1], g[k - 2]).add(g[k - 1]), (g = b));
            if (
              void 0 === this.type ||
              "centripetal" === this.type ||
              "chordal" === this.type
            ) {
              var m = "chordal" === this.type ? 0.5 : 0.25;
              k = Math.pow(l.distanceToSquared(n), m);
              h = Math.pow(n.distanceToSquared(p), m);
              m = Math.pow(p.distanceToSquared(g), m);
              1e-4 > h && (h = 1);
              1e-4 > k && (k = h);
              1e-4 > m && (m = h);
              c.initNonuniformCatmullRom(l.x, n.x, p.x, g.x, k, h, m);
              d.initNonuniformCatmullRom(l.y, n.y, p.y, g.y, k, h, m);
              e.initNonuniformCatmullRom(l.z, n.z, p.z, g.z, k, h, m);
            } else
              "catmullrom" === this.type &&
                ((k = void 0 !== this.tension ? this.tension : 0.5),
                c.initCatmullRom(l.x, n.x, p.x, g.x, k),
                d.initCatmullRom(l.y, n.y, p.y, g.y, k),
                e.initCatmullRom(l.z, n.z, p.z, g.z, k));
            return new THREE.Vector3(c.calc(a), d.calc(a), e.calc(a));
          }
        );
      })();
      THREE.ClosedSplineCurve3 = function (a) {
        console.warn(
          "THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."
        );
        THREE.CatmullRomCurve3.call(this, a);
        this.type = "catmullrom";
        this.closed = !0;
      };
      THREE.ClosedSplineCurve3.prototype = Object.create(
        THREE.CatmullRomCurve3.prototype
      );
      THREE.BoxGeometry = function (a, b, c, d, e, f) {
        function g(a, b, c, d, e, f, g, u) {
          var t,
            x = h.widthSegments,
            v = h.heightSegments,
            C = e / 2,
            w = f / 2,
            D = h.vertices.length;
          if (("x" === a && "y" === b) || ("y" === a && "x" === b)) t = "z";
          else if (("x" === a && "z" === b) || ("z" === a && "x" === b))
            (t = "y"), (v = h.depthSegments);
          else if (("z" === a && "y" === b) || ("y" === a && "z" === b))
            (t = "x"), (x = h.depthSegments);
          var z = x + 1,
            y = v + 1,
            A = e / x,
            H = f / v,
            G = new THREE.Vector3();
          G[t] = 0 < g ? 1 : -1;
          for (e = 0; e < y; e++)
            for (f = 0; f < z; f++) {
              var E = new THREE.Vector3();
              E[a] = (f * A - C) * c;
              E[b] = (e * H - w) * d;
              E[t] = g;
              h.vertices.push(E);
            }
          for (e = 0; e < v; e++)
            for (f = 0; f < x; f++)
              (w = f + z * e),
                (a = f + z * (e + 1)),
                (b = f + 1 + z * (e + 1)),
                (c = f + 1 + z * e),
                (d = new THREE.Vector2(f / x, 1 - e / v)),
                (g = new THREE.Vector2(f / x, 1 - (e + 1) / v)),
                (t = new THREE.Vector2((f + 1) / x, 1 - (e + 1) / v)),
                (C = new THREE.Vector2((f + 1) / x, 1 - e / v)),
                (w = new THREE.Face3(w + D, a + D, c + D)),
                w.normal.copy(G),
                w.vertexNormals.push(G.clone(), G.clone(), G.clone()),
                (w.materialIndex = u),
                h.faces.push(w),
                h.faceVertexUvs[0].push([d, g, C]),
                (w = new THREE.Face3(a + D, b + D, c + D)),
                w.normal.copy(G),
                w.vertexNormals.push(G.clone(), G.clone(), G.clone()),
                (w.materialIndex = u),
                h.faces.push(w),
                h.faceVertexUvs[0].push([g.clone(), t, C.clone()]);
        }
        THREE.Geometry.call(this);
        this.type = "BoxGeometry";
        this.parameters = {
          width: a,
          height: b,
          depth: c,
          widthSegments: d,
          heightSegments: e,
          depthSegments: f,
        };
        this.widthSegments = d || 1;
        this.heightSegments = e || 1;
        this.depthSegments = f || 1;
        var h = this;
        d = a / 2;
        e = b / 2;
        f = c / 2;
        g("z", "y", -1, -1, c, b, d, 0);
        g("z", "y", 1, -1, c, b, -d, 1);
        g("x", "z", 1, 1, a, c, e, 2);
        g("x", "z", 1, -1, a, c, -e, 3);
        g("x", "y", 1, -1, a, b, f, 4);
        g("x", "y", -1, -1, a, b, -f, 5);
        this.mergeVertices();
      };
      THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
      THREE.CubeGeometry = THREE.BoxGeometry;
      THREE.CircleGeometry = function (a, b, c, d) {
        THREE.Geometry.call(this);
        this.type = "CircleGeometry";
        this.parameters = {
          radius: a,
          segments: b,
          thetaStart: c,
          thetaLength: d,
        };
        this.fromBufferGeometry(new THREE.CircleBufferGeometry(a, b, c, d));
      };
      THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
      THREE.CircleBufferGeometry = function (a, b, c, d) {
        THREE.BufferGeometry.call(this);
        this.type = "CircleBufferGeometry";
        this.parameters = {
          radius: a,
          segments: b,
          thetaStart: c,
          thetaLength: d,
        };
        a = a || 50;
        b = void 0 !== b ? Math.max(3, b) : 8;
        c = void 0 !== c ? c : 0;
        d = void 0 !== d ? d : 2 * Math.PI;
        var e = b + 2,
          f = new Float32Array(3 * e),
          g = new Float32Array(3 * e),
          e = new Float32Array(2 * e);
        g[2] = 1;
        e[0] = 0.5;
        e[1] = 0.5;
        for (var h = 0, k = 3, l = 2; h <= b; h++, k += 3, l += 2) {
          var n = c + (h / b) * d;
          f[k] = a * Math.cos(n);
          f[k + 1] = a * Math.sin(n);
          g[k + 2] = 1;
          e[l] = (f[k] / a + 1) / 2;
          e[l + 1] = (f[k + 1] / a + 1) / 2;
        }
        c = [];
        for (k = 1; k <= b; k++) c.push(k, k + 1, 0);
        this.setIndex(new THREE.BufferAttribute(new Uint16Array(c), 1));
        this.addAttribute("position", new THREE.BufferAttribute(f, 3));
        this.addAttribute("normal", new THREE.BufferAttribute(g, 3));
        this.addAttribute("uv", new THREE.BufferAttribute(e, 2));
        this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
      };
      THREE.CircleBufferGeometry.prototype = Object.create(
        THREE.BufferGeometry.prototype
      );
      THREE.CircleBufferGeometry.prototype.constructor =
        THREE.CircleBufferGeometry;
      THREE.CylinderGeometry = function (a, b, c, d, e, f, g, h) {
        THREE.Geometry.call(this);
        this.type = "CylinderGeometry";
        this.parameters = {
          radiusTop: a,
          radiusBottom: b,
          height: c,
          radialSegments: d,
          heightSegments: e,
          openEnded: f,
          thetaStart: g,
          thetaLength: h,
        };
        a = void 0 !== a ? a : 20;
        b = void 0 !== b ? b : 20;
        c = void 0 !== c ? c : 100;
        d = d || 8;
        e = e || 1;
        f = void 0 !== f ? f : !1;
        g = void 0 !== g ? g : 0;
        h = void 0 !== h ? h : 2 * Math.PI;
        var k = c / 2,
          l,
          n,
          p = [],
          m = [];
        for (n = 0; n <= e; n++) {
          var q = [],
            s = [],
            u = n / e,
            t = u * (b - a) + a;
          for (l = 0; l <= d; l++) {
            var x = l / d,
              v = new THREE.Vector3();
            v.x = t * Math.sin(x * h + g);
            v.y = -u * c + k;
            v.z = t * Math.cos(x * h + g);
            this.vertices.push(v);
            q.push(this.vertices.length - 1);
            s.push(new THREE.Vector2(x, 1 - u));
          }
          p.push(q);
          m.push(s);
        }
        c = (b - a) / c;
        for (l = 0; l < d; l++)
          for (
            0 !== a
              ? ((g = this.vertices[p[0][l]].clone()),
                (h = this.vertices[p[0][l + 1]].clone()))
              : ((g = this.vertices[p[1][l]].clone()),
                (h = this.vertices[p[1][l + 1]].clone())),
              g.setY(Math.sqrt(g.x * g.x + g.z * g.z) * c).normalize(),
              h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * c).normalize(),
              n = 0;
            n < e;
            n++
          ) {
            var q = p[n][l],
              s = p[n + 1][l],
              u = p[n + 1][l + 1],
              t = p[n][l + 1],
              x = g.clone(),
              v = g.clone(),
              C = h.clone(),
              w = h.clone(),
              D = m[n][l].clone(),
              z = m[n + 1][l].clone(),
              y = m[n + 1][l + 1].clone(),
              A = m[n][l + 1].clone();
            this.faces.push(new THREE.Face3(q, s, t, [x, v, w]));
            this.faceVertexUvs[0].push([D, z, A]);
            this.faces.push(
              new THREE.Face3(s, u, t, [v.clone(), C, w.clone()])
            );
            this.faceVertexUvs[0].push([z.clone(), y, A.clone()]);
          }
        if (!1 === f && 0 < a)
          for (
            this.vertices.push(new THREE.Vector3(0, k, 0)), l = 0;
            l < d;
            l++
          )
            (q = p[0][l]),
              (s = p[0][l + 1]),
              (u = this.vertices.length - 1),
              (x = new THREE.Vector3(0, 1, 0)),
              (v = new THREE.Vector3(0, 1, 0)),
              (C = new THREE.Vector3(0, 1, 0)),
              (D = m[0][l].clone()),
              (z = m[0][l + 1].clone()),
              (y = new THREE.Vector2(z.x, 0)),
              this.faces.push(new THREE.Face3(q, s, u, [x, v, C], void 0, 1)),
              this.faceVertexUvs[0].push([D, z, y]);
        if (!1 === f && 0 < b)
          for (
            this.vertices.push(new THREE.Vector3(0, -k, 0)), l = 0;
            l < d;
            l++
          )
            (q = p[e][l + 1]),
              (s = p[e][l]),
              (u = this.vertices.length - 1),
              (x = new THREE.Vector3(0, -1, 0)),
              (v = new THREE.Vector3(0, -1, 0)),
              (C = new THREE.Vector3(0, -1, 0)),
              (D = m[e][l + 1].clone()),
              (z = m[e][l].clone()),
              (y = new THREE.Vector2(z.x, 1)),
              this.faces.push(new THREE.Face3(q, s, u, [x, v, C], void 0, 2)),
              this.faceVertexUvs[0].push([D, z, y]);
        this.computeFaceNormals();
      };
      THREE.CylinderGeometry.prototype = Object.create(
        THREE.Geometry.prototype
      );
      THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
      THREE.EdgesGeometry = function (a, b) {
        function c(a, b) {
          return a - b;
        }
        THREE.BufferGeometry.call(this);
        var d = Math.cos(THREE.Math.degToRad(void 0 !== b ? b : 1)),
          e = [0, 0],
          f = {},
          g = ["a", "b", "c"],
          h;
        a instanceof THREE.BufferGeometry
          ? ((h = new THREE.Geometry()), h.fromBufferGeometry(a))
          : (h = a.clone());
        h.mergeVertices();
        h.computeFaceNormals();
        var k = h.vertices;
        h = h.faces;
        for (var l = 0, n = h.length; l < n; l++)
          for (var p = h[l], m = 0; 3 > m; m++) {
            e[0] = p[g[m]];
            e[1] = p[g[(m + 1) % 3]];
            e.sort(c);
            var q = e.toString();
            void 0 === f[q]
              ? (f[q] = { vert1: e[0], vert2: e[1], face1: l, face2: void 0 })
              : (f[q].face2 = l);
          }
        e = [];
        for (q in f)
          if (
            ((g = f[q]),
            void 0 === g.face2 || h[g.face1].normal.dot(h[g.face2].normal) <= d)
          )
            (l = k[g.vert1]),
              e.push(l.x),
              e.push(l.y),
              e.push(l.z),
              (l = k[g.vert2]),
              e.push(l.x),
              e.push(l.y),
              e.push(l.z);
        this.addAttribute(
          "position",
          new THREE.BufferAttribute(new Float32Array(e), 3)
        );
      };
      THREE.EdgesGeometry.prototype = Object.create(
        THREE.BufferGeometry.prototype
      );
      THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
      THREE.ExtrudeGeometry = function (a, b) {
        "undefined" !== typeof a &&
          (THREE.Geometry.call(this),
          (this.type = "ExtrudeGeometry"),
          (a = Array.isArray(a) ? a : [a]),
          this.addShapeList(a, b),
          this.computeFaceNormals());
      };
      THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
      THREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {
        for (var c = a.length, d = 0; d < c; d++) this.addShape(a[d], b);
      };
      THREE.ExtrudeGeometry.prototype.addShape = function (a, b) {
        function c(a, b, c) {
          b || console.error("THREE.ExtrudeGeometry: vec does not exist");
          return b.clone().multiplyScalar(c).add(a);
        }
        function d(a, b, c) {
          var d = 1,
            d = a.x - b.x,
            e = a.y - b.y,
            f = c.x - a.x,
            g = c.y - a.y,
            h = d * d + e * e;
          if (Math.abs(d * g - e * f) > Number.EPSILON) {
            var k = Math.sqrt(h),
              l = Math.sqrt(f * f + g * g),
              h = b.x - e / k;
            b = b.y + d / k;
            f =
              ((c.x - g / l - h) * g - (c.y + f / l - b) * f) / (d * g - e * f);
            c = h + d * f - a.x;
            a = b + e * f - a.y;
            d = c * c + a * a;
            if (2 >= d) return new THREE.Vector2(c, a);
            d = Math.sqrt(d / 2);
          } else
            (a = !1),
              d > Number.EPSILON
                ? f > Number.EPSILON && (a = !0)
                : d < -Number.EPSILON
                ? f < -Number.EPSILON && (a = !0)
                : Math.sign(e) === Math.sign(g) && (a = !0),
              a
                ? ((c = -e), (a = d), (d = Math.sqrt(h)))
                : ((c = d), (a = e), (d = Math.sqrt(h / 2)));
          return new THREE.Vector2(c / d, a / d);
        }
        function e(a, b) {
          var c, d;
          for (F = a.length; 0 <= --F; ) {
            c = F;
            d = F - 1;
            0 > d && (d = a.length - 1);
            for (var e = 0, f = q + 2 * n, e = 0; e < f; e++) {
              var g = O * e,
                h = O * (e + 1),
                k = b + c + g,
                g = b + d + g,
                l = b + d + h,
                h = b + c + h,
                k = k + G,
                g = g + G,
                l = l + G,
                h = h + G;
              H.faces.push(new THREE.Face3(k, g, h, null, null, 1));
              H.faces.push(new THREE.Face3(g, l, h, null, null, 1));
              k = x.generateSideWallUV(H, k, g, l, h);
              H.faceVertexUvs[0].push([k[0], k[1], k[3]]);
              H.faceVertexUvs[0].push([k[1], k[2], k[3]]);
            }
          }
        }
        function f(a, b, c) {
          H.vertices.push(new THREE.Vector3(a, b, c));
        }
        function g(a, b, c) {
          a += G;
          b += G;
          c += G;
          H.faces.push(new THREE.Face3(a, b, c, null, null, 0));
          a = x.generateTopUV(H, a, b, c);
          H.faceVertexUvs[0].push(a);
        }
        var h = void 0 !== b.amount ? b.amount : 100,
          k = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
          l = void 0 !== b.bevelSize ? b.bevelSize : k - 2,
          n = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
          p = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
          m = void 0 !== b.curveSegments ? b.curveSegments : 12,
          q = void 0 !== b.steps ? b.steps : 1,
          s = b.extrudePath,
          u,
          t = !1,
          x =
            void 0 !== b.UVGenerator
              ? b.UVGenerator
              : THREE.ExtrudeGeometry.WorldUVGenerator,
          v,
          C,
          w,
          D;
        s &&
          ((u = s.getSpacedPoints(q)),
          (t = !0),
          (p = !1),
          (v =
            void 0 !== b.frames
              ? b.frames
              : new THREE.TubeGeometry.FrenetFrames(s, q, !1)),
          (C = new THREE.Vector3()),
          (w = new THREE.Vector3()),
          (D = new THREE.Vector3()));
        p || (l = k = n = 0);
        var z,
          y,
          A,
          H = this,
          G = this.vertices.length,
          s = a.extractPoints(m),
          m = s.shape,
          E = s.holes;
        if ((s = !THREE.ShapeUtils.isClockWise(m))) {
          m = m.reverse();
          y = 0;
          for (A = E.length; y < A; y++)
            (z = E[y]), THREE.ShapeUtils.isClockWise(z) && (E[y] = z.reverse());
          s = !1;
        }
        var K = THREE.ShapeUtils.triangulateShape(m, E),
          P = m;
        y = 0;
        for (A = E.length; y < A; y++) (z = E[y]), (m = m.concat(z));
        var N,
          L,
          B,
          M,
          Q,
          O = m.length,
          S,
          J = K.length,
          s = [],
          F = 0;
        B = P.length;
        N = B - 1;
        for (L = F + 1; F < B; F++, N++, L++)
          N === B && (N = 0), L === B && (L = 0), (s[F] = d(P[F], P[N], P[L]));
        var Y = [],
          V,
          aa = s.concat();
        y = 0;
        for (A = E.length; y < A; y++) {
          z = E[y];
          V = [];
          F = 0;
          B = z.length;
          N = B - 1;
          for (L = F + 1; F < B; F++, N++, L++)
            N === B && (N = 0),
              L === B && (L = 0),
              (V[F] = d(z[F], z[N], z[L]));
          Y.push(V);
          aa = aa.concat(V);
        }
        for (N = 0; N < n; N++) {
          B = N / n;
          M = k * (1 - B);
          L = l * Math.sin((B * Math.PI) / 2);
          F = 0;
          for (B = P.length; F < B; F++)
            (Q = c(P[F], s[F], L)), f(Q.x, Q.y, -M);
          y = 0;
          for (A = E.length; y < A; y++)
            for (z = E[y], V = Y[y], F = 0, B = z.length; F < B; F++)
              (Q = c(z[F], V[F], L)), f(Q.x, Q.y, -M);
        }
        L = l;
        for (F = 0; F < O; F++)
          (Q = p ? c(m[F], aa[F], L) : m[F]),
            t
              ? (w.copy(v.normals[0]).multiplyScalar(Q.x),
                C.copy(v.binormals[0]).multiplyScalar(Q.y),
                D.copy(u[0]).add(w).add(C),
                f(D.x, D.y, D.z))
              : f(Q.x, Q.y, 0);
        for (B = 1; B <= q; B++)
          for (F = 0; F < O; F++)
            (Q = p ? c(m[F], aa[F], L) : m[F]),
              t
                ? (w.copy(v.normals[B]).multiplyScalar(Q.x),
                  C.copy(v.binormals[B]).multiplyScalar(Q.y),
                  D.copy(u[B]).add(w).add(C),
                  f(D.x, D.y, D.z))
                : f(Q.x, Q.y, (h / q) * B);
        for (N = n - 1; 0 <= N; N--) {
          B = N / n;
          M = k * (1 - B);
          L = l * Math.sin((B * Math.PI) / 2);
          F = 0;
          for (B = P.length; F < B; F++)
            (Q = c(P[F], s[F], L)), f(Q.x, Q.y, h + M);
          y = 0;
          for (A = E.length; y < A; y++)
            for (z = E[y], V = Y[y], F = 0, B = z.length; F < B; F++)
              (Q = c(z[F], V[F], L)),
                t
                  ? f(Q.x, Q.y + u[q - 1].y, u[q - 1].x + M)
                  : f(Q.x, Q.y, h + M);
        }
        (function () {
          if (p) {
            var a;
            a = 0 * O;
            for (F = 0; F < J; F++) (S = K[F]), g(S[2] + a, S[1] + a, S[0] + a);
            a = q + 2 * n;
            a *= O;
            for (F = 0; F < J; F++) (S = K[F]), g(S[0] + a, S[1] + a, S[2] + a);
          } else {
            for (F = 0; F < J; F++) (S = K[F]), g(S[2], S[1], S[0]);
            for (F = 0; F < J; F++)
              (S = K[F]), g(S[0] + O * q, S[1] + O * q, S[2] + O * q);
          }
        })();
        (function () {
          var a = 0;
          e(P, a);
          a += P.length;
          y = 0;
          for (A = E.length; y < A; y++) (z = E[y]), e(z, a), (a += z.length);
        })();
      };
      THREE.ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function (a, b, c, d) {
          a = a.vertices;
          b = a[b];
          c = a[c];
          d = a[d];
          return [
            new THREE.Vector2(b.x, b.y),
            new THREE.Vector2(c.x, c.y),
            new THREE.Vector2(d.x, d.y),
          ];
        },
        generateSideWallUV: function (a, b, c, d, e) {
          a = a.vertices;
          b = a[b];
          c = a[c];
          d = a[d];
          e = a[e];
          return 0.01 > Math.abs(b.y - c.y)
            ? [
                new THREE.Vector2(b.x, 1 - b.z),
                new THREE.Vector2(c.x, 1 - c.z),
                new THREE.Vector2(d.x, 1 - d.z),
                new THREE.Vector2(e.x, 1 - e.z),
              ]
            : [
                new THREE.Vector2(b.y, 1 - b.z),
                new THREE.Vector2(c.y, 1 - c.z),
                new THREE.Vector2(d.y, 1 - d.z),
                new THREE.Vector2(e.y, 1 - e.z),
              ];
        },
      };
      THREE.ShapeGeometry = function (a, b) {
        THREE.Geometry.call(this);
        this.type = "ShapeGeometry";
        !1 === Array.isArray(a) && (a = [a]);
        this.addShapeList(a, b);
        this.computeFaceNormals();
      };
      THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
      THREE.ShapeGeometry.prototype.addShapeList = function (a, b) {
        for (var c = 0, d = a.length; c < d; c++) this.addShape(a[c], b);
        return this;
      };
      THREE.ShapeGeometry.prototype.addShape = function (a, b) {
        void 0 === b && (b = {});
        var c = b.material,
          d =
            void 0 === b.UVGenerator
              ? THREE.ExtrudeGeometry.WorldUVGenerator
              : b.UVGenerator,
          e,
          f,
          g,
          h = this.vertices.length;
        e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
        var k = e.shape,
          l = e.holes;
        if (!THREE.ShapeUtils.isClockWise(k))
          for (k = k.reverse(), e = 0, f = l.length; e < f; e++)
            (g = l[e]), THREE.ShapeUtils.isClockWise(g) && (l[e] = g.reverse());
        var n = THREE.ShapeUtils.triangulateShape(k, l);
        e = 0;
        for (f = l.length; e < f; e++) (g = l[e]), (k = k.concat(g));
        l = k.length;
        f = n.length;
        for (e = 0; e < l; e++)
          (g = k[e]), this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
        for (e = 0; e < f; e++)
          (l = n[e]),
            (k = l[0] + h),
            (g = l[1] + h),
            (l = l[2] + h),
            this.faces.push(new THREE.Face3(k, g, l, null, null, c)),
            this.faceVertexUvs[0].push(d.generateTopUV(this, k, g, l));
      };
      THREE.LatheGeometry = function (a, b, c, d) {
        THREE.Geometry.call(this);
        this.type = "LatheGeometry";
        this.parameters = { points: a, segments: b, phiStart: c, phiLength: d };
        b = b || 12;
        c = c || 0;
        d = d || 2 * Math.PI;
        for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; g <= h; g++)
          for (
            var k = c + g * f * d,
              l = Math.sin(k),
              n = Math.cos(k),
              k = 0,
              p = a.length;
            k < p;
            k++
          ) {
            var m = a[k],
              q = new THREE.Vector3();
            q.x = m.x * l;
            q.y = m.y;
            q.z = m.x * n;
            this.vertices.push(q);
          }
        c = a.length;
        g = 0;
        for (h = b; g < h; g++)
          for (k = 0, p = a.length - 1; k < p; k++) {
            b = k + c * g;
            d = b + c;
            var l = b + 1 + c,
              n = b + 1,
              m = g * f,
              q = k * e,
              s = m + f,
              u = q + e;
            this.faces.push(new THREE.Face3(b, d, n));
            this.faceVertexUvs[0].push([
              new THREE.Vector2(m, q),
              new THREE.Vector2(s, q),
              new THREE.Vector2(m, u),
            ]);
            this.faces.push(new THREE.Face3(d, l, n));
            this.faceVertexUvs[0].push([
              new THREE.Vector2(s, q),
              new THREE.Vector2(s, u),
              new THREE.Vector2(m, u),
            ]);
          }
        this.mergeVertices();
        this.computeFaceNormals();
        this.computeVertexNormals();
      };
      THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
      THREE.PlaneGeometry = function (a, b, c, d) {
        THREE.Geometry.call(this);
        this.type = "PlaneGeometry";
        this.parameters = {
          width: a,
          height: b,
          widthSegments: c,
          heightSegments: d,
        };
        this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, c, d));
      };
      THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
      THREE.PlaneBufferGeometry = function (a, b, c, d) {
        THREE.BufferGeometry.call(this);
        this.type = "PlaneBufferGeometry";
        this.parameters = {
          width: a,
          height: b,
          widthSegments: c,
          heightSegments: d,
        };
        var e = a / 2,
          f = b / 2;
        c = Math.floor(c) || 1;
        d = Math.floor(d) || 1;
        var g = c + 1,
          h = d + 1,
          k = a / c,
          l = b / d;
        b = new Float32Array(g * h * 3);
        a = new Float32Array(g * h * 3);
        for (
          var n = new Float32Array(g * h * 2), p = 0, m = 0, q = 0;
          q < h;
          q++
        )
          for (var s = q * l - f, u = 0; u < g; u++)
            (b[p] = u * k - e),
              (b[p + 1] = -s),
              (a[p + 2] = 1),
              (n[m] = u / c),
              (n[m + 1] = 1 - q / d),
              (p += 3),
              (m += 2);
        p = 0;
        e = new (65535 < b.length / 3 ? Uint32Array : Uint16Array)(c * d * 6);
        for (q = 0; q < d; q++)
          for (u = 0; u < c; u++)
            (f = u + g * (q + 1)),
              (h = u + 1 + g * (q + 1)),
              (k = u + 1 + g * q),
              (e[p] = u + g * q),
              (e[p + 1] = f),
              (e[p + 2] = k),
              (e[p + 3] = f),
              (e[p + 4] = h),
              (e[p + 5] = k),
              (p += 6);
        this.setIndex(new THREE.BufferAttribute(e, 1));
        this.addAttribute("position", new THREE.BufferAttribute(b, 3));
        this.addAttribute("normal", new THREE.BufferAttribute(a, 3));
        this.addAttribute("uv", new THREE.BufferAttribute(n, 2));
      };
      THREE.PlaneBufferGeometry.prototype = Object.create(
        THREE.BufferGeometry.prototype
      );
      THREE.PlaneBufferGeometry.prototype.constructor =
        THREE.PlaneBufferGeometry;
      THREE.RingGeometry = function (a, b, c, d, e, f) {
        THREE.Geometry.call(this);
        this.type = "RingGeometry";
        this.parameters = {
          innerRadius: a,
          outerRadius: b,
          thetaSegments: c,
          phiSegments: d,
          thetaStart: e,
          thetaLength: f,
        };
        a = a || 0;
        b = b || 50;
        e = void 0 !== e ? e : 0;
        f = void 0 !== f ? f : 2 * Math.PI;
        c = void 0 !== c ? Math.max(3, c) : 8;
        d = void 0 !== d ? Math.max(1, d) : 8;
        var g,
          h = [],
          k = a,
          l = (b - a) / d;
        for (a = 0; a < d + 1; a++) {
          for (g = 0; g < c + 1; g++) {
            var n = new THREE.Vector3(),
              p = e + (g / c) * f;
            n.x = k * Math.cos(p);
            n.y = k * Math.sin(p);
            this.vertices.push(n);
            h.push(new THREE.Vector2((n.x / b + 1) / 2, (n.y / b + 1) / 2));
          }
          k += l;
        }
        b = new THREE.Vector3(0, 0, 1);
        for (a = 0; a < d; a++)
          for (e = a * (c + 1), g = 0; g < c; g++)
            (f = p = g + e),
              (l = p + c + 1),
              (n = p + c + 2),
              this.faces.push(
                new THREE.Face3(f, l, n, [b.clone(), b.clone(), b.clone()])
              ),
              this.faceVertexUvs[0].push([
                h[f].clone(),
                h[l].clone(),
                h[n].clone(),
              ]),
              (f = p),
              (l = p + c + 2),
              (n = p + 1),
              this.faces.push(
                new THREE.Face3(f, l, n, [b.clone(), b.clone(), b.clone()])
              ),
              this.faceVertexUvs[0].push([
                h[f].clone(),
                h[l].clone(),
                h[n].clone(),
              ]);
        this.computeFaceNormals();
        this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), k);
      };
      THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
      THREE.SphereGeometry = function (a, b, c, d, e, f, g) {
        THREE.Geometry.call(this);
        this.type = "SphereGeometry";
        this.parameters = {
          radius: a,
          widthSegments: b,
          heightSegments: c,
          phiStart: d,
          phiLength: e,
          thetaStart: f,
          thetaLength: g,
        };
        this.fromBufferGeometry(
          new THREE.SphereBufferGeometry(a, b, c, d, e, f, g)
        );
      };
      THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
      THREE.SphereBufferGeometry = function (a, b, c, d, e, f, g) {
        THREE.BufferGeometry.call(this);
        this.type = "SphereBufferGeometry";
        this.parameters = {
          radius: a,
          widthSegments: b,
          heightSegments: c,
          phiStart: d,
          phiLength: e,
          thetaStart: f,
          thetaLength: g,
        };
        a = a || 50;
        b = Math.max(3, Math.floor(b) || 8);
        c = Math.max(2, Math.floor(c) || 6);
        d = void 0 !== d ? d : 0;
        e = void 0 !== e ? e : 2 * Math.PI;
        f = void 0 !== f ? f : 0;
        g = void 0 !== g ? g : Math.PI;
        for (
          var h = f + g,
            k = (b + 1) * (c + 1),
            l = new THREE.BufferAttribute(new Float32Array(3 * k), 3),
            n = new THREE.BufferAttribute(new Float32Array(3 * k), 3),
            k = new THREE.BufferAttribute(new Float32Array(2 * k), 2),
            p = 0,
            m = [],
            q = new THREE.Vector3(),
            s = 0;
          s <= c;
          s++
        ) {
          for (var u = [], t = s / c, x = 0; x <= b; x++) {
            var v = x / b,
              C = -a * Math.cos(d + v * e) * Math.sin(f + t * g),
              w = a * Math.cos(f + t * g),
              D = a * Math.sin(d + v * e) * Math.sin(f + t * g);
            q.set(C, w, D).normalize();
            l.setXYZ(p, C, w, D);
            n.setXYZ(p, q.x, q.y, q.z);
            k.setXY(p, v, 1 - t);
            u.push(p);
            p++;
          }
          m.push(u);
        }
        d = [];
        for (s = 0; s < c; s++)
          for (x = 0; x < b; x++)
            (e = m[s][x + 1]),
              (g = m[s][x]),
              (p = m[s + 1][x]),
              (q = m[s + 1][x + 1]),
              (0 !== s || 0 < f) && d.push(e, g, q),
              (s !== c - 1 || h < Math.PI) && d.push(g, p, q);
        this.setIndex(
          new (65535 < l.count ? THREE.Uint32Attribute : THREE.Uint16Attribute)(
            d,
            1
          )
        );
        this.addAttribute("position", l);
        this.addAttribute("normal", n);
        this.addAttribute("uv", k);
        this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
      };
      THREE.SphereBufferGeometry.prototype = Object.create(
        THREE.BufferGeometry.prototype
      );
      THREE.SphereBufferGeometry.prototype.constructor =
        THREE.SphereBufferGeometry;
      THREE.TextGeometry = function (a, b) {
        b = b || {};
        var c = b.font;
        if (!1 === c instanceof THREE.Font)
          return (
            console.error(
              "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
            ),
            new THREE.Geometry()
          );
        c = c.generateShapes(a, b.size, b.curveSegments);
        b.amount = void 0 !== b.height ? b.height : 50;
        void 0 === b.bevelThickness && (b.bevelThickness = 10);
        void 0 === b.bevelSize && (b.bevelSize = 8);
        void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
        THREE.ExtrudeGeometry.call(this, c, b);
        this.type = "TextGeometry";
      };
      THREE.TextGeometry.prototype = Object.create(
        THREE.ExtrudeGeometry.prototype
      );
      THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
      THREE.TorusGeometry = function (a, b, c, d, e) {
        THREE.Geometry.call(this);
        this.type = "TorusGeometry";
        this.parameters = {
          radius: a,
          tube: b,
          radialSegments: c,
          tubularSegments: d,
          arc: e,
        };
        a = a || 100;
        b = b || 40;
        c = c || 8;
        d = d || 6;
        e = e || 2 * Math.PI;
        for (var f = new THREE.Vector3(), g = [], h = [], k = 0; k <= c; k++)
          for (var l = 0; l <= d; l++) {
            var n = (l / d) * e,
              p = (k / c) * Math.PI * 2;
            f.x = a * Math.cos(n);
            f.y = a * Math.sin(n);
            var m = new THREE.Vector3();
            m.x = (a + b * Math.cos(p)) * Math.cos(n);
            m.y = (a + b * Math.cos(p)) * Math.sin(n);
            m.z = b * Math.sin(p);
            this.vertices.push(m);
            g.push(new THREE.Vector2(l / d, k / c));
            h.push(m.clone().sub(f).normalize());
          }
        for (k = 1; k <= c; k++)
          for (l = 1; l <= d; l++)
            (a = (d + 1) * k + l - 1),
              (b = (d + 1) * (k - 1) + l - 1),
              (e = (d + 1) * (k - 1) + l),
              (f = (d + 1) * k + l),
              (n = new THREE.Face3(a, b, f, [
                h[a].clone(),
                h[b].clone(),
                h[f].clone(),
              ])),
              this.faces.push(n),
              this.faceVertexUvs[0].push([
                g[a].clone(),
                g[b].clone(),
                g[f].clone(),
              ]),
              (n = new THREE.Face3(b, e, f, [
                h[b].clone(),
                h[e].clone(),
                h[f].clone(),
              ])),
              this.faces.push(n),
              this.faceVertexUvs[0].push([
                g[b].clone(),
                g[e].clone(),
                g[f].clone(),
              ]);
        this.computeFaceNormals();
      };
      THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
      THREE.TorusKnotGeometry = function (a, b, c, d, e, f, g) {
        function h(a, b, c, d, e) {
          var f = Math.cos(a),
            g = Math.sin(a);
          a *= b / c;
          b = Math.cos(a);
          f *= d * (2 + b) * 0.5;
          g = d * (2 + b) * g * 0.5;
          d = e * d * Math.sin(a) * 0.5;
          return new THREE.Vector3(f, g, d);
        }
        THREE.Geometry.call(this);
        this.type = "TorusKnotGeometry";
        this.parameters = {
          radius: a,
          tube: b,
          radialSegments: c,
          tubularSegments: d,
          p: e,
          q: f,
          heightScale: g,
        };
        a = a || 100;
        b = b || 40;
        c = c || 64;
        d = d || 8;
        e = e || 2;
        f = f || 3;
        g = g || 1;
        for (
          var k = Array(c),
            l = new THREE.Vector3(),
            n = new THREE.Vector3(),
            p = new THREE.Vector3(),
            m = 0;
          m < c;
          ++m
        ) {
          k[m] = Array(d);
          var q = (m / c) * 2 * e * Math.PI,
            s = h(q, f, e, a, g),
            q = h(q + 0.01, f, e, a, g);
          l.subVectors(q, s);
          n.addVectors(q, s);
          p.crossVectors(l, n);
          n.crossVectors(p, l);
          p.normalize();
          n.normalize();
          for (q = 0; q < d; ++q) {
            var u = (q / d) * 2 * Math.PI,
              t = -b * Math.cos(u),
              u = b * Math.sin(u),
              x = new THREE.Vector3();
            x.x = s.x + t * n.x + u * p.x;
            x.y = s.y + t * n.y + u * p.y;
            x.z = s.z + t * n.z + u * p.z;
            k[m][q] = this.vertices.push(x) - 1;
          }
        }
        for (m = 0; m < c; ++m)
          for (q = 0; q < d; ++q)
            (e = (m + 1) % c),
              (f = (q + 1) % d),
              (a = k[m][q]),
              (b = k[e][q]),
              (e = k[e][f]),
              (f = k[m][f]),
              (g = new THREE.Vector2(m / c, q / d)),
              (l = new THREE.Vector2((m + 1) / c, q / d)),
              (n = new THREE.Vector2((m + 1) / c, (q + 1) / d)),
              (p = new THREE.Vector2(m / c, (q + 1) / d)),
              this.faces.push(new THREE.Face3(a, b, f)),
              this.faceVertexUvs[0].push([g, l, p]),
              this.faces.push(new THREE.Face3(b, e, f)),
              this.faceVertexUvs[0].push([l.clone(), n, p.clone()]);
        this.computeFaceNormals();
        this.computeVertexNormals();
      };
      THREE.TorusKnotGeometry.prototype = Object.create(
        THREE.Geometry.prototype
      );
      THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
      THREE.TubeGeometry = function (a, b, c, d, e, f) {
        THREE.Geometry.call(this);
        this.type = "TubeGeometry";
        this.parameters = {
          path: a,
          segments: b,
          radius: c,
          radialSegments: d,
          closed: e,
          taper: f,
        };
        b = b || 64;
        c = c || 1;
        d = d || 8;
        e = e || !1;
        f = f || THREE.TubeGeometry.NoTaper;
        var g = [],
          h,
          k,
          l = b + 1,
          n,
          p,
          m,
          q,
          s,
          u = new THREE.Vector3(),
          t,
          x,
          v;
        t = new THREE.TubeGeometry.FrenetFrames(a, b, e);
        x = t.normals;
        v = t.binormals;
        this.tangents = t.tangents;
        this.normals = x;
        this.binormals = v;
        for (t = 0; t < l; t++)
          for (
            g[t] = [],
              n = t / (l - 1),
              s = a.getPointAt(n),
              h = x[t],
              k = v[t],
              m = c * f(n),
              n = 0;
            n < d;
            n++
          )
            (p = (n / d) * 2 * Math.PI),
              (q = -m * Math.cos(p)),
              (p = m * Math.sin(p)),
              u.copy(s),
              (u.x += q * h.x + p * k.x),
              (u.y += q * h.y + p * k.y),
              (u.z += q * h.z + p * k.z),
              (g[t][n] =
                this.vertices.push(new THREE.Vector3(u.x, u.y, u.z)) - 1);
        for (t = 0; t < b; t++)
          for (n = 0; n < d; n++)
            (f = e ? (t + 1) % b : t + 1),
              (l = (n + 1) % d),
              (a = g[t][n]),
              (c = g[f][n]),
              (f = g[f][l]),
              (l = g[t][l]),
              (u = new THREE.Vector2(t / b, n / d)),
              (x = new THREE.Vector2((t + 1) / b, n / d)),
              (v = new THREE.Vector2((t + 1) / b, (n + 1) / d)),
              (h = new THREE.Vector2(t / b, (n + 1) / d)),
              this.faces.push(new THREE.Face3(a, c, l)),
              this.faceVertexUvs[0].push([u, x, h]),
              this.faces.push(new THREE.Face3(c, f, l)),
              this.faceVertexUvs[0].push([x.clone(), v, h.clone()]);
        this.computeFaceNormals();
        this.computeVertexNormals();
      };
      THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
      THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
      THREE.TubeGeometry.NoTaper = function (a) {
        return 1;
      };
      THREE.TubeGeometry.SinusoidalTaper = function (a) {
        return Math.sin(Math.PI * a);
      };
      THREE.TubeGeometry.FrenetFrames = function (a, b, c) {
        var d = new THREE.Vector3(),
          e = [],
          f = [],
          g = [],
          h = new THREE.Vector3(),
          k = new THREE.Matrix4();
        b += 1;
        var l, n, p;
        this.tangents = e;
        this.normals = f;
        this.binormals = g;
        for (l = 0; l < b; l++)
          (n = l / (b - 1)), (e[l] = a.getTangentAt(n)), e[l].normalize();
        f[0] = new THREE.Vector3();
        g[0] = new THREE.Vector3();
        a = Number.MAX_VALUE;
        l = Math.abs(e[0].x);
        n = Math.abs(e[0].y);
        p = Math.abs(e[0].z);
        l <= a && ((a = l), d.set(1, 0, 0));
        n <= a && ((a = n), d.set(0, 1, 0));
        p <= a && d.set(0, 0, 1);
        h.crossVectors(e[0], d).normalize();
        f[0].crossVectors(e[0], h);
        g[0].crossVectors(e[0], f[0]);
        for (l = 1; l < b; l++)
          (f[l] = f[l - 1].clone()),
            (g[l] = g[l - 1].clone()),
            h.crossVectors(e[l - 1], e[l]),
            h.length() > Number.EPSILON &&
              (h.normalize(),
              (d = Math.acos(THREE.Math.clamp(e[l - 1].dot(e[l]), -1, 1))),
              f[l].applyMatrix4(k.makeRotationAxis(h, d))),
            g[l].crossVectors(e[l], f[l]);
        if (c)
          for (
            d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)),
              d /= b - 1,
              0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d),
              l = 1;
            l < b;
            l++
          )
            f[l].applyMatrix4(k.makeRotationAxis(e[l], d * l)),
              g[l].crossVectors(e[l], f[l]);
      };
      THREE.PolyhedronGeometry = function (a, b, c, d) {
        function e(a) {
          var b = a.normalize().clone();
          b.index = k.vertices.push(b) - 1;
          var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + 0.5;
          a =
            Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + 0.5;
          b.uv = new THREE.Vector2(c, 1 - a);
          return b;
        }
        function f(a, b, c, d) {
          d = new THREE.Face3(
            a.index,
            b.index,
            c.index,
            [a.clone(), b.clone(), c.clone()],
            void 0,
            d
          );
          k.faces.push(d);
          t.copy(a).add(b).add(c).divideScalar(3);
          d = Math.atan2(t.z, -t.x);
          k.faceVertexUvs[0].push([
            h(a.uv, a, d),
            h(b.uv, b, d),
            h(c.uv, c, d),
          ]);
        }
        function g(a, b) {
          for (
            var c = Math.pow(2, b),
              d = e(k.vertices[a.a]),
              g = e(k.vertices[a.b]),
              h = e(k.vertices[a.c]),
              l = [],
              m = a.materialIndex,
              n = 0;
            n <= c;
            n++
          ) {
            l[n] = [];
            for (
              var p = e(d.clone().lerp(h, n / c)),
                q = e(g.clone().lerp(h, n / c)),
                s = c - n,
                t = 0;
              t <= s;
              t++
            )
              l[n][t] = 0 === t && n === c ? p : e(p.clone().lerp(q, t / s));
          }
          for (n = 0; n < c; n++)
            for (t = 0; t < 2 * (c - n) - 1; t++)
              (d = Math.floor(t / 2)),
                0 === t % 2
                  ? f(l[n][d + 1], l[n + 1][d], l[n][d], m)
                  : f(l[n][d + 1], l[n + 1][d + 1], l[n + 1][d], m);
        }
        function h(a, b, c) {
          0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));
          0 === b.x &&
            0 === b.z &&
            (a = new THREE.Vector2(c / 2 / Math.PI + 0.5, a.y));
          return a.clone();
        }
        THREE.Geometry.call(this);
        this.type = "PolyhedronGeometry";
        this.parameters = { vertices: a, indices: b, radius: c, detail: d };
        c = c || 1;
        d = d || 0;
        for (var k = this, l = 0, n = a.length; l < n; l += 3)
          e(new THREE.Vector3(a[l], a[l + 1], a[l + 2]));
        a = this.vertices;
        for (var p = [], m = (l = 0), n = b.length; l < n; l += 3, m++) {
          var q = a[b[l]],
            s = a[b[l + 1]],
            u = a[b[l + 2]];
          p[m] = new THREE.Face3(
            q.index,
            s.index,
            u.index,
            [q.clone(), s.clone(), u.clone()],
            void 0,
            m
          );
        }
        for (var t = new THREE.Vector3(), l = 0, n = p.length; l < n; l++)
          g(p[l], d);
        l = 0;
        for (n = this.faceVertexUvs[0].length; l < n; l++)
          (b = this.faceVertexUvs[0][l]),
            (d = b[0].x),
            (a = b[1].x),
            (p = b[2].x),
            (m = Math.max(d, a, p)),
            (q = Math.min(d, a, p)),
            0.9 < m &&
              0.1 > q &&
              (0.2 > d && (b[0].x += 1),
              0.2 > a && (b[1].x += 1),
              0.2 > p && (b[2].x += 1));
        l = 0;
        for (n = this.vertices.length; l < n; l++)
          this.vertices[l].multiplyScalar(c);
        this.mergeVertices();
        this.computeFaceNormals();
        this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), c);
      };
      THREE.PolyhedronGeometry.prototype = Object.create(
        THREE.Geometry.prototype
      );
      THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
      THREE.DodecahedronGeometry = function (a, b) {
        var c = (1 + Math.sqrt(5)) / 2,
          d = 1 / c;
        THREE.PolyhedronGeometry.call(
          this,
          [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -d,
            -c,
            0,
            -d,
            c,
            0,
            d,
            -c,
            0,
            d,
            c,
            -d,
            -c,
            0,
            -d,
            c,
            0,
            d,
            -c,
            0,
            d,
            c,
            0,
            -c,
            0,
            -d,
            c,
            0,
            -d,
            -c,
            0,
            d,
            c,
            0,
            d,
          ],
          [
            3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
            8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0,
            1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18,
            3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4,
            0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4,
            17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
          ],
          a,
          b
        );
        this.type = "DodecahedronGeometry";
        this.parameters = { radius: a, detail: b };
      };
      THREE.DodecahedronGeometry.prototype = Object.create(
        THREE.PolyhedronGeometry.prototype
      );
      THREE.DodecahedronGeometry.prototype.constructor =
        THREE.DodecahedronGeometry;
      THREE.IcosahedronGeometry = function (a, b) {
        var c = (1 + Math.sqrt(5)) / 2;
        THREE.PolyhedronGeometry.call(
          this,
          [
            -1,
            c,
            0,
            1,
            c,
            0,
            -1,
            -c,
            0,
            1,
            -c,
            0,
            0,
            -1,
            c,
            0,
            1,
            c,
            0,
            -1,
            -c,
            0,
            1,
            -c,
            c,
            0,
            -1,
            c,
            0,
            1,
            -c,
            0,
            -1,
            -c,
            0,
            1,
          ],
          [
            0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
            11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
            8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
          ],
          a,
          b
        );
        this.type = "IcosahedronGeometry";
        this.parameters = { radius: a, detail: b };
      };
      THREE.IcosahedronGeometry.prototype = Object.create(
        THREE.PolyhedronGeometry.prototype
      );
      THREE.IcosahedronGeometry.prototype.constructor =
        THREE.IcosahedronGeometry;
      THREE.OctahedronGeometry = function (a, b) {
        THREE.PolyhedronGeometry.call(
          this,
          [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
          [
            0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4,
            2,
          ],
          a,
          b
        );
        this.type = "OctahedronGeometry";
        this.parameters = { radius: a, detail: b };
      };
      THREE.OctahedronGeometry.prototype = Object.create(
        THREE.PolyhedronGeometry.prototype
      );
      THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
      THREE.TetrahedronGeometry = function (a, b) {
        THREE.PolyhedronGeometry.call(
          this,
          [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
          [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
          a,
          b
        );
        this.type = "TetrahedronGeometry";
        this.parameters = { radius: a, detail: b };
      };
      THREE.TetrahedronGeometry.prototype = Object.create(
        THREE.PolyhedronGeometry.prototype
      );
      THREE.TetrahedronGeometry.prototype.constructor =
        THREE.TetrahedronGeometry;
      THREE.ParametricGeometry = function (a, b, c) {
        THREE.Geometry.call(this);
        this.type = "ParametricGeometry";
        this.parameters = { func: a, slices: b, stacks: c };
        var d = this.vertices,
          e = this.faces,
          f = this.faceVertexUvs[0],
          g,
          h,
          k,
          l,
          n = b + 1;
        for (g = 0; g <= c; g++)
          for (l = g / c, h = 0; h <= b; h++)
            (k = h / b), (k = a(k, l)), d.push(k);
        var p, m, q, s;
        for (g = 0; g < c; g++)
          for (h = 0; h < b; h++)
            (a = g * n + h),
              (d = g * n + h + 1),
              (l = (g + 1) * n + h + 1),
              (k = (g + 1) * n + h),
              (p = new THREE.Vector2(h / b, g / c)),
              (m = new THREE.Vector2((h + 1) / b, g / c)),
              (q = new THREE.Vector2((h + 1) / b, (g + 1) / c)),
              (s = new THREE.Vector2(h / b, (g + 1) / c)),
              e.push(new THREE.Face3(a, d, k)),
              f.push([p, m, s]),
              e.push(new THREE.Face3(d, l, k)),
              f.push([m.clone(), q, s.clone()]);
        this.computeFaceNormals();
        this.computeVertexNormals();
      };
      THREE.ParametricGeometry.prototype = Object.create(
        THREE.Geometry.prototype
      );
      THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
      THREE.WireframeGeometry = function (a) {
        function b(a, b) {
          return a - b;
        }
        THREE.BufferGeometry.call(this);
        var c = [0, 0],
          d = {},
          e = ["a", "b", "c"];
        if (a instanceof THREE.Geometry) {
          var f = a.vertices,
            g = a.faces,
            h = 0,
            k = new Uint32Array(6 * g.length);
          a = 0;
          for (var l = g.length; a < l; a++)
            for (var n = g[a], p = 0; 3 > p; p++) {
              c[0] = n[e[p]];
              c[1] = n[e[(p + 1) % 3]];
              c.sort(b);
              var m = c.toString();
              void 0 === d[m] &&
                ((k[2 * h] = c[0]), (k[2 * h + 1] = c[1]), (d[m] = !0), h++);
            }
          c = new Float32Array(6 * h);
          a = 0;
          for (l = h; a < l; a++)
            for (p = 0; 2 > p; p++)
              (d = f[k[2 * a + p]]),
                (h = 6 * a + 3 * p),
                (c[h + 0] = d.x),
                (c[h + 1] = d.y),
                (c[h + 2] = d.z);
          this.addAttribute("position", new THREE.BufferAttribute(c, 3));
        } else if (a instanceof THREE.BufferGeometry) {
          if (null !== a.index) {
            l = a.index.array;
            f = a.attributes.position;
            e = a.groups;
            h = 0;
            0 === e.length && a.addGroup(0, l.length);
            k = new Uint32Array(2 * l.length);
            g = 0;
            for (n = e.length; g < n; ++g) {
              a = e[g];
              p = a.start;
              m = a.count;
              a = p;
              for (var q = p + m; a < q; a += 3)
                for (p = 0; 3 > p; p++)
                  (c[0] = l[a + p]),
                    (c[1] = l[a + ((p + 1) % 3)]),
                    c.sort(b),
                    (m = c.toString()),
                    void 0 === d[m] &&
                      ((k[2 * h] = c[0]),
                      (k[2 * h + 1] = c[1]),
                      (d[m] = !0),
                      h++);
            }
            c = new Float32Array(6 * h);
            a = 0;
            for (l = h; a < l; a++)
              for (p = 0; 2 > p; p++)
                (h = 6 * a + 3 * p),
                  (d = k[2 * a + p]),
                  (c[h + 0] = f.getX(d)),
                  (c[h + 1] = f.getY(d)),
                  (c[h + 2] = f.getZ(d));
          } else
            for (
              f = a.attributes.position.array,
                h = f.length / 3,
                k = h / 3,
                c = new Float32Array(6 * h),
                a = 0,
                l = k;
              a < l;
              a++
            )
              for (p = 0; 3 > p; p++)
                (h = 18 * a + 6 * p),
                  (k = 9 * a + 3 * p),
                  (c[h + 0] = f[k]),
                  (c[h + 1] = f[k + 1]),
                  (c[h + 2] = f[k + 2]),
                  (d = 9 * a + ((p + 1) % 3) * 3),
                  (c[h + 3] = f[d]),
                  (c[h + 4] = f[d + 1]),
                  (c[h + 5] = f[d + 2]);
          this.addAttribute("position", new THREE.BufferAttribute(c, 3));
        }
      };
      THREE.WireframeGeometry.prototype = Object.create(
        THREE.BufferGeometry.prototype
      );
      THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
      THREE.AxisHelper = function (a) {
        a = a || 1;
        var b = new Float32Array([
            0,
            0,
            0,
            a,
            0,
            0,
            0,
            0,
            0,
            0,
            a,
            0,
            0,
            0,
            0,
            0,
            0,
            a,
          ]),
          c = new Float32Array([
            1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1,
          ]);
        a = new THREE.BufferGeometry();
        a.addAttribute("position", new THREE.BufferAttribute(b, 3));
        a.addAttribute("color", new THREE.BufferAttribute(c, 3));
        b = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
        THREE.LineSegments.call(this, a, b);
      };
      THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype);
      THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
      THREE.ArrowHelper = (function () {
        var a = new THREE.Geometry();
        a.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
        var b = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
        b.translate(0, -0.5, 0);
        return function (c, d, e, f, g, h) {
          THREE.Object3D.call(this);
          void 0 === f && (f = 16776960);
          void 0 === e && (e = 1);
          void 0 === g && (g = 0.2 * e);
          void 0 === h && (h = 0.2 * g);
          this.position.copy(d);
          this.line = new THREE.Line(
            a,
            new THREE.LineBasicMaterial({ color: f })
          );
          this.line.matrixAutoUpdate = !1;
          this.add(this.line);
          this.cone = new THREE.Mesh(
            b,
            new THREE.MeshBasicMaterial({ color: f })
          );
          this.cone.matrixAutoUpdate = !1;
          this.add(this.cone);
          this.setDirection(c);
          this.setLength(e, g, h);
        };
      })();
      THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
      THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
      THREE.ArrowHelper.prototype.setDirection = (function () {
        var a = new THREE.Vector3(),
          b;
        return function (c) {
          0.99999 < c.y
            ? this.quaternion.set(0, 0, 0, 1)
            : -0.99999 > c.y
            ? this.quaternion.set(1, 0, 0, 0)
            : (a.set(c.z, 0, -c.x).normalize(),
              (b = Math.acos(c.y)),
              this.quaternion.setFromAxisAngle(a, b));
        };
      })();
      THREE.ArrowHelper.prototype.setLength = function (a, b, c) {
        void 0 === b && (b = 0.2 * a);
        void 0 === c && (c = 0.2 * b);
        this.line.scale.set(1, Math.max(0, a - b), 1);
        this.line.updateMatrix();
        this.cone.scale.set(c, b, c);
        this.cone.position.y = a;
        this.cone.updateMatrix();
      };
      THREE.ArrowHelper.prototype.setColor = function (a) {
        this.line.material.color.set(a);
        this.cone.material.color.set(a);
      };
      THREE.BoxHelper = function (a) {
        var b = new Uint16Array([
            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
            7,
          ]),
          c = new Float32Array(24),
          d = new THREE.BufferGeometry();
        d.setIndex(new THREE.BufferAttribute(b, 1));
        d.addAttribute("position", new THREE.BufferAttribute(c, 3));
        THREE.LineSegments.call(
          this,
          d,
          new THREE.LineBasicMaterial({ color: 16776960 })
        );
        void 0 !== a && this.update(a);
      };
      THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype);
      THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
      THREE.BoxHelper.prototype.update = (function () {
        var a = new THREE.Box3();
        return function (b) {
          a.setFromObject(b);
          if (!a.isEmpty()) {
            b = a.min;
            var c = a.max,
              d = this.geometry.attributes.position,
              e = d.array;
            e[0] = c.x;
            e[1] = c.y;
            e[2] = c.z;
            e[3] = b.x;
            e[4] = c.y;
            e[5] = c.z;
            e[6] = b.x;
            e[7] = b.y;
            e[8] = c.z;
            e[9] = c.x;
            e[10] = b.y;
            e[11] = c.z;
            e[12] = c.x;
            e[13] = c.y;
            e[14] = b.z;
            e[15] = b.x;
            e[16] = c.y;
            e[17] = b.z;
            e[18] = b.x;
            e[19] = b.y;
            e[20] = b.z;
            e[21] = c.x;
            e[22] = b.y;
            e[23] = b.z;
            d.needsUpdate = !0;
            this.geometry.computeBoundingSphere();
          }
        };
      })();
      THREE.BoundingBoxHelper = function (a, b) {
        var c = void 0 !== b ? b : 8947848;
        this.object = a;
        this.box = new THREE.Box3();
        THREE.Mesh.call(
          this,
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshBasicMaterial({ color: c, wireframe: !0 })
        );
      };
      THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
      THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
      THREE.BoundingBoxHelper.prototype.update = function () {
        this.box.setFromObject(this.object);
        this.box.size(this.scale);
        this.box.center(this.position);
      };
      THREE.CameraHelper = function (a) {
        function b(a, b, d) {
          c(a, d);
          c(b, d);
        }
        function c(a, b) {
          d.vertices.push(new THREE.Vector3());
          d.colors.push(new THREE.Color(b));
          void 0 === f[a] && (f[a] = []);
          f[a].push(d.vertices.length - 1);
        }
        var d = new THREE.Geometry(),
          e = new THREE.LineBasicMaterial({
            color: 16777215,
            vertexColors: THREE.FaceColors,
          }),
          f = {};
        b("n1", "n2", 16755200);
        b("n2", "n4", 16755200);
        b("n4", "n3", 16755200);
        b("n3", "n1", 16755200);
        b("f1", "f2", 16755200);
        b("f2", "f4", 16755200);
        b("f4", "f3", 16755200);
        b("f3", "f1", 16755200);
        b("n1", "f1", 16755200);
        b("n2", "f2", 16755200);
        b("n3", "f3", 16755200);
        b("n4", "f4", 16755200);
        b("p", "n1", 16711680);
        b("p", "n2", 16711680);
        b("p", "n3", 16711680);
        b("p", "n4", 16711680);
        b("u1", "u2", 43775);
        b("u2", "u3", 43775);
        b("u3", "u1", 43775);
        b("c", "t", 16777215);
        b("p", "c", 3355443);
        b("cn1", "cn2", 3355443);
        b("cn3", "cn4", 3355443);
        b("cf1", "cf2", 3355443);
        b("cf3", "cf4", 3355443);
        THREE.LineSegments.call(this, d, e);
        this.camera = a;
        this.camera.updateProjectionMatrix();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.pointMap = f;
        this.update();
      };
      THREE.CameraHelper.prototype = Object.create(
        THREE.LineSegments.prototype
      );
      THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
      THREE.CameraHelper.prototype.update = (function () {
        function a(a, g, h, k) {
          d.set(g, h, k).unproject(e);
          a = c[a];
          if (void 0 !== a)
            for (g = 0, h = a.length; g < h; g++) b.vertices[a[g]].copy(d);
        }
        var b,
          c,
          d = new THREE.Vector3(),
          e = new THREE.Camera();
        return function () {
          b = this.geometry;
          c = this.pointMap;
          e.projectionMatrix.copy(this.camera.projectionMatrix);
          a("c", 0, 0, -1);
          a("t", 0, 0, 1);
          a("n1", -1, -1, -1);
          a("n2", 1, -1, -1);
          a("n3", -1, 1, -1);
          a("n4", 1, 1, -1);
          a("f1", -1, -1, 1);
          a("f2", 1, -1, 1);
          a("f3", -1, 1, 1);
          a("f4", 1, 1, 1);
          a("u1", 0.7, 1.1, -1);
          a("u2", -0.7, 1.1, -1);
          a("u3", 0, 2, -1);
          a("cf1", -1, 0, 1);
          a("cf2", 1, 0, 1);
          a("cf3", 0, -1, 1);
          a("cf4", 0, 1, 1);
          a("cn1", -1, 0, -1);
          a("cn2", 1, 0, -1);
          a("cn3", 0, -1, -1);
          a("cn4", 0, 1, -1);
          b.verticesNeedUpdate = !0;
        };
      })();
      THREE.DirectionalLightHelper = function (a, b) {
        THREE.Object3D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        b = b || 1;
        var c = new THREE.Geometry();
        c.vertices.push(
          new THREE.Vector3(-b, b, 0),
          new THREE.Vector3(b, b, 0),
          new THREE.Vector3(b, -b, 0),
          new THREE.Vector3(-b, -b, 0),
          new THREE.Vector3(-b, b, 0)
        );
        var d = new THREE.LineBasicMaterial({ fog: !1 });
        d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.lightPlane = new THREE.Line(c, d);
        this.add(this.lightPlane);
        c = new THREE.Geometry();
        c.vertices.push(new THREE.Vector3(), new THREE.Vector3());
        d = new THREE.LineBasicMaterial({ fog: !1 });
        d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine = new THREE.Line(c, d);
        this.add(this.targetLine);
        this.update();
      };
      THREE.DirectionalLightHelper.prototype = Object.create(
        THREE.Object3D.prototype
      );
      THREE.DirectionalLightHelper.prototype.constructor =
        THREE.DirectionalLightHelper;
      THREE.DirectionalLightHelper.prototype.dispose = function () {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
      };
      THREE.DirectionalLightHelper.prototype.update = (function () {
        var a = new THREE.Vector3(),
          b = new THREE.Vector3(),
          c = new THREE.Vector3();
        return function () {
          a.setFromMatrixPosition(this.light.matrixWorld);
          b.setFromMatrixPosition(this.light.target.matrixWorld);
          c.subVectors(b, a);
          this.lightPlane.lookAt(c);
          this.lightPlane.material.color
            .copy(this.light.color)
            .multiplyScalar(this.light.intensity);
          this.targetLine.geometry.vertices[1].copy(c);
          this.targetLine.geometry.verticesNeedUpdate = !0;
          this.targetLine.material.color.copy(this.lightPlane.material.color);
        };
      })();
      THREE.EdgesHelper = function (a, b, c) {
        b = void 0 !== b ? b : 16777215;
        THREE.LineSegments.call(
          this,
          new THREE.EdgesGeometry(a.geometry, c),
          new THREE.LineBasicMaterial({ color: b })
        );
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
      };
      THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype);
      THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
      THREE.FaceNormalsHelper = function (a, b, c, d) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        a = void 0 !== c ? c : 16776960;
        d = void 0 !== d ? d : 1;
        b = 0;
        c = this.object.geometry;
        c instanceof THREE.Geometry
          ? (b = c.faces.length)
          : console.warn(
              "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
            );
        c = new THREE.BufferGeometry();
        b = new THREE.Float32Attribute(6 * b, 3);
        c.addAttribute("position", b);
        THREE.LineSegments.call(
          this,
          c,
          new THREE.LineBasicMaterial({ color: a, linewidth: d })
        );
        this.matrixAutoUpdate = !1;
        this.update();
      };
      THREE.FaceNormalsHelper.prototype = Object.create(
        THREE.LineSegments.prototype
      );
      THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
      THREE.FaceNormalsHelper.prototype.update = (function () {
        var a = new THREE.Vector3(),
          b = new THREE.Vector3(),
          c = new THREE.Matrix3();
        return function () {
          this.object.updateMatrixWorld(!0);
          c.getNormalMatrix(this.object.matrixWorld);
          for (
            var d = this.object.matrixWorld,
              e = this.geometry.attributes.position,
              f = this.object.geometry,
              g = f.vertices,
              f = f.faces,
              h = 0,
              k = 0,
              l = f.length;
            k < l;
            k++
          ) {
            var n = f[k],
              p = n.normal;
            a.copy(g[n.a])
              .add(g[n.b])
              .add(g[n.c])
              .divideScalar(3)
              .applyMatrix4(d);
            b.copy(p)
              .applyMatrix3(c)
              .normalize()
              .multiplyScalar(this.size)
              .add(a);
            e.setXYZ(h, a.x, a.y, a.z);
            h += 1;
            e.setXYZ(h, b.x, b.y, b.z);
            h += 1;
          }
          e.needsUpdate = !0;
          return this;
        };
      })();
      THREE.GridHelper = function (a, b) {
        var c = new THREE.Geometry(),
          d = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
        this.color1 = new THREE.Color(4473924);
        this.color2 = new THREE.Color(8947848);
        for (var e = -a; e <= a; e += b) {
          c.vertices.push(
            new THREE.Vector3(-a, 0, e),
            new THREE.Vector3(a, 0, e),
            new THREE.Vector3(e, 0, -a),
            new THREE.Vector3(e, 0, a)
          );
          var f = 0 === e ? this.color1 : this.color2;
          c.colors.push(f, f, f, f);
        }
        THREE.LineSegments.call(this, c, d);
      };
      THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype);
      THREE.GridHelper.prototype.constructor = THREE.GridHelper;
      THREE.GridHelper.prototype.setColors = function (a, b) {
        this.color1.set(a);
        this.color2.set(b);
        this.geometry.colorsNeedUpdate = !0;
      };
      THREE.HemisphereLightHelper = function (a, b) {
        THREE.Object3D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.colors = [new THREE.Color(), new THREE.Color()];
        var c = new THREE.SphereGeometry(b, 4, 2);
        c.rotateX(-Math.PI / 2);
        for (var d = 0; 8 > d; d++)
          c.faces[d].color = this.colors[4 > d ? 0 : 1];
        d = new THREE.MeshBasicMaterial({
          vertexColors: THREE.FaceColors,
          wireframe: !0,
        });
        this.lightSphere = new THREE.Mesh(c, d);
        this.add(this.lightSphere);
        this.update();
      };
      THREE.HemisphereLightHelper.prototype = Object.create(
        THREE.Object3D.prototype
      );
      THREE.HemisphereLightHelper.prototype.constructor =
        THREE.HemisphereLightHelper;
      THREE.HemisphereLightHelper.prototype.dispose = function () {
        this.lightSphere.geometry.dispose();
        this.lightSphere.material.dispose();
      };
      THREE.HemisphereLightHelper.prototype.update = (function () {
        var a = new THREE.Vector3();
        return function () {
          this.colors[0]
            .copy(this.light.color)
            .multiplyScalar(this.light.intensity);
          this.colors[1]
            .copy(this.light.groundColor)
            .multiplyScalar(this.light.intensity);
          this.lightSphere.lookAt(
            a.setFromMatrixPosition(this.light.matrixWorld).negate()
          );
          this.lightSphere.geometry.colorsNeedUpdate = !0;
        };
      })();
      THREE.PointLightHelper = function (a, b) {
        this.light = a;
        this.light.updateMatrixWorld();
        var c = new THREE.SphereGeometry(b, 4, 2),
          d = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });
        d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        THREE.Mesh.call(this, c, d);
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = !1;
      };
      THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
      THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
      THREE.PointLightHelper.prototype.dispose = function () {
        this.geometry.dispose();
        this.material.dispose();
      };
      THREE.PointLightHelper.prototype.update = function () {
        this.material.color
          .copy(this.light.color)
          .multiplyScalar(this.light.intensity);
      };
      THREE.SkeletonHelper = function (a) {
        this.bones = this.getBoneList(a);
        for (var b = new THREE.Geometry(), c = 0; c < this.bones.length; c++)
          this.bones[c].parent instanceof THREE.Bone &&
            (b.vertices.push(new THREE.Vector3()),
            b.vertices.push(new THREE.Vector3()),
            b.colors.push(new THREE.Color(0, 0, 1)),
            b.colors.push(new THREE.Color(0, 1, 0)));
        b.dynamic = !0;
        c = new THREE.LineBasicMaterial({
          vertexColors: THREE.VertexColors,
          depthTest: !1,
          depthWrite: !1,
          transparent: !0,
        });
        THREE.LineSegments.call(this, b, c);
        this.root = a;
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.update();
      };
      THREE.SkeletonHelper.prototype = Object.create(
        THREE.LineSegments.prototype
      );
      THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
      THREE.SkeletonHelper.prototype.getBoneList = function (a) {
        var b = [];
        a instanceof THREE.Bone && b.push(a);
        for (var c = 0; c < a.children.length; c++)
          b.push.apply(b, this.getBoneList(a.children[c]));
        return b;
      };
      THREE.SkeletonHelper.prototype.update = function () {
        for (
          var a = this.geometry,
            b = new THREE.Matrix4().getInverse(this.root.matrixWorld),
            c = new THREE.Matrix4(),
            d = 0,
            e = 0;
          e < this.bones.length;
          e++
        ) {
          var f = this.bones[e];
          f.parent instanceof THREE.Bone &&
            (c.multiplyMatrices(b, f.matrixWorld),
            a.vertices[d].setFromMatrixPosition(c),
            c.multiplyMatrices(b, f.parent.matrixWorld),
            a.vertices[d + 1].setFromMatrixPosition(c),
            (d += 2));
        }
        a.verticesNeedUpdate = !0;
        a.computeBoundingSphere();
      };
      THREE.SpotLightHelper = function (a) {
        THREE.Object3D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
        a.translate(0, -0.5, 0);
        a.rotateX(-Math.PI / 2);
        var b = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });
        this.cone = new THREE.Mesh(a, b);
        this.add(this.cone);
        this.update();
      };
      THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
      THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
      THREE.SpotLightHelper.prototype.dispose = function () {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
      };
      THREE.SpotLightHelper.prototype.update = (function () {
        var a = new THREE.Vector3(),
          b = new THREE.Vector3();
        return function () {
          var c = this.light.distance ? this.light.distance : 1e4,
            d = c * Math.tan(this.light.angle);
          this.cone.scale.set(d, d, c);
          a.setFromMatrixPosition(this.light.matrixWorld);
          b.setFromMatrixPosition(this.light.target.matrixWorld);
          this.cone.lookAt(b.sub(a));
          this.cone.material.color
            .copy(this.light.color)
            .multiplyScalar(this.light.intensity);
        };
      })();
      THREE.VertexNormalsHelper = function (a, b, c, d) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        a = void 0 !== c ? c : 16711680;
        d = void 0 !== d ? d : 1;
        b = 0;
        c = this.object.geometry;
        c instanceof THREE.Geometry
          ? (b = 3 * c.faces.length)
          : c instanceof THREE.BufferGeometry &&
            (b = c.attributes.normal.count);
        c = new THREE.BufferGeometry();
        b = new THREE.Float32Attribute(6 * b, 3);
        c.addAttribute("position", b);
        THREE.LineSegments.call(
          this,
          c,
          new THREE.LineBasicMaterial({ color: a, linewidth: d })
        );
        this.matrixAutoUpdate = !1;
        this.update();
      };
      THREE.VertexNormalsHelper.prototype = Object.create(
        THREE.LineSegments.prototype
      );
      THREE.VertexNormalsHelper.prototype.constructor =
        THREE.VertexNormalsHelper;
      THREE.VertexNormalsHelper.prototype.update = (function () {
        var a = new THREE.Vector3(),
          b = new THREE.Vector3(),
          c = new THREE.Matrix3();
        return function () {
          var d = ["a", "b", "c"];
          this.object.updateMatrixWorld(!0);
          c.getNormalMatrix(this.object.matrixWorld);
          var e = this.object.matrixWorld,
            f = this.geometry.attributes.position,
            g = this.object.geometry;
          if (g instanceof THREE.Geometry)
            for (
              var h = g.vertices, k = g.faces, l = (g = 0), n = k.length;
              l < n;
              l++
            )
              for (
                var p = k[l], m = 0, q = p.vertexNormals.length;
                m < q;
                m++
              ) {
                var s = p.vertexNormals[m];
                a.copy(h[p[d[m]]]).applyMatrix4(e);
                b.copy(s)
                  .applyMatrix3(c)
                  .normalize()
                  .multiplyScalar(this.size)
                  .add(a);
                f.setXYZ(g, a.x, a.y, a.z);
                g += 1;
                f.setXYZ(g, b.x, b.y, b.z);
                g += 1;
              }
          else if (g instanceof THREE.BufferGeometry)
            for (
              d = g.attributes.position,
                h = g.attributes.normal,
                m = g = 0,
                q = d.count;
              m < q;
              m++
            )
              a.set(d.getX(m), d.getY(m), d.getZ(m)).applyMatrix4(e),
                b.set(h.getX(m), h.getY(m), h.getZ(m)),
                b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a),
                f.setXYZ(g, a.x, a.y, a.z),
                (g += 1),
                f.setXYZ(g, b.x, b.y, b.z),
                (g += 1);
          f.needsUpdate = !0;
          return this;
        };
      })();
      THREE.WireframeHelper = function (a, b) {
        var c = void 0 !== b ? b : 16777215;
        THREE.LineSegments.call(
          this,
          new THREE.WireframeGeometry(a.geometry),
          new THREE.LineBasicMaterial({ color: c })
        );
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
      };
      THREE.WireframeHelper.prototype = Object.create(
        THREE.LineSegments.prototype
      );
      THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
      THREE.ImmediateRenderObject = function (a) {
        THREE.Object3D.call(this);
        this.material = a;
        this.render = function (a) {};
      };
      THREE.ImmediateRenderObject.prototype = Object.create(
        THREE.Object3D.prototype
      );
      THREE.ImmediateRenderObject.prototype.constructor =
        THREE.ImmediateRenderObject;
      THREE.MorphBlendMesh = function (a, b) {
        THREE.Mesh.call(this, a, b);
        this.animationsMap = {};
        this.animationsList = [];
        var c = this.geometry.morphTargets.length;
        this.createAnimation("__default", 0, c - 1, c / 1);
        this.setAnimationWeight("__default", 1);
      };
      THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
      THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
      THREE.MorphBlendMesh.prototype.createAnimation = function (a, b, c, d) {
        b = {
          start: b,
          end: c,
          length: c - b + 1,
          fps: d,
          duration: (c - b) / d,
          lastFrame: 0,
          currentFrame: 0,
          active: !1,
          time: 0,
          direction: 1,
          weight: 1,
          directionBackwards: !1,
          mirroredLoop: !1,
        };
        this.animationsMap[a] = b;
        this.animationsList.push(b);
      };
      THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (a) {
        for (
          var b = /([a-z]+)_?(\d+)/i,
            c,
            d = {},
            e = this.geometry,
            f = 0,
            g = e.morphTargets.length;
          f < g;
          f++
        ) {
          var h = e.morphTargets[f].name.match(b);
          if (h && 1 < h.length) {
            var k = h[1];
            d[k] || (d[k] = { start: Infinity, end: -Infinity });
            h = d[k];
            f < h.start && (h.start = f);
            f > h.end && (h.end = f);
            c || (c = k);
          }
        }
        for (k in d) (h = d[k]), this.createAnimation(k, h.start, h.end, a);
        this.firstAnimation = c;
      };
      THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (
        a
      ) {
        if ((a = this.animationsMap[a]))
          (a.direction = 1), (a.directionBackwards = !1);
      };
      THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (
        a
      ) {
        if ((a = this.animationsMap[a]))
          (a.direction = -1), (a.directionBackwards = !0);
      };
      THREE.MorphBlendMesh.prototype.setAnimationFPS = function (a, b) {
        var c = this.animationsMap[a];
        c && ((c.fps = b), (c.duration = (c.end - c.start) / c.fps));
      };
      THREE.MorphBlendMesh.prototype.setAnimationDuration = function (a, b) {
        var c = this.animationsMap[a];
        c && ((c.duration = b), (c.fps = (c.end - c.start) / c.duration));
      };
      THREE.MorphBlendMesh.prototype.setAnimationWeight = function (a, b) {
        var c = this.animationsMap[a];
        c && (c.weight = b);
      };
      THREE.MorphBlendMesh.prototype.setAnimationTime = function (a, b) {
        var c = this.animationsMap[a];
        c && (c.time = b);
      };
      THREE.MorphBlendMesh.prototype.getAnimationTime = function (a) {
        var b = 0;
        if ((a = this.animationsMap[a])) b = a.time;
        return b;
      };
      THREE.MorphBlendMesh.prototype.getAnimationDuration = function (a) {
        var b = -1;
        if ((a = this.animationsMap[a])) b = a.duration;
        return b;
      };
      THREE.MorphBlendMesh.prototype.playAnimation = function (a) {
        var b = this.animationsMap[a];
        b
          ? ((b.time = 0), (b.active = !0))
          : console.warn(
              "THREE.MorphBlendMesh: animation[" +
                a +
                "] undefined in .playAnimation()"
            );
      };
      THREE.MorphBlendMesh.prototype.stopAnimation = function (a) {
        if ((a = this.animationsMap[a])) a.active = !1;
      };
      THREE.MorphBlendMesh.prototype.update = function (a) {
        for (var b = 0, c = this.animationsList.length; b < c; b++) {
          var d = this.animationsList[b];
          if (d.active) {
            var e = d.duration / d.length;
            d.time += d.direction * a;
            if (d.mirroredLoop) {
              if (d.time > d.duration || 0 > d.time)
                (d.direction *= -1),
                  d.time > d.duration &&
                    ((d.time = d.duration), (d.directionBackwards = !0)),
                  0 > d.time && ((d.time = 0), (d.directionBackwards = !1));
            } else (d.time %= d.duration), 0 > d.time && (d.time += d.duration);
            var f =
                d.start +
                THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1),
              g = d.weight;
            f !== d.currentFrame &&
              ((this.morphTargetInfluences[d.lastFrame] = 0),
              (this.morphTargetInfluences[d.currentFrame] = 1 * g),
              (this.morphTargetInfluences[f] = 0),
              (d.lastFrame = d.currentFrame),
              (d.currentFrame = f));
            e = (d.time % e) / e;
            d.directionBackwards && (e = 1 - e);
            d.currentFrame !== d.lastFrame
              ? ((this.morphTargetInfluences[d.currentFrame] = e * g),
                (this.morphTargetInfluences[d.lastFrame] = (1 - e) * g))
              : (this.morphTargetInfluences[d.currentFrame] = g);
          }
        }
      };

      /***/
    },
    /* 4 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /**
       * @author qiao / https://github.com/qiao
       * @author mrdoob / http://mrdoob.com
       * @author alteredq / http://alteredqualia.com/
       * @author WestLangley / http://github.com/WestLangley
       * @author erich666 / http://erichaines.com
       */

      // This set of controls performs orbiting, dollying (zooming), and panning.
      // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
      //
      //    Orbit - left mouse / touch: one finger move
      //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
      //    Pan - right mouse, or arrow keys / touch: three finter swipe

      THREE.OrbitControls = function (object, domElement) {
        this.object = object;

        this.domElement = domElement !== undefined ? domElement : document;

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the object orbits around
        this.target = new THREE.Vector3();

        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // How far you can orbit horizontally, upper and lower limits.
        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians

        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.25;

        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;

        // Set to false to disable panning
        this.enablePan = true;
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // Set to false to disable use of the keys
        this.enableKeys = true;

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        // Mouse buttons
        this.mouseButtons = {
          ORBIT: THREE.MOUSE.LEFT,
          ZOOM: THREE.MOUSE.MIDDLE,
          PAN: THREE.MOUSE.RIGHT,
        };

        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;

        //
        // public methods
        //

        this.getPolarAngle = function () {
          return phi;
        };

        this.getAzimuthalAngle = function () {
          return theta;
        };

        this.reset = function () {
          scope.target.copy(scope.target0);
          scope.object.position.copy(scope.position0);
          scope.object.zoom = scope.zoom0;

          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(changeEvent);

          scope.update();

          state = STATE.NONE;
        };

        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = (function () {
          var offset = new THREE.Vector3();

          // so camera.up is the orbit axis
          var quat = new THREE.Quaternion().setFromUnitVectors(
            object.up,
            new THREE.Vector3(0, 1, 0)
          );
          var quatInverse = quat.clone().inverse();

          var lastPosition = new THREE.Vector3();
          var lastQuaternion = new THREE.Quaternion();

          return function () {
            var position = scope.object.position;

            offset.copy(position).sub(scope.target);

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion(quat);

            // angle from z-axis around y-axis

            theta = Math.atan2(offset.x, offset.z);

            // angle from y-axis

            phi = Math.atan2(
              Math.sqrt(offset.x * offset.x + offset.z * offset.z),
              offset.y
            );

            if (scope.autoRotate && state === STATE.NONE) {
              rotateLeft(getAutoRotationAngle());
            }

            theta += thetaDelta;
            phi += phiDelta;

            // restrict theta to be between desired limits
            theta = Math.max(
              scope.minAzimuthAngle,
              Math.min(scope.maxAzimuthAngle, theta)
            );

            // restrict phi to be between desired limits
            phi = Math.max(
              scope.minPolarAngle,
              Math.min(scope.maxPolarAngle, phi)
            );

            // restrict phi to be betwee EPS and PI-EPS
            phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

            var radius = offset.length() * scale;

            // restrict radius to be between desired limits
            radius = Math.max(
              scope.minDistance,
              Math.min(scope.maxDistance, radius)
            );

            // move target to panned location
            scope.target.add(panOffset);

            offset.x = radius * Math.sin(phi) * Math.sin(theta);
            offset.y = radius * Math.cos(phi);
            offset.z = radius * Math.sin(phi) * Math.cos(theta);

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion(quatInverse);

            position.copy(scope.target).add(offset);

            scope.object.lookAt(scope.target);

            if (scope.enableDamping === true) {
              thetaDelta *= 1 - scope.dampingFactor;
              phiDelta *= 1 - scope.dampingFactor;
            } else {
              thetaDelta = 0;
              phiDelta = 0;
            }

            scale = 1;
            panOffset.set(0, 0, 0);

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if (
              zoomChanged ||
              lastPosition.distanceToSquared(scope.object.position) > EPS ||
              8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS
            ) {
              scope.dispatchEvent(changeEvent);

              lastPosition.copy(scope.object.position);
              lastQuaternion.copy(scope.object.quaternion);
              zoomChanged = false;

              return true;
            }

            return false;
          };
        })();

        this.dispose = function () {
          scope.domElement.removeEventListener(
            "contextmenu",
            onContextMenu,
            false
          );
          scope.domElement.removeEventListener("mousedown", onMouseDown, false);
          scope.domElement.removeEventListener(
            "mousewheel",
            onMouseWheel,
            false
          );
          scope.domElement.removeEventListener(
            "MozMousePixelScroll",
            onMouseWheel,
            false
          ); // firefox

          scope.domElement.removeEventListener(
            "touchstart",
            onTouchStart,
            false
          );
          scope.domElement.removeEventListener("touchend", onTouchEnd, false);
          scope.domElement.removeEventListener("touchmove", onTouchMove, false);

          document.removeEventListener("mousemove", onMouseMove, false);
          document.removeEventListener("mouseup", onMouseUp, false);
          document.removeEventListener("mouseout", onMouseUp, false);

          window.removeEventListener("keydown", onKeyDown, false);

          //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
        };

        //
        // internals
        //

        var scope = this;

        var changeEvent = { type: "change" };
        var startEvent = { type: "start" };
        var endEvent = { type: "end" };

        var STATE = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_DOLLY: 4,
          TOUCH_PAN: 5,
        };

        var state = STATE.NONE;

        var EPS = 0.000001;

        // current position in spherical coordinates
        var theta;
        var phi;

        var phiDelta = 0;
        var thetaDelta = 0;
        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        function getAutoRotationAngle() {
          return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
        }

        function getZoomScale() {
          return Math.pow(0.95, scope.zoomSpeed);
        }

        function rotateLeft(angle) {
          thetaDelta -= angle;
        }

        function rotateUp(angle) {
          phiDelta -= angle;
        }

        var panLeft = (function () {
          var v = new THREE.Vector3();

          return function panLeft(distance, objectMatrix) {
            var te = objectMatrix.elements;

            // get X column of objectMatrix
            v.set(te[0], te[1], te[2]);

            v.multiplyScalar(-distance);

            panOffset.add(v);
          };
        })();

        var panUp = (function () {
          var v = new THREE.Vector3();

          return function panUp(distance, objectMatrix) {
            var te = objectMatrix.elements;

            // get Y column of objectMatrix
            v.set(te[4], te[5], te[6]);

            v.multiplyScalar(distance);

            panOffset.add(v);
          };
        })();

        // deltaX and deltaY are in pixels; right and down are positive
        var pan = (function () {
          var offset = new THREE.Vector3();

          return function (deltaX, deltaY) {
            var element =
              scope.domElement === document
                ? scope.domElement.body
                : scope.domElement;

            if (scope.object instanceof THREE.PerspectiveCamera) {
              // perspective
              var position = scope.object.position;
              offset.copy(position).sub(scope.target);
              var targetDistance = offset.length();

              // half of the fov is center to top of screen
              targetDistance *= Math.tan(
                ((scope.object.fov / 2) * Math.PI) / 180.0
              );

              // we actually don't use screenWidth, since perspective camera is fixed to screen height
              panLeft(
                (2 * deltaX * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
              panUp(
                (2 * deltaY * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
            } else if (scope.object instanceof THREE.OrthographicCamera) {
              // orthographic
              panLeft(
                (deltaX * (scope.object.right - scope.object.left)) /
                  element.clientWidth,
                scope.object.matrix
              );
              panUp(
                (deltaY * (scope.object.top - scope.object.bottom)) /
                  element.clientHeight,
                scope.object.matrix
              );
            } else {
              // camera neither orthographic nor perspective
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
              );
              scope.enablePan = false;
            }
          };
        })();

        function dollyIn(dollyScale) {
          if (scope.object instanceof THREE.PerspectiveCamera) {
            scale /= dollyScale;
          } else if (scope.object instanceof THREE.OrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom * dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        function dollyOut(dollyScale) {
          if (scope.object instanceof THREE.PerspectiveCamera) {
            scale *= dollyScale;
          } else if (scope.object instanceof THREE.OrthographicCamera) {
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom / dollyScale)
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            );
            scope.enableZoom = false;
          }
        }

        //
        // event callbacks - update the object state
        //

        function handleMouseDownRotate(event) {
          //console.log( 'handleMouseDownRotate' );

          rotateStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownDolly(event) {
          //console.log( 'handleMouseDownDolly' );

          dollyStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownPan(event) {
          //console.log( 'handleMouseDownPan' );

          panStart.set(event.clientX, event.clientY);
        }

        function handleMouseMoveRotate(event) {
          //console.log( 'handleMouseMoveRotate' );

          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart);

          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;

          // rotating across whole screen goes 360 degrees around
          rotateLeft(
            ((2 * Math.PI * rotateDelta.x) / element.clientWidth) *
              scope.rotateSpeed
          );

          // rotating up and down along whole screen attempts to go 360, but limited to 180
          rotateUp(
            ((2 * Math.PI * rotateDelta.y) / element.clientHeight) *
              scope.rotateSpeed
          );

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleMouseMoveDolly(event) {
          //console.log( 'handleMouseMoveDolly' );

          dollyEnd.set(event.clientX, event.clientY);

          dollyDelta.subVectors(dollyEnd, dollyStart);

          if (dollyDelta.y > 0) {
            dollyIn(getZoomScale());
          } else if (dollyDelta.y < 0) {
            dollyOut(getZoomScale());
          }

          dollyStart.copy(dollyEnd);

          scope.update();
        }

        function handleMouseMovePan(event) {
          //console.log( 'handleMouseMovePan' );

          panEnd.set(event.clientX, event.clientY);

          panDelta.subVectors(panEnd, panStart);

          pan(panDelta.x, panDelta.y);

          panStart.copy(panEnd);

          scope.update();
        }

        function handleMouseUp(event) {
          //console.log( 'handleMouseUp' );
        }

        function handleMouseWheel(event) {
          //console.log( 'handleMouseWheel' );

          var delta = 0;

          if (event.wheelDelta !== undefined) {
            // WebKit / Opera / Explorer 9

            delta = event.wheelDelta;
          } else if (event.detail !== undefined) {
            // Firefox

            delta = -event.detail;
          }

          if (delta > 0) {
            dollyOut(getZoomScale());
          } else if (delta < 0) {
            dollyIn(getZoomScale());
          }

          scope.update();
        }

        function handleKeyDown(event) {
          //console.log( 'handleKeyDown' );

          switch (event.keyCode) {
            case scope.keys.UP:
              pan(0, scope.keyPanSpeed);
              scope.update();
              break;

            case scope.keys.BOTTOM:
              pan(0, -scope.keyPanSpeed);
              scope.update();
              break;

            case scope.keys.LEFT:
              pan(scope.keyPanSpeed, 0);
              scope.update();
              break;

            case scope.keys.RIGHT:
              pan(-scope.keyPanSpeed, 0);
              scope.update();
              break;
          }
        }

        function handleTouchStartRotate(event) {
          //console.log( 'handleTouchStartRotate' );

          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        }

        function handleTouchStartDolly(event) {
          //console.log( 'handleTouchStartDolly' );

          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;

          var distance = Math.sqrt(dx * dx + dy * dy);

          dollyStart.set(0, distance);
        }

        function handleTouchStartPan(event) {
          //console.log( 'handleTouchStartPan' );

          panStart.set(event.touches[0].pageX, event.touches[0].pageY);
        }

        function handleTouchMoveRotate(event) {
          //console.log( 'handleTouchMoveRotate' );

          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
          rotateDelta.subVectors(rotateEnd, rotateStart);

          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;

          // rotating across whole screen goes 360 degrees around
          rotateLeft(
            ((2 * Math.PI * rotateDelta.x) / element.clientWidth) *
              scope.rotateSpeed
          );

          // rotating up and down along whole screen attempts to go 360, but limited to 180
          rotateUp(
            ((2 * Math.PI * rotateDelta.y) / element.clientHeight) *
              scope.rotateSpeed
          );

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleTouchMoveDolly(event) {
          //console.log( 'handleTouchMoveDolly' );

          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;

          var distance = Math.sqrt(dx * dx + dy * dy);

          dollyEnd.set(0, distance);

          dollyDelta.subVectors(dollyEnd, dollyStart);

          if (dollyDelta.y > 0) {
            dollyOut(getZoomScale());
          } else if (dollyDelta.y < 0) {
            dollyIn(getZoomScale());
          }

          dollyStart.copy(dollyEnd);

          scope.update();
        }

        function handleTouchMovePan(event) {
          //console.log( 'handleTouchMovePan' );

          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

          panDelta.subVectors(panEnd, panStart);

          pan(panDelta.x, panDelta.y);

          panStart.copy(panEnd);

          scope.update();
        }

        function handleTouchEnd(event) {
          //console.log( 'handleTouchEnd' );
        }

        //
        // event handlers - FSM: listen for events and reset state
        //

        function onMouseDown(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          if (event.button === scope.mouseButtons.ORBIT) {
            if (scope.enableRotate === false) return;

            handleMouseDownRotate(event);

            state = STATE.ROTATE;
          } else if (event.button === scope.mouseButtons.ZOOM) {
            if (scope.enableZoom === false) return;

            handleMouseDownDolly(event);

            state = STATE.DOLLY;
          } else if (event.button === scope.mouseButtons.PAN) {
            if (scope.enablePan === false) return;

            handleMouseDownPan(event);

            state = STATE.PAN;
          }

          if (state !== STATE.NONE) {
            document.addEventListener("mousemove", onMouseMove, false);
            document.addEventListener("mouseup", onMouseUp, false);
            document.addEventListener("mouseout", onMouseUp, false);

            scope.dispatchEvent(startEvent);
          }
        }

        function onMouseMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          if (state === STATE.ROTATE) {
            if (scope.enableRotate === false) return;

            handleMouseMoveRotate(event);
          } else if (state === STATE.DOLLY) {
            if (scope.enableZoom === false) return;

            handleMouseMoveDolly(event);
          } else if (state === STATE.PAN) {
            if (scope.enablePan === false) return;

            handleMouseMovePan(event);
          }
        }

        function onMouseUp(event) {
          if (scope.enabled === false) return;

          handleMouseUp(event);

          document.removeEventListener("mousemove", onMouseMove, false);
          document.removeEventListener("mouseup", onMouseUp, false);
          document.removeEventListener("mouseout", onMouseUp, false);

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        function onMouseWheel(event) {
          if (
            scope.enabled === false ||
            scope.enableZoom === false ||
            state !== STATE.NONE
          )
            return;

          event.preventDefault();
          event.stopPropagation();

          handleMouseWheel(event);

          scope.dispatchEvent(startEvent); // not sure why these are here...
          scope.dispatchEvent(endEvent);
        }

        function onKeyDown(event) {
          if (
            scope.enabled === false ||
            scope.enableKeys === false ||
            scope.enablePan === false
          )
            return;

          handleKeyDown(event);
        }

        function onTouchStart(event) {
          if (scope.enabled === false) return;

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;

              handleTouchStartRotate(event);

              state = STATE.TOUCH_ROTATE;

              break;

            case 2: // two-fingered touch: dolly
              if (scope.enableZoom === false) return;

              handleTouchStartDolly(event);

              state = STATE.TOUCH_DOLLY;

              break;

            case 3: // three-fingered touch: pan
              if (scope.enablePan === false) return;

              handleTouchStartPan(event);

              state = STATE.TOUCH_PAN;

              break;

            default:
              state = STATE.NONE;
          }

          if (state !== STATE.NONE) {
            scope.dispatchEvent(startEvent);
          }
        }

        function onTouchMove(event) {
          if (scope.enabled === false) return;

          event.preventDefault();
          event.stopPropagation();

          switch (event.touches.length) {
            case 1: // one-fingered touch: rotate
              if (scope.enableRotate === false) return;
              if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

              handleTouchMoveRotate(event);

              break;

            case 2: // two-fingered touch: dolly
              if (scope.enableZoom === false) return;
              if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

              handleTouchMoveDolly(event);

              break;

            case 3: // three-fingered touch: pan
              if (scope.enablePan === false) return;
              if (state !== STATE.TOUCH_PAN) return; // is this needed?...

              handleTouchMovePan(event);

              break;

            default:
              state = STATE.NONE;
          }
        }

        function onTouchEnd(event) {
          if (scope.enabled === false) return;

          handleTouchEnd(event);

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        function onContextMenu(event) {
          event.preventDefault();
        }

        //

        scope.domElement.addEventListener("contextmenu", onContextMenu, false);

        scope.domElement.addEventListener("mousedown", onMouseDown, false);
        scope.domElement.addEventListener("mousewheel", onMouseWheel, false);
        scope.domElement.addEventListener(
          "MozMousePixelScroll",
          onMouseWheel,
          false
        ); // firefox

        scope.domElement.addEventListener("touchstart", onTouchStart, false);
        scope.domElement.addEventListener("touchend", onTouchEnd, false);
        scope.domElement.addEventListener("touchmove", onTouchMove, false);

        window.addEventListener("keydown", onKeyDown, false);

        // force an update at start

        this.update();
      };

      THREE.OrbitControls.prototype = Object.create(
        THREE.EventDispatcher.prototype
      );
      THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

      Object.defineProperties(THREE.OrbitControls.prototype, {
        center: {
          get: function () {
            console.warn(
              "THREE.OrbitControls: .center has been renamed to .target"
            );
            return this.target;
          },
        },

        // backward compatibility

        noZoom: {
          get: function () {
            console.warn(
              "THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."
            );
            return !this.enableZoom;
          },

          set: function (value) {
            console.warn(
              "THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."
            );
            this.enableZoom = !value;
          },
        },

        noRotate: {
          get: function () {
            console.warn(
              "THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."
            );
            return !this.enableRotate;
          },

          set: function (value) {
            console.warn(
              "THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."
            );
            this.enableRotate = !value;
          },
        },

        noPan: {
          get: function () {
            console.warn(
              "THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."
            );
            return !this.enablePan;
          },

          set: function (value) {
            console.warn(
              "THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."
            );
            this.enablePan = !value;
          },
        },

        noKeys: {
          get: function () {
            console.warn(
              "THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."
            );
            return !this.enableKeys;
          },

          set: function (value) {
            console.warn(
              "THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."
            );
            this.enableKeys = !value;
          },
        },

        staticMoving: {
          get: function () {
            console.warn(
              "THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."
            );
            return !this.constraint.enableDamping;
          },

          set: function (value) {
            console.warn(
              "THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."
            );
            this.constraint.enableDamping = !value;
          },
        },

        dynamicDampingFactor: {
          get: function () {
            console.warn(
              "THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."
            );
            return this.constraint.dampingFactor;
          },

          set: function (value) {
            console.warn(
              "THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."
            );
            this.constraint.dampingFactor = value;
          },
        },
      });

      /***/
    },
    /* 5 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /**
       * @author alteredq / http://alteredqualia.com/
       *
       * Full-screen textured quad shader
       */

      THREE.CopyShader = {
        uniforms: {
          tDiffuse: { type: "t", value: null },
          opacity: { type: "f", value: 1.0 },
        },

        vertexShader: [
          "varying vec2 vUv;",

          "void main() {",

          "vUv = uv;",
          "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

          "}",
        ].join("\n"),

        fragmentShader: [
          "uniform float opacity;",

          "uniform sampler2D tDiffuse;",

          "varying vec2 vUv;",

          "void main() {",

          "vec4 texel = texture2D( tDiffuse, vUv );",
          "gl_FragColor = opacity * texel;",

          "}",
        ].join("\n"),
      };

      /***/
    },
    /* 6 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /**
       * @author alteredq / http://alteredqualia.com/
       */

      THREE.RenderPass = function (
        scene,
        camera,
        overrideMaterial,
        clearColor,
        clearAlpha
      ) {
        this.scene = scene;
        this.camera = camera;

        this.overrideMaterial = overrideMaterial;

        this.clearColor = clearColor;
        this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 1;

        this.oldClearColor = new THREE.Color();
        this.oldClearAlpha = 1;

        this.enabled = true;
        this.clear = true;
        this.needsSwap = false;
      };

      THREE.RenderPass.prototype = {
        render: function (renderer, writeBuffer, readBuffer, delta) {
          this.scene.overrideMaterial = this.overrideMaterial;

          if (this.clearColor) {
            this.oldClearColor.copy(renderer.getClearColor());
            this.oldClearAlpha = renderer.getClearAlpha();

            renderer.setClearColor(this.clearColor, this.clearAlpha);
          }

          renderer.render(this.scene, this.camera, readBuffer, this.clear);

          if (this.clearColor) {
            renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
          }

          this.scene.overrideMaterial = null;
        },
      };

      /***/
    },
    /* 7 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /**
       * @author alteredq / http://alteredqualia.com/
       */

      THREE.ShaderPass = function (shader, textureID) {
        this.textureID = textureID !== undefined ? textureID : "tDiffuse";

        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

        this.material = new THREE.ShaderMaterial({
          defines: shader.defines || {},
          uniforms: this.uniforms,
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader,
        });

        this.renderToScreen = false;

        this.enabled = true;
        this.needsSwap = true;
        this.clear = false;

        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.scene = new THREE.Scene();

        this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
        this.scene.add(this.quad);
      };

      THREE.ShaderPass.prototype = {
        render: function (renderer, writeBuffer, readBuffer, delta) {
          if (this.uniforms[this.textureID]) {
            this.uniforms[this.textureID].value = readBuffer;
          }

          this.quad.material = this.material;

          if (this.renderToScreen) {
            renderer.render(this.scene, this.camera);
          } else {
            renderer.render(this.scene, this.camera, writeBuffer, this.clear);
          }
        },
      };

      /***/
    },
    /* 8 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /**
       * @author alteredq / http://alteredqualia.com/
       */

      THREE.MaskPass = function (scene, camera) {
        this.scene = scene;
        this.camera = camera;

        this.enabled = true;
        this.clear = true;
        this.needsSwap = false;

        this.inverse = false;
      };

      THREE.MaskPass.prototype = {
        render: function (renderer, writeBuffer, readBuffer, delta) {
          var context = renderer.context;

          // don't update color or depth

          context.colorMask(false, false, false, false);
          context.depthMask(false);

          // set up stencil

          var writeValue, clearValue;

          if (this.inverse) {
            writeValue = 0;
            clearValue = 1;
          } else {
            writeValue = 1;
            clearValue = 0;
          }

          context.enable(context.STENCIL_TEST);
          context.stencilOp(context.REPLACE, context.REPLACE, context.REPLACE);
          context.stencilFunc(context.ALWAYS, writeValue, 0xffffffff);
          context.clearStencil(clearValue);

          // draw into the stencil buffer

          renderer.render(this.scene, this.camera, readBuffer, this.clear);
          renderer.render(this.scene, this.camera, writeBuffer, this.clear);

          // re-enable update of color and depth

          context.colorMask(true, true, true, true);
          context.depthMask(true);

          // only render where stencil is set to 1

          context.stencilFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
          context.stencilOp(context.KEEP, context.KEEP, context.KEEP);
        },
      };

      THREE.ClearMaskPass = function () {
        this.enabled = true;
      };

      THREE.ClearMaskPass.prototype = {
        render: function (renderer, writeBuffer, readBuffer, delta) {
          var context = renderer.context;

          context.disable(context.STENCIL_TEST);
        },
      };

      /***/
    },
    /* 9 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /**
       * @author mattatz / http://mattatz.github.io/
       */

      THREE.BloomBlendPass = function (amount, opacity, resolution) {
        this.amount = amount !== undefined ? amount : 1.0;
        this.opacity = opacity !== undefined ? opacity : 1.0;
        this.resolution =
          resolution !== undefined ? resolution : new THREE.Vector2(512, 512);

        // render targets

        var pars = {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBAFormat,
        };

        this.renderTargetX = new THREE.WebGLRenderTarget(
          this.resolution.x,
          this.resolution.y,
          pars
        );
        this.renderTargetY = new THREE.WebGLRenderTarget(
          this.resolution.x,
          this.resolution.y,
          pars
        );

        var kernel = [
          "varying vec2 vUv;",

          "void main() {",

          "vUv = uv;",
          "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

          "}",
        ].join("\n");

        this.blurMaterial = new THREE.ShaderMaterial({
          uniforms: {
            tDiffuse: { type: "t", value: null },
            inc: { type: "v2", value: new THREE.Vector2() },
          },
          vertexShader: kernel,
          fragmentShader: [
            "uniform sampler2D tDiffuse;",

            "uniform vec2 inc;",

            "varying vec2 vUv;",

            "void main() {",

            "vec4 sum = vec4(0.0);",

            "sum += texture2D(tDiffuse, (vUv - inc * 4.0)) * 0.051;",
            "sum += texture2D(tDiffuse, (vUv - inc * 3.0)) * 0.0918;",
            "sum += texture2D(tDiffuse, (vUv - inc * 2.0)) * 0.12245;",
            "sum += texture2D(tDiffuse, (vUv - inc * 1.0)) * 0.1531;",
            "sum += texture2D(tDiffuse, (vUv + inc * 0.0)) * 0.1633;",
            "sum += texture2D(tDiffuse, (vUv + inc * 1.0)) * 0.1531;",
            "sum += texture2D(tDiffuse, (vUv + inc * 2.0)) * 0.12245;",
            "sum += texture2D(tDiffuse, (vUv + inc * 3.0)) * 0.0918;",
            "sum += texture2D(tDiffuse, (vUv + inc * 4.0)) * 0.051;",

            "gl_FragColor = sum;",

            "}",
          ].join("\n"),
        });

        this.blendMaterial = new THREE.ShaderMaterial({
          uniforms: {
            tDiffuse: { type: "t", value: null },
            tBlend: { type: "t", value: null },
            opacity: { type: "f", value: this.opacity },
          },
          vertexShader: kernel,
          fragmentShader: [
            "uniform sampler2D tDiffuse;",
            "uniform sampler2D tBlend;",
            "uniform float opacity;",

            "varying vec2 vUv;",

            "void main() {",

            "vec4 base = texture2D(tDiffuse, vUv);",
            "vec4 blend = texture2D(tBlend, vUv);",

            // screen
            "gl_FragColor = (1.0 - ((1.0 - base) * (1.0 - blend)));",
            "gl_FragColor = gl_FragColor * opacity + base * ( 1. - opacity );",

            "}",
          ].join("\n"),
        });

        this.enabled = true;
        this.needsSwap = true;
        this.clear = false;

        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.scene = new THREE.Scene();

        this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
        this.scene.add(this.quad);
      };

      THREE.BloomBlendPass.prototype = {
        render: function (
          renderer,
          writeBuffer,
          readBuffer,
          delta,
          maskActive
        ) {
          if (maskActive)
            renderer.context.disable(renderer.context.STENCIL_TEST);

          this.quad.material = this.blurMaterial;

          // horizontal blur
          this.blurMaterial.uniforms["tDiffuse"].value = readBuffer;
          this.blurMaterial.uniforms["inc"].value.set(
            this.amount / readBuffer.width,
            0.0
          );

          renderer.render(this.scene, this.camera, this.renderTargetX, false);

          // vertical blur
          this.blurMaterial.uniforms["tDiffuse"].value = this.renderTargetX;
          this.blurMaterial.uniforms["inc"].value.set(
            0.0,
            this.amount / this.renderTargetX.height
          );

          renderer.render(this.scene, this.camera, this.renderTargetY, false);

          // blending original buffer and blurred buffer

          this.quad.material = this.blendMaterial;
          this.blendMaterial.uniforms["tDiffuse"].value = readBuffer;
          this.blendMaterial.uniforms["tBlend"].value = this.renderTargetY;

          if (maskActive)
            renderer.context.enable(renderer.context.STENCIL_TEST);

          renderer.render(this.scene, this.camera, writeBuffer, this.clear);
        },
      };

      /***/
    },
    /* 10 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /**
       * @author alteredq / http://alteredqualia.com/
       */

      THREE.EffectComposer = function (renderer, renderTarget) {
        this.renderer = renderer;

        if (renderTarget === undefined) {
          var pixelRatio = renderer.getPixelRatio();

          var width =
            Math.floor(renderer.context.canvas.width / pixelRatio) || 1;
          var height =
            Math.floor(renderer.context.canvas.height / pixelRatio) || 1;
          var parameters = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBFormat,
            stencilBuffer: false,
          };

          renderTarget = new THREE.WebGLRenderTarget(width, height, parameters);
        }

        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();

        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;

        this.passes = [];

        if (THREE.CopyShader === undefined)
          console.error("THREE.EffectComposer relies on THREE.CopyShader");

        this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
      };

      THREE.EffectComposer.prototype = {
        swapBuffers: function () {
          var tmp = this.readBuffer;
          this.readBuffer = this.writeBuffer;
          this.writeBuffer = tmp;
        },

        addPass: function (pass) {
          this.passes.push(pass);
        },

        insertPass: function (pass, index) {
          this.passes.splice(index, 0, pass);
        },

        render: function (delta) {
          this.writeBuffer = this.renderTarget1;
          this.readBuffer = this.renderTarget2;

          var maskActive = false;

          var pass,
            i,
            il = this.passes.length;

          for (i = 0; i < il; i++) {
            pass = this.passes[i];

            if (!pass.enabled) continue;

            pass.render(
              this.renderer,
              this.writeBuffer,
              this.readBuffer,
              delta,
              maskActive
            );

            if (pass.needsSwap) {
              if (maskActive) {
                var context = this.renderer.context;

                context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);

                this.copyPass.render(
                  this.renderer,
                  this.writeBuffer,
                  this.readBuffer,
                  delta
                );

                context.stencilFunc(context.EQUAL, 1, 0xffffffff);
              }

              this.swapBuffers();
            }

            if (pass instanceof THREE.MaskPass) {
              maskActive = true;
            } else if (pass instanceof THREE.ClearMaskPass) {
              maskActive = false;
            }
          }
        },

        reset: function (renderTarget) {
          if (renderTarget === undefined) {
            renderTarget = this.renderTarget1.clone();

            var pixelRatio = this.renderer.getPixelRatio();

            renderTarget.width = Math.floor(
              this.renderer.context.canvas.width / pixelRatio
            );
            renderTarget.height = Math.floor(
              this.renderer.context.canvas.height / pixelRatio
            );
          }

          this.renderTarget1.dispose();
          this.renderTarget1 = renderTarget;
          this.renderTarget2.dispose();
          this.renderTarget2 = renderTarget.clone();

          this.writeBuffer = this.renderTarget1;
          this.readBuffer = this.renderTarget2;
        },

        setSize: function (width, height) {
          this.renderTarget1.setSize(width, height);
          this.renderTarget2.setSize(width, height);
        },
      };

      /***/
    },
    /* 11 */
    /***/ function (module, exports) {
      /*
       * A speed-improved perlin and simplex noise algorithms for 2D.
       *
       * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
       * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
       * Better rank ordering method by Stefan Gustavson in 2012.
       * Converted to Javascript by Joseph Gentle.
       *
       * Version 2012-03-09
       *
       * This code was placed in the public domain by its original author,
       * Stefan Gustavson. You may use it as you see fit, but
       * attribution is appreciated.
       *
       */

      (function (global) {
        var module = (global.noise = {});

        function Grad(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }

        Grad.prototype.dot2 = function (x, y) {
          return this.x * x + this.y * y;
        };

        Grad.prototype.dot3 = function (x, y, z) {
          return this.x * x + this.y * y + this.z * z;
        };

        var grad3 = [
          new Grad(1, 1, 0),
          new Grad(-1, 1, 0),
          new Grad(1, -1, 0),
          new Grad(-1, -1, 0),
          new Grad(1, 0, 1),
          new Grad(-1, 0, 1),
          new Grad(1, 0, -1),
          new Grad(-1, 0, -1),
          new Grad(0, 1, 1),
          new Grad(0, -1, 1),
          new Grad(0, 1, -1),
          new Grad(0, -1, -1),
        ];

        var p = [
          151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
          140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148,
          247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32,
          57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68,
          175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111,
          229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
          102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208,
          89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109,
          198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,
          118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,
          189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70,
          221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108,
          110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251,
          34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235,
          249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204,
          176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114,
          67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
        ];
        // To remove the need for index wrapping, double the permutation table length
        var perm = new Array(512);
        var gradP = new Array(512);

        // This isn't a very good seeding function, but it works ok. It supports 2^16
        // different seed values. Write something better if you need more seeds.
        module.seed = function (seed) {
          if (seed > 0 && seed < 1) {
            // Scale the seed out
            seed *= 65536;
          }

          seed = Math.floor(seed);
          if (seed < 256) {
            seed |= seed << 8;
          }

          for (var i = 0; i < 256; i++) {
            var v;
            if (i & 1) {
              v = p[i] ^ (seed & 255);
            } else {
              v = p[i] ^ ((seed >> 8) & 255);
            }

            perm[i] = perm[i + 256] = v;
            gradP[i] = gradP[i + 256] = grad3[v % 12];
          }
        };

        module.seed(0);

        /*
	  for(var i=0; i<256; i++) {
	    perm[i] = perm[i + 256] = p[i];
	    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
	  }*/

        // Skewing and unskewing factors for 2, 3, and 4 dimensions
        var F2 = 0.5 * (Math.sqrt(3) - 1);
        var G2 = (3 - Math.sqrt(3)) / 6;

        var F3 = 1 / 3;
        var G3 = 1 / 6;

        // 2D simplex noise
        module.simplex2 = function (xin, yin) {
          var n0, n1, n2; // Noise contributions from the three corners
          // Skew the input space to determine which simplex cell we're in
          var s = (xin + yin) * F2; // Hairy factor for 2D
          var i = Math.floor(xin + s);
          var j = Math.floor(yin + s);
          var t = (i + j) * G2;
          var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
          var y0 = yin - j + t;
          // For the 2D case, the simplex shape is an equilateral triangle.
          // Determine which simplex we are in.
          var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
          if (x0 > y0) {
            // lower triangle, XY order: (0,0)->(1,0)->(1,1)
            i1 = 1;
            j1 = 0;
          } else {
            // upper triangle, YX order: (0,0)->(0,1)->(1,1)
            i1 = 0;
            j1 = 1;
          }
          // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
          // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
          // c = (3-sqrt(3))/6
          var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
          var y1 = y0 - j1 + G2;
          var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
          var y2 = y0 - 1 + 2 * G2;
          // Work out the hashed gradient indices of the three simplex corners
          i &= 255;
          j &= 255;
          var gi0 = gradP[i + perm[j]];
          var gi1 = gradP[i + i1 + perm[j + j1]];
          var gi2 = gradP[i + 1 + perm[j + 1]];
          // Calculate the contribution from the three corners
          var t0 = 0.5 - x0 * x0 - y0 * y0;
          if (t0 < 0) {
            n0 = 0;
          } else {
            t0 *= t0;
            n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient
          }
          var t1 = 0.5 - x1 * x1 - y1 * y1;
          if (t1 < 0) {
            n1 = 0;
          } else {
            t1 *= t1;
            n1 = t1 * t1 * gi1.dot2(x1, y1);
          }
          var t2 = 0.5 - x2 * x2 - y2 * y2;
          if (t2 < 0) {
            n2 = 0;
          } else {
            t2 *= t2;
            n2 = t2 * t2 * gi2.dot2(x2, y2);
          }
          // Add contributions from each corner to get the final noise value.
          // The result is scaled to return values in the interval [-1,1].
          return 70 * (n0 + n1 + n2);
        };

        // 3D simplex noise
        module.simplex3 = function (xin, yin, zin) {
          var n0, n1, n2, n3; // Noise contributions from the four corners

          // Skew the input space to determine which simplex cell we're in
          var s = (xin + yin + zin) * F3; // Hairy factor for 2D
          var i = Math.floor(xin + s);
          var j = Math.floor(yin + s);
          var k = Math.floor(zin + s);

          var t = (i + j + k) * G3;
          var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
          var y0 = yin - j + t;
          var z0 = zin - k + t;

          // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
          // Determine which simplex we are in.
          var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
          var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
          if (x0 >= y0) {
            if (y0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            } else if (x0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            }
          } else {
            if (y0 < z0) {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else if (x0 < z0) {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            }
          }
          // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
          // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
          // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
          // c = 1/6.
          var x1 = x0 - i1 + G3; // Offsets for second corner
          var y1 = y0 - j1 + G3;
          var z1 = z0 - k1 + G3;

          var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
          var y2 = y0 - j2 + 2 * G3;
          var z2 = z0 - k2 + 2 * G3;

          var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
          var y3 = y0 - 1 + 3 * G3;
          var z3 = z0 - 1 + 3 * G3;

          // Work out the hashed gradient indices of the four simplex corners
          i &= 255;
          j &= 255;
          k &= 255;
          var gi0 = gradP[i + perm[j + perm[k]]];
          var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];
          var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];
          var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];

          // Calculate the contribution from the four corners
          var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
          if (t0 < 0) {
            n0 = 0;
          } else {
            t0 *= t0;
            n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient
          }
          var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
          if (t1 < 0) {
            n1 = 0;
          } else {
            t1 *= t1;
            n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
          }
          var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
          if (t2 < 0) {
            n2 = 0;
          } else {
            t2 *= t2;
            n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
          }
          var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
          if (t3 < 0) {
            n3 = 0;
          } else {
            t3 *= t3;
            n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
          }
          // Add contributions from each corner to get the final noise value.
          // The result is scaled to return values in the interval [-1,1].
          return 32 * (n0 + n1 + n2 + n3);
        };

        // ##### Perlin noise stuff

        function fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10);
        }

        function lerp(a, b, t) {
          return (1 - t) * a + t * b;
        }

        // 2D Perlin Noise
        module.perlin2 = function (x, y) {
          // Find unit grid cell containing point
          var X = Math.floor(x),
            Y = Math.floor(y);
          // Get relative xy coordinates of point within that cell
          x = x - X;
          y = y - Y;
          // Wrap the integer cells at 255 (smaller integer period can be introduced here)
          X = X & 255;
          Y = Y & 255;

          // Calculate noise contributions from each of the four corners
          var n00 = gradP[X + perm[Y]].dot2(x, y);
          var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);
          var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);
          var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);

          // Compute the fade curve value for x
          var u = fade(x);

          // Interpolate the four results
          return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));
        };

        // 3D Perlin Noise
        module.perlin3 = function (x, y, z) {
          // Find unit grid cell containing point
          var X = Math.floor(x),
            Y = Math.floor(y),
            Z = Math.floor(z);
          // Get relative xyz coordinates of point within that cell
          x = x - X;
          y = y - Y;
          z = z - Z;
          // Wrap the integer cells at 255 (smaller integer period can be introduced here)
          X = X & 255;
          Y = Y & 255;
          Z = Z & 255;

          // Calculate noise contributions from each of the eight corners
          var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);
          var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);
          var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);
          var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);
          var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);
          var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);
          var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);
          var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(
            x - 1,
            y - 1,
            z - 1
          );

          // Compute the fade curve value for x, y, z
          var u = fade(x);
          var v = fade(y);
          var w = fade(z);

          // Interpolate
          return lerp(
            lerp(lerp(n000, n100, u), lerp(n001, n101, u), w),
            lerp(lerp(n010, n110, u), lerp(n011, n111, u), w),
            v
          );
        };
      })(this);

      module.exports = this.noise;

      /***/
    },
    /* 12 */
    /***/ function (module, exports) {
      /**
       * dat-gui JavaScript Controller Library
       * http://code.google.com/p/dat-gui
       *
       * Copyright 2011 Data Arts Team, Google Creative Lab
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       */
      var dat = dat || {};
      dat.gui = dat.gui || {};
      dat.utils = dat.utils || {};
      dat.controllers = dat.controllers || {};
      dat.dom = dat.dom || {};
      dat.color = dat.color || {};
      dat.utils.css = (function () {
        return {
          load: function (f, a) {
            a = a || document;
            var d = a.createElement("link");
            d.type = "text/css";
            d.rel = "stylesheet";
            d.href = f;
            a.getElementsByTagName("head")[0].appendChild(d);
          },
          inject: function (f, a) {
            a = a || document;
            var d = document.createElement("style");
            d.type = "text/css";
            d.innerHTML = f;
            a.getElementsByTagName("head")[0].appendChild(d);
          },
        };
      })();
      dat.utils.common = (function () {
        var f = Array.prototype.forEach,
          a = Array.prototype.slice;
        return {
          BREAK: {},
          extend: function (d) {
            this.each(
              a.call(arguments, 1),
              function (a) {
                for (var c in a) this.isUndefined(a[c]) || (d[c] = a[c]);
              },
              this
            );
            return d;
          },
          defaults: function (d) {
            this.each(
              a.call(arguments, 1),
              function (a) {
                for (var c in a) this.isUndefined(d[c]) && (d[c] = a[c]);
              },
              this
            );
            return d;
          },
          compose: function () {
            var d = a.call(arguments);
            return function () {
              for (var e = a.call(arguments), c = d.length - 1; 0 <= c; c--)
                e = [d[c].apply(this, e)];
              return e[0];
            };
          },
          each: function (a, e, c) {
            if (a)
              if (f && a.forEach && a.forEach === f) a.forEach(e, c);
              else if (a.length === a.length + 0)
                for (
                  var b = 0, p = a.length;
                  b < p && !(b in a && e.call(c, a[b], b) === this.BREAK);
                  b++
                );
              else for (b in a) if (e.call(c, a[b], b) === this.BREAK) break;
          },
          defer: function (a) {
            setTimeout(a, 0);
          },
          toArray: function (d) {
            return d.toArray ? d.toArray() : a.call(d);
          },
          isUndefined: function (a) {
            return void 0 === a;
          },
          isNull: function (a) {
            return null === a;
          },
          isNaN: function (a) {
            return a !== a;
          },
          isArray:
            Array.isArray ||
            function (a) {
              return a.constructor === Array;
            },
          isObject: function (a) {
            return a === Object(a);
          },
          isNumber: function (a) {
            return a === a + 0;
          },
          isString: function (a) {
            return a === a + "";
          },
          isBoolean: function (a) {
            return !1 === a || !0 === a;
          },
          isFunction: function (a) {
            return "[object Function]" === Object.prototype.toString.call(a);
          },
        };
      })();
      dat.controllers.Controller = (function (f) {
        var a = function (a, e) {
          this.initialValue = a[e];
          this.domElement = document.createElement("div");
          this.object = a;
          this.property = e;
          this.__onFinishChange = this.__onChange = void 0;
        };
        f.extend(a.prototype, {
          onChange: function (a) {
            this.__onChange = a;
            return this;
          },
          onFinishChange: function (a) {
            this.__onFinishChange = a;
            return this;
          },
          setValue: function (a) {
            this.object[this.property] = a;
            this.__onChange && this.__onChange.call(this, a);
            this.updateDisplay();
            return this;
          },
          getValue: function () {
            return this.object[this.property];
          },
          updateDisplay: function () {
            return this;
          },
          isModified: function () {
            return this.initialValue !== this.getValue();
          },
        });
        return a;
      })(dat.utils.common);
      dat.dom.dom = (function (f) {
        function a(b) {
          if ("0" === b || f.isUndefined(b)) return 0;
          b = b.match(e);
          return f.isNull(b) ? 0 : parseFloat(b[1]);
        }
        var d = {};
        f.each(
          {
            HTMLEvents: ["change"],
            MouseEvents: [
              "click",
              "mousemove",
              "mousedown",
              "mouseup",
              "mouseover",
            ],
            KeyboardEvents: ["keydown"],
          },
          function (b, a) {
            f.each(b, function (b) {
              d[b] = a;
            });
          }
        );
        var e = /(\d+(\.\d+)?)px/,
          c = {
            makeSelectable: function (b, a) {
              void 0 !== b &&
                void 0 !== b.style &&
                ((b.onselectstart = a
                  ? function () {
                      return !1;
                    }
                  : function () {}),
                (b.style.MozUserSelect = a ? "auto" : "none"),
                (b.style.KhtmlUserSelect = a ? "auto" : "none"),
                (b.unselectable = a ? "on" : "off"));
            },
            makeFullscreen: function (b, a, c) {
              f.isUndefined(a) && (a = !0);
              f.isUndefined(c) && (c = !0);
              b.style.position = "absolute";
              a && ((b.style.left = 0), (b.style.right = 0));
              c && ((b.style.top = 0), (b.style.bottom = 0));
            },
            fakeEvent: function (b, a, c, e) {
              c = c || {};
              var r = d[a];
              if (!r) throw Error("Event type " + a + " not supported.");
              var n = document.createEvent(r);
              switch (r) {
                case "MouseEvents":
                  n.initMouseEvent(
                    a,
                    c.bubbles || !1,
                    c.cancelable || !0,
                    window,
                    c.clickCount || 1,
                    0,
                    0,
                    c.x || c.clientX || 0,
                    c.y || c.clientY || 0,
                    !1,
                    !1,
                    !1,
                    !1,
                    0,
                    null
                  );
                  break;
                case "KeyboardEvents":
                  r = n.initKeyboardEvent || n.initKeyEvent;
                  f.defaults(c, {
                    cancelable: !0,
                    ctrlKey: !1,
                    altKey: !1,
                    shiftKey: !1,
                    metaKey: !1,
                    keyCode: void 0,
                    charCode: void 0,
                  });
                  r(
                    a,
                    c.bubbles || !1,
                    c.cancelable,
                    window,
                    c.ctrlKey,
                    c.altKey,
                    c.shiftKey,
                    c.metaKey,
                    c.keyCode,
                    c.charCode
                  );
                  break;
                default:
                  n.initEvent(a, c.bubbles || !1, c.cancelable || !0);
              }
              f.defaults(n, e);
              b.dispatchEvent(n);
            },
            bind: function (a, e, d, f) {
              a.addEventListener
                ? a.addEventListener(e, d, f || !1)
                : a.attachEvent && a.attachEvent("on" + e, d);
              return c;
            },
            unbind: function (a, e, d, f) {
              a.removeEventListener
                ? a.removeEventListener(e, d, f || !1)
                : a.detachEvent && a.detachEvent("on" + e, d);
              return c;
            },
            addClass: function (a, e) {
              if (void 0 === a.className) a.className = e;
              else if (a.className !== e) {
                var d = a.className.split(/ +/);
                -1 == d.indexOf(e) &&
                  (d.push(e),
                  (a.className = d
                    .join(" ")
                    .replace(/^\s+/, "")
                    .replace(/\s+$/, "")));
              }
              return c;
            },
            removeClass: function (a, e) {
              if (e) {
                if (void 0 !== a.className)
                  if (a.className === e) a.removeAttribute("class");
                  else {
                    var d = a.className.split(/ +/),
                      f = d.indexOf(e);
                    -1 != f && (d.splice(f, 1), (a.className = d.join(" ")));
                  }
              } else a.className = void 0;
              return c;
            },
            hasClass: function (a, c) {
              return (
                new RegExp("(?:^|\\s+)" + c + "(?:\\s+|$)").test(a.className) ||
                !1
              );
            },
            getWidth: function (b) {
              b = getComputedStyle(b);
              return (
                a(b["border-left-width"]) +
                a(b["border-right-width"]) +
                a(b["padding-left"]) +
                a(b["padding-right"]) +
                a(b.width)
              );
            },
            getHeight: function (b) {
              b = getComputedStyle(b);
              return (
                a(b["border-top-width"]) +
                a(b["border-bottom-width"]) +
                a(b["padding-top"]) +
                a(b["padding-bottom"]) +
                a(b.height)
              );
            },
            getOffset: function (a) {
              var c = { left: 0, top: 0 };
              if (a.offsetParent) {
                do (c.left += a.offsetLeft), (c.top += a.offsetTop);
                while ((a = a.offsetParent));
              }
              return c;
            },
            isActive: function (a) {
              return a === document.activeElement && (a.type || a.href);
            },
          };
        return c;
      })(dat.utils.common);
      dat.controllers.OptionController = (function (f, a, d) {
        var e = function (c, b, f) {
          e.superclass.call(this, c, b);
          var q = this;
          this.__select = document.createElement("select");
          if (d.isArray(f)) {
            var l = {};
            d.each(f, function (a) {
              l[a] = a;
            });
            f = l;
          }
          d.each(f, function (a, b) {
            var c = document.createElement("option");
            c.innerHTML = b;
            c.setAttribute("value", a);
            q.__select.appendChild(c);
          });
          this.updateDisplay();
          a.bind(this.__select, "change", function () {
            q.setValue(this.options[this.selectedIndex].value);
          });
          this.domElement.appendChild(this.__select);
        };
        e.superclass = f;
        d.extend(e.prototype, f.prototype, {
          setValue: function (a) {
            a = e.superclass.prototype.setValue.call(this, a);
            this.__onFinishChange &&
              this.__onFinishChange.call(this, this.getValue());
            return a;
          },
          updateDisplay: function () {
            this.__select.value = this.getValue();
            return e.superclass.prototype.updateDisplay.call(this);
          },
        });
        return e;
      })(dat.controllers.Controller, dat.dom.dom, dat.utils.common);
      dat.controllers.NumberController = (function (f, a) {
        function d(a) {
          a = a.toString();
          return -1 < a.indexOf(".") ? a.length - a.indexOf(".") - 1 : 0;
        }
        var e = function (c, b, f) {
          e.superclass.call(this, c, b);
          f = f || {};
          this.__min = f.min;
          this.__max = f.max;
          this.__step = f.step;
          a.isUndefined(this.__step)
            ? (this.__impliedStep =
                0 == this.initialValue
                  ? 1
                  : Math.pow(
                      10,
                      Math.floor(Math.log(this.initialValue) / Math.LN10)
                    ) / 10)
            : (this.__impliedStep = this.__step);
          this.__precision = d(this.__impliedStep);
        };
        e.superclass = f;
        a.extend(e.prototype, f.prototype, {
          setValue: function (a) {
            void 0 !== this.__min && a < this.__min
              ? (a = this.__min)
              : void 0 !== this.__max && a > this.__max && (a = this.__max);
            void 0 !== this.__step &&
              0 != a % this.__step &&
              (a = Math.round(a / this.__step) * this.__step);
            return e.superclass.prototype.setValue.call(this, a);
          },
          min: function (a) {
            this.__min = a;
            return this;
          },
          max: function (a) {
            this.__max = a;
            return this;
          },
          step: function (a) {
            this.__impliedStep = this.__step = a;
            this.__precision = d(a);
            return this;
          },
        });
        return e;
      })(dat.controllers.Controller, dat.utils.common);
      dat.controllers.NumberControllerBox = (function (f, a, d) {
        var e = function (c, b, f) {
          function q() {
            var a = parseFloat(n.__input.value);
            d.isNaN(a) || n.setValue(a);
          }
          function l(a) {
            var b = u - a.clientY;
            n.setValue(n.getValue() + b * n.__impliedStep);
            u = a.clientY;
          }
          function r() {
            a.unbind(window, "mousemove", l);
            a.unbind(window, "mouseup", r);
          }
          this.__truncationSuspended = !1;
          e.superclass.call(this, c, b, f);
          var n = this,
            u;
          this.__input = document.createElement("input");
          this.__input.setAttribute("type", "text");
          a.bind(this.__input, "change", q);
          a.bind(this.__input, "blur", function () {
            q();
            n.__onFinishChange && n.__onFinishChange.call(n, n.getValue());
          });
          a.bind(this.__input, "mousedown", function (b) {
            a.bind(window, "mousemove", l);
            a.bind(window, "mouseup", r);
            u = b.clientY;
          });
          a.bind(this.__input, "keydown", function (a) {
            13 === a.keyCode &&
              ((n.__truncationSuspended = !0),
              this.blur(),
              (n.__truncationSuspended = !1));
          });
          this.updateDisplay();
          this.domElement.appendChild(this.__input);
        };
        e.superclass = f;
        d.extend(e.prototype, f.prototype, {
          updateDisplay: function () {
            var a = this.__input,
              b;
            if (this.__truncationSuspended) b = this.getValue();
            else {
              b = this.getValue();
              var d = Math.pow(10, this.__precision);
              b = Math.round(b * d) / d;
            }
            a.value = b;
            return e.superclass.prototype.updateDisplay.call(this);
          },
        });
        return e;
      })(dat.controllers.NumberController, dat.dom.dom, dat.utils.common);
      dat.controllers.NumberControllerSlider = (function (f, a, d, e, c) {
        function b(a, b, c, e, d) {
          return e + ((a - b) / (c - b)) * (d - e);
        }
        var p = function (c, e, d, f, u) {
          function A(c) {
            c.preventDefault();
            var e = a.getOffset(k.__background),
              d = a.getWidth(k.__background);
            k.setValue(b(c.clientX, e.left, e.left + d, k.__min, k.__max));
            return !1;
          }
          function g() {
            a.unbind(window, "mousemove", A);
            a.unbind(window, "mouseup", g);
            k.__onFinishChange && k.__onFinishChange.call(k, k.getValue());
          }
          p.superclass.call(this, c, e, { min: d, max: f, step: u });
          var k = this;
          this.__background = document.createElement("div");
          this.__foreground = document.createElement("div");
          a.bind(this.__background, "mousedown", function (b) {
            a.bind(window, "mousemove", A);
            a.bind(window, "mouseup", g);
            A(b);
          });
          a.addClass(this.__background, "slider");
          a.addClass(this.__foreground, "slider-fg");
          this.updateDisplay();
          this.__background.appendChild(this.__foreground);
          this.domElement.appendChild(this.__background);
        };
        p.superclass = f;
        p.useDefaultStyles = function () {
          d.inject(c);
        };
        e.extend(p.prototype, f.prototype, {
          updateDisplay: function () {
            var a = (this.getValue() - this.__min) / (this.__max - this.__min);
            this.__foreground.style.width = 100 * a + "%";
            return p.superclass.prototype.updateDisplay.call(this);
          },
        });
        return p;
      })(
        dat.controllers.NumberController,
        dat.dom.dom,
        dat.utils.css,
        dat.utils.common,
        "/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n.slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}"
      );
      dat.controllers.FunctionController = (function (f, a, d) {
        var e = function (c, b, d) {
          e.superclass.call(this, c, b);
          var f = this;
          this.__button = document.createElement("div");
          this.__button.innerHTML = void 0 === d ? "Fire" : d;
          a.bind(this.__button, "click", function (a) {
            a.preventDefault();
            f.fire();
            return !1;
          });
          a.addClass(this.__button, "button");
          this.domElement.appendChild(this.__button);
        };
        e.superclass = f;
        d.extend(e.prototype, f.prototype, {
          fire: function () {
            this.__onChange && this.__onChange.call(this);
            this.getValue().call(this.object);
            this.__onFinishChange &&
              this.__onFinishChange.call(this, this.getValue());
          },
        });
        return e;
      })(dat.controllers.Controller, dat.dom.dom, dat.utils.common);
      dat.controllers.BooleanController = (function (f, a, d) {
        var e = function (c, b) {
          e.superclass.call(this, c, b);
          var d = this;
          this.__prev = this.getValue();
          this.__checkbox = document.createElement("input");
          this.__checkbox.setAttribute("type", "checkbox");
          a.bind(
            this.__checkbox,
            "change",
            function () {
              d.setValue(!d.__prev);
            },
            !1
          );
          this.domElement.appendChild(this.__checkbox);
          this.updateDisplay();
        };
        e.superclass = f;
        d.extend(e.prototype, f.prototype, {
          setValue: function (a) {
            a = e.superclass.prototype.setValue.call(this, a);
            this.__onFinishChange &&
              this.__onFinishChange.call(this, this.getValue());
            this.__prev = this.getValue();
            return a;
          },
          updateDisplay: function () {
            !0 === this.getValue()
              ? (this.__checkbox.setAttribute("checked", "checked"),
                (this.__checkbox.checked = !0))
              : (this.__checkbox.checked = !1);
            return e.superclass.prototype.updateDisplay.call(this);
          },
        });
        return e;
      })(dat.controllers.Controller, dat.dom.dom, dat.utils.common);
      dat.color.toString = (function (f) {
        return function (a) {
          if (1 == a.a || f.isUndefined(a.a)) {
            for (a = a.hex.toString(16); 6 > a.length; ) a = "0" + a;
            return "#" + a;
          }
          return (
            "rgba(" +
            Math.round(a.r) +
            "," +
            Math.round(a.g) +
            "," +
            Math.round(a.b) +
            "," +
            a.a +
            ")"
          );
        };
      })(dat.utils.common);
      dat.color.interpret = (function (f, a) {
        var d,
          e,
          c = [
            {
              litmus: a.isString,
              conversions: {
                THREE_CHAR_HEX: {
                  read: function (a) {
                    a = a.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                    return null === a
                      ? !1
                      : {
                          space: "HEX",
                          hex: parseInt(
                            "0x" +
                              a[1].toString() +
                              a[1].toString() +
                              a[2].toString() +
                              a[2].toString() +
                              a[3].toString() +
                              a[3].toString()
                          ),
                        };
                  },
                  write: f,
                },
                SIX_CHAR_HEX: {
                  read: function (a) {
                    a = a.match(/^#([A-F0-9]{6})$/i);
                    return null === a
                      ? !1
                      : { space: "HEX", hex: parseInt("0x" + a[1].toString()) };
                  },
                  write: f,
                },
                CSS_RGB: {
                  read: function (a) {
                    a = a.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                    return null === a
                      ? !1
                      : {
                          space: "RGB",
                          r: parseFloat(a[1]),
                          g: parseFloat(a[2]),
                          b: parseFloat(a[3]),
                        };
                  },
                  write: f,
                },
                CSS_RGBA: {
                  read: function (a) {
                    a = a.match(
                      /^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/
                    );
                    return null === a
                      ? !1
                      : {
                          space: "RGB",
                          r: parseFloat(a[1]),
                          g: parseFloat(a[2]),
                          b: parseFloat(a[3]),
                          a: parseFloat(a[4]),
                        };
                  },
                  write: f,
                },
              },
            },
            {
              litmus: a.isNumber,
              conversions: {
                HEX: {
                  read: function (a) {
                    return { space: "HEX", hex: a, conversionName: "HEX" };
                  },
                  write: function (a) {
                    return a.hex;
                  },
                },
              },
            },
            {
              litmus: a.isArray,
              conversions: {
                RGB_ARRAY: {
                  read: function (a) {
                    return 3 != a.length
                      ? !1
                      : { space: "RGB", r: a[0], g: a[1], b: a[2] };
                  },
                  write: function (a) {
                    return [a.r, a.g, a.b];
                  },
                },
                RGBA_ARRAY: {
                  read: function (a) {
                    return 4 != a.length
                      ? !1
                      : { space: "RGB", r: a[0], g: a[1], b: a[2], a: a[3] };
                  },
                  write: function (a) {
                    return [a.r, a.g, a.b, a.a];
                  },
                },
              },
            },
            {
              litmus: a.isObject,
              conversions: {
                RGBA_OBJ: {
                  read: function (b) {
                    return a.isNumber(b.r) &&
                      a.isNumber(b.g) &&
                      a.isNumber(b.b) &&
                      a.isNumber(b.a)
                      ? { space: "RGB", r: b.r, g: b.g, b: b.b, a: b.a }
                      : !1;
                  },
                  write: function (a) {
                    return { r: a.r, g: a.g, b: a.b, a: a.a };
                  },
                },
                RGB_OBJ: {
                  read: function (b) {
                    return a.isNumber(b.r) && a.isNumber(b.g) && a.isNumber(b.b)
                      ? { space: "RGB", r: b.r, g: b.g, b: b.b }
                      : !1;
                  },
                  write: function (a) {
                    return { r: a.r, g: a.g, b: a.b };
                  },
                },
                HSVA_OBJ: {
                  read: function (b) {
                    return a.isNumber(b.h) &&
                      a.isNumber(b.s) &&
                      a.isNumber(b.v) &&
                      a.isNumber(b.a)
                      ? { space: "HSV", h: b.h, s: b.s, v: b.v, a: b.a }
                      : !1;
                  },
                  write: function (a) {
                    return { h: a.h, s: a.s, v: a.v, a: a.a };
                  },
                },
                HSV_OBJ: {
                  read: function (b) {
                    return a.isNumber(b.h) && a.isNumber(b.s) && a.isNumber(b.v)
                      ? { space: "HSV", h: b.h, s: b.s, v: b.v }
                      : !1;
                  },
                  write: function (a) {
                    return { h: a.h, s: a.s, v: a.v };
                  },
                },
              },
            },
          ];
        return function () {
          e = !1;
          var b = 1 < arguments.length ? a.toArray(arguments) : arguments[0];
          a.each(c, function (c) {
            if (c.litmus(b))
              return (
                a.each(c.conversions, function (c, f) {
                  d = c.read(b);
                  if (!1 === e && !1 !== d)
                    return (
                      (e = d),
                      (d.conversionName = f),
                      (d.conversion = c),
                      a.BREAK
                    );
                }),
                a.BREAK
              );
          });
          return e;
        };
      })(dat.color.toString, dat.utils.common);
      dat.GUI = dat.gui.GUI = (function (
        f,
        a,
        d,
        e,
        c,
        b,
        p,
        q,
        l,
        r,
        n,
        u,
        A,
        g,
        k
      ) {
        function v(a, b, h, d) {
          if (void 0 === b[h])
            throw Error("Object " + b + ' has no property "' + h + '"');
          d.color
            ? (b = new n(b, h))
            : ((b = [b, h].concat(d.factoryArgs)), (b = e.apply(a, b)));
          d.before instanceof c && (d.before = d.before.__li);
          y(a, b);
          g.addClass(b.domElement, "c");
          h = document.createElement("span");
          g.addClass(h, "property-name");
          h.innerHTML = b.property;
          var f = document.createElement("div");
          f.appendChild(h);
          f.appendChild(b.domElement);
          d = w(a, f, d.before);
          g.addClass(d, m.CLASS_CONTROLLER_ROW);
          g.addClass(d, typeof b.getValue());
          t(a, d, b);
          a.__controllers.push(b);
          return b;
        }
        function w(a, b, h) {
          var c = document.createElement("li");
          b && c.appendChild(b);
          h ? a.__ul.insertBefore(c, params.before) : a.__ul.appendChild(c);
          a.onResize();
          return c;
        }
        function t(a, c, h) {
          h.__li = c;
          h.__gui = a;
          k.extend(h, {
            options: function (b) {
              if (1 < arguments.length)
                return (
                  h.remove(),
                  v(a, h.object, h.property, {
                    before: h.__li.nextElementSibling,
                    factoryArgs: [k.toArray(arguments)],
                  })
                );
              if (k.isArray(b) || k.isObject(b))
                return (
                  h.remove(),
                  v(a, h.object, h.property, {
                    before: h.__li.nextElementSibling,
                    factoryArgs: [b],
                  })
                );
            },
            name: function (a) {
              h.__li.firstElementChild.firstElementChild.innerHTML = a;
              return h;
            },
            listen: function () {
              h.__gui.listen(h);
              return h;
            },
            remove: function () {
              h.__gui.remove(h);
              return h;
            },
          });
          if (h instanceof l) {
            var d = new q(h.object, h.property, {
              min: h.__min,
              max: h.__max,
              step: h.__step,
            });
            k.each(
              ["updateDisplay", "onChange", "onFinishChange"],
              function (a) {
                var K = h[a],
                  b = d[a];
                h[a] = d[a] = function () {
                  var a = Array.prototype.slice.call(arguments);
                  K.apply(h, a);
                  return b.apply(d, a);
                };
              }
            );
            g.addClass(c, "has-slider");
            h.domElement.insertBefore(
              d.domElement,
              h.domElement.firstElementChild
            );
          } else if (h instanceof q) {
            var e = function (b) {
              return k.isNumber(h.__min) && k.isNumber(h.__max)
                ? (h.remove(),
                  v(a, h.object, h.property, {
                    before: h.__li.nextElementSibling,
                    factoryArgs: [h.__min, h.__max, h.__step],
                  }))
                : b;
            };
            h.min = k.compose(e, h.min);
            h.max = k.compose(e, h.max);
          } else
            h instanceof b
              ? (g.bind(c, "click", function () {
                  g.fakeEvent(h.__checkbox, "click");
                }),
                g.bind(h.__checkbox, "click", function (a) {
                  a.stopPropagation();
                }))
              : h instanceof p
              ? (g.bind(c, "click", function () {
                  g.fakeEvent(h.__button, "click");
                }),
                g.bind(c, "mouseover", function () {
                  g.addClass(h.__button, "hover");
                }),
                g.bind(c, "mouseout", function () {
                  g.removeClass(h.__button, "hover");
                }))
              : h instanceof n &&
                (g.addClass(c, "color"),
                (h.updateDisplay = k.compose(function (a) {
                  c.style.borderLeftColor = h.__color.toString();
                  return a;
                }, h.updateDisplay)),
                h.updateDisplay());
          h.setValue = k.compose(function (b) {
            a.getRoot().__preset_select && h.isModified() && E(a.getRoot(), !0);
            return b;
          }, h.setValue);
        }
        function y(a, b) {
          var c = a.getRoot(),
            d = c.__rememberedObjects.indexOf(b.object);
          if (-1 != d) {
            var e = c.__rememberedObjectIndecesToControllers[d];
            void 0 === e &&
              ((e = {}), (c.__rememberedObjectIndecesToControllers[d] = e));
            e[b.property] = b;
            if (c.load && c.load.remembered) {
              c = c.load.remembered;
              if (c[a.preset]) c = c[a.preset];
              else if (c.Default) c = c.Default;
              else return;
              c[d] &&
                void 0 !== c[d][b.property] &&
                ((d = c[d][b.property]), (b.initialValue = d), b.setValue(d));
            }
          }
        }
        function L(a) {
          var b = (a.__save_row = document.createElement("li"));
          g.addClass(a.domElement, "has-save");
          a.__ul.insertBefore(b, a.__ul.firstChild);
          g.addClass(b, "save-row");
          var c = document.createElement("span");
          c.innerHTML = "&nbsp;";
          g.addClass(c, "button gears");
          var d = document.createElement("span");
          d.innerHTML = "Save";
          g.addClass(d, "button");
          g.addClass(d, "save");
          var e = document.createElement("span");
          e.innerHTML = "New";
          g.addClass(e, "button");
          g.addClass(e, "save-as");
          var f = document.createElement("span");
          f.innerHTML = "Revert";
          g.addClass(f, "button");
          g.addClass(f, "revert");
          var r = (a.__preset_select = document.createElement("select"));
          a.load && a.load.remembered
            ? k.each(a.load.remembered, function (b, c) {
                F(a, c, c == a.preset);
              })
            : F(a, "Default", !1);
          g.bind(r, "change", function () {
            for (var b = 0; b < a.__preset_select.length; b++)
              a.__preset_select[b].innerHTML = a.__preset_select[b].value;
            a.preset = this.value;
          });
          b.appendChild(r);
          b.appendChild(c);
          b.appendChild(d);
          b.appendChild(e);
          b.appendChild(f);
          if (x) {
            var n = function () {
                u.style.display = a.useLocalStorage ? "block" : "none";
              },
              b = document.getElementById("dg-save-locally"),
              u = document.getElementById("dg-local-explain");
            b.style.display = "block";
            b = document.getElementById("dg-local-storage");
            "true" ===
              localStorage.getItem(document.location.href + ".isLocal") &&
              b.setAttribute("checked", "checked");
            n();
            g.bind(b, "change", function () {
              a.useLocalStorage = !a.useLocalStorage;
              n();
            });
          }
          var m = document.getElementById("dg-new-constructor");
          g.bind(m, "keydown", function (a) {
            !a.metaKey || (67 !== a.which && 67 != a.keyCode) || B.hide();
          });
          g.bind(c, "click", function () {
            m.innerHTML = JSON.stringify(a.getSaveObject(), void 0, 2);
            B.show();
            m.focus();
            m.select();
          });
          g.bind(d, "click", function () {
            a.save();
          });
          g.bind(e, "click", function () {
            var b = prompt("Enter a new preset name.");
            b && a.saveAs(b);
          });
          g.bind(f, "click", function () {
            a.revert();
          });
        }
        function M(a) {
          function b(f) {
            f.preventDefault();
            e = f.clientX;
            g.addClass(a.__closeButton, m.CLASS_DRAG);
            g.bind(window, "mousemove", c);
            g.bind(window, "mouseup", d);
            return !1;
          }
          function c(b) {
            b.preventDefault();
            a.width += e - b.clientX;
            a.onResize();
            e = b.clientX;
            return !1;
          }
          function d() {
            g.removeClass(a.__closeButton, m.CLASS_DRAG);
            g.unbind(window, "mousemove", c);
            g.unbind(window, "mouseup", d);
          }
          a.__resize_handle = document.createElement("div");
          k.extend(a.__resize_handle.style, {
            width: "6px",
            marginLeft: "-3px",
            height: "200px",
            cursor: "ew-resize",
            position: "absolute",
          });
          var e;
          g.bind(a.__resize_handle, "mousedown", b);
          g.bind(a.__closeButton, "mousedown", b);
          a.domElement.insertBefore(
            a.__resize_handle,
            a.domElement.firstElementChild
          );
        }
        function G(a, b) {
          a.domElement.style.width = b + "px";
          a.__save_row && a.autoPlace && (a.__save_row.style.width = b + "px");
          a.__closeButton && (a.__closeButton.style.width = b + "px");
        }
        function C(a, b) {
          var c = {};
          k.each(a.__rememberedObjects, function (d, e) {
            var f = {};
            k.each(
              a.__rememberedObjectIndecesToControllers[e],
              function (a, c) {
                f[c] = b ? a.initialValue : a.getValue();
              }
            );
            c[e] = f;
          });
          return c;
        }
        function F(a, b, c) {
          var d = document.createElement("option");
          d.innerHTML = b;
          d.value = b;
          a.__preset_select.appendChild(d);
          c && (a.__preset_select.selectedIndex = a.__preset_select.length - 1);
        }
        function E(a, b) {
          var c = a.__preset_select[a.__preset_select.selectedIndex];
          c.innerHTML = b ? c.value + "*" : c.value;
        }
        function H(a) {
          0 != a.length &&
            u(function () {
              H(a);
            });
          k.each(a, function (a) {
            a.updateDisplay();
          });
        }
        f.inject(d);
        var x;
        try {
          x = "localStorage" in window && null !== window.localStorage;
        } catch (N) {
          x = !1;
        }
        var B,
          I = !0,
          z,
          D = !1,
          J = [],
          m = function (a) {
            function b() {
              var a = c.getRoot();
              a.width += 1;
              k.defer(function () {
                --a.width;
              });
            }
            var c = this;
            this.domElement = document.createElement("div");
            this.__ul = document.createElement("ul");
            this.domElement.appendChild(this.__ul);
            g.addClass(this.domElement, "dg");
            this.__folders = {};
            this.__controllers = [];
            this.__rememberedObjects = [];
            this.__rememberedObjectIndecesToControllers = [];
            this.__listening = [];
            a = a || {};
            a = k.defaults(a, { autoPlace: !0, width: m.DEFAULT_WIDTH });
            a = k.defaults(a, {
              resizable: a.autoPlace,
              hideable: a.autoPlace,
            });
            k.isUndefined(a.load)
              ? (a.load = { preset: "Default" })
              : a.preset && (a.load.preset = a.preset);
            k.isUndefined(a.parent) && a.hideable && J.push(this);
            a.resizable = k.isUndefined(a.parent) && a.resizable;
            a.autoPlace && k.isUndefined(a.scrollable) && (a.scrollable = !0);
            var d =
                x &&
                "true" ===
                  localStorage.getItem(document.location.href + ".isLocal"),
              e;
            Object.defineProperties(this, {
              parent: {
                get: function () {
                  return a.parent;
                },
              },
              scrollable: {
                get: function () {
                  return a.scrollable;
                },
              },
              autoPlace: {
                get: function () {
                  return a.autoPlace;
                },
              },
              preset: {
                get: function () {
                  return c.parent ? c.getRoot().preset : a.load.preset;
                },
                set: function (b) {
                  c.parent ? (c.getRoot().preset = b) : (a.load.preset = b);
                  for (b = 0; b < this.__preset_select.length; b++)
                    this.__preset_select[b].value == this.preset &&
                      (this.__preset_select.selectedIndex = b);
                  c.revert();
                },
              },
              width: {
                get: function () {
                  return a.width;
                },
                set: function (b) {
                  a.width = b;
                  G(c, b);
                },
              },
              name: {
                get: function () {
                  return a.name;
                },
                set: function (b) {
                  a.name = b;
                  r && (r.innerHTML = a.name);
                },
              },
              closed: {
                get: function () {
                  return a.closed;
                },
                set: function (b) {
                  a.closed = b;
                  a.closed
                    ? g.addClass(c.__ul, m.CLASS_CLOSED)
                    : g.removeClass(c.__ul, m.CLASS_CLOSED);
                  this.onResize();
                  c.__closeButton &&
                    (c.__closeButton.innerHTML = b
                      ? m.TEXT_OPEN
                      : m.TEXT_CLOSED);
                },
              },
              load: {
                get: function () {
                  return a.load;
                },
              },
              useLocalStorage: {
                get: function () {
                  return d;
                },
                set: function (a) {
                  x &&
                    ((d = a)
                      ? g.bind(window, "unload", e)
                      : g.unbind(window, "unload", e),
                    localStorage.setItem(
                      document.location.href + ".isLocal",
                      a
                    ));
                },
              },
            });
            if (k.isUndefined(a.parent)) {
              a.closed = !1;
              g.addClass(this.domElement, m.CLASS_MAIN);
              g.makeSelectable(this.domElement, !1);
              if (x && d) {
                c.useLocalStorage = !0;
                var f = localStorage.getItem(document.location.href + ".gui");
                f && (a.load = JSON.parse(f));
              }
              this.__closeButton = document.createElement("div");
              this.__closeButton.innerHTML = m.TEXT_CLOSED;
              g.addClass(this.__closeButton, m.CLASS_CLOSE_BUTTON);
              this.domElement.appendChild(this.__closeButton);
              g.bind(this.__closeButton, "click", function () {
                c.closed = !c.closed;
              });
            } else {
              void 0 === a.closed && (a.closed = !0);
              var r = document.createTextNode(a.name);
              g.addClass(r, "controller-name");
              f = w(c, r);
              g.addClass(this.__ul, m.CLASS_CLOSED);
              g.addClass(f, "title");
              g.bind(f, "click", function (a) {
                a.preventDefault();
                c.closed = !c.closed;
                return !1;
              });
              a.closed || (this.closed = !1);
            }
            a.autoPlace &&
              (k.isUndefined(a.parent) &&
                (I &&
                  ((z = document.createElement("div")),
                  g.addClass(z, "dg"),
                  g.addClass(z, m.CLASS_AUTO_PLACE_CONTAINER),
                  document.body.appendChild(z),
                  (I = !1)),
                z.appendChild(this.domElement),
                g.addClass(this.domElement, m.CLASS_AUTO_PLACE)),
              this.parent || G(c, a.width));
            g.bind(window, "resize", function () {
              c.onResize();
            });
            g.bind(this.__ul, "webkitTransitionEnd", function () {
              c.onResize();
            });
            g.bind(this.__ul, "transitionend", function () {
              c.onResize();
            });
            g.bind(this.__ul, "oTransitionEnd", function () {
              c.onResize();
            });
            this.onResize();
            a.resizable && M(this);
            this.saveToLocalStorageIfPossible = e = function () {
              x &&
                "true" ===
                  localStorage.getItem(document.location.href + ".isLocal") &&
                localStorage.setItem(
                  document.location.href + ".gui",
                  JSON.stringify(c.getSaveObject())
                );
            };
            c.getRoot();
            a.parent || b();
          };
        m.toggleHide = function () {
          D = !D;
          k.each(J, function (a) {
            a.domElement.style.zIndex = D ? -999 : 999;
            a.domElement.style.opacity = D ? 0 : 1;
          });
        };
        m.CLASS_AUTO_PLACE = "a";
        m.CLASS_AUTO_PLACE_CONTAINER = "ac";
        m.CLASS_MAIN = "main";
        m.CLASS_CONTROLLER_ROW = "cr";
        m.CLASS_TOO_TALL = "taller-than-window";
        m.CLASS_CLOSED = "closed";
        m.CLASS_CLOSE_BUTTON = "close-button";
        m.CLASS_DRAG = "drag";
        m.DEFAULT_WIDTH = 245;
        m.TEXT_CLOSED = "Close Controls";
        m.TEXT_OPEN = "Open Controls";
        g.bind(
          window,
          "keydown",
          function (a) {
            "text" === document.activeElement.type ||
              (72 !== a.which && 72 != a.keyCode) ||
              m.toggleHide();
          },
          !1
        );
        k.extend(m.prototype, {
          add: function (a, b) {
            return v(this, a, b, {
              factoryArgs: Array.prototype.slice.call(arguments, 2),
            });
          },
          addColor: function (a, b) {
            return v(this, a, b, { color: !0 });
          },
          remove: function (a) {
            this.__ul.removeChild(a.__li);
            this.__controllers.splice(this.__controllers.indexOf(a), 1);
            var b = this;
            k.defer(function () {
              b.onResize();
            });
          },
          destroy: function () {
            this.autoPlace && z.removeChild(this.domElement);
          },
          addFolder: function (a) {
            if (void 0 !== this.__folders[a])
              throw Error(
                'You already have a folder in this GUI by the name "' + a + '"'
              );
            var b = { name: a, parent: this };
            b.autoPlace = this.autoPlace;
            this.load &&
              this.load.folders &&
              this.load.folders[a] &&
              ((b.closed = this.load.folders[a].closed),
              (b.load = this.load.folders[a]));
            b = new m(b);
            this.__folders[a] = b;
            a = w(this, b.domElement);
            g.addClass(a, "folder");
            return b;
          },
          open: function () {
            this.closed = !1;
          },
          close: function () {
            this.closed = !0;
          },
          onResize: function () {
            var a = this.getRoot();
            if (a.scrollable) {
              var b = g.getOffset(a.__ul).top,
                c = 0;
              k.each(a.__ul.childNodes, function (b) {
                (a.autoPlace && b === a.__save_row) || (c += g.getHeight(b));
              });
              window.innerHeight - b - 20 < c
                ? (g.addClass(a.domElement, m.CLASS_TOO_TALL),
                  (a.__ul.style.height = window.innerHeight - b - 20 + "px"))
                : (g.removeClass(a.domElement, m.CLASS_TOO_TALL),
                  (a.__ul.style.height = "auto"));
            }
            a.__resize_handle &&
              k.defer(function () {
                a.__resize_handle.style.height = a.__ul.offsetHeight + "px";
              });
            a.__closeButton && (a.__closeButton.style.width = a.width + "px");
          },
          remember: function () {
            k.isUndefined(B) && ((B = new A()), (B.domElement.innerHTML = a));
            if (this.parent)
              throw Error("You can only call remember on a top level GUI.");
            var b = this;
            k.each(Array.prototype.slice.call(arguments), function (a) {
              0 == b.__rememberedObjects.length && L(b);
              -1 == b.__rememberedObjects.indexOf(a) &&
                b.__rememberedObjects.push(a);
            });
            this.autoPlace && G(this, this.width);
          },
          getRoot: function () {
            for (var a = this; a.parent; ) a = a.parent;
            return a;
          },
          getSaveObject: function () {
            var a = this.load;
            a.closed = this.closed;
            0 < this.__rememberedObjects.length &&
              ((a.preset = this.preset),
              a.remembered || (a.remembered = {}),
              (a.remembered[this.preset] = C(this)));
            a.folders = {};
            k.each(this.__folders, function (b, c) {
              a.folders[c] = b.getSaveObject();
            });
            return a;
          },
          save: function () {
            this.load.remembered || (this.load.remembered = {});
            this.load.remembered[this.preset] = C(this);
            E(this, !1);
            this.saveToLocalStorageIfPossible();
          },
          saveAs: function (a) {
            this.load.remembered ||
              ((this.load.remembered = {}),
              (this.load.remembered.Default = C(this, !0)));
            this.load.remembered[a] = C(this);
            this.preset = a;
            F(this, a, !0);
            this.saveToLocalStorageIfPossible();
          },
          revert: function (a) {
            k.each(
              this.__controllers,
              function (b) {
                this.getRoot().load.remembered
                  ? y(a || this.getRoot(), b)
                  : b.setValue(b.initialValue);
              },
              this
            );
            k.each(this.__folders, function (a) {
              a.revert(a);
            });
            a || E(this.getRoot(), !1);
          },
          listen: function (a) {
            var b = 0 == this.__listening.length;
            this.__listening.push(a);
            b && H(this.__listening);
          },
        });
        return m;
      })(
        dat.utils.css,
        '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>',
        ".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      position: absolute;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul {\n      margin-top: 27px; }\n      .dg.a.has-save > ul.closed {\n        margin-top: 0; }\n    .dg.a .save-row {\n      position: fixed;\n      top: 0;\n      z-index: 1002; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: hidden;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid rgba(0, 0, 0, 0); }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 9px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name,\n  .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: black url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2fa1d6; }\n    .dg .cr.number input[type=text] {\n      color: #2fa1d6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover, .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2fa1d6; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n",
        (dat.controllers.factory = (function (f, a, d, e, c, b, p) {
          return function (q, l, r, n) {
            var u = q[l];
            if (p.isArray(r) || p.isObject(r)) return new f(q, l, r);
            if (p.isNumber(u))
              return p.isNumber(r) && p.isNumber(n)
                ? new d(q, l, r, n)
                : new a(q, l, { min: r, max: n });
            if (p.isString(u)) return new e(q, l);
            if (p.isFunction(u)) return new c(q, l, "");
            if (p.isBoolean(u)) return new b(q, l);
          };
        })(
          dat.controllers.OptionController,
          dat.controllers.NumberControllerBox,
          dat.controllers.NumberControllerSlider,
          (dat.controllers.StringController = (function (f, a, d) {
            var e = function (c, b) {
              function d() {
                f.setValue(f.__input.value);
              }
              e.superclass.call(this, c, b);
              var f = this;
              this.__input = document.createElement("input");
              this.__input.setAttribute("type", "text");
              a.bind(this.__input, "keyup", d);
              a.bind(this.__input, "change", d);
              a.bind(this.__input, "blur", function () {
                f.__onFinishChange && f.__onFinishChange.call(f, f.getValue());
              });
              a.bind(this.__input, "keydown", function (a) {
                13 === a.keyCode && this.blur();
              });
              this.updateDisplay();
              this.domElement.appendChild(this.__input);
            };
            e.superclass = f;
            d.extend(e.prototype, f.prototype, {
              updateDisplay: function () {
                a.isActive(this.__input) ||
                  (this.__input.value = this.getValue());
                return e.superclass.prototype.updateDisplay.call(this);
              },
            });
            return e;
          })(dat.controllers.Controller, dat.dom.dom, dat.utils.common)),
          dat.controllers.FunctionController,
          dat.controllers.BooleanController,
          dat.utils.common
        )),
        dat.controllers.Controller,
        dat.controllers.BooleanController,
        dat.controllers.FunctionController,
        dat.controllers.NumberControllerBox,
        dat.controllers.NumberControllerSlider,
        dat.controllers.OptionController,
        (dat.controllers.ColorController = (function (f, a, d, e, c) {
          function b(a, b, d, e) {
            a.style.background = "";
            c.each(l, function (c) {
              a.style.cssText +=
                "background: " +
                c +
                "linear-gradient(" +
                b +
                ", " +
                d +
                " 0%, " +
                e +
                " 100%); ";
            });
          }
          function p(a) {
            a.style.background = "";
            a.style.cssText +=
              "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);";
            a.style.cssText +=
              "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
            a.style.cssText +=
              "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
            a.style.cssText +=
              "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
            a.style.cssText +=
              "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
          }
          var q = function (f, n) {
            function u(b) {
              v(b);
              a.bind(window, "mousemove", v);
              a.bind(window, "mouseup", l);
            }
            function l() {
              a.unbind(window, "mousemove", v);
              a.unbind(window, "mouseup", l);
            }
            function g() {
              var a = e(this.value);
              !1 !== a
                ? ((t.__color.__state = a), t.setValue(t.__color.toOriginal()))
                : (this.value = t.__color.toString());
            }
            function k() {
              a.unbind(window, "mousemove", w);
              a.unbind(window, "mouseup", k);
            }
            function v(b) {
              b.preventDefault();
              var c = a.getWidth(t.__saturation_field),
                d = a.getOffset(t.__saturation_field),
                e = (b.clientX - d.left + document.body.scrollLeft) / c;
              b = 1 - (b.clientY - d.top + document.body.scrollTop) / c;
              1 < b ? (b = 1) : 0 > b && (b = 0);
              1 < e ? (e = 1) : 0 > e && (e = 0);
              t.__color.v = b;
              t.__color.s = e;
              t.setValue(t.__color.toOriginal());
              return !1;
            }
            function w(b) {
              b.preventDefault();
              var c = a.getHeight(t.__hue_field),
                d = a.getOffset(t.__hue_field);
              b = 1 - (b.clientY - d.top + document.body.scrollTop) / c;
              1 < b ? (b = 1) : 0 > b && (b = 0);
              t.__color.h = 360 * b;
              t.setValue(t.__color.toOriginal());
              return !1;
            }
            q.superclass.call(this, f, n);
            this.__color = new d(this.getValue());
            this.__temp = new d(0);
            var t = this;
            this.domElement = document.createElement("div");
            a.makeSelectable(this.domElement, !1);
            this.__selector = document.createElement("div");
            this.__selector.className = "selector";
            this.__saturation_field = document.createElement("div");
            this.__saturation_field.className = "saturation-field";
            this.__field_knob = document.createElement("div");
            this.__field_knob.className = "field-knob";
            this.__field_knob_border = "2px solid ";
            this.__hue_knob = document.createElement("div");
            this.__hue_knob.className = "hue-knob";
            this.__hue_field = document.createElement("div");
            this.__hue_field.className = "hue-field";
            this.__input = document.createElement("input");
            this.__input.type = "text";
            this.__input_textShadow = "0 1px 1px ";
            a.bind(this.__input, "keydown", function (a) {
              13 === a.keyCode && g.call(this);
            });
            a.bind(this.__input, "blur", g);
            a.bind(this.__selector, "mousedown", function (b) {
              a.addClass(this, "drag").bind(window, "mouseup", function (b) {
                a.removeClass(t.__selector, "drag");
              });
            });
            var y = document.createElement("div");
            c.extend(this.__selector.style, {
              width: "122px",
              height: "102px",
              padding: "3px",
              backgroundColor: "#222",
              boxShadow: "0px 1px 3px rgba(0,0,0,0.3)",
            });
            c.extend(this.__field_knob.style, {
              position: "absolute",
              width: "12px",
              height: "12px",
              border:
                this.__field_knob_border +
                (0.5 > this.__color.v ? "#fff" : "#000"),
              boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
              borderRadius: "12px",
              zIndex: 1,
            });
            c.extend(this.__hue_knob.style, {
              position: "absolute",
              width: "15px",
              height: "2px",
              borderRight: "4px solid #fff",
              zIndex: 1,
            });
            c.extend(this.__saturation_field.style, {
              width: "100px",
              height: "100px",
              border: "1px solid #555",
              marginRight: "3px",
              display: "inline-block",
              cursor: "pointer",
            });
            c.extend(y.style, {
              width: "100%",
              height: "100%",
              background: "none",
            });
            b(y, "top", "rgba(0,0,0,0)", "#000");
            c.extend(this.__hue_field.style, {
              width: "15px",
              height: "100px",
              display: "inline-block",
              border: "1px solid #555",
              cursor: "ns-resize",
            });
            p(this.__hue_field);
            c.extend(this.__input.style, {
              outline: "none",
              textAlign: "center",
              color: "#fff",
              border: 0,
              fontWeight: "bold",
              textShadow: this.__input_textShadow + "rgba(0,0,0,0.7)",
            });
            a.bind(this.__saturation_field, "mousedown", u);
            a.bind(this.__field_knob, "mousedown", u);
            a.bind(this.__hue_field, "mousedown", function (b) {
              w(b);
              a.bind(window, "mousemove", w);
              a.bind(window, "mouseup", k);
            });
            this.__saturation_field.appendChild(y);
            this.__selector.appendChild(this.__field_knob);
            this.__selector.appendChild(this.__saturation_field);
            this.__selector.appendChild(this.__hue_field);
            this.__hue_field.appendChild(this.__hue_knob);
            this.domElement.appendChild(this.__input);
            this.domElement.appendChild(this.__selector);
            this.updateDisplay();
          };
          q.superclass = f;
          c.extend(q.prototype, f.prototype, {
            updateDisplay: function () {
              var a = e(this.getValue());
              if (!1 !== a) {
                var f = !1;
                c.each(
                  d.COMPONENTS,
                  function (b) {
                    if (
                      !c.isUndefined(a[b]) &&
                      !c.isUndefined(this.__color.__state[b]) &&
                      a[b] !== this.__color.__state[b]
                    )
                      return (f = !0), {};
                  },
                  this
                );
                f && c.extend(this.__color.__state, a);
              }
              c.extend(this.__temp.__state, this.__color.__state);
              this.__temp.a = 1;
              var l = 0.5 > this.__color.v || 0.5 < this.__color.s ? 255 : 0,
                p = 255 - l;
              c.extend(this.__field_knob.style, {
                marginLeft: 100 * this.__color.s - 7 + "px",
                marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                backgroundColor: this.__temp.toString(),
                border:
                  this.__field_knob_border +
                  "rgb(" +
                  l +
                  "," +
                  l +
                  "," +
                  l +
                  ")",
              });
              this.__hue_knob.style.marginTop =
                100 * (1 - this.__color.h / 360) + "px";
              this.__temp.s = 1;
              this.__temp.v = 1;
              b(
                this.__saturation_field,
                "left",
                "#fff",
                this.__temp.toString()
              );
              c.extend(this.__input.style, {
                backgroundColor: (this.__input.value = this.__color.toString()),
                color: "rgb(" + l + "," + l + "," + l + ")",
                textShadow:
                  this.__input_textShadow +
                  "rgba(" +
                  p +
                  "," +
                  p +
                  "," +
                  p +
                  ",.7)",
              });
            },
          });
          var l = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
          return q;
        })(
          dat.controllers.Controller,
          dat.dom.dom,
          (dat.color.Color = (function (f, a, d, e) {
            function c(a, b, c) {
              Object.defineProperty(a, b, {
                get: function () {
                  if ("RGB" === this.__state.space) return this.__state[b];
                  p(this, b, c);
                  return this.__state[b];
                },
                set: function (a) {
                  "RGB" !== this.__state.space &&
                    (p(this, b, c), (this.__state.space = "RGB"));
                  this.__state[b] = a;
                },
              });
            }
            function b(a, b) {
              Object.defineProperty(a, b, {
                get: function () {
                  if ("HSV" === this.__state.space) return this.__state[b];
                  q(this);
                  return this.__state[b];
                },
                set: function (a) {
                  "HSV" !== this.__state.space &&
                    (q(this), (this.__state.space = "HSV"));
                  this.__state[b] = a;
                },
              });
            }
            function p(b, c, d) {
              if ("HEX" === b.__state.space)
                b.__state[c] = a.component_from_hex(b.__state.hex, d);
              else if ("HSV" === b.__state.space)
                e.extend(
                  b.__state,
                  a.hsv_to_rgb(b.__state.h, b.__state.s, b.__state.v)
                );
              else throw "Corrupted color state";
            }
            function q(b) {
              var c = a.rgb_to_hsv(b.r, b.g, b.b);
              e.extend(b.__state, { s: c.s, v: c.v });
              e.isNaN(c.h)
                ? e.isUndefined(b.__state.h) && (b.__state.h = 0)
                : (b.__state.h = c.h);
            }
            var l = function () {
              this.__state = f.apply(this, arguments);
              if (!1 === this.__state)
                throw "Failed to interpret color arguments";
              this.__state.a = this.__state.a || 1;
            };
            l.COMPONENTS = "r g b h s v hex a".split(" ");
            e.extend(l.prototype, {
              toString: function () {
                return d(this);
              },
              toOriginal: function () {
                return this.__state.conversion.write(this);
              },
            });
            c(l.prototype, "r", 2);
            c(l.prototype, "g", 1);
            c(l.prototype, "b", 0);
            b(l.prototype, "h");
            b(l.prototype, "s");
            b(l.prototype, "v");
            Object.defineProperty(l.prototype, "a", {
              get: function () {
                return this.__state.a;
              },
              set: function (a) {
                this.__state.a = a;
              },
            });
            Object.defineProperty(l.prototype, "hex", {
              get: function () {
                "HEX" !== !this.__state.space &&
                  (this.__state.hex = a.rgb_to_hex(this.r, this.g, this.b));
                return this.__state.hex;
              },
              set: function (a) {
                this.__state.space = "HEX";
                this.__state.hex = a;
              },
            });
            return l;
          })(
            dat.color.interpret,
            (dat.color.math = (function () {
              var f;
              return {
                hsv_to_rgb: function (a, d, e) {
                  var c = a / 60 - Math.floor(a / 60),
                    b = e * (1 - d),
                    f = e * (1 - c * d);
                  d = e * (1 - (1 - c) * d);
                  a = [
                    [e, d, b],
                    [f, e, b],
                    [b, e, d],
                    [b, f, e],
                    [d, b, e],
                    [e, b, f],
                  ][Math.floor(a / 60) % 6];
                  return { r: 255 * a[0], g: 255 * a[1], b: 255 * a[2] };
                },
                rgb_to_hsv: function (a, d, e) {
                  var c = Math.min(a, d, e),
                    b = Math.max(a, d, e),
                    c = b - c;
                  if (0 == b) return { h: NaN, s: 0, v: 0 };
                  a =
                    (a == b
                      ? (d - e) / c
                      : d == b
                      ? 2 + (e - a) / c
                      : 4 + (a - d) / c) / 6;
                  0 > a && (a += 1);
                  return { h: 360 * a, s: c / b, v: b / 255 };
                },
                rgb_to_hex: function (a, d, e) {
                  a = this.hex_with_component(0, 2, a);
                  a = this.hex_with_component(a, 1, d);
                  return (a = this.hex_with_component(a, 0, e));
                },
                component_from_hex: function (a, d) {
                  return (a >> (8 * d)) & 255;
                },
                hex_with_component: function (a, d, e) {
                  return (e << (f = 8 * d)) | (a & ~(255 << f));
                },
              };
            })()),
            dat.color.toString,
            dat.utils.common
          )),
          dat.color.interpret,
          dat.utils.common
        )),
        (dat.utils.requestAnimationFrame = (function () {
          return (
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (f, a) {
              window.setTimeout(f, 1e3 / 60);
            }
          );
        })()),
        (dat.dom.CenteredDiv = (function (f, a) {
          var d = function () {
            this.backgroundElement = document.createElement("div");
            a.extend(this.backgroundElement.style, {
              backgroundColor: "rgba(0,0,0,0.8)",
              top: 0,
              left: 0,
              display: "none",
              zIndex: "1000",
              opacity: 0,
              WebkitTransition: "opacity 0.2s linear",
              transition: "opacity 0.2s linear",
            });
            f.makeFullscreen(this.backgroundElement);
            this.backgroundElement.style.position = "fixed";
            this.domElement = document.createElement("div");
            a.extend(this.domElement.style, {
              position: "fixed",
              display: "none",
              zIndex: "1001",
              opacity: 0,
              WebkitTransition:
                "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
              transition: "transform 0.2s ease-out, opacity 0.2s linear",
            });
            document.body.appendChild(this.backgroundElement);
            document.body.appendChild(this.domElement);
            var d = this;
            f.bind(this.backgroundElement, "click", function () {
              d.hide();
            });
          };
          d.prototype.show = function () {
            var d = this;
            this.backgroundElement.style.display = "block";
            this.domElement.style.display = "block";
            this.domElement.style.opacity = 0;
            this.domElement.style.webkitTransform = "scale(1.1)";
            this.layout();
            a.defer(function () {
              d.backgroundElement.style.opacity = 1;
              d.domElement.style.opacity = 1;
              d.domElement.style.webkitTransform = "scale(1)";
            });
          };
          d.prototype.hide = function () {
            var a = this,
              c = function () {
                a.domElement.style.display = "none";
                a.backgroundElement.style.display = "none";
                f.unbind(a.domElement, "webkitTransitionEnd", c);
                f.unbind(a.domElement, "transitionend", c);
                f.unbind(a.domElement, "oTransitionEnd", c);
              };
            f.bind(this.domElement, "webkitTransitionEnd", c);
            f.bind(this.domElement, "transitionend", c);
            f.bind(this.domElement, "oTransitionEnd", c);
            this.backgroundElement.style.opacity = 0;
            this.domElement.style.opacity = 0;
            this.domElement.style.webkitTransform = "scale(1.1)";
          };
          d.prototype.layout = function () {
            this.domElement.style.left =
              window.innerWidth / 2 - f.getWidth(this.domElement) / 2 + "px";
            this.domElement.style.top =
              window.innerHeight / 2 - f.getHeight(this.domElement) / 2 + "px";
          };
          return d;
        })(dat.dom.dom, dat.utils.common)),
        dat.dom.dom,
        dat.utils.common
      );

      /*** EXPORTS FROM exports-loader ***/
      module.exports = dat;

      /***/
    },
    /* 13 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      /**
       * Tween.js - Licensed under the MIT license
       * https://github.com/tweenjs/tween.js
       * ----------------------------------------------
       *
       * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
       * Thank you all, you're awesome!
       */

      // Include a performance.now polyfill
      (function () {
        if ("performance" in window === false) {
          window.performance = {};
        }

        // IE 8
        Date.now =
          Date.now ||
          function () {
            return new Date().getTime();
          };

        if ("now" in window.performance === false) {
          var offset =
            window.performance.timing &&
            window.performance.timing.navigationStart
              ? window.performance.timing.navigationStart
              : Date.now();

          window.performance.now = function () {
            return Date.now() - offset;
          };
        }
      })();

      var TWEEN =
        TWEEN ||
        (function () {
          var _tweens = [];

          return {
            getAll: function () {
              return _tweens;
            },

            removeAll: function () {
              _tweens = [];
            },

            add: function (tween) {
              _tweens.push(tween);
            },

            remove: function (tween) {
              var i = _tweens.indexOf(tween);

              if (i !== -1) {
                _tweens.splice(i, 1);
              }
            },

            update: function (time) {
              if (_tweens.length === 0) {
                return false;
              }

              var i = 0;

              time = time !== undefined ? time : window.performance.now();

              while (i < _tweens.length) {
                if (_tweens[i].update(time)) {
                  i++;
                } else {
                  _tweens.splice(i, 1);
                }
              }

              return true;
            },
          };
        })();

      TWEEN.Tween = function (object) {
        var _object = object;
        var _valuesStart = {};
        var _valuesEnd = {};
        var _valuesStartRepeat = {};
        var _duration = 1000;
        var _repeat = 0;
        var _yoyo = false;
        var _isPlaying = false;
        var _reversed = false;
        var _delayTime = 0;
        var _startTime = null;
        var _easingFunction = TWEEN.Easing.Linear.None;
        var _interpolationFunction = TWEEN.Interpolation.Linear;
        var _chainedTweens = [];
        var _onStartCallback = null;
        var _onStartCallbackFired = false;
        var _onUpdateCallback = null;
        var _onCompleteCallback = null;
        var _onStopCallback = null;

        // Set all starting values present on the target object
        for (var field in object) {
          _valuesStart[field] = parseFloat(object[field], 10);
        }

        this.to = function (properties, duration) {
          if (duration !== undefined) {
            _duration = duration;
          }

          _valuesEnd = properties;

          return this;
        };

        this.start = function (time) {
          TWEEN.add(this);

          _isPlaying = true;

          _onStartCallbackFired = false;

          _startTime = time !== undefined ? time : window.performance.now();
          _startTime += _delayTime;

          for (var property in _valuesEnd) {
            // Check if an Array was provided as property value
            if (_valuesEnd[property] instanceof Array) {
              if (_valuesEnd[property].length === 0) {
                continue;
              }

              // Create a local copy of the Array with the start value at the front
              _valuesEnd[property] = [_object[property]].concat(
                _valuesEnd[property]
              );
            }

            _valuesStart[property] = _object[property];

            if (_valuesStart[property] instanceof Array === false) {
              _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
            }

            _valuesStartRepeat[property] = _valuesStart[property] || 0;
          }

          return this;
        };

        this.stop = function () {
          if (!_isPlaying) {
            return this;
          }

          TWEEN.remove(this);
          _isPlaying = false;

          if (_onStopCallback !== null) {
            _onStopCallback.call(_object);
          }

          this.stopChainedTweens();
          return this;
        };

        this.stopChainedTweens = function () {
          for (
            var i = 0, numChainedTweens = _chainedTweens.length;
            i < numChainedTweens;
            i++
          ) {
            _chainedTweens[i].stop();
          }
        };

        this.delay = function (amount) {
          _delayTime = amount;
          return this;
        };

        this.repeat = function (times) {
          _repeat = times;
          return this;
        };

        this.yoyo = function (yoyo) {
          _yoyo = yoyo;
          return this;
        };

        this.easing = function (easing) {
          _easingFunction = easing;
          return this;
        };

        this.interpolation = function (interpolation) {
          _interpolationFunction = interpolation;
          return this;
        };

        this.chain = function () {
          _chainedTweens = arguments;
          return this;
        };

        this.onStart = function (callback) {
          _onStartCallback = callback;
          return this;
        };

        this.onUpdate = function (callback) {
          _onUpdateCallback = callback;
          return this;
        };

        this.onComplete = function (callback) {
          _onCompleteCallback = callback;
          return this;
        };

        this.onStop = function (callback) {
          _onStopCallback = callback;
          return this;
        };

        this.update = function (time) {
          var property;
          var elapsed;
          var value;

          if (time < _startTime) {
            return true;
          }

          if (_onStartCallbackFired === false) {
            if (_onStartCallback !== null) {
              _onStartCallback.call(_object);
            }

            _onStartCallbackFired = true;
          }

          elapsed = (time - _startTime) / _duration;
          elapsed = elapsed > 1 ? 1 : elapsed;

          value = _easingFunction(elapsed);

          for (property in _valuesEnd) {
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];

            if (end instanceof Array) {
              _object[property] = _interpolationFunction(end, value);
            } else {
              // Parses relative end values with start as base (e.g.: +10, -3)
              if (typeof end === "string") {
                end = start + parseFloat(end, 10);
              }

              // Protect against non numeric properties.
              if (typeof end === "number") {
                _object[property] = start + (end - start) * value;
              }
            }
          }

          if (_onUpdateCallback !== null) {
            _onUpdateCallback.call(_object, value);
          }

          if (elapsed === 1) {
            if (_repeat > 0) {
              if (isFinite(_repeat)) {
                _repeat--;
              }

              // Reassign starting values, restart by making startTime = now
              for (property in _valuesStartRepeat) {
                if (typeof _valuesEnd[property] === "string") {
                  _valuesStartRepeat[property] =
                    _valuesStartRepeat[property] +
                    parseFloat(_valuesEnd[property], 10);
                }

                if (_yoyo) {
                  var tmp = _valuesStartRepeat[property];

                  _valuesStartRepeat[property] = _valuesEnd[property];
                  _valuesEnd[property] = tmp;
                }

                _valuesStart[property] = _valuesStartRepeat[property];
              }

              if (_yoyo) {
                _reversed = !_reversed;
              }

              _startTime = time + _delayTime;

              return true;
            } else {
              if (_onCompleteCallback !== null) {
                _onCompleteCallback.call(_object);
              }

              for (
                var i = 0, numChainedTweens = _chainedTweens.length;
                i < numChainedTweens;
                i++
              ) {
                // Make the chained tweens start exactly at the time they should,
                // even if the `update()` method was called way past the duration of the tween
                _chainedTweens[i].start(_startTime + _duration);
              }

              return false;
            }
          }

          return true;
        };
      };

      TWEEN.Easing = {
        Linear: {
          None: function (k) {
            return k;
          },
        },

        Quadratic: {
          In: function (k) {
            return k * k;
          },

          Out: function (k) {
            return k * (2 - k);
          },

          InOut: function (k) {
            if ((k *= 2) < 1) {
              return 0.5 * k * k;
            }

            return -0.5 * (--k * (k - 2) - 1);
          },
        },

        Cubic: {
          In: function (k) {
            return k * k * k;
          },

          Out: function (k) {
            return --k * k * k + 1;
          },

          InOut: function (k) {
            if ((k *= 2) < 1) {
              return 0.5 * k * k * k;
            }

            return 0.5 * ((k -= 2) * k * k + 2);
          },
        },

        Quartic: {
          In: function (k) {
            return k * k * k * k;
          },

          Out: function (k) {
            return 1 - --k * k * k * k;
          },

          InOut: function (k) {
            if ((k *= 2) < 1) {
              return 0.5 * k * k * k * k;
            }

            return -0.5 * ((k -= 2) * k * k * k - 2);
          },
        },

        Quintic: {
          In: function (k) {
            return k * k * k * k * k;
          },

          Out: function (k) {
            return --k * k * k * k * k + 1;
          },

          InOut: function (k) {
            if ((k *= 2) < 1) {
              return 0.5 * k * k * k * k * k;
            }

            return 0.5 * ((k -= 2) * k * k * k * k + 2);
          },
        },

        Sinusoidal: {
          In: function (k) {
            return 1 - Math.cos((k * Math.PI) / 2);
          },

          Out: function (k) {
            return Math.sin((k * Math.PI) / 2);
          },

          InOut: function (k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
          },
        },

        Exponential: {
          In: function (k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
          },

          Out: function (k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
          },

          InOut: function (k) {
            if (k === 0) {
              return 0;
            }

            if (k === 1) {
              return 1;
            }

            if ((k *= 2) < 1) {
              return 0.5 * Math.pow(1024, k - 1);
            }

            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
          },
        },

        Circular: {
          In: function (k) {
            return 1 - Math.sqrt(1 - k * k);
          },

          Out: function (k) {
            return Math.sqrt(1 - --k * k);
          },

          InOut: function (k) {
            if ((k *= 2) < 1) {
              return -0.5 * (Math.sqrt(1 - k * k) - 1);
            }

            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
          },
        },

        Elastic: {
          In: function (k) {
            var s;
            var a = 0.1;
            var p = 0.4;

            if (k === 0) {
              return 0;
            }

            if (k === 1) {
              return 1;
            }

            if (!a || a < 1) {
              a = 1;
              s = p / 4;
            } else {
              s = (p * Math.asin(1 / a)) / (2 * Math.PI);
            }

            return -(
              a *
              Math.pow(2, 10 * (k -= 1)) *
              Math.sin(((k - s) * (2 * Math.PI)) / p)
            );
          },

          Out: function (k) {
            var s;
            var a = 0.1;
            var p = 0.4;

            if (k === 0) {
              return 0;
            }

            if (k === 1) {
              return 1;
            }

            if (!a || a < 1) {
              a = 1;
              s = p / 4;
            } else {
              s = (p * Math.asin(1 / a)) / (2 * Math.PI);
            }

            return (
              a *
                Math.pow(2, -10 * k) *
                Math.sin(((k - s) * (2 * Math.PI)) / p) +
              1
            );
          },

          InOut: function (k) {
            var s;
            var a = 0.1;
            var p = 0.4;

            if (k === 0) {
              return 0;
            }

            if (k === 1) {
              return 1;
            }

            if (!a || a < 1) {
              a = 1;
              s = p / 4;
            } else {
              s = (p * Math.asin(1 / a)) / (2 * Math.PI);
            }

            if ((k *= 2) < 1) {
              return (
                -0.5 *
                (a *
                  Math.pow(2, 10 * (k -= 1)) *
                  Math.sin(((k - s) * (2 * Math.PI)) / p))
              );
            }

            return (
              a *
                Math.pow(2, -10 * (k -= 1)) *
                Math.sin(((k - s) * (2 * Math.PI)) / p) *
                0.5 +
              1
            );
          },
        },

        Back: {
          In: function (k) {
            var s = 1.70158;

            return k * k * ((s + 1) * k - s);
          },

          Out: function (k) {
            var s = 1.70158;

            return --k * k * ((s + 1) * k + s) + 1;
          },

          InOut: function (k) {
            var s = 1.70158 * 1.525;

            if ((k *= 2) < 1) {
              return 0.5 * (k * k * ((s + 1) * k - s));
            }

            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
          },
        },

        Bounce: {
          In: function (k) {
            return 1 - TWEEN.Easing.Bounce.Out(1 - k);
          },

          Out: function (k) {
            if (k < 1 / 2.75) {
              return 7.5625 * k * k;
            } else if (k < 2 / 2.75) {
              return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
            } else if (k < 2.5 / 2.75) {
              return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
            } else {
              return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
            }
          },

          InOut: function (k) {
            if (k < 0.5) {
              return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
            }

            return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
          },
        },
      };

      TWEEN.Interpolation = {
        Linear: function (v, k) {
          var m = v.length - 1;
          var f = m * k;
          var i = Math.floor(f);
          var fn = TWEEN.Interpolation.Utils.Linear;

          if (k < 0) {
            return fn(v[0], v[1], f);
          }

          if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
          }

          return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
        },

        Bezier: function (v, k) {
          var b = 0;
          var n = v.length - 1;
          var pw = Math.pow;
          var bn = TWEEN.Interpolation.Utils.Bernstein;

          for (var i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
          }

          return b;
        },

        CatmullRom: function (v, k) {
          var m = v.length - 1;
          var f = m * k;
          var i = Math.floor(f);
          var fn = TWEEN.Interpolation.Utils.CatmullRom;

          if (v[0] === v[m]) {
            if (k < 0) {
              i = Math.floor((f = m * (1 + k)));
            }

            return fn(
              v[(i - 1 + m) % m],
              v[i],
              v[(i + 1) % m],
              v[(i + 2) % m],
              f - i
            );
          } else {
            if (k < 0) {
              return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            }

            if (k > 1) {
              return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            }

            return fn(
              v[i ? i - 1 : 0],
              v[i],
              v[m < i + 1 ? m : i + 1],
              v[m < i + 2 ? m : i + 2],
              f - i
            );
          }
        },

        Utils: {
          Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
          },

          Bernstein: function (n, i) {
            var fc = TWEEN.Interpolation.Utils.Factorial;

            return fc(n) / fc(i) / fc(n - i);
          },

          Factorial: (function () {
            var a = [1];

            return function (n) {
              var s = 1;

              if (a[n]) {
                return a[n];
              }

              for (var i = n; i > 1; i--) {
                s *= i;
              }

              a[n] = s;
              return s;
            };
          })(),

          CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;

            return (
              (2 * p1 - 2 * p2 + v0 + v1) * t3 +
              (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 +
              v0 * t +
              p1
            );
          },
        },
      };

      // UMD (Universal Module Definition)
      (function (root) {
        if (true) {
          // AMD
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
          (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return TWEEN;
          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (typeof exports === "object") {
          // Node.js
          module.exports = TWEEN;
        } else {
          // Global variable
          root.TWEEN = TWEEN;
        }
      })(this);

      /***/
    },
    /* 14 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /*
       * tree.js
       * */

      /*
       * params
       *  theta : the amount of randomization direction
       *  attenuation : the attenuation rate of length
       *  rootRange : the range of segments for branch' parent
       * */
      THREE.TreeSpawner = function (params) {
        params = params || {};
        this.theta = params.theta || Math.PI * 0.5;
        this.attenuation = params.attenuation || 0.75;

        this.rootRange = params.rootRange || new THREE.Vector2(0.75, 1.0);
      };

      THREE.TreeSpawner.prototype = {
        spawn: function (branch, extension) {
          var theta = this.theta;
          var atten = this.attenuation;

          var htheta = theta * 0.5;
          var x = Math.random() * theta - htheta;
          var z = Math.random() * theta - htheta;
          var len = branch.length * atten;

          var rot = new THREE.Matrix4();
          var euler = new THREE.Euler(x, 0, z);
          rot.makeRotationFromEuler(euler);
          rot.multiply(branch.rotation);

          var segmentIndex;
          extension = extension || false;
          if (extension) {
            segmentIndex = branch.segments.length - 1;
          } else {
            segmentIndex = Math.floor(
              (Math.random() * (this.rootRange.y - this.rootRange.x) +
                this.rootRange.x) *
                branch.segments.length
            );
          }

          var segment = branch.segments[segmentIndex];
          return new THREE.TreeBranch({
            from: segment,
            rotation: rot,
            length: len,
            uvOffset: segment.uvOffset,
            uvLength: branch.uvLength,
            generation: branch.generation + 1,
            generations: branch.generations,
            radius: branch.radius,
            radiusSegments: branch.radiusSegments,
            heightSegments: branch.heightSegments,
          });
        },
      };

      /*
       * params
       *  from : THREE.Vector3 or TreeSegment
       *  rotation : THREE.Matrix4
       *  length : Number
       *  generation : branch' generation from root
       *  generations : the # of generations
       * */
      THREE.TreeBranch = function (params) {
        var from = params.from;
        this.rotation = params.rotation;
        this.length = params.length;

        this.generation = params.generation || 0;
        this.generations = params.generations;

        this.uvLength = params.uvLength || 10.0;
        this.uvOffset = params.uvOffset || 0.0;
        this.radius = params.radius || 0.1;
        this.radiusSegments = params.radiusSegments;
        this.heightSegments = params.heightSegments;

        if (from instanceof THREE.TreeSegment) {
          this.from = from;
          // this.position = from.position;
          this.position = from.position
            .clone()
            .add(
              new THREE.Vector3(0, 1, 0)
                .applyMatrix4(from.rotation)
                .setLength(0.05)
            );
        } else if (from instanceof THREE.Vector3) {
          this.from = null; // root branch
          this.position = from;
        } else {
          console.warning("from argument is missing !");
        }

        var direction = new THREE.Vector3(0, 1, 0).applyMatrix4(this.rotation);
        this.to = this.position.clone().add(direction.setLength(this.length));

        this.segments = this.buildTreeSegments(
          this.radius,
          this.radiusSegments,
          direction,
          this.heightSegments
        );
        this.children = [];
      };

      THREE.TreeBranch.prototype = {
        buildTreeSegments: function (
          radius,
          radiusSegments,
          direction,
          heightSegments
        ) {
          // randomize control point
          var theta = Math.PI * 0.25;
          var htheta = theta * 0.5;
          var x = Math.random() * theta - htheta;
          var z = Math.random() * theta - htheta;
          var rot = new THREE.Matrix4();
          var euler = new THREE.Euler(x, 0, z);
          rot.makeRotationFromEuler(euler);
          direction.applyMatrix4(rot);
          var controlPoint = this.position
            .clone()
            .add(direction.setLength(this.length * 0.5));

          var curve = new THREE.CatmullRomCurve3([
            this.position,
            controlPoint,
            this.to,
          ]);

          var fromRatio =
            this.generation == 0
              ? 1.0
              : 1.0 - this.generation / (this.generations + 1);
          var toRatio = 1.0 - (this.generation + 1) / (this.generations + 1);

          var fromRadius = radius * fromRatio;
          var toRadius = radius * toRatio;

          var rotation = this.rotation;

          var segments = [];
          var uvLength = this.uvLength;
          var uvOffset = this.uvOffset;
          var points = curve.getPoints(heightSegments);

          if (this.from !== null) {
            uvOffset += this.from.position.distanceTo(points[0]) / uvLength;
          }

          segments.push(
            new THREE.TreeSegment(
              points[0],
              rotation,
              uvOffset,
              fromRadius,
              radiusSegments
            )
          );

          for (var i = 1; i < heightSegments; i++) {
            var p0 = points[i];
            var p1 = points[i + 1];

            var ry = i / (heightSegments - 1);
            var radius = fromRadius + (toRadius - fromRadius) * ry;
            var d = p1.distanceTo(p0);
            uvOffset += d / uvLength;

            var segment = new THREE.TreeSegment(
              p0,
              rotation,
              uvOffset,
              radius,
              radiusSegments
            );
            segments.push(segment);
          }

          return segments;
        },

        branch: function (spawner, count) {
          for (var i = 0; i < count; i++) {
            // MEMO:
            //  at least one child is an extended branch.
            this.spawn(spawner, i == 0);
          }
          this.children.forEach(function (child) {
            child.branch(spawner, count - 1);
          });
        },

        grow: function (spawner, count) {
          if (this.children.length <= 0) {
            this.branch(spawner, 1);
          } else {
            this.children.forEach(function (child) {
              child.grow(spawner);
            });
          }
        },

        spawn: function (spawner, extension) {
          var child = spawner.spawn(this, extension);
          this.children.push(child);
        },

        branchlets: function () {
          if (this.children.length == 0) {
            return this;
          } else {
            return Array.prototype.concat.apply(
              [],
              this.children.map(function (child) {
                return child.branchlets();
              })
            );
          }
        },

        calculateLength: function () {
          var segments = this.segments;
          var length = 0;
          for (var i = 0, n = segments.length - 1; i < n; i++) {
            var p0 = segments[i].position;
            var p1 = segments[i + 1].position;
            length += p0.distanceTo(p1);
          }
          return length;
        },
      };

      /*
       * position : THREE.Vector3
       * rotation : THREE.Matrix4
       * */
      THREE.TreeSegment = function (
        position,
        rotation,
        uvOffset,
        radius,
        radiusSegments
      ) {
        this.position = position;
        this.rotation = rotation;
        this.uvOffset = uvOffset;
        this.radius = radius;

        this.vertices = [];
        this.uvs = [];

        this.build(radius, radiusSegments);
      };

      THREE.TreeSegment.prototype = {
        build: function (radius, radiusSegments) {
          var thetaLength = Math.PI * 2;
          for (var x = 0; x <= radiusSegments; x++) {
            var u = x / radiusSegments;
            var vertex = new THREE.Vector3(
              radius * Math.sin(u * thetaLength),
              0,
              radius * Math.cos(u * thetaLength)
            )
              .applyMatrix4(this.rotation)
              .add(this.position);

            this.vertices.push(vertex);
            this.uvs.push(new THREE.Vector2(u, this.uvOffset));
          }
        },
      };

      THREE.Tree = function (params, spawner) {
        params = params || {};

        var from = params.from || new THREE.Vector3();
        var rotation = new THREE.Matrix4();
        if (params.rotation) {
          if (params.rotation instanceof THREE.Euler) {
            var euler = params.rotation;
            rotation.makeRotationFromEuler(euler);
          } else if (params.rotation instanceof THREE.Matrix4) {
            rotation = params.rotation;
          }
        }

        var length = params.length || 3.0;
        var uvLength = params.uvLength || 10.0;
        var generations =
          params.generations !== undefined ? params.generations : 5;

        var radius = params.radius || 0.1;
        this.radiusSegments = params.radiusSegments || 8;
        this.heightSegments = params.heightSegments || 8;

        this.generations = generations;
        this.root = new THREE.TreeBranch({
          from: from,
          rotation: rotation,
          length: length,
          uvLength: uvLength,
          generation: 0,
          generations: this.generations,
          radius: radius,
          radiusSegments: this.radiusSegments,
          heightSegments: this.heightSegments,
        });

        this.spawner = spawner || new THREE.TreeSpawner();
        this.root.branch(this.spawner, this.generations);
      };

      THREE.Tree.prototype = {
        grow: function (count, spawner) {
          spawner = spawner || this.spawner;

          this.generation++;
          this.root.grow(spawner, count);
        },

        branchlets: function () {
          return this.root.branchlets();
        },
      };

      /***/
    },
    /* 15 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /*
       * tree_geometry.js
       * */

      THREE.TreeGeometry = {
        /*
         * build branch surface geometry.
         * */
        build: function (tree) {
          var geometry = new THREE.Geometry();

          this.buildBranches(tree.root, geometry);
          geometry.computeFaceNormals();
          geometry.computeVertexNormals();

          return geometry;
        },

        /*
         * build geometry recursively
         * */
        buildBranches: function (branch, geometry) {
          var radiusSegments = branch.radiusSegments;
          var heightSegments = branch.segments.length - 1;

          var thetaLength = Math.PI * 2;

          var vertices = [];
          var faces = [];
          var faceVertexUvs = [];

          var indices = [];
          var uvs = [];

          var index = 0;
          var offset = geometry.vertices.length;

          for (var y = 0; y <= heightSegments; y++) {
            var indicesRow = [];
            var uvsRow = [];

            var segment = branch.segments[y];

            var ry = (y + 1) / heightSegments;

            vertices = vertices.concat(segment.vertices);
            uvs.push(segment.uvs);

            for (var x = 0; x <= radiusSegments; x++) {
              indicesRow.push(index++);
            }

            indices.push(indicesRow);
          }

          for (var x = 0; x < radiusSegments; x++) {
            for (var y = 0; y < heightSegments; y++) {
              var cy = y,
                ny = y + 1;
              var cx = x,
                nx = x + 1;

              var v1 = indices[cy][cx] + offset;
              var v2 = indices[ny][cx] + offset;
              var v3 = indices[ny][nx] + offset;
              var v4 = indices[cy][nx] + offset;

              var uv1 = uvs[cy][cx];
              var uv2 = uvs[ny][cx];
              var uv3 = uvs[ny][nx];
              var uv4 = uvs[cy][nx];

              faces.push(new THREE.Face3(v1, v4, v2));
              faceVertexUvs.push([uv1, uv4, uv2]);

              faces.push(new THREE.Face3(v2, v4, v3));
              faceVertexUvs.push([uv2, uv4, uv3]);
            }
          }

          // bottom cap

          /*
           * root branch
           * */
          if (branch.from === null) {
            var bottom = branch.segments[0];
            vertices.push(bottom.position);
            indices.push(index++);

            var y = 0;

            for (var x = 0; x < radiusSegments; x++) {
              var v1 = indices[y][x] + offset;
              var v2 = indices[y][x + 1] + offset;
              var v3 = index - 1 + offset;

              var uv1 = uvs[y][x];
              var uv2 = uvs[y][x + 1];
              var uv3 = new THREE.Vector2(uv2.x, branch.uvOffset);

              faces.push(new THREE.Face3(v1, v3, v2));
              faceVertexUvs.push([uv1, uv3, uv2]);
            }
          } else {
            var from = branch.from;

            var y = 0;
            vertices = vertices.concat(from.vertices);

            var bottomIndices = [];
            for (var x = 0; x <= radiusSegments; x++) {
              bottomIndices.push(index++ + offset);
            }

            for (var x = 0; x < radiusSegments; x++) {
              var v0 = indices[y][x] + offset;
              var v1 = indices[y][x + 1] + offset;
              var v2 = bottomIndices[x];
              var v3 = bottomIndices[x + 1];

              var uv0 = uvs[y][x];
              var uv1 = uvs[y][x + 1];
              var uv2 = from.uvs[x];
              var uv3 = from.uvs[x + 1];

              faces.push(new THREE.Face3(v0, v3, v1));
              faceVertexUvs.push([uv0, uv3, uv1]);

              faces.push(new THREE.Face3(v0, v2, v3));
              faceVertexUvs.push([uv0, uv2, uv3]);
            }
          }

          geometry.vertices = geometry.vertices.concat(vertices);
          geometry.faces = geometry.faces.concat(faces);
          geometry.faceVertexUvs[0] =
            geometry.faceVertexUvs[0].concat(faceVertexUvs);

          var self = this;
          branch.children.forEach(function (child) {
            self.buildBranches(child, geometry);
          });
        },

        /*
         * build line strips geometry for THREE.Line object.
         * */
        buildLineStrips: function (tree) {
          var vertices = [];

          var recur = function (branch) {
            var segments = branch.segments;
            for (var i = 0, n = segments.length; i < n - 1; i++) {
              var s0 = segments[i];
              var s1 = segments[i + 1];
              vertices.push(s0.position, s1.position);
            }

            branch.children.forEach(function (child) {
              recur(child);
            });
          };
          recur(tree.root);

          var geometry = new THREE.Geometry();
          geometry.vertices = vertices;
          return geometry;
        },

        calculateLength: function (tree) {
          return this.calculateSegmentLength(tree.root);
        },

        calculateSegmentLength: function (branch) {
          var longest = 0.0;
          var self = this;
          branch.children.forEach(function (child) {
            var len = self.calculateSegmentLength(child);
            if (len > longest) {
              longest = len;
            }
          });
          return longest + branch.calculateLength();
        },
      };

      /***/
    },
    /* 16 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /*
       * tree_helper.js
       * */

      THREE.TreeHelper = function (system) {
        THREE.Object3D.call(this);

        this.system = system;
      };

      THREE.TreeHelper.prototype = Object.create(THREE.Object3D.prototype);
      THREE.TreeHelper.prototype.constructor = THREE.TreeHelper;

      THREE.TreeHelper.prototype.clear = function () {
        for (var i = this.children.length - 1; i >= 0; i--) {
          this.remove(this.children[i]);
        }
      };

      THREE.TreeHelper.prototype.showLine = function (opt) {
        this.clear();

        var geometry = THREE.TreeGeometry.buildLineStrips(this.system);
        var vertices = geometry.vertices;

        opt = opt || {};

        var line = new THREE.LineSegments(
          geometry,
          new THREE.LineBasicMaterial({
            linewidth: opt.linewidth || 1,
            color: opt.linecolor || 0x00ff00,
          })
        );
        this.add(line);

        geometry = new THREE.Geometry();
        for (var i = 0, n = vertices.length; i < n; i += 2) {
          geometry.vertices.push(vertices[i]);
        }
        var points = new THREE.Points(
          geometry,
          new THREE.PointsMaterial({
            size: opt.pointsize || 0.05,
            color: opt.pointcolor || 0xff0000,
          })
        );
        this.add(points);
      };

      /***/
    },
    /* 17 */
    /***/ function (module, exports, __webpack_require__) {
      /*** IMPORTS FROM imports-loader ***/
      var THREE = __webpack_require__(3);

      /*
       * tree_material.js
       * */

      THREE.TreeMaterial = function () {
        // copy from THREE.ShaderLib["phong"]
        var parameters = {
          defines: {
            USE_MAP: true,
            USE_NORMALMAP: true,
          },
          extensions: {
            derivatives: true,
          },
          uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib["common"],
            THREE.UniformsLib["aomap"],
            THREE.UniformsLib["lightmap"],
            THREE.UniformsLib["emissivemap"],
            THREE.UniformsLib["bumpmap"],
            THREE.UniformsLib["normalmap"],
            THREE.UniformsLib["displacementmap"],
            THREE.UniformsLib["fog"],
            THREE.UniformsLib["ambient"],
            THREE.UniformsLib["lights"],
            {
              emissive: { type: "c", value: new THREE.Color(0x000000) },
              specular: { type: "c", value: new THREE.Color(0x111111) },
              shininess: { type: "f", value: 5 },
              uGrow: { type: "f", value: 1.0 },
            },
          ]),
          vertexShader: [
            "#define PHONG",

            "varying vec3 vViewPosition;",

            "#ifndef FLAT_SHADED",
            "	varying vec3 vNormal;",
            "#endif",

            THREE.ShaderChunk["common"],
            THREE.ShaderChunk["uv_pars_vertex"],
            THREE.ShaderChunk["uv2_pars_vertex"],
            THREE.ShaderChunk["displacementmap_pars_vertex"],
            THREE.ShaderChunk["envmap_pars_vertex"],
            THREE.ShaderChunk["lights_phong_pars_vertex"],
            THREE.ShaderChunk["color_pars_vertex"],
            THREE.ShaderChunk["morphtarget_pars_vertex"],
            THREE.ShaderChunk["skinning_pars_vertex"],
            THREE.ShaderChunk["shadowmap_pars_vertex"],
            THREE.ShaderChunk["logdepthbuf_pars_vertex"],

            "varying float vGrow;",

            "void main() {",

            "vGrow = uv.y;",

            THREE.ShaderChunk["uv_vertex"],
            THREE.ShaderChunk["uv2_vertex"],
            THREE.ShaderChunk["color_vertex"],

            THREE.ShaderChunk["beginnormal_vertex"],
            THREE.ShaderChunk["morphnormal_vertex"],
            THREE.ShaderChunk["skinbase_vertex"],
            THREE.ShaderChunk["skinnormal_vertex"],
            THREE.ShaderChunk["defaultnormal_vertex"],

            "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

            "	vNormal = normalize( transformedNormal );",

            "#endif",

            THREE.ShaderChunk["begin_vertex"],
            THREE.ShaderChunk["displacementmap_vertex"],
            THREE.ShaderChunk["morphtarget_vertex"],
            THREE.ShaderChunk["skinning_vertex"],
            THREE.ShaderChunk["project_vertex"],
            THREE.ShaderChunk["logdepthbuf_vertex"],

            "	vViewPosition = - mvPosition.xyz;",

            THREE.ShaderChunk["worldpos_vertex"],
            THREE.ShaderChunk["envmap_vertex"],
            THREE.ShaderChunk["lights_phong_vertex"],
            THREE.ShaderChunk["shadowmap_vertex"],

            "}",
          ].join("\n"),
          fragmentShader: [
            "#define PHONG",

            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",
            "uniform float opacity;",

            "uniform float uGrow;",
            "varying float vGrow;",

            THREE.ShaderChunk["common"],
            THREE.ShaderChunk["color_pars_fragment"],
            THREE.ShaderChunk["uv_pars_fragment"],
            THREE.ShaderChunk["uv2_pars_fragment"],
            THREE.ShaderChunk["map_pars_fragment"],
            THREE.ShaderChunk["alphamap_pars_fragment"],
            THREE.ShaderChunk["aomap_pars_fragment"],
            THREE.ShaderChunk["lightmap_pars_fragment"],
            THREE.ShaderChunk["emissivemap_pars_fragment"],
            THREE.ShaderChunk["envmap_pars_fragment"],
            THREE.ShaderChunk["fog_pars_fragment"],
            THREE.ShaderChunk["bsdfs"],
            THREE.ShaderChunk["ambient_pars"],
            THREE.ShaderChunk["lights_pars"],
            THREE.ShaderChunk["lights_phong_pars_fragment"],
            THREE.ShaderChunk["shadowmap_pars_fragment"],
            THREE.ShaderChunk["bumpmap_pars_fragment"],
            THREE.ShaderChunk["normalmap_pars_fragment"],
            THREE.ShaderChunk["specularmap_pars_fragment"],
            THREE.ShaderChunk["logdepthbuf_pars_fragment"],

            "void main() {",

            "   if(vGrow > uGrow) discard;",

            "	vec4 diffuseColor = vec4( diffuse, opacity );",
            "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
            "	vec3 totalEmissiveLight = emissive;",

            THREE.ShaderChunk["logdepthbuf_fragment"],
            THREE.ShaderChunk["map_fragment"],
            THREE.ShaderChunk["color_fragment"],
            THREE.ShaderChunk["alphamap_fragment"],
            THREE.ShaderChunk["alphatest_fragment"],
            THREE.ShaderChunk["specularmap_fragment"],
            THREE.ShaderChunk["normal_fragment"],
            THREE.ShaderChunk["emissivemap_fragment"],

            // accumulation
            THREE.ShaderChunk["lights_phong_fragment"],
            THREE.ShaderChunk["lights_template"],

            // modulation
            THREE.ShaderChunk["aomap_fragment"],

            "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",

            THREE.ShaderChunk["envmap_fragment"],
            THREE.ShaderChunk["linear_to_gamma_fragment"],

            THREE.ShaderChunk["fog_fragment"],

            "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

            "}",
          ].join("\n"),
          lights: true,
        };
        THREE.ShaderMaterial.call(this, parameters);
      };

      THREE.TreeMaterial.prototype = Object.create(THREE.Material.prototype);
      THREE.TreeMaterial.prototype.constructor = THREE.TreeMaterial;

      /***/
    },
    /* 18 */
    /***/ function (module, exports) {
      module.exports =
        "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n}\n\n";

      /***/
    },
    /* 19 */
    /***/ function (module, exports) {
      module.exports =
        "#define GLSLIFY 1\nuniform sampler2D tDiffuse;\nuniform float uDS;\nvarying vec2 vUv;\n\nvec4 desaturate(vec3 color, float ds) { \n    const vec3 grayXfer = vec3(0.3, 0.59, 0.11); \n    float grayf = dot(grayXfer, color); \n    vec3 gray = vec3(grayf, grayf, grayf); \n    return vec4(mix(color, gray, ds), 1.0);\n}\n\nvoid main() {\n    vec4 sample = texture2D(tDiffuse, vUv);\n    gl_FragColor = desaturate(sample.rgb, uDS);\n}\n\n";

      /***/
    },
    /* 20 */
    /***/ function (module, exports) {
      module.exports =
        "#define GLSLIFY 1\nvarying float vGrow;\n\nvoid main() {\n    vec3 pos = position;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n    vGrow = uv.y;\n}\n\n";

      /***/
    },
    /* 21 */
    /***/ function (module, exports) {
      module.exports =
        "#define GLSLIFY 1\nuniform float uGrow;\nvarying float vGrow;\n\nvec4 pack_depth( const in float depth ) {\n    const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n    const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n    vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n\nvoid main() {\n    if(vGrow > uGrow) discard;\n\n    gl_FragData[0] = pack_depth(gl_FragCoord.z);\n}\n\n";

      /***/
    },
    /******/
  ]
);
